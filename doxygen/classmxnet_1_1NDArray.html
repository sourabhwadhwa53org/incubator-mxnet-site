<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta content="text/xhtml;charset=utf-8" http-equiv="Content-Type"/>
<meta content="IE=9" http-equiv="X-UA-Compatible"/>
<meta content="Doxygen 1.8.11" name="generator"/>
<title>mxnet: mxnet::NDArray Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script src="jquery.js" type="text/javascript"></script>
<script src="dynsections.js" type="text/javascript"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script src="search/searchdata.js" type="text/javascript"></script>
<script src="search/search.js" type="text/javascript"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellpadding="0" cellspacing="0">
<tbody>
<tr style="height: 56px;">
<td id="projectalign" style="padding-left: 0.5em;">
<div id="projectname">mxnet
   </div>
</td>
</tr>
</tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<div class="tabs" id="navrow1">
<ul class="tablist">
<li><a href="index.html"><span>Main Page</span></a></li>
<li><a href="pages.html"><span>Related Pages</span></a></li>
<li><a href="modules.html"><span>Modules</span></a></li>
<li><a href="namespaces.html"><span>Namespaces</span></a></li>
<li class="current"><a href="annotated.html"><span>Classes</span></a></li>
<li><a href="files.html"><span>Files</span></a></li>
<li>
<div class="MSearchBoxInactive" id="MSearchBox">
<span class="left">
<img alt="" id="MSearchSelect" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()" src="search/mag_sel.png"/>
<input accesskey="S" id="MSearchField" onblur="searchBox.OnSearchFieldFocus(false)" onfocus="searchBox.OnSearchFieldFocus(true)" onkeyup="searchBox.OnSearchFieldChange(event)" type="text" value="Search"/>
</span><span class="right">
<a href="javascript:searchBox.CloseResultsWindow()" id="MSearchClose"><img alt="" border="0" id="MSearchCloseImg" src="search/close.png"/></a>
</span>
</div>
</li>
</ul>
</div>
<div class="tabs2" id="navrow2">
<ul class="tablist">
<li><a href="annotated.html"><span>Class List</span></a></li>
<li><a href="classes.html"><span>Class Index</span></a></li>
<li><a href="inherits.html"><span>Class Hierarchy</span></a></li>
<li><a href="functions.html"><span>Class Members</span></a></li>
</ul>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onkeydown="return searchBox.OnSearchSelectKey(event)" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe frameborder="0" id="MSearchResults" name="MSearchResults" src="javascript:void(0)">
</iframe>
</div>
<div class="navpath" id="nav-path">
<ul>
<li class="navelem"><a class="el" href="namespacemxnet.html">mxnet</a></li><li class="navelem"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a></li> </ul>
</div>
</div><!-- top -->
<div class="header">
<div class="summary">
<a href="#nested-classes">Classes</a> |
<a href="#pub-methods">Public Member Functions</a> |
<a href="#pub-static-methods">Static Public Member Functions</a> |
<a href="#friends">Friends</a> |
<a href="classmxnet_1_1NDArray-members.html">List of all members</a> </div>
<div class="headertitle">
<div class="title">mxnet::NDArray Class Reference</div> </div>
</div><!--header-->
<div class="contents">
<p>ndarray interface  
 <a href="classmxnet_1_1NDArray.html#details">More...</a></p>
<p><code>#include &lt;<a class="el" href="include_2mxnet_2ndarray_8h_source.html">ndarray.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for mxnet::NDArray:</div>
<div class="dyncontent">
<div class="center"><img alt="Collaboration graph" border="0" src="classmxnet_1_1NDArray__coll__graph.png" usemap="#mxnet_1_1NDArray_coll__map"/></div>
<map id="mxnet_1_1NDArray_coll__map" name="mxnet_1_1NDArray_coll__map">
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a12ec978e5dbe9092d21721a657c39756"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a12ec978e5dbe9092d21721a657c39756">NDArray</a> ()</td></tr>
<tr class="memdesc:a12ec978e5dbe9092d21721a657c39756"><td class="mdescLeft"> </td><td class="mdescRight">default constructor  <a href="#a12ec978e5dbe9092d21721a657c39756">More...</a><br/></td></tr>
<tr class="separator:a12ec978e5dbe9092d21721a657c39756"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a58d6f716d7eebf822c75e841342d9feb"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a58d6f716d7eebf822c75e841342d9feb">NDArray</a> (const <a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a> &amp;<a class="el" href="classmxnet_1_1NDArray.html#a1910c16c97754399ceafcd36e80893e2">shape</a>, <a class="el" href="structmxnet_1_1Context.html">Context</a> <a class="el" href="classmxnet_1_1NDArray.html#a5e2eb64751872f537ae3cb25f949fff1">ctx</a>, bool delay_alloc=false, int <a class="el" href="classmxnet_1_1NDArray.html#a1b6038a196c14d038bd3e6d6bbe36ad2">dtype</a>=mshadow::default_type_flag)</td></tr>
<tr class="memdesc:a58d6f716d7eebf822c75e841342d9feb"><td class="mdescLeft"> </td><td class="mdescRight">constructs a new dynamic <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> <a href="#a58d6f716d7eebf822c75e841342d9feb">More...</a><br/></td></tr>
<tr class="separator:a58d6f716d7eebf822c75e841342d9feb"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad45e6e6669cdde0232d05f1e549ec607"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#ad45e6e6669cdde0232d05f1e549ec607">NDArray</a> (const <a class="el" href="namespacemxnet.html#a536b732faa980e1de446c552460ff76a">NDArrayStorageType</a> stype, const <a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a> &amp;<a class="el" href="classmxnet_1_1NDArray.html#a1910c16c97754399ceafcd36e80893e2">shape</a>, <a class="el" href="structmxnet_1_1Context.html">Context</a> <a class="el" href="classmxnet_1_1NDArray.html#a5e2eb64751872f537ae3cb25f949fff1">ctx</a>, bool delay_alloc=true, int <a class="el" href="classmxnet_1_1NDArray.html#a1b6038a196c14d038bd3e6d6bbe36ad2">dtype</a>=mshadow::default_type_flag, std::vector&lt; int &gt; <a class="el" href="classmxnet_1_1NDArray.html#a8970b39ecb7947218981f607d9b6dce8">aux_types</a>={}, <a class="el" href="namespacemxnet.html#a87e1c30aafac389774c6f4d905c0e5ea">mxnet::ShapeVector</a> <a class="el" href="classmxnet_1_1NDArray.html#a251088c33eb30d4fcef12e27e9ba4490">aux_shapes</a>={}, <a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a> <a class="el" href="classmxnet_1_1NDArray.html#a45fba0f5e822d832bf5bed08bb8cfb36">storage_shape</a>=<a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a>(mshadow::Shape1(0)))</td></tr>
<tr class="memdesc:ad45e6e6669cdde0232d05f1e549ec607"><td class="mdescLeft"> </td><td class="mdescRight">constructor for <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> with storage type  <a href="#ad45e6e6669cdde0232d05f1e549ec607">More...</a><br/></td></tr>
<tr class="separator:ad45e6e6669cdde0232d05f1e549ec607"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:afbfcf25b4e005007c40300c711c34f69"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#afbfcf25b4e005007c40300c711c34f69">NDArray</a> (<a class="el" href="structmxnet_1_1Context.html">Context</a> <a class="el" href="classmxnet_1_1NDArray.html#a5e2eb64751872f537ae3cb25f949fff1">ctx</a>, int <a class="el" href="classmxnet_1_1NDArray.html#a1b6038a196c14d038bd3e6d6bbe36ad2">dtype</a>=mshadow::default_type_flag)</td></tr>
<tr class="memdesc:afbfcf25b4e005007c40300c711c34f69"><td class="mdescLeft"> </td><td class="mdescRight">constructs a new dynamic <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> whose shape is unknown, hence the <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> is inherently lazily created  <a href="#afbfcf25b4e005007c40300c711c34f69">More...</a><br/></td></tr>
<tr class="separator:afbfcf25b4e005007c40300c711c34f69"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1a7288505ac9bbb19830161f7e5c1a6f"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a1a7288505ac9bbb19830161f7e5c1a6f">NDArray</a> (const <a class="el" href="classmxnet_1_1TBlob.html">TBlob</a> &amp;<a class="el" href="classmxnet_1_1NDArray.html#aebd03e900ec7664a99b780a0cb1efea6">data</a>, int dev_id)</td></tr>
<tr class="memdesc:a1a7288505ac9bbb19830161f7e5c1a6f"><td class="mdescLeft"> </td><td class="mdescRight">constructing a static <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> that shares data with <a class="el" href="classmxnet_1_1TBlob.html" title="tensor blob class that can be used to hold tensor of any dimension, any device and any data type...">TBlob</a> Use with caution: allocate ONLY ONE <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> for each <a class="el" href="classmxnet_1_1TBlob.html" title="tensor blob class that can be used to hold tensor of any dimension, any device and any data type...">TBlob</a>, make sure the memory region is available through out the life of <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> <a href="#a1a7288505ac9bbb19830161f7e5c1a6f">More...</a><br/></td></tr>
<tr class="separator:a1a7288505ac9bbb19830161f7e5c1a6f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa2e26d3d53e546a8b5f458c0cc204387"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#aa2e26d3d53e546a8b5f458c0cc204387">NDArray</a> (const <a class="el" href="classmxnet_1_1TBlob.html">TBlob</a> &amp;<a class="el" href="classmxnet_1_1NDArray.html#aebd03e900ec7664a99b780a0cb1efea6">data</a>, int dev_id, const std::function&lt; void()&gt; &amp;deleter)</td></tr>
<tr class="memdesc:aa2e26d3d53e546a8b5f458c0cc204387"><td class="mdescLeft"> </td><td class="mdescRight">constructing a static <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> that shares data with <a class="el" href="classmxnet_1_1TBlob.html" title="tensor blob class that can be used to hold tensor of any dimension, any device and any data type...">TBlob</a> which is with deleter Use with caution: allocate ONLY ONE <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> for each <a class="el" href="classmxnet_1_1TBlob.html" title="tensor blob class that can be used to hold tensor of any dimension, any device and any data type...">TBlob</a>, make sure the memory region is available through out the life of <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> <a href="#aa2e26d3d53e546a8b5f458c0cc204387">More...</a><br/></td></tr>
<tr class="separator:aa2e26d3d53e546a8b5f458c0cc204387"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac5858cd154fbf68f832c2717f4f925e8"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#ac5858cd154fbf68f832c2717f4f925e8">NDArray</a> (int shared_pid, int shared_id, const <a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a> &amp;<a class="el" href="classmxnet_1_1NDArray.html#a1910c16c97754399ceafcd36e80893e2">shape</a>, int <a class="el" href="classmxnet_1_1NDArray.html#a1b6038a196c14d038bd3e6d6bbe36ad2">dtype</a>)</td></tr>
<tr class="memdesc:ac5858cd154fbf68f832c2717f4f925e8"><td class="mdescLeft"> </td><td class="mdescRight">create ndarray from shared memory  <a href="#ac5858cd154fbf68f832c2717f4f925e8">More...</a><br/></td></tr>
<tr class="separator:ac5858cd154fbf68f832c2717f4f925e8"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a3ab28f889680e6aad1b981b378f206d9"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a3ab28f889680e6aad1b981b378f206d9">NDArray</a> (const <a class="el" href="namespacemxnet.html#a536b732faa980e1de446c552460ff76a">NDArrayStorageType</a> stype, const <a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a> &amp;<a class="el" href="classmxnet_1_1NDArray.html#a1910c16c97754399ceafcd36e80893e2">shape</a>, const <a class="el" href="classmxnet_1_1TBlob.html">TBlob</a> &amp;<a class="el" href="classmxnet_1_1NDArray.html#aebd03e900ec7664a99b780a0cb1efea6">data</a>, const std::vector&lt; <a class="el" href="classmxnet_1_1TBlob.html">TBlob</a> &gt; &amp;<a class="el" href="classmxnet_1_1NDArray.html#ad8194805eabb65d8a9d33fda840b66a9">aux_data</a>, int dev_id)</td></tr>
<tr class="memdesc:a3ab28f889680e6aad1b981b378f206d9"><td class="mdescLeft"> </td><td class="mdescRight">constructing a static <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> of non-default storage that shares data with <a class="el" href="classmxnet_1_1TBlob.html" title="tensor blob class that can be used to hold tensor of any dimension, any device and any data type...">TBlob</a> Use with caution: allocate ONLY ONE <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> for each <a class="el" href="classmxnet_1_1TBlob.html" title="tensor blob class that can be used to hold tensor of any dimension, any device and any data type...">TBlob</a>, make sure the memory region is available through out the life of <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> <a href="#a3ab28f889680e6aad1b981b378f206d9">More...</a><br/></td></tr>
<tr class="separator:a3ab28f889680e6aad1b981b378f206d9"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1e789a9d17c0b15749d247122e9b207a"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a1e789a9d17c0b15749d247122e9b207a">Init</a> (const <a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a> &amp;<a class="el" href="classmxnet_1_1NDArray.html#a1910c16c97754399ceafcd36e80893e2">shape</a>)</td></tr>
<tr class="memdesc:a1e789a9d17c0b15749d247122e9b207a"><td class="mdescLeft"> </td><td class="mdescRight">initialize the <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>, assuming it is not assigned a meaningful shape before  <a href="#a1e789a9d17c0b15749d247122e9b207a">More...</a><br/></td></tr>
<tr class="separator:a1e789a9d17c0b15749d247122e9b207a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a24287317390bd1a58d7f93772a64c2cb"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a24287317390bd1a58d7f93772a64c2cb">SetShapeFromChunk</a> ()</td></tr>
<tr class="memdesc:a24287317390bd1a58d7f93772a64c2cb"><td class="mdescLeft"> </td><td class="mdescRight">set the correct shape of <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> directly from the storage_shape of its own chunk.  <a href="#a24287317390bd1a58d7f93772a64c2cb">More...</a><br/></td></tr>
<tr class="separator:a24287317390bd1a58d7f93772a64c2cb"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a117e3af0d08abf56ff8852adfb71f413"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a117e3af0d08abf56ff8852adfb71f413">IsView</a> () const </td></tr>
<tr class="separator:a117e3af0d08abf56ff8852adfb71f413"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:adfd9872e55953d5cbea39728ea7d4289"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#adfd9872e55953d5cbea39728ea7d4289">IsSame</a> (const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;other) const </td></tr>
<tr class="separator:adfd9872e55953d5cbea39728ea7d4289"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1910c16c97754399ceafcd36e80893e2"><td align="right" class="memItemLeft" valign="top">const <a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a> &amp; </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a1910c16c97754399ceafcd36e80893e2">shape</a> () const </td></tr>
<tr class="separator:a1910c16c97754399ceafcd36e80893e2"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a45fba0f5e822d832bf5bed08bb8cfb36"><td align="right" class="memItemLeft" valign="top">const <a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a> &amp; </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a45fba0f5e822d832bf5bed08bb8cfb36">storage_shape</a> () const </td></tr>
<tr class="separator:a45fba0f5e822d832bf5bed08bb8cfb36"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a594a69f0f6cc791664f9561285a22ab1"><td align="right" class="memItemLeft" valign="top">const <a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a> &amp; </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a594a69f0f6cc791664f9561285a22ab1">aux_shape</a> (size_t index) const </td></tr>
<tr class="memdesc:a594a69f0f6cc791664f9561285a22ab1"><td class="mdescLeft"> </td><td class="mdescRight">get the shape of aux_data(index)  <a href="#a594a69f0f6cc791664f9561285a22ab1">More...</a><br/></td></tr>
<tr class="separator:a594a69f0f6cc791664f9561285a22ab1"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a251088c33eb30d4fcef12e27e9ba4490"><td align="right" class="memItemLeft" valign="top">const <a class="el" href="namespacemxnet.html#a87e1c30aafac389774c6f4d905c0e5ea">mxnet::ShapeVector</a> &amp; </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a251088c33eb30d4fcef12e27e9ba4490">aux_shapes</a> () const </td></tr>
<tr class="separator:a251088c33eb30d4fcef12e27e9ba4490"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a8970b39ecb7947218981f607d9b6dce8"><td align="right" class="memItemLeft" valign="top">const std::vector&lt; int &gt; &amp; </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a8970b39ecb7947218981f607d9b6dce8">aux_types</a> () const </td></tr>
<tr class="separator:a8970b39ecb7947218981f607d9b6dce8"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aac690d8073f38b6dbb882ccc894390bb"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#aac690d8073f38b6dbb882ccc894390bb">set_aux_shape</a> (size_t index, const <a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a> &amp;<a class="el" href="classmxnet_1_1NDArray.html#a1910c16c97754399ceafcd36e80893e2">shape</a>) const </td></tr>
<tr class="memdesc:aac690d8073f38b6dbb882ccc894390bb"><td class="mdescLeft"> </td><td class="mdescRight">For a sparse operation on a csr matrix for example, the size of the column index array is an estimated value in the beginning for allocating enough capacity for the final result. After the operation is done, the exact size of the shape is known and need to be reset using this function.  <a href="#aac690d8073f38b6dbb882ccc894390bb">More...</a><br/></td></tr>
<tr class="separator:aac690d8073f38b6dbb882ccc894390bb"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aebd03e900ec7664a99b780a0cb1efea6"><td align="right" class="memItemLeft" valign="top">const <a class="el" href="classmxnet_1_1TBlob.html">TBlob</a> &amp; </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#aebd03e900ec7664a99b780a0cb1efea6">data</a> () const </td></tr>
<tr class="separator:aebd03e900ec7664a99b780a0cb1efea6"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aed729c3bc9db04ab346fd3969b4fc982"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#aed729c3bc9db04ab346fd3969b4fc982">grad</a> () const </td></tr>
<tr class="separator:aed729c3bc9db04ab346fd3969b4fc982"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad8194805eabb65d8a9d33fda840b66a9"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1TBlob.html">TBlob</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#ad8194805eabb65d8a9d33fda840b66a9">aux_data</a> (size_t i) const </td></tr>
<tr class="separator:ad8194805eabb65d8a9d33fda840b66a9"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5e2eb64751872f537ae3cb25f949fff1"><td align="right" class="memItemLeft" valign="top"><a class="el" href="structmxnet_1_1Context.html">Context</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a5e2eb64751872f537ae3cb25f949fff1">ctx</a> () const </td></tr>
<tr class="separator:a5e2eb64751872f537ae3cb25f949fff1"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1b6038a196c14d038bd3e6d6bbe36ad2"><td align="right" class="memItemLeft" valign="top">int </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a1b6038a196c14d038bd3e6d6bbe36ad2">dtype</a> () const </td></tr>
<tr class="separator:a1b6038a196c14d038bd3e6d6bbe36ad2"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a02fe304d3498632571fea1a7c1fd91d6"><td align="right" class="memItemLeft" valign="top">int </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a02fe304d3498632571fea1a7c1fd91d6">aux_type</a> (size_t i) const </td></tr>
<tr class="separator:a02fe304d3498632571fea1a7c1fd91d6"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4d8f894c0306ad693ccf29278a613732"><td align="right" class="memItemLeft" valign="top"><a class="el" href="namespacemxnet.html#a536b732faa980e1de446c552460ff76a">NDArrayStorageType</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a4d8f894c0306ad693ccf29278a613732">storage_type</a> () const </td></tr>
<tr class="separator:a4d8f894c0306ad693ccf29278a613732"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2a15ffdbf29d4d5455a4fbb4b607880c"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a2a15ffdbf29d4d5455a4fbb4b607880c">is_none</a> () const </td></tr>
<tr class="separator:a2a15ffdbf29d4d5455a4fbb4b607880c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aee74980eb87bf7c482d15458f5194cbe"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#aee74980eb87bf7c482d15458f5194cbe">fresh_out_grad</a> () const </td></tr>
<tr class="separator:aee74980eb87bf7c482d15458f5194cbe"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a32ed2be4ecf94c58b19bd43b48f2b1fa"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a32ed2be4ecf94c58b19bd43b48f2b1fa">set_fresh_out_grad</a> (bool state) const </td></tr>
<tr class="separator:a32ed2be4ecf94c58b19bd43b48f2b1fa"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a0f59c72c8caefcc069d5839d35288cd1"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a0f59c72c8caefcc069d5839d35288cd1">storage_initialized</a> () const </td></tr>
<tr class="memdesc:a0f59c72c8caefcc069d5839d35288cd1"><td class="mdescLeft"> </td><td class="mdescRight">Returns true if a sparse ndarray's aux_data and storage are initialized Throws an exception if the indices array shape is inconsistent Returns false if the indices array is empty(nnz = 0) for csr/row_sparse.  <a href="#a0f59c72c8caefcc069d5839d35288cd1">More...</a><br/></td></tr>
<tr class="separator:a0f59c72c8caefcc069d5839d35288cd1"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad330f5e35c41078cb64cd84ae59a0bc3"><td align="right" class="memItemLeft" valign="top"><a class="el" href="structmxnet_1_1Storage_1_1Handle.html">Storage::Handle</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#ad330f5e35c41078cb64cd84ae59a0bc3">storage_handle</a> () const </td></tr>
<tr class="memdesc:ad330f5e35c41078cb64cd84ae59a0bc3"><td class="mdescLeft"> </td><td class="mdescRight">get storage handle  <a href="#ad330f5e35c41078cb64cd84ae59a0bc3">More...</a><br/></td></tr>
<tr class="separator:ad330f5e35c41078cb64cd84ae59a0bc3"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aedd79a43d5fa4173f3ddd719fb939fbc"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#aedd79a43d5fa4173f3ddd719fb939fbc">WaitToRead</a> () const </td></tr>
<tr class="memdesc:aedd79a43d5fa4173f3ddd719fb939fbc"><td class="mdescLeft"> </td><td class="mdescRight">Block until all the pending write operations with respect to current <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> are finished, and read can be performed.  <a href="#aedd79a43d5fa4173f3ddd719fb939fbc">More...</a><br/></td></tr>
<tr class="separator:aedd79a43d5fa4173f3ddd719fb939fbc"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4b88b5d86ec9ddf4ca96701107337461"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a4b88b5d86ec9ddf4ca96701107337461">WaitToWrite</a> () const </td></tr>
<tr class="memdesc:a4b88b5d86ec9ddf4ca96701107337461"><td class="mdescLeft"> </td><td class="mdescRight">Block until all the pending read/write operations with respect to current <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> are finished, and write can be performed.  <a href="#a4b88b5d86ec9ddf4ca96701107337461">More...</a><br/></td></tr>
<tr class="separator:a4b88b5d86ec9ddf4ca96701107337461"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a35c9b5da0852b480e0114f0865338cbc"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1Engine.html#aac31510c793a12944c33f9cac6150491">Engine::VarHandle</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a35c9b5da0852b480e0114f0865338cbc">var</a> () const </td></tr>
<tr class="separator:a35c9b5da0852b480e0114f0865338cbc"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5dfa016a606afd37b8bc85dc2832b025"><td align="right" class="memItemLeft" valign="top">size_t </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a5dfa016a606afd37b8bc85dc2832b025">byte_offset</a> () const </td></tr>
<tr class="separator:a5dfa016a606afd37b8bc85dc2832b025"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae650c3f9c9a8b4adeecf747b2fd99141"><td align="right" class="memItemLeft" valign="top">size_t </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#ae650c3f9c9a8b4adeecf747b2fd99141">version</a> () const </td></tr>
<tr class="memdesc:ae650c3f9c9a8b4adeecf747b2fd99141"><td class="mdescLeft"> </td><td class="mdescRight">return var version of the <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> <a href="#ae650c3f9c9a8b4adeecf747b2fd99141">More...</a><br/></td></tr>
<tr class="separator:ae650c3f9c9a8b4adeecf747b2fd99141"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a524662078483f8f46c6c71714fbfde0b"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a524662078483f8f46c6c71714fbfde0b">Save</a> (dmlc::Stream *strm) const </td></tr>
<tr class="memdesc:a524662078483f8f46c6c71714fbfde0b"><td class="mdescLeft"> </td><td class="mdescRight">save the content into binary stream  <a href="#a524662078483f8f46c6c71714fbfde0b">More...</a><br/></td></tr>
<tr class="separator:a524662078483f8f46c6c71714fbfde0b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a0b212c0a0c4c83c64a6bf6d0c430602b"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a0b212c0a0c4c83c64a6bf6d0c430602b">LegacyLoad</a> (dmlc::Stream *strm, const uint32_t magic)</td></tr>
<tr class="memdesc:a0b212c0a0c4c83c64a6bf6d0c430602b"><td class="mdescLeft"> </td><td class="mdescRight">load ndarrays before supporting sparse ndarrays  <a href="#a0b212c0a0c4c83c64a6bf6d0c430602b">More...</a><br/></td></tr>
<tr class="separator:a0b212c0a0c4c83c64a6bf6d0c430602b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5203aa033a53942deaecb7bb3bf46480"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a5203aa033a53942deaecb7bb3bf46480">Load</a> (dmlc::Stream *strm)</td></tr>
<tr class="memdesc:a5203aa033a53942deaecb7bb3bf46480"><td class="mdescLeft"> </td><td class="mdescRight">load the content from binary stream  <a href="#a5203aa033a53942deaecb7bb3bf46480">More...</a><br/></td></tr>
<tr class="separator:a5203aa033a53942deaecb7bb3bf46480"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa7a198e3e4c80a48cf92a913009aab8f"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp; </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#aa7a198e3e4c80a48cf92a913009aab8f">operator=</a> (<a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a> scalar)</td></tr>
<tr class="memdesc:aa7a198e3e4c80a48cf92a913009aab8f"><td class="mdescLeft"> </td><td class="mdescRight">set all the elements in ndarray to be scalar  <a href="#aa7a198e3e4c80a48cf92a913009aab8f">More...</a><br/></td></tr>
<tr class="separator:aa7a198e3e4c80a48cf92a913009aab8f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7df5a5d9956a481635fc43ca4d9a196c"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp; </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a7df5a5d9956a481635fc43ca4d9a196c">operator+=</a> (const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;src)</td></tr>
<tr class="memdesc:a7df5a5d9956a481635fc43ca4d9a196c"><td class="mdescLeft"> </td><td class="mdescRight">elementwise add to current space this mutate the current <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> <a href="#a7df5a5d9956a481635fc43ca4d9a196c">More...</a><br/></td></tr>
<tr class="separator:a7df5a5d9956a481635fc43ca4d9a196c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1068954b69113429bab7b369300fdbe0"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp; </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a1068954b69113429bab7b369300fdbe0">operator+=</a> (const <a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a> &amp;src)</td></tr>
<tr class="memdesc:a1068954b69113429bab7b369300fdbe0"><td class="mdescLeft"> </td><td class="mdescRight">elementwise add to current space this mutate the current <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> <a href="#a1068954b69113429bab7b369300fdbe0">More...</a><br/></td></tr>
<tr class="separator:a1068954b69113429bab7b369300fdbe0"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad35ba01da6949494afe895b7429e4fc3"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp; </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#ad35ba01da6949494afe895b7429e4fc3">operator-=</a> (const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;src)</td></tr>
<tr class="memdesc:ad35ba01da6949494afe895b7429e4fc3"><td class="mdescLeft"> </td><td class="mdescRight">elementwise subtract from current ndarray this mutate the current <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> <a href="#ad35ba01da6949494afe895b7429e4fc3">More...</a><br/></td></tr>
<tr class="separator:ad35ba01da6949494afe895b7429e4fc3"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a81a7b37678af0f23edc2beec6daca3ab"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp; </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a81a7b37678af0f23edc2beec6daca3ab">operator-=</a> (const <a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a> &amp;src)</td></tr>
<tr class="memdesc:a81a7b37678af0f23edc2beec6daca3ab"><td class="mdescLeft"> </td><td class="mdescRight">elementwise subtract from current ndarray this mutate the current <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> <a href="#a81a7b37678af0f23edc2beec6daca3ab">More...</a><br/></td></tr>
<tr class="separator:a81a7b37678af0f23edc2beec6daca3ab"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1b47078a60bf0369ff0a7df893caf65b"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp; </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a1b47078a60bf0369ff0a7df893caf65b">operator*=</a> (const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;src)</td></tr>
<tr class="memdesc:a1b47078a60bf0369ff0a7df893caf65b"><td class="mdescLeft"> </td><td class="mdescRight">elementwise multiplication to current ndarray this mutate the current <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> <a href="#a1b47078a60bf0369ff0a7df893caf65b">More...</a><br/></td></tr>
<tr class="separator:a1b47078a60bf0369ff0a7df893caf65b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7b4b2ac8b0c154ae8c53ebfd2d1d3fcf"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp; </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a7b4b2ac8b0c154ae8c53ebfd2d1d3fcf">operator*=</a> (const <a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a> &amp;src)</td></tr>
<tr class="memdesc:a7b4b2ac8b0c154ae8c53ebfd2d1d3fcf"><td class="mdescLeft"> </td><td class="mdescRight">elementwise multiplication to current ndarray this mutate the current <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> <a href="#a7b4b2ac8b0c154ae8c53ebfd2d1d3fcf">More...</a><br/></td></tr>
<tr class="separator:a7b4b2ac8b0c154ae8c53ebfd2d1d3fcf"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aebc61006705874666423c45f161df546"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp; </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#aebc61006705874666423c45f161df546">operator/=</a> (const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;src)</td></tr>
<tr class="memdesc:aebc61006705874666423c45f161df546"><td class="mdescLeft"> </td><td class="mdescRight">elementwise division from current ndarray this mutate the current <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> <a href="#aebc61006705874666423c45f161df546">More...</a><br/></td></tr>
<tr class="separator:aebc61006705874666423c45f161df546"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab88b476b2092b30c7d456d99df9f36e3"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp; </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#ab88b476b2092b30c7d456d99df9f36e3">operator/=</a> (const <a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a> &amp;src)</td></tr>
<tr class="memdesc:ab88b476b2092b30c7d456d99df9f36e3"><td class="mdescLeft"> </td><td class="mdescRight">elementwise division from current ndarray this mutate the current <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> <a href="#ab88b476b2092b30c7d456d99df9f36e3">More...</a><br/></td></tr>
<tr class="separator:ab88b476b2092b30c7d456d99df9f36e3"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4a00e2868ad8b9ccb0a48079635b110f"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a4a00e2868ad8b9ccb0a48079635b110f">Copy</a> (<a class="el" href="structmxnet_1_1Context.html">Context</a> <a class="el" href="classmxnet_1_1NDArray.html#a5e2eb64751872f537ae3cb25f949fff1">ctx</a>) const </td></tr>
<tr class="memdesc:a4a00e2868ad8b9ccb0a48079635b110f"><td class="mdescLeft"> </td><td class="mdescRight">return a new copy this <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> <a href="#a4a00e2868ad8b9ccb0a48079635b110f">More...</a><br/></td></tr>
<tr class="separator:a4a00e2868ad8b9ccb0a48079635b110f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a422c70b16646f8a273e9b4936fbe2e37"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a422c70b16646f8a273e9b4936fbe2e37">SyncCopyFromCPU</a> (const void *<a class="el" href="classmxnet_1_1NDArray.html#aebd03e900ec7664a99b780a0cb1efea6">data</a>, size_t size) const </td></tr>
<tr class="memdesc:a422c70b16646f8a273e9b4936fbe2e37"><td class="mdescLeft"> </td><td class="mdescRight">Do a synchronize copy from a continugous CPU memory region.  <a href="#a422c70b16646f8a273e9b4936fbe2e37">More...</a><br/></td></tr>
<tr class="separator:a422c70b16646f8a273e9b4936fbe2e37"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa3943fcf632304f6ab165b8628710609"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#aa3943fcf632304f6ab165b8628710609">SyncCopyFromNDArray</a> (const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;src, int i=-1, int j=-1)</td></tr>
<tr class="memdesc:aa3943fcf632304f6ab165b8628710609"><td class="mdescLeft"> </td><td class="mdescRight">Copy from src.data()/aux_data(i) to this-&gt;<a class="el" href="classmxnet_1_1NDArray.html#aebd03e900ec7664a99b780a0cb1efea6">data()</a>/aux_data(j)  <a href="#aa3943fcf632304f6ab165b8628710609">More...</a><br/></td></tr>
<tr class="separator:aa3943fcf632304f6ab165b8628710609"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4819d2e6431ccdf4b9f8efa8eb0bd1fd"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a4819d2e6431ccdf4b9f8efa8eb0bd1fd">SyncCopyToCPU</a> (void *<a class="el" href="classmxnet_1_1NDArray.html#aebd03e900ec7664a99b780a0cb1efea6">data</a>, size_t size) const </td></tr>
<tr class="memdesc:a4819d2e6431ccdf4b9f8efa8eb0bd1fd"><td class="mdescLeft"> </td><td class="mdescRight">Do a synchronize copy to a continugous CPU memory region.  <a href="#a4819d2e6431ccdf4b9f8efa8eb0bd1fd">More...</a><br/></td></tr>
<tr class="separator:a4819d2e6431ccdf4b9f8efa8eb0bd1fd"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ade97bd4e93028ede123f6ccec5b3b038"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#ade97bd4e93028ede123f6ccec5b3b038">SyncCheckFormat</a> (const bool full_check) const </td></tr>
<tr class="memdesc:ade97bd4e93028ede123f6ccec5b3b038"><td class="mdescLeft"> </td><td class="mdescRight">check whether the <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> format is valid  <a href="#ade97bd4e93028ede123f6ccec5b3b038">More...</a><br/></td></tr>
<tr class="separator:ade97bd4e93028ede123f6ccec5b3b038"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7acb6462c11e071949db2b0e1fbfd66e"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a7acb6462c11e071949db2b0e1fbfd66e">Slice</a> (<a class="el" href="namespacemxnet.html#abadedc1b42ee3e5b8852e63783b982ef">index_t</a> begin, <a class="el" href="namespacemxnet.html#abadedc1b42ee3e5b8852e63783b982ef">index_t</a> end) const </td></tr>
<tr class="memdesc:a7acb6462c11e071949db2b0e1fbfd66e"><td class="mdescLeft"> </td><td class="mdescRight">Slice a <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>.  <a href="#a7acb6462c11e071949db2b0e1fbfd66e">More...</a><br/></td></tr>
<tr class="separator:a7acb6462c11e071949db2b0e1fbfd66e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a0d868e5303669d6ce8a5ada1c34940ac"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a0d868e5303669d6ce8a5ada1c34940ac">SliceWithRecord</a> (<a class="el" href="namespacemxnet.html#abadedc1b42ee3e5b8852e63783b982ef">index_t</a> begin, <a class="el" href="namespacemxnet.html#abadedc1b42ee3e5b8852e63783b982ef">index_t</a> end)</td></tr>
<tr class="memdesc:a0d868e5303669d6ce8a5ada1c34940ac"><td class="mdescLeft"> </td><td class="mdescRight">Slice a <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>. Supports recording with autograd.  <a href="#a0d868e5303669d6ce8a5ada1c34940ac">More...</a><br/></td></tr>
<tr class="separator:a0d868e5303669d6ce8a5ada1c34940ac"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a3b615512a8fb89b9edc99b35064ead95"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a3b615512a8fb89b9edc99b35064ead95">At</a> (<a class="el" href="namespacemxnet.html#abadedc1b42ee3e5b8852e63783b982ef">index_t</a> idx) const </td></tr>
<tr class="memdesc:a3b615512a8fb89b9edc99b35064ead95"><td class="mdescLeft"> </td><td class="mdescRight">Index a <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>.  <a href="#a3b615512a8fb89b9edc99b35064ead95">More...</a><br/></td></tr>
<tr class="separator:a3b615512a8fb89b9edc99b35064ead95"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa2a801dd5c47b5bdd01a385d2c4327b8"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#aa2a801dd5c47b5bdd01a385d2c4327b8">AtWithRecord</a> (<a class="el" href="namespacemxnet.html#abadedc1b42ee3e5b8852e63783b982ef">index_t</a> idx)</td></tr>
<tr class="memdesc:aa2a801dd5c47b5bdd01a385d2c4327b8"><td class="mdescLeft"> </td><td class="mdescRight">Index a <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>.  <a href="#aa2a801dd5c47b5bdd01a385d2c4327b8">More...</a><br/></td></tr>
<tr class="separator:aa2a801dd5c47b5bdd01a385d2c4327b8"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a3d018c2cfcba0ad499ee5f8ac1475964"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a3d018c2cfcba0ad499ee5f8ac1475964">aux_ndarray</a> (size_t i) const </td></tr>
<tr class="memdesc:a3d018c2cfcba0ad499ee5f8ac1475964"><td class="mdescLeft"> </td><td class="mdescRight">Generate a deep copy of aux_data(i) returned as a default storage type <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>.  <a href="#a3d018c2cfcba0ad499ee5f8ac1475964">More...</a><br/></td></tr>
<tr class="separator:a3d018c2cfcba0ad499ee5f8ac1475964"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af6d456d1e9f105fe913b696fe88efdc3"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#af6d456d1e9f105fe913b696fe88efdc3">data_ndarray</a> () const </td></tr>
<tr class="memdesc:af6d456d1e9f105fe913b696fe88efdc3"><td class="mdescLeft"> </td><td class="mdescRight">Generate a deep copy of <a class="el" href="classmxnet_1_1NDArray.html#aebd03e900ec7664a99b780a0cb1efea6">data()</a> returned as a default storage type <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>.  <a href="#af6d456d1e9f105fe913b696fe88efdc3">More...</a><br/></td></tr>
<tr class="separator:af6d456d1e9f105fe913b696fe88efdc3"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a46ccc06ccb40071d0d275d4c649f3d07"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a46ccc06ccb40071d0d275d4c649f3d07">AsArray</a> (const <a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a> &amp;<a class="el" href="classmxnet_1_1NDArray.html#a1910c16c97754399ceafcd36e80893e2">shape</a>, int <a class="el" href="classmxnet_1_1NDArray.html#a1b6038a196c14d038bd3e6d6bbe36ad2">dtype</a>) const </td></tr>
<tr class="memdesc:a46ccc06ccb40071d0d275d4c649f3d07"><td class="mdescLeft"> </td><td class="mdescRight">Create a <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> that shares memory with current one The new array must have smaller memory size than the current array.  <a href="#a46ccc06ccb40071d0d275d4c649f3d07">More...</a><br/></td></tr>
<tr class="separator:a46ccc06ccb40071d0d275d4c649f3d07"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a89d6048d5aa182e20507bf85f6aaff31"><td align="right" class="memItemLeft" valign="top">DLManagedTensor * </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a89d6048d5aa182e20507bf85f6aaff31">ToDLPack</a> () const </td></tr>
<tr class="memdesc:a89d6048d5aa182e20507bf85f6aaff31"><td class="mdescLeft"> </td><td class="mdescRight">Create a reference view of <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> that represents as DLManagedTensor.  <a href="#a89d6048d5aa182e20507bf85f6aaff31">More...</a><br/></td></tr>
<tr class="separator:a89d6048d5aa182e20507bf85f6aaff31"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a36348646a0c2756b8c8cfa80f44f1eef"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a36348646a0c2756b8c8cfa80f44f1eef">SparseUpdateChunk</a> (const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;arr) const </td></tr>
<tr class="memdesc:a36348646a0c2756b8c8cfa80f44f1eef"><td class="mdescLeft"> </td><td class="mdescRight">Update ndarray chunk storage handles using existing ndarray storage handles Also update the aux_handle, aux_shapes and aux_types. This is specifically used for custom op to update the inputs and outputs from the temporary ndarray which stores intermediate custom op results. Should be used with caution elsewhere. Supports only CSR and RSP formats.  <a href="#a36348646a0c2756b8c8cfa80f44f1eef">More...</a><br/></td></tr>
<tr class="separator:a36348646a0c2756b8c8cfa80f44f1eef"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6fae131254fca49b6120c3e0bef4633d"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a6fae131254fca49b6120c3e0bef4633d">Reshape</a> (const <a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a> &amp;<a class="el" href="classmxnet_1_1NDArray.html#a1910c16c97754399ceafcd36e80893e2">shape</a>) const </td></tr>
<tr class="memdesc:a6fae131254fca49b6120c3e0bef4633d"><td class="mdescLeft"> </td><td class="mdescRight">Get an reshaped <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>.  <a href="#a6fae131254fca49b6120c3e0bef4633d">More...</a><br/></td></tr>
<tr class="separator:a6fae131254fca49b6120c3e0bef4633d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a318e6f3ae6f94026dec90aa98a7e3f10"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a318e6f3ae6f94026dec90aa98a7e3f10">ReshapeWithRecord</a> (const <a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a> &amp;<a class="el" href="classmxnet_1_1NDArray.html#a1910c16c97754399ceafcd36e80893e2">shape</a>)</td></tr>
<tr class="memdesc:a318e6f3ae6f94026dec90aa98a7e3f10"><td class="mdescLeft"> </td><td class="mdescRight">Get an reshaped <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>. Supports autograd recording.  <a href="#a318e6f3ae6f94026dec90aa98a7e3f10">More...</a><br/></td></tr>
<tr class="separator:a318e6f3ae6f94026dec90aa98a7e3f10"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a34a3694141050a257dc6b40a6ad2c4ec"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a34a3694141050a257dc6b40a6ad2c4ec">Detach</a> () const </td></tr>
<tr class="memdesc:a34a3694141050a257dc6b40a6ad2c4ec"><td class="mdescLeft"> </td><td class="mdescRight">Return a copy of this <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> without autograd history.  <a href="#a34a3694141050a257dc6b40a6ad2c4ec">More...</a><br/></td></tr>
<tr class="separator:a34a3694141050a257dc6b40a6ad2c4ec"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a8f03aa51719b1c7d6ec8b812cdcb7f14"><td align="right" class="memItemLeft" valign="top">nnvm::Symbol </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a8f03aa51719b1c7d6ec8b812cdcb7f14">get_autograd_symbol</a> () const </td></tr>
<tr class="separator:a8f03aa51719b1c7d6ec8b812cdcb7f14"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a35c2a2c797f601fbc5d560481b11720a"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a35c2a2c797f601fbc5d560481b11720a">CheckAndAlloc</a> () const </td></tr>
<tr class="memdesc:a35c2a2c797f601fbc5d560481b11720a"><td class="mdescLeft"> </td><td class="mdescRight">Allocate the space if it is delayed allocated. This is an internal function used by system that normal user should not use.  <a href="#a35c2a2c797f601fbc5d560481b11720a">More...</a><br/></td></tr>
<tr class="separator:a35c2a2c797f601fbc5d560481b11720a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa99f425040db90b52f945007a2f11b73"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#aa99f425040db90b52f945007a2f11b73">ReshapeAndAlloc</a> (const <a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a> &amp;<a class="el" href="classmxnet_1_1NDArray.html#a1910c16c97754399ceafcd36e80893e2">shape</a>)</td></tr>
<tr class="memdesc:aa99f425040db90b52f945007a2f11b73"><td class="mdescLeft"> </td><td class="mdescRight">Allocate the space if the allocation has been delayed or the requested size is bigger than the available one. This function can only be called by ndarray of default storage type and effectively changes the ndarray's shape_. Note: This function is named as this to avoid overload conflict with CheckAndAlloc(const mxnet::ShapeVector &amp;aux_shapes), since <a class="el" href="classmxnet_1_1TShape.html" title="A Shape class that is used to represent shape of each tensor. ">mxnet::TShape</a> tmp = some_shape is equivalent to <a class="el" href="classmxnet_1_1TShape.html" title="A Shape class that is used to represent shape of each tensor. ">mxnet::TShape</a> tmp = {some_shape}.  <a href="#aa99f425040db90b52f945007a2f11b73">More...</a><br/></td></tr>
<tr class="separator:aa99f425040db90b52f945007a2f11b73"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a05980c2e87a04b13efa673bb4faf1ab0"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a05980c2e87a04b13efa673bb4faf1ab0">CheckAndAlloc</a> (const <a class="el" href="namespacemxnet.html#a87e1c30aafac389774c6f4d905c0e5ea">mxnet::ShapeVector</a> &amp;<a class="el" href="classmxnet_1_1NDArray.html#a251088c33eb30d4fcef12e27e9ba4490">aux_shapes</a>) const </td></tr>
<tr class="separator:a05980c2e87a04b13efa673bb4faf1ab0"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a991f21c9018f166ec397142c4da1cec3"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a991f21c9018f166ec397142c4da1cec3">CheckAndAllocData</a> (const <a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a> &amp;<a class="el" href="classmxnet_1_1NDArray.html#a45fba0f5e822d832bf5bed08bb8cfb36">storage_shape</a>) const </td></tr>
<tr class="separator:a991f21c9018f166ec397142c4da1cec3"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1132664766298aca778cbe2cd96ceb81"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a1132664766298aca778cbe2cd96ceb81">CheckAndAllocAuxData</a> (size_t i, const <a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a> &amp;<a class="el" href="classmxnet_1_1NDArray.html#a594a69f0f6cc791664f9561285a22ab1">aux_shape</a>) const </td></tr>
<tr class="separator:a1132664766298aca778cbe2cd96ceb81"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a0d7a0ccf8e8a76e8be1c5817f4754236"><td align="right" class="memItemLeft" valign="top">static <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a0d7a0ccf8e8a76e8be1c5817f4754236">FromDLPack</a> (const DLManagedTensor *tensor, bool transient_handle)</td></tr>
<tr class="memdesc:a0d7a0ccf8e8a76e8be1c5817f4754236"><td class="mdescLeft"> </td><td class="mdescRight">Create a <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> backed by a dlpack tensor.  <a href="#a0d7a0ccf8e8a76e8be1c5817f4754236">More...</a><br/></td></tr>
<tr class="separator:a0d7a0ccf8e8a76e8be1c5817f4754236"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af215b7a886e717b4bb3c911fe3c1a032"><td align="right" class="memItemLeft" valign="top">static void </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#af215b7a886e717b4bb3c911fe3c1a032">Save</a> (dmlc::Stream *fo, const std::vector&lt; <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &gt; &amp;<a class="el" href="classmxnet_1_1NDArray.html#aebd03e900ec7664a99b780a0cb1efea6">data</a>, const std::vector&lt; std::string &gt; &amp;names)</td></tr>
<tr class="memdesc:af215b7a886e717b4bb3c911fe3c1a032"><td class="mdescLeft"> </td><td class="mdescRight">Save list of ndarray into the Stream.x.  <a href="#af215b7a886e717b4bb3c911fe3c1a032">More...</a><br/></td></tr>
<tr class="separator:af215b7a886e717b4bb3c911fe3c1a032"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae45c38de80d6d4dc79ad3d24baa9e981"><td align="right" class="memItemLeft" valign="top">static void </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#ae45c38de80d6d4dc79ad3d24baa9e981">Load</a> (dmlc::Stream *fi, std::vector&lt; <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &gt; *<a class="el" href="classmxnet_1_1NDArray.html#aebd03e900ec7664a99b780a0cb1efea6">data</a>, std::vector&lt; std::string &gt; *keys)</td></tr>
<tr class="memdesc:ae45c38de80d6d4dc79ad3d24baa9e981"><td class="mdescLeft"> </td><td class="mdescRight">Load list of ndarray into from the stream.  <a href="#ae45c38de80d6d4dc79ad3d24baa9e981">More...</a><br/></td></tr>
<tr class="separator:ae45c38de80d6d4dc79ad3d24baa9e981"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:add286ab9a359eb017008c9a3ff53701f"><td align="right" class="memItemLeft" valign="top">class </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#add286ab9a359eb017008c9a3ff53701f">Imperative</a></td></tr>
<tr class="separator:add286ab9a359eb017008c9a3ff53701f"><td class="memSeparator" colspan="2"> </td></tr>
</table>
<a id="details" name="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>ndarray interface </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a12ec978e5dbe9092d21721a657c39756"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">mxnet::NDArray::NDArray </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>default constructor </p>
</div>
</div>
<a class="anchor" id="a58d6f716d7eebf822c75e841342d9feb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">mxnet::NDArray::NDArray </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a> &amp; </td>
<td class="paramname"><em>shape</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1Context.html">Context</a> </td>
<td class="paramname"><em>ctx</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>delay_alloc</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>dtype</em> = <code>mshadow::default_type_flag</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>constructs a new dynamic <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">shape</td><td>the shape of array </td></tr>
<tr><td class="paramname">ctx</td><td>context of <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> </td></tr>
<tr><td class="paramname">delay_alloc</td><td>whether delay the allocation </td></tr>
<tr><td class="paramname">dtype</td><td>data type of this ndarray </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="ad45e6e6669cdde0232d05f1e549ec607"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">mxnet::NDArray::NDArray </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="namespacemxnet.html#a536b732faa980e1de446c552460ff76a">NDArrayStorageType</a> </td>
<td class="paramname"><em>stype</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a> &amp; </td>
<td class="paramname"><em>shape</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1Context.html">Context</a> </td>
<td class="paramname"><em>ctx</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>delay_alloc</em> = <code>true</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>dtype</em> = <code>mshadow::default_type_flag</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">std::vector&lt; int &gt; </td>
<td class="paramname"><em>aux_types</em> = <code>{}</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespacemxnet.html#a87e1c30aafac389774c6f4d905c0e5ea">mxnet::ShapeVector</a> </td>
<td class="paramname"><em>aux_shapes</em> = <code>{}</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a> </td>
<td class="paramname"><em>storage_shape</em> = <code><a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a>(mshadow::Shape1(0))</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>constructor for <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> with storage type </p>
</div>
</div>
<a class="anchor" id="afbfcf25b4e005007c40300c711c34f69"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">mxnet::NDArray::NDArray </td>
<td>(</td>
<td class="paramtype"><a class="el" href="structmxnet_1_1Context.html">Context</a> </td>
<td class="paramname"><em>ctx</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>dtype</em> = <code>mshadow::default_type_flag</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>constructs a new dynamic <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> whose shape is unknown, hence the <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> is inherently lazily created </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">ctx</td><td>context of <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> </td></tr>
<tr><td class="paramname">dtype</td><td>data type of this ndarray </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="a1a7288505ac9bbb19830161f7e5c1a6f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">mxnet::NDArray::NDArray </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="classmxnet_1_1TBlob.html">TBlob</a> &amp; </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>dev_id</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>constructing a static <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> that shares data with <a class="el" href="classmxnet_1_1TBlob.html" title="tensor blob class that can be used to hold tensor of any dimension, any device and any data type...">TBlob</a> Use with caution: allocate ONLY ONE <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> for each <a class="el" href="classmxnet_1_1TBlob.html" title="tensor blob class that can be used to hold tensor of any dimension, any device and any data type...">TBlob</a>, make sure the memory region is available through out the life of <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>the memory content of static data </td></tr>
<tr><td class="paramname">dev_id</td><td>the device id this tensor sits at </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="aa2e26d3d53e546a8b5f458c0cc204387"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">mxnet::NDArray::NDArray </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="classmxnet_1_1TBlob.html">TBlob</a> &amp; </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>dev_id</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const std::function&lt; void()&gt; &amp; </td>
<td class="paramname"><em>deleter</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>constructing a static <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> that shares data with <a class="el" href="classmxnet_1_1TBlob.html" title="tensor blob class that can be used to hold tensor of any dimension, any device and any data type...">TBlob</a> which is with deleter Use with caution: allocate ONLY ONE <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> for each <a class="el" href="classmxnet_1_1TBlob.html" title="tensor blob class that can be used to hold tensor of any dimension, any device and any data type...">TBlob</a>, make sure the memory region is available through out the life of <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>the memory content of static data </td></tr>
<tr><td class="paramname">dev_id</td><td>the device id this tensor sits at </td></tr>
<tr><td class="paramname">deleter</td><td>the function pointer of custom deleter </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="ac5858cd154fbf68f832c2717f4f925e8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">mxnet::NDArray::NDArray </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>shared_pid</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>shared_id</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a> &amp; </td>
<td class="paramname"><em>shape</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>dtype</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>create ndarray from shared memory </p>
</div>
</div>
<a class="anchor" id="a3ab28f889680e6aad1b981b378f206d9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">mxnet::NDArray::NDArray </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="namespacemxnet.html#a536b732faa980e1de446c552460ff76a">NDArrayStorageType</a> </td>
<td class="paramname"><em>stype</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a> &amp; </td>
<td class="paramname"><em>shape</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="classmxnet_1_1TBlob.html">TBlob</a> &amp; </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const std::vector&lt; <a class="el" href="classmxnet_1_1TBlob.html">TBlob</a> &gt; &amp; </td>
<td class="paramname"><em>aux_data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>dev_id</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>constructing a static <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> of non-default storage that shares data with <a class="el" href="classmxnet_1_1TBlob.html" title="tensor blob class that can be used to hold tensor of any dimension, any device and any data type...">TBlob</a> Use with caution: allocate ONLY ONE <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> for each <a class="el" href="classmxnet_1_1TBlob.html" title="tensor blob class that can be used to hold tensor of any dimension, any device and any data type...">TBlob</a>, make sure the memory region is available through out the life of <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">stype</td><td>the storage type of <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> </td></tr>
<tr><td class="paramname">shape</td><td>the shape of <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> </td></tr>
<tr><td class="paramname">data</td><td>the memory content of static data </td></tr>
<tr><td class="paramname">aux_data</td><td>the memory content of static aux data </td></tr>
<tr><td class="paramname">dev_id</td><td>the device id this tensor sits at </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a46ccc06ccb40071d0d275d4c649f3d07"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> mxnet::NDArray::AsArray </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a> &amp; </td>
<td class="paramname"><em>shape</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>dtype</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Create a <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> that shares memory with current one The new array must have smaller memory size than the current array. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">shape</td><td>new shape </td></tr>
<tr><td class="paramname">dtype</td><td>The data type. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> in new shape and type. </dd></dl>
</div>
</div>
<a class="anchor" id="a3b615512a8fb89b9edc99b35064ead95"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> mxnet::NDArray::At </td>
<td>(</td>
<td class="paramtype"><a class="el" href="namespacemxnet.html#abadedc1b42ee3e5b8852e63783b982ef">index_t</a> </td>
<td class="paramname"><em>idx</em></td><td>)</td>
<td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Index a <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">idx</td><td>the index </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>idx-th sub array <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> </dd></dl>
</div>
</div>
<a class="anchor" id="aa2a801dd5c47b5bdd01a385d2c4327b8"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> mxnet::NDArray::AtWithRecord </td>
<td>(</td>
<td class="paramtype"><a class="el" href="namespacemxnet.html#abadedc1b42ee3e5b8852e63783b982ef">index_t</a> </td>
<td class="paramname"><em>idx</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Index a <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">idx</td><td>the index </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>idx-th sub array <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> </dd></dl>
</div>
</div>
<a class="anchor" id="ad8194805eabb65d8a9d33fda840b66a9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1TBlob.html">TBlob</a> mxnet::NDArray::aux_data </td>
<td>(</td>
<td class="paramtype">size_t </td>
<td class="paramname"><em>i</em></td><td>)</td>
<td> const</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the aux <a class="el" href="classmxnet_1_1TBlob.html" title="tensor blob class that can be used to hold tensor of any dimension, any device and any data type...">TBlob</a> </dd></dl>
</div>
</div>
<a class="anchor" id="a3d018c2cfcba0ad499ee5f8ac1475964"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> mxnet::NDArray::aux_ndarray </td>
<td>(</td>
<td class="paramtype">size_t </td>
<td class="paramname"><em>i</em></td><td>)</td>
<td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Generate a deep copy of aux_data(i) returned as a default storage type <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>. </p>
</div>
</div>
<a class="anchor" id="a594a69f0f6cc791664f9561285a22ab1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">const <a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a>&amp; mxnet::NDArray::aux_shape </td>
<td>(</td>
<td class="paramtype">size_t </td>
<td class="paramname"><em>index</em></td><td>)</td>
<td> const</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>get the shape of aux_data(index) </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">index</td><td>the index of the aux data </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the shape of aux data at given index </dd></dl>
</div>
</div>
<a class="anchor" id="a251088c33eb30d4fcef12e27e9ba4490"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">const <a class="el" href="namespacemxnet.html#a87e1c30aafac389774c6f4d905c0e5ea">mxnet::ShapeVector</a>&amp; mxnet::NDArray::aux_shapes </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a class="anchor" id="a02fe304d3498632571fea1a7c1fd91d6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">int mxnet::NDArray::aux_type </td>
<td>(</td>
<td class="paramtype">size_t </td>
<td class="paramname"><em>i</em></td><td>)</td>
<td> const</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a class="anchor" id="a8970b39ecb7947218981f607d9b6dce8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">const std::vector&lt;int&gt;&amp; mxnet::NDArray::aux_types </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>returns the dtypes of all aux data </p>
</div>
</div>
<a class="anchor" id="a5dfa016a606afd37b8bc85dc2832b025"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">size_t mxnet::NDArray::byte_offset </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>byte offset in chunk of the ndarray </dd></dl>
</div>
</div>
<a class="anchor" id="a35c2a2c797f601fbc5d560481b11720a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">void mxnet::NDArray::CheckAndAlloc </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Allocate the space if it is delayed allocated. This is an internal function used by system that normal user should not use. </p>
</div>
</div>
<a class="anchor" id="a05980c2e87a04b13efa673bb4faf1ab0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">void mxnet::NDArray::CheckAndAlloc </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="namespacemxnet.html#a87e1c30aafac389774c6f4d905c0e5ea">mxnet::ShapeVector</a> &amp; </td>
<td class="paramname"><em>aux_shapes</em></td><td>)</td>
<td> const</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a class="anchor" id="a1132664766298aca778cbe2cd96ceb81"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">void mxnet::NDArray::CheckAndAllocAuxData </td>
<td>(</td>
<td class="paramtype">size_t </td>
<td class="paramname"><em>i</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a> &amp; </td>
<td class="paramname"><em>aux_shape</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a class="anchor" id="a991f21c9018f166ec397142c4da1cec3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">void mxnet::NDArray::CheckAndAllocData </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a> &amp; </td>
<td class="paramname"><em>storage_shape</em></td><td>)</td>
<td> const</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a class="anchor" id="a4a00e2868ad8b9ccb0a48079635b110f"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> mxnet::NDArray::Copy </td>
<td>(</td>
<td class="paramtype"><a class="el" href="structmxnet_1_1Context.html">Context</a> </td>
<td class="paramname"><em>ctx</em></td><td>)</td>
<td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>return a new copy this <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">ctx</td><td>the new context of this <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new copy </dd></dl>
</div>
</div>
<a class="anchor" id="a5e2eb64751872f537ae3cb25f949fff1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="structmxnet_1_1Context.html">Context</a> mxnet::NDArray::ctx </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the context of <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>, this function is only valid when the <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> is not empty </dd></dl>
</div>
</div>
<a class="anchor" id="aebd03e900ec7664a99b780a0cb1efea6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">const <a class="el" href="classmxnet_1_1TBlob.html">TBlob</a>&amp; mxnet::NDArray::data </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the data <a class="el" href="classmxnet_1_1TBlob.html" title="tensor blob class that can be used to hold tensor of any dimension, any device and any data type...">TBlob</a> </dd></dl>
</div>
</div>
<a class="anchor" id="af6d456d1e9f105fe913b696fe88efdc3"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> mxnet::NDArray::data_ndarray </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Generate a deep copy of <a class="el" href="classmxnet_1_1NDArray.html#aebd03e900ec7664a99b780a0cb1efea6">data()</a> returned as a default storage type <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>. </p>
</div>
</div>
<a class="anchor" id="a34a3694141050a257dc6b40a6ad2c4ec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> mxnet::NDArray::Detach </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Return a copy of this <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> without autograd history. </p>
</div>
</div>
<a class="anchor" id="a1b6038a196c14d038bd3e6d6bbe36ad2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">int mxnet::NDArray::dtype </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the data type of <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>, this function is only valid when the <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> is not empty </dd></dl>
</div>
</div>
<a class="anchor" id="aee74980eb87bf7c482d15458f5194cbe"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">bool mxnet::NDArray::fresh_out_grad </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>updated grad state in entry_ </dd></dl>
</div>
</div>
<a class="anchor" id="a0d7a0ccf8e8a76e8be1c5817f4754236"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">static <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> mxnet::NDArray::FromDLPack </td>
<td>(</td>
<td class="paramtype">const DLManagedTensor * </td>
<td class="paramname"><em>tensor</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>transient_handle</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Create a <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> backed by a dlpack tensor. </p>
<p>This allows us to create a <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> using the memory allocated by an external deep learning framework that is DLPack compatible.</p>
<p>The memory is retained until the <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> went out of scope.</p>
<dl class="section return"><dt>Returns</dt><dd>The created <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> view. </dd></dl>
</div>
</div>
<a class="anchor" id="a8f03aa51719b1c7d6ec8b812cdcb7f14"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">nnvm::Symbol mxnet::NDArray::get_autograd_symbol </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a class="anchor" id="aed729c3bc9db04ab346fd3969b4fc982"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> mxnet::NDArray::grad </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the gradient ndarray. </dd></dl>
</div>
</div>
<a class="anchor" id="a1e789a9d17c0b15749d247122e9b207a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">void mxnet::NDArray::Init </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a> &amp; </td>
<td class="paramname"><em>shape</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>initialize the <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>, assuming it is not assigned a meaningful shape before </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">shape</td><td>the shape of the <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="a2a15ffdbf29d4d5455a4fbb4b607880c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">bool mxnet::NDArray::is_none </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>whether this ndarray is not initialized </dd></dl>
</div>
</div>
<a class="anchor" id="adfd9872e55953d5cbea39728ea7d4289"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">bool mxnet::NDArray::IsSame </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp; </td>
<td class="paramname"><em>other</em></td><td>)</td>
<td> const</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a class="anchor" id="a117e3af0d08abf56ff8852adfb71f413"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">bool mxnet::NDArray::IsView </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a class="anchor" id="a0b212c0a0c4c83c64a6bf6d0c430602b"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">bool mxnet::NDArray::LegacyLoad </td>
<td>(</td>
<td class="paramtype">dmlc::Stream * </td>
<td class="paramname"><em>strm</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const uint32_t </td>
<td class="paramname"><em>magic</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>load ndarrays before supporting sparse ndarrays </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">strm</td><td>the output stream </td></tr>
<tr><td class="paramname">magic</td><td>the magic number used for version control </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="a5203aa033a53942deaecb7bb3bf46480"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">bool mxnet::NDArray::Load </td>
<td>(</td>
<td class="paramtype">dmlc::Stream * </td>
<td class="paramname"><em>strm</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>load the content from binary stream </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">strm</td><td>the output stream </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the load is successful </dd></dl>
</div>
</div>
<a class="anchor" id="ae45c38de80d6d4dc79ad3d24baa9e981"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">static void mxnet::NDArray::Load </td>
<td>(</td>
<td class="paramtype">dmlc::Stream * </td>
<td class="paramname"><em>fi</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">std::vector&lt; <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &gt; * </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">std::vector&lt; std::string &gt; * </td>
<td class="paramname"><em>keys</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Load list of ndarray into from the stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">fi</td><td>The stream of the input file. </td></tr>
<tr><td class="paramname">data</td><td>the NDArrays to be loaded </td></tr>
<tr><td class="paramname">keys</td><td>the name of the <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>, if saved in the file. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="a1b47078a60bf0369ff0a7df893caf65b"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a>&amp; mxnet::NDArray::operator*= </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp; </td>
<td class="paramname"><em>src</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>elementwise multiplication to current ndarray this mutate the current <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">src</td><td>the data to subtract </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference of self </dd></dl>
</div>
</div>
<a class="anchor" id="a7b4b2ac8b0c154ae8c53ebfd2d1d3fcf"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a>&amp; mxnet::NDArray::operator*= </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a> &amp; </td>
<td class="paramname"><em>src</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>elementwise multiplication to current ndarray this mutate the current <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">src</td><td>the data to subtract </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference of self </dd></dl>
</div>
</div>
<a class="anchor" id="a7df5a5d9956a481635fc43ca4d9a196c"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a>&amp; mxnet::NDArray::operator+= </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp; </td>
<td class="paramname"><em>src</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>elementwise add to current space this mutate the current <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">src</td><td>the data to add </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference of self </dd></dl>
</div>
</div>
<a class="anchor" id="a1068954b69113429bab7b369300fdbe0"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a>&amp; mxnet::NDArray::operator+= </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a> &amp; </td>
<td class="paramname"><em>src</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>elementwise add to current space this mutate the current <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">src</td><td>the data to add </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference of self </dd></dl>
</div>
</div>
<a class="anchor" id="ad35ba01da6949494afe895b7429e4fc3"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a>&amp; mxnet::NDArray::operator-= </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp; </td>
<td class="paramname"><em>src</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>elementwise subtract from current ndarray this mutate the current <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">src</td><td>the data to subtract </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference of self </dd></dl>
</div>
</div>
<a class="anchor" id="a81a7b37678af0f23edc2beec6daca3ab"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a>&amp; mxnet::NDArray::operator-= </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a> &amp; </td>
<td class="paramname"><em>src</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>elementwise subtract from current ndarray this mutate the current <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">src</td><td>the data to subtract </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference of self </dd></dl>
</div>
</div>
<a class="anchor" id="aebc61006705874666423c45f161df546"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a>&amp; mxnet::NDArray::operator/= </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp; </td>
<td class="paramname"><em>src</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>elementwise division from current ndarray this mutate the current <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">src</td><td>the data to subtract </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference of self </dd></dl>
</div>
</div>
<a class="anchor" id="ab88b476b2092b30c7d456d99df9f36e3"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a>&amp; mxnet::NDArray::operator/= </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a> &amp; </td>
<td class="paramname"><em>src</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>elementwise division from current ndarray this mutate the current <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">src</td><td>the data to subtract </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference of self </dd></dl>
</div>
</div>
<a class="anchor" id="aa7a198e3e4c80a48cf92a913009aab8f"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a>&amp; mxnet::NDArray::operator= </td>
<td>(</td>
<td class="paramtype"><a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a> </td>
<td class="paramname"><em>scalar</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>set all the elements in ndarray to be scalar </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">scalar</td><td>the scalar to set </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference of self </dd></dl>
</div>
</div>
<a class="anchor" id="a6fae131254fca49b6120c3e0bef4633d"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> mxnet::NDArray::Reshape </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a> &amp; </td>
<td class="paramname"><em>shape</em></td><td>)</td>
<td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Get an reshaped <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">shape</td><td>new shape </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> in new shape </dd></dl>
</div>
</div>
<a class="anchor" id="aa99f425040db90b52f945007a2f11b73"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">void mxnet::NDArray::ReshapeAndAlloc </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a> &amp; </td>
<td class="paramname"><em>shape</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Allocate the space if the allocation has been delayed or the requested size is bigger than the available one. This function can only be called by ndarray of default storage type and effectively changes the ndarray's shape_. Note: This function is named as this to avoid overload conflict with CheckAndAlloc(const mxnet::ShapeVector &amp;aux_shapes), since <a class="el" href="classmxnet_1_1TShape.html" title="A Shape class that is used to represent shape of each tensor. ">mxnet::TShape</a> tmp = some_shape is equivalent to <a class="el" href="classmxnet_1_1TShape.html" title="A Shape class that is used to represent shape of each tensor. ">mxnet::TShape</a> tmp = {some_shape}. </p>
</div>
</div>
<a class="anchor" id="a318e6f3ae6f94026dec90aa98a7e3f10"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> mxnet::NDArray::ReshapeWithRecord </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a> &amp; </td>
<td class="paramname"><em>shape</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Get an reshaped <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>. Supports autograd recording. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">shape</td><td>new shape </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> in new shape </dd></dl>
</div>
</div>
<a class="anchor" id="a524662078483f8f46c6c71714fbfde0b"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void mxnet::NDArray::Save </td>
<td>(</td>
<td class="paramtype">dmlc::Stream * </td>
<td class="paramname"><em>strm</em></td><td>)</td>
<td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>save the content into binary stream </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">strm</td><td>the output stream </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="af215b7a886e717b4bb3c911fe3c1a032"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">static void mxnet::NDArray::Save </td>
<td>(</td>
<td class="paramtype">dmlc::Stream * </td>
<td class="paramname"><em>fo</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const std::vector&lt; <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &gt; &amp; </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const std::vector&lt; std::string &gt; &amp; </td>
<td class="paramname"><em>names</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Save list of ndarray into the Stream.x. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">fo</td><td>The stream of output. </td></tr>
<tr><td class="paramname">data</td><td>the NDArrays to be saved. </td></tr>
<tr><td class="paramname">names</td><td>the name of the <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>, optional, can be zero length. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="aac690d8073f38b6dbb882ccc894390bb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">void mxnet::NDArray::set_aux_shape </td>
<td>(</td>
<td class="paramtype">size_t </td>
<td class="paramname"><em>index</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a> &amp; </td>
<td class="paramname"><em>shape</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>For a sparse operation on a csr matrix for example, the size of the column index array is an estimated value in the beginning for allocating enough capacity for the final result. After the operation is done, the exact size of the shape is known and need to be reset using this function. </p>
</div>
</div>
<a class="anchor" id="a32ed2be4ecf94c58b19bd43b48f2b1fa"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void mxnet::NDArray::set_fresh_out_grad </td>
<td>(</td>
<td class="paramtype">bool </td>
<td class="paramname"><em>state</em></td><td>)</td>
<td> const</td>
</tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>updated grad state in entry_ </dd></dl>
</div>
</div>
<a class="anchor" id="a24287317390bd1a58d7f93772a64c2cb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">void mxnet::NDArray::SetShapeFromChunk </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>set the correct shape of <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> directly from the storage_shape of its own chunk. </p>
</div>
</div>
<a class="anchor" id="a1910c16c97754399ceafcd36e80893e2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">const <a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a>&amp; mxnet::NDArray::shape </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the shape of current <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>. </dd></dl>
</div>
</div>
<a class="anchor" id="a7acb6462c11e071949db2b0e1fbfd66e"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> mxnet::NDArray::Slice </td>
<td>(</td>
<td class="paramtype"><a class="el" href="namespacemxnet.html#abadedc1b42ee3e5b8852e63783b982ef">index_t</a> </td>
<td class="paramname"><em>begin</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespacemxnet.html#abadedc1b42ee3e5b8852e63783b982ef">index_t</a> </td>
<td class="paramname"><em>end</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Slice a <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">begin</td><td>begin index in first dim (inclusive) </td></tr>
<tr><td class="paramname">end</td><td>end index in first dim (exclusive) </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sliced <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> </dd></dl>
</div>
</div>
<a class="anchor" id="a0d868e5303669d6ce8a5ada1c34940ac"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> mxnet::NDArray::SliceWithRecord </td>
<td>(</td>
<td class="paramtype"><a class="el" href="namespacemxnet.html#abadedc1b42ee3e5b8852e63783b982ef">index_t</a> </td>
<td class="paramname"><em>begin</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespacemxnet.html#abadedc1b42ee3e5b8852e63783b982ef">index_t</a> </td>
<td class="paramname"><em>end</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Slice a <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>. Supports recording with autograd. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">begin</td><td>begin index in first dim (inclusive) </td></tr>
<tr><td class="paramname">end</td><td>end index in first dim (exclusive) </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sliced <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> </dd></dl>
</div>
</div>
<a class="anchor" id="a36348646a0c2756b8c8cfa80f44f1eef"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">void mxnet::NDArray::SparseUpdateChunk </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp; </td>
<td class="paramname"><em>arr</em></td><td>)</td>
<td> const</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Update ndarray chunk storage handles using existing ndarray storage handles Also update the aux_handle, aux_shapes and aux_types. This is specifically used for custom op to update the inputs and outputs from the temporary ndarray which stores intermediate custom op results. Should be used with caution elsewhere. Supports only CSR and RSP formats. </p>
</div>
</div>
<a class="anchor" id="ad330f5e35c41078cb64cd84ae59a0bc3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="structmxnet_1_1Storage_1_1Handle.html">Storage::Handle</a> mxnet::NDArray::storage_handle </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>get storage handle </p>
</div>
</div>
<a class="anchor" id="a0f59c72c8caefcc069d5839d35288cd1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">bool mxnet::NDArray::storage_initialized </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns true if a sparse ndarray's aux_data and storage are initialized Throws an exception if the indices array shape is inconsistent Returns false if the indices array is empty(nnz = 0) for csr/row_sparse. </p>
</div>
</div>
<a class="anchor" id="a45fba0f5e822d832bf5bed08bb8cfb36"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">const <a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a>&amp; mxnet::NDArray::storage_shape </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the shape of underlying chunk which stores the <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> data/value. It is only intended for non-default storage. For row-sparse storage, it is the shape of the tensor which stores the non-zero values. </dd></dl>
</div>
</div>
<a class="anchor" id="a4d8f894c0306ad693ccf29278a613732"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="namespacemxnet.html#a536b732faa980e1de446c552460ff76a">NDArrayStorageType</a> mxnet::NDArray::storage_type </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a class="anchor" id="ade97bd4e93028ede123f6ccec5b3b038"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void mxnet::NDArray::SyncCheckFormat </td>
<td>(</td>
<td class="paramtype">const bool </td>
<td class="paramname"><em>full_check</em></td><td>)</td>
<td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>check whether the <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> format is valid </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">full_check</td><td>if <code>True</code>, rigorous check, O(N) operations Otherwise basic check, O(1) operations </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="a422c70b16646f8a273e9b4936fbe2e37"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void mxnet::NDArray::SyncCopyFromCPU </td>
<td>(</td>
<td class="paramtype">const void * </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t </td>
<td class="paramname"><em>size</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Do a synchronize copy from a continugous CPU memory region. </p>
<p>This function will call WaitToWrite before the copy is performed. This is useful to copy data from existing memory region that are not wrapped by NDArray(thus dependency not being tracked).</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>the data source to copy from. </td></tr>
<tr><td class="paramname">size</td><td>the size of the source array, in sizeof(DType) not raw btyes. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="aa3943fcf632304f6ab165b8628710609"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void mxnet::NDArray::SyncCopyFromNDArray </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp; </td>
<td class="paramname"><em>src</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>i</em> = <code>-1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>j</em> = <code>-1</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Copy from src.data()/aux_data(i) to this-&gt;<a class="el" href="classmxnet_1_1NDArray.html#aebd03e900ec7664a99b780a0cb1efea6">data()</a>/aux_data(j) </p>
</div>
</div>
<a class="anchor" id="a4819d2e6431ccdf4b9f8efa8eb0bd1fd"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void mxnet::NDArray::SyncCopyToCPU </td>
<td>(</td>
<td class="paramtype">void * </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t </td>
<td class="paramname"><em>size</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Do a synchronize copy to a continugous CPU memory region. </p>
<p>This function will call WaitToRead before the copy is performed. This is useful to copy data from existing memory region that are not wrapped by NDArray(thus dependency not being tracked).</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>the data source to copyinto. </td></tr>
<tr><td class="paramname">size</td><td>the memory size we want to copy into, in sizeof(DType) not raw btyes. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="a89d6048d5aa182e20507bf85f6aaff31"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">DLManagedTensor* mxnet::NDArray::ToDLPack </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Create a reference view of <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> that represents as DLManagedTensor. </p>
<dl class="section return"><dt>Returns</dt><dd>A DLManagedTensor </dd></dl>
</div>
</div>
<a class="anchor" id="a35c9b5da0852b480e0114f0865338cbc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1Engine.html#aac31510c793a12944c33f9cac6150491">Engine::VarHandle</a> mxnet::NDArray::var </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the associated variable of the ndarray. </dd></dl>
</div>
</div>
<a class="anchor" id="ae650c3f9c9a8b4adeecf747b2fd99141"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">size_t mxnet::NDArray::version </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>return var version of the <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> </p>
</div>
</div>
<a class="anchor" id="aedd79a43d5fa4173f3ddd719fb939fbc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">void mxnet::NDArray::WaitToRead </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Block until all the pending write operations with respect to current <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> are finished, and read can be performed. </p>
</div>
</div>
<a class="anchor" id="a4b88b5d86ec9ddf4ca96701107337461"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">void mxnet::NDArray::WaitToWrite </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Block until all the pending read/write operations with respect to current <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> are finished, and write can be performed. </p>
<p>Push an empty mutable function to flush all preceding reads to the variable.</p>
</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="add286ab9a359eb017008c9a3ff53701f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">friend class <a class="el" href="classmxnet_1_1Imperative.html">Imperative</a></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/mxnet/<a class="el" href="include_2mxnet_2ndarray_8h_source.html">ndarray.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Sep 19 2019 12:25:12 for mxnet by  <a href="http://www.doxygen.org/index.html">
<img alt="doxygen" class="footer" src="doxygen.png"/>
</a> 1.8.11
</small></address>
</body>
</html>
