<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta content="text/xhtml;charset=utf-8" http-equiv="Content-Type"/>
<meta content="IE=9" http-equiv="X-UA-Compatible"/>
<meta content="Doxygen 1.8.11" name="generator"/>
<title>mxnet: mxnet::cpp Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script src="jquery.js" type="text/javascript"></script>
<script src="dynsections.js" type="text/javascript"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script src="search/searchdata.js" type="text/javascript"></script>
<script src="search/search.js" type="text/javascript"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellpadding="0" cellspacing="0">
<tbody>
<tr style="height: 56px;">
<td id="projectalign" style="padding-left: 0.5em;">
<div id="projectname">mxnet
   </div>
</td>
</tr>
</tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<div class="tabs" id="navrow1">
<ul class="tablist">
<li><a href="index.html"><span>Main Page</span></a></li>
<li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
<li><a href="annotated.html"><span>Classes</span></a></li>
<li><a href="files.html"><span>Files</span></a></li>
<li>
<div class="MSearchBoxInactive" id="MSearchBox">
<span class="left">
<img alt="" id="MSearchSelect" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()" src="search/mag_sel.png"/>
<input accesskey="S" id="MSearchField" onblur="searchBox.OnSearchFieldFocus(false)" onfocus="searchBox.OnSearchFieldFocus(true)" onkeyup="searchBox.OnSearchFieldChange(event)" type="text" value="Search"/>
</span><span class="right">
<a href="javascript:searchBox.CloseResultsWindow()" id="MSearchClose"><img alt="" border="0" id="MSearchCloseImg" src="search/close.png"/></a>
</span>
</div>
</li>
</ul>
</div>
<div class="tabs2" id="navrow2">
<ul class="tablist">
<li><a href="namespaces.html"><span>Namespace List</span></a></li>
<li><a href="namespacemembers.html"><span>Namespace Members</span></a></li>
</ul>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onkeydown="return searchBox.OnSearchSelectKey(event)" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe frameborder="0" id="MSearchResults" name="MSearchResults" src="javascript:void(0)">
</iframe>
</div>
<div class="navpath" id="nav-path">
<ul>
<li class="navelem"><a class="el" href="namespacemxnet.html">mxnet</a></li><li class="navelem"><a class="el" href="namespacemxnet_1_1cpp.html">cpp</a></li> </ul>
</div>
</div><!-- top -->
<div class="header">
<div class="summary">
<a href="#nested-classes">Classes</a> |
<a href="#typedef-members">Typedefs</a> |
<a href="#enum-members">Enumerations</a> |
<a href="#func-members">Functions</a> </div>
<div class="headertitle">
<div class="title">mxnet::cpp Namespace Reference</div> </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1cpp_1_1Accuracy.html">Accuracy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1cpp_1_1AdaDeltaOptimizer.html">AdaDeltaOptimizer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1cpp_1_1AdaGradOptimizer.html">AdaGradOptimizer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1cpp_1_1AdamOptimizer.html">AdamOptimizer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1cpp_1_1Bilinear.html">Bilinear</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1cpp_1_1Constant.html">Constant</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1cpp_1_1Context.html">Context</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight"><a class="el" href="classmxnet_1_1cpp_1_1Context.html" title="Context interface. ">Context</a> interface.  <a href="classmxnet_1_1cpp_1_1Context.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1cpp_1_1DataBatch.html">DataBatch</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">Default object for holding a mini-batch of data and related information.  <a href="classmxnet_1_1cpp_1_1DataBatch.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1cpp_1_1DataIter.html">DataIter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1cpp_1_1EvalMetric.html">EvalMetric</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1cpp_1_1Executor.html">Executor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight"><a class="el" href="classmxnet_1_1cpp_1_1Executor.html" title="Executor interface. ">Executor</a> interface.  <a href="classmxnet_1_1cpp_1_1Executor.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1cpp_1_1FactorScheduler.html">FactorScheduler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1cpp_1_1FeedForward.html">FeedForward</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structmxnet_1_1cpp_1_1FeedForwardConfig.html">FeedForwardConfig</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1cpp_1_1Initializer.html">Initializer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1cpp_1_1KVStore.html">KVStore</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1cpp_1_1LogLoss.html">LogLoss</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1cpp_1_1LRScheduler.html">LRScheduler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">lr scheduler interface  <a href="classmxnet_1_1cpp_1_1LRScheduler.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1cpp_1_1MAE.html">MAE</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1cpp_1_1Monitor.html">Monitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight"><a class="el" href="classmxnet_1_1cpp_1_1Monitor.html" title="Monitor interface. ">Monitor</a> interface.  <a href="classmxnet_1_1cpp_1_1Monitor.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1cpp_1_1MSE.html">MSE</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1cpp_1_1MSRAPrelu.html">MSRAPrelu</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1cpp_1_1MXDataIter.html">MXDataIter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structmxnet_1_1cpp_1_1MXDataIterBlob.html">MXDataIterBlob</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1cpp_1_1MXDataIterMap.html">MXDataIterMap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1cpp_1_1NDArray.html">NDArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight"><a class="el" href="classmxnet_1_1cpp_1_1NDArray.html" title="NDArray interface. ">NDArray</a> interface.  <a href="classmxnet_1_1cpp_1_1NDArray.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structmxnet_1_1cpp_1_1NDBlob.html">NDBlob</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">struct to store NDArrayHandle  <a href="structmxnet_1_1cpp_1_1NDBlob.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1cpp_1_1Normal.html">Normal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1cpp_1_1One.html">One</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1cpp_1_1Operator.html">Operator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight"><a class="el" href="classmxnet_1_1cpp_1_1Operator.html" title="Operator interface. ">Operator</a> interface.  <a href="classmxnet_1_1cpp_1_1Operator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1cpp_1_1OpMap.html">OpMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight"><a class="el" href="classmxnet_1_1cpp_1_1OpMap.html" title="OpMap instance holds a map of all the symbol creators so we can get symbol creators by name...">OpMap</a> instance holds a map of all the symbol creators so we can get symbol creators by name. This is used internally by <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html" title="Symbol interface. ">Symbol</a> and <a class="el" href="classmxnet_1_1cpp_1_1Operator.html" title="Operator interface. ">Operator</a>.  <a href="classmxnet_1_1cpp_1_1OpMap.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1cpp_1_1Optimizer.html">Optimizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight"><a class="el" href="classmxnet_1_1cpp_1_1Optimizer.html" title="Optimizer interface. ">Optimizer</a> interface.  <a href="classmxnet_1_1cpp_1_1Optimizer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1cpp_1_1OptimizerRegistry.html">OptimizerRegistry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1cpp_1_1PSNR.html">PSNR</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1cpp_1_1RMSE.html">RMSE</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1cpp_1_1RMSPropOptimizer.html">RMSPropOptimizer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1cpp_1_1SGDOptimizer.html">SGDOptimizer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">dynamic shape class that can hold shape of arbirary dimension  <a href="structmxnet_1_1cpp_1_1Shape.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1cpp_1_1SignumOptimizer.html">SignumOptimizer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structmxnet_1_1cpp_1_1SymBlob.html">SymBlob</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">struct to store SymbolHandle  <a href="structmxnet_1_1cpp_1_1SymBlob.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html" title="Symbol interface. ">Symbol</a> interface.  <a href="classmxnet_1_1cpp_1_1Symbol.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1cpp_1_1Uniform.html">Uniform</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1cpp_1_1Xavier.html">Xavier</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1cpp_1_1Zero.html">Zero</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ae3c39bf39510741647c969f5409bb5d4"><td align="right" class="memItemLeft" valign="top">typedef unsigned </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#ae3c39bf39510741647c969f5409bb5d4">index_t</a></td></tr>
<tr class="separator:ae3c39bf39510741647c969f5409bb5d4"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a16a22578671e5ebcf8addb2275c317bc"><td align="right" class="memItemLeft" valign="top">typedef std::function&lt; <a class="el" href="classmxnet_1_1cpp_1_1Optimizer.html">Optimizer</a> *()&gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a16a22578671e5ebcf8addb2275c317bc">OptimizerCreator</a></td></tr>
<tr class="separator:a16a22578671e5ebcf8addb2275c317bc"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ae1e49a337d45c7071defefda2ec91845"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#ae1e49a337d45c7071defefda2ec91845">OpReqType</a> { <a class="el" href="namespacemxnet_1_1cpp.html#ae1e49a337d45c7071defefda2ec91845aefc84e1f8e37df690eb120d7f85f2cb2">kNullOp</a>, 
<a class="el" href="namespacemxnet_1_1cpp.html#ae1e49a337d45c7071defefda2ec91845aeeb7170b414b47800f504038816d5b68">kWriteTo</a>, 
<a class="el" href="namespacemxnet_1_1cpp.html#ae1e49a337d45c7071defefda2ec91845aae1754f69deaa9fe7d2d37479126d08d">kWriteInplace</a>, 
<a class="el" href="namespacemxnet_1_1cpp.html#ae1e49a337d45c7071defefda2ec91845a00aae45e4e69f21765e2ff3ecea6ac81">kAddTo</a>
 }</td></tr>
<tr class="separator:ae1e49a337d45c7071defefda2ec91845"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a65c3def958cbb9d09c7f56082a5257d6"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a65c3def958cbb9d09c7f56082a5257d6">DeviceType</a> { <a class="el" href="namespacemxnet_1_1cpp.html#a65c3def958cbb9d09c7f56082a5257d6a9705bd4da252932c6c64160d1ea7dbae">kCPU</a> = 1, 
<a class="el" href="namespacemxnet_1_1cpp.html#a65c3def958cbb9d09c7f56082a5257d6a98a378997114516ab326b392a1668158">kGPU</a> = 2, 
<a class="el" href="namespacemxnet_1_1cpp.html#a65c3def958cbb9d09c7f56082a5257d6abe32f7c482f2fb25e142b3834524252a">kCPUPinned</a> = 3
 }</td></tr>
<tr class="separator:a65c3def958cbb9d09c7f56082a5257d6"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a30fd3a240ebc436ddb671d0c33d5bdc3"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a30fd3a240ebc436ddb671d0c33d5bdc3">PickMode</a> { <a class="el" href="namespacemxnet_1_1cpp.html#a30fd3a240ebc436ddb671d0c33d5bdc3ae2867cadc2a39b014e89d241b72f3a75">PickMode::kClip</a> = 0, 
<a class="el" href="namespacemxnet_1_1cpp.html#a30fd3a240ebc436ddb671d0c33d5bdc3af6574e59f887a486b1b8d8a7c3cf3f83">PickMode::kWrap</a> = 1
 }</td></tr>
<tr class="separator:a30fd3a240ebc436ddb671d0c33d5bdc3"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa5dbdd69827034fc43c16cf350db7e1e"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#aa5dbdd69827034fc43c16cf350db7e1e">DotForwardStype</a> { <a class="el" href="namespacemxnet_1_1cpp.html#aa5dbdd69827034fc43c16cf350db7e1ea35c3ace1970663a16e5c65baa5941b13">DotForwardStype::kNone</a> = 0, 
<a class="el" href="namespacemxnet_1_1cpp.html#aa5dbdd69827034fc43c16cf350db7e1ea1775d6a702cfd3b6e09439e44566b877">DotForwardStype::kCsr</a> = 1, 
<a class="el" href="namespacemxnet_1_1cpp.html#aa5dbdd69827034fc43c16cf350db7e1ea6867faeaa475fda467e48267db2bb8a8">DotForwardStype::kDefault</a> = 2, 
<a class="el" href="namespacemxnet_1_1cpp.html#aa5dbdd69827034fc43c16cf350db7e1ea362f1e9fcc0ffe1058a27f4a6f22aa15">DotForwardStype::kRow_sparse</a> = 3
 }</td></tr>
<tr class="separator:aa5dbdd69827034fc43c16cf350db7e1e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a45bddc3aa629f2554f95429b0a270a16"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a45bddc3aa629f2554f95429b0a270a16">Batch_dotForwardStype</a> { <a class="el" href="namespacemxnet_1_1cpp.html#a45bddc3aa629f2554f95429b0a270a16a35c3ace1970663a16e5c65baa5941b13">Batch_dotForwardStype::kNone</a> = 0, 
<a class="el" href="namespacemxnet_1_1cpp.html#a45bddc3aa629f2554f95429b0a270a16a1775d6a702cfd3b6e09439e44566b877">Batch_dotForwardStype::kCsr</a> = 1, 
<a class="el" href="namespacemxnet_1_1cpp.html#a45bddc3aa629f2554f95429b0a270a16a6867faeaa475fda467e48267db2bb8a8">Batch_dotForwardStype::kDefault</a> = 2, 
<a class="el" href="namespacemxnet_1_1cpp.html#a45bddc3aa629f2554f95429b0a270a16a362f1e9fcc0ffe1058a27f4a6f22aa15">Batch_dotForwardStype::kRow_sparse</a> = 3
 }</td></tr>
<tr class="separator:a45bddc3aa629f2554f95429b0a270a16"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a8e907a5fbbe4ec21628e500b34a5f35d"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a8e907a5fbbe4ec21628e500b34a5f35d">CastDtype</a> { <br/>
  <a class="el" href="namespacemxnet_1_1cpp.html#a8e907a5fbbe4ec21628e500b34a5f35da907b19d7a9943987059cdc540f11e440">CastDtype::kFloat16</a> = 0, 
<a class="el" href="namespacemxnet_1_1cpp.html#a8e907a5fbbe4ec21628e500b34a5f35da9a78d6a569d086b524c3caf8c2522f96">CastDtype::kFloat32</a> = 1, 
<a class="el" href="namespacemxnet_1_1cpp.html#a8e907a5fbbe4ec21628e500b34a5f35da78f9bf284cc7269efe0093b7c505feaa">CastDtype::kFloat64</a> = 2, 
<a class="el" href="namespacemxnet_1_1cpp.html#a8e907a5fbbe4ec21628e500b34a5f35da10c09f8bff3c372f21cd8a13e01ae941">CastDtype::kInt32</a> = 3, 
<br/>
  <a class="el" href="namespacemxnet_1_1cpp.html#a8e907a5fbbe4ec21628e500b34a5f35da22c776007533004e22da8e6bdd888b33">CastDtype::kInt64</a> = 4, 
<a class="el" href="namespacemxnet_1_1cpp.html#a8e907a5fbbe4ec21628e500b34a5f35daf112965031ccac10c07073b4e7430107">CastDtype::kInt8</a> = 5, 
<a class="el" href="namespacemxnet_1_1cpp.html#a8e907a5fbbe4ec21628e500b34a5f35da11f076c48d8c2d080d2b9fbf5bf1725c">CastDtype::kUint8</a> = 6
<br/>
 }</td></tr>
<tr class="separator:a8e907a5fbbe4ec21628e500b34a5f35d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a3d86bd343a0a3b4d7f1205cadaf24855"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a3d86bd343a0a3b4d7f1205cadaf24855">TopkRetTyp</a> { <a class="el" href="namespacemxnet_1_1cpp.html#a3d86bd343a0a3b4d7f1205cadaf24855a4f968049bc5e5f7c6e0d89946366fff2">TopkRetTyp::kBoth</a> = 0, 
<a class="el" href="namespacemxnet_1_1cpp.html#a3d86bd343a0a3b4d7f1205cadaf24855ac514f90edc83d38e3527476bbfb8e5e8">TopkRetTyp::kIndices</a> = 1, 
<a class="el" href="namespacemxnet_1_1cpp.html#a3d86bd343a0a3b4d7f1205cadaf24855a9ff0f8feb708b8d7fabfe8682b22b201">TopkRetTyp::kMask</a> = 2, 
<a class="el" href="namespacemxnet_1_1cpp.html#a3d86bd343a0a3b4d7f1205cadaf24855a83de3546ca2d3aa334f69240ecbaff07">TopkRetTyp::kValue</a> = 3
 }</td></tr>
<tr class="separator:a3d86bd343a0a3b4d7f1205cadaf24855"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a992f67b993b07623d888ddcf01f9ddc3"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a992f67b993b07623d888ddcf01f9ddc3">TopkDtype</a> { <br/>
  <a class="el" href="namespacemxnet_1_1cpp.html#a992f67b993b07623d888ddcf01f9ddc3a907b19d7a9943987059cdc540f11e440">TopkDtype::kFloat16</a> = 0, 
<a class="el" href="namespacemxnet_1_1cpp.html#a992f67b993b07623d888ddcf01f9ddc3a9a78d6a569d086b524c3caf8c2522f96">TopkDtype::kFloat32</a> = 1, 
<a class="el" href="namespacemxnet_1_1cpp.html#a992f67b993b07623d888ddcf01f9ddc3a78f9bf284cc7269efe0093b7c505feaa">TopkDtype::kFloat64</a> = 2, 
<a class="el" href="namespacemxnet_1_1cpp.html#a992f67b993b07623d888ddcf01f9ddc3a10c09f8bff3c372f21cd8a13e01ae941">TopkDtype::kInt32</a> = 3, 
<br/>
  <a class="el" href="namespacemxnet_1_1cpp.html#a992f67b993b07623d888ddcf01f9ddc3a11f076c48d8c2d080d2b9fbf5bf1725c">TopkDtype::kUint8</a> = 4
<br/>
 }</td></tr>
<tr class="separator:a992f67b993b07623d888ddcf01f9ddc3"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae9d179e796188c53f2d2a36dfde2bd7a"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#ae9d179e796188c53f2d2a36dfde2bd7a">ArgsortDtype</a> { <br/>
  <a class="el" href="namespacemxnet_1_1cpp.html#ae9d179e796188c53f2d2a36dfde2bd7aa907b19d7a9943987059cdc540f11e440">ArgsortDtype::kFloat16</a> = 0, 
<a class="el" href="namespacemxnet_1_1cpp.html#ae9d179e796188c53f2d2a36dfde2bd7aa9a78d6a569d086b524c3caf8c2522f96">ArgsortDtype::kFloat32</a> = 1, 
<a class="el" href="namespacemxnet_1_1cpp.html#ae9d179e796188c53f2d2a36dfde2bd7aa78f9bf284cc7269efe0093b7c505feaa">ArgsortDtype::kFloat64</a> = 2, 
<a class="el" href="namespacemxnet_1_1cpp.html#ae9d179e796188c53f2d2a36dfde2bd7aa10c09f8bff3c372f21cd8a13e01ae941">ArgsortDtype::kInt32</a> = 3, 
<br/>
  <a class="el" href="namespacemxnet_1_1cpp.html#ae9d179e796188c53f2d2a36dfde2bd7aa11f076c48d8c2d080d2b9fbf5bf1725c">ArgsortDtype::kUint8</a> = 4
<br/>
 }</td></tr>
<tr class="separator:ae9d179e796188c53f2d2a36dfde2bd7a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a3c80705d63347982667fc541ad5bf845"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a3c80705d63347982667fc541ad5bf845">EmbeddingDtype</a> { <br/>
  <a class="el" href="namespacemxnet_1_1cpp.html#a3c80705d63347982667fc541ad5bf845a907b19d7a9943987059cdc540f11e440">EmbeddingDtype::kFloat16</a> = 0, 
<a class="el" href="namespacemxnet_1_1cpp.html#a3c80705d63347982667fc541ad5bf845a9a78d6a569d086b524c3caf8c2522f96">EmbeddingDtype::kFloat32</a> = 1, 
<a class="el" href="namespacemxnet_1_1cpp.html#a3c80705d63347982667fc541ad5bf845a78f9bf284cc7269efe0093b7c505feaa">EmbeddingDtype::kFloat64</a> = 2, 
<a class="el" href="namespacemxnet_1_1cpp.html#a3c80705d63347982667fc541ad5bf845a10c09f8bff3c372f21cd8a13e01ae941">EmbeddingDtype::kInt32</a> = 3, 
<br/>
  <a class="el" href="namespacemxnet_1_1cpp.html#a3c80705d63347982667fc541ad5bf845a22c776007533004e22da8e6bdd888b33">EmbeddingDtype::kInt64</a> = 4, 
<a class="el" href="namespacemxnet_1_1cpp.html#a3c80705d63347982667fc541ad5bf845af112965031ccac10c07073b4e7430107">EmbeddingDtype::kInt8</a> = 5, 
<a class="el" href="namespacemxnet_1_1cpp.html#a3c80705d63347982667fc541ad5bf845a11f076c48d8c2d080d2b9fbf5bf1725c">EmbeddingDtype::kUint8</a> = 6
<br/>
 }</td></tr>
<tr class="separator:a3c80705d63347982667fc541ad5bf845"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab8b82422d329aa4497e6891590633325"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#ab8b82422d329aa4497e6891590633325">TakeMode</a> { <a class="el" href="namespacemxnet_1_1cpp.html#ab8b82422d329aa4497e6891590633325ae2867cadc2a39b014e89d241b72f3a75">TakeMode::kClip</a> = 0, 
<a class="el" href="namespacemxnet_1_1cpp.html#ab8b82422d329aa4497e6891590633325a3538405b5d9916e92ac29b5f5458a88a">TakeMode::kRaise</a> = 1, 
<a class="el" href="namespacemxnet_1_1cpp.html#ab8b82422d329aa4497e6891590633325af6574e59f887a486b1b8d8a7c3cf3f83">TakeMode::kWrap</a> = 2
 }</td></tr>
<tr class="separator:ab8b82422d329aa4497e6891590633325"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a38cfaf4948f45cc4e6e46fbef0f6b8c2"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a38cfaf4948f45cc4e6e46fbef0f6b8c2">One_hotDtype</a> { <br/>
  <a class="el" href="namespacemxnet_1_1cpp.html#a38cfaf4948f45cc4e6e46fbef0f6b8c2a907b19d7a9943987059cdc540f11e440">One_hotDtype::kFloat16</a> = 0, 
<a class="el" href="namespacemxnet_1_1cpp.html#a38cfaf4948f45cc4e6e46fbef0f6b8c2a9a78d6a569d086b524c3caf8c2522f96">One_hotDtype::kFloat32</a> = 1, 
<a class="el" href="namespacemxnet_1_1cpp.html#a38cfaf4948f45cc4e6e46fbef0f6b8c2a78f9bf284cc7269efe0093b7c505feaa">One_hotDtype::kFloat64</a> = 2, 
<a class="el" href="namespacemxnet_1_1cpp.html#a38cfaf4948f45cc4e6e46fbef0f6b8c2a10c09f8bff3c372f21cd8a13e01ae941">One_hotDtype::kInt32</a> = 3, 
<br/>
  <a class="el" href="namespacemxnet_1_1cpp.html#a38cfaf4948f45cc4e6e46fbef0f6b8c2a22c776007533004e22da8e6bdd888b33">One_hotDtype::kInt64</a> = 4, 
<a class="el" href="namespacemxnet_1_1cpp.html#a38cfaf4948f45cc4e6e46fbef0f6b8c2af112965031ccac10c07073b4e7430107">One_hotDtype::kInt8</a> = 5, 
<a class="el" href="namespacemxnet_1_1cpp.html#a38cfaf4948f45cc4e6e46fbef0f6b8c2a11f076c48d8c2d080d2b9fbf5bf1725c">One_hotDtype::kUint8</a> = 6
<br/>
 }</td></tr>
<tr class="separator:a38cfaf4948f45cc4e6e46fbef0f6b8c2"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aac92e2f3642173e36bb79eb4854728ff"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#aac92e2f3642173e36bb79eb4854728ff">Cast_storageStype</a> { <a class="el" href="namespacemxnet_1_1cpp.html#aac92e2f3642173e36bb79eb4854728ffa1775d6a702cfd3b6e09439e44566b877">Cast_storageStype::kCsr</a> = 0, 
<a class="el" href="namespacemxnet_1_1cpp.html#aac92e2f3642173e36bb79eb4854728ffa6867faeaa475fda467e48267db2bb8a8">Cast_storageStype::kDefault</a> = 1, 
<a class="el" href="namespacemxnet_1_1cpp.html#aac92e2f3642173e36bb79eb4854728ffa362f1e9fcc0ffe1058a27f4a6f22aa15">Cast_storageStype::kRow_sparse</a> = 2
 }</td></tr>
<tr class="separator:aac92e2f3642173e36bb79eb4854728ff"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a44ef744b314acdba218a7405f56e00be"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a44ef744b314acdba218a7405f56e00be">PoolingPoolType</a> { <a class="el" href="namespacemxnet_1_1cpp.html#a44ef744b314acdba218a7405f56e00beaa22c1525680159c49e69ff9c43d1d01b">PoolingPoolType::kAvg</a> = 0, 
<a class="el" href="namespacemxnet_1_1cpp.html#a44ef744b314acdba218a7405f56e00beaf724eae0207adfdb7859ce8226b495f2">PoolingPoolType::kLp</a> = 1, 
<a class="el" href="namespacemxnet_1_1cpp.html#a44ef744b314acdba218a7405f56e00beaa0b1ac8aae6b1cfbbe89085c642b3b4b">PoolingPoolType::kMax</a> = 2, 
<a class="el" href="namespacemxnet_1_1cpp.html#a44ef744b314acdba218a7405f56e00beaa1dc5fbfa16754d1e628d66381725617">PoolingPoolType::kSum</a> = 3
 }</td></tr>
<tr class="separator:a44ef744b314acdba218a7405f56e00be"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:abaf9ea614ede3210454943dd3130c5cd"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#abaf9ea614ede3210454943dd3130c5cd">PoolingPoolingConvention</a> { <a class="el" href="namespacemxnet_1_1cpp.html#abaf9ea614ede3210454943dd3130c5cdaa60924e124da4d51bd4dc74c8f85b158">PoolingPoolingConvention::kFull</a> = 0, 
<a class="el" href="namespacemxnet_1_1cpp.html#abaf9ea614ede3210454943dd3130c5cda4d3576c37e6f03700bad4345238fffa0">PoolingPoolingConvention::kValid</a> = 1
 }</td></tr>
<tr class="separator:abaf9ea614ede3210454943dd3130c5cd"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae25c98b47a52531322d1622509c0e84d"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#ae25c98b47a52531322d1622509c0e84d">DeconvolutionCudnnTune</a> { <a class="el" href="namespacemxnet_1_1cpp.html#ae25c98b47a52531322d1622509c0e84da35c3ace1970663a16e5c65baa5941b13">DeconvolutionCudnnTune::kNone</a> = 0, 
<a class="el" href="namespacemxnet_1_1cpp.html#ae25c98b47a52531322d1622509c0e84da3ce44e130de6ca8e948584251bd77987">DeconvolutionCudnnTune::kFastest</a> = 1, 
<a class="el" href="namespacemxnet_1_1cpp.html#ae25c98b47a52531322d1622509c0e84da4ccc61daf45abfd4a8dd419c4123dd30">DeconvolutionCudnnTune::kLimited_workspace</a> = 2, 
<a class="el" href="namespacemxnet_1_1cpp.html#ae25c98b47a52531322d1622509c0e84dacc9ab5e60ac2a9a675ba64bf4bb49dc8">DeconvolutionCudnnTune::kOff</a> = 3
 }</td></tr>
<tr class="separator:ae25c98b47a52531322d1622509c0e84d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a63a3b219f6bced4a550ed4bc5207e997"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a63a3b219f6bced4a550ed4bc5207e997">DeconvolutionLayout</a> { <br/>
  <a class="el" href="namespacemxnet_1_1cpp.html#a63a3b219f6bced4a550ed4bc5207e997a35c3ace1970663a16e5c65baa5941b13">DeconvolutionLayout::kNone</a> = 0, 
<a class="el" href="namespacemxnet_1_1cpp.html#a63a3b219f6bced4a550ed4bc5207e997af0e34dad85df0415c577fc810d54a111">DeconvolutionLayout::kNCDHW</a> = 1, 
<a class="el" href="namespacemxnet_1_1cpp.html#a63a3b219f6bced4a550ed4bc5207e997acaf70f83fa10041f93bb2ee89848d4b9">DeconvolutionLayout::kNCHW</a> = 2, 
<a class="el" href="namespacemxnet_1_1cpp.html#a63a3b219f6bced4a550ed4bc5207e997abed1add3caa07f613b3384a819d440c2">DeconvolutionLayout::kNCW</a> = 3, 
<br/>
  <a class="el" href="namespacemxnet_1_1cpp.html#a63a3b219f6bced4a550ed4bc5207e997a65b2b3c8eed83e59b3cb6a8c1a30a5c8">DeconvolutionLayout::kNDHWC</a> = 4, 
<a class="el" href="namespacemxnet_1_1cpp.html#a63a3b219f6bced4a550ed4bc5207e997af6d739344f54ea3cddfa1f02f7f39b0a">DeconvolutionLayout::kNHWC</a> = 5
<br/>
 }</td></tr>
<tr class="separator:a63a3b219f6bced4a550ed4bc5207e997"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a919a622dc07b83d4431e8ff775455962"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a919a622dc07b83d4431e8ff775455962">ActivationActType</a> { <br/>
  <a class="el" href="namespacemxnet_1_1cpp.html#a919a622dc07b83d4431e8ff775455962a067892a9ea619b2c378e06000c9763af">ActivationActType::kRelu</a> = 0, 
<a class="el" href="namespacemxnet_1_1cpp.html#a919a622dc07b83d4431e8ff775455962ac00732693e14261bf9c2a4612a7f9bf9">ActivationActType::kSigmoid</a> = 1, 
<a class="el" href="namespacemxnet_1_1cpp.html#a919a622dc07b83d4431e8ff775455962a16649b2702b00ce7861366cbe7079e0f">ActivationActType::kSoftrelu</a> = 2, 
<a class="el" href="namespacemxnet_1_1cpp.html#a919a622dc07b83d4431e8ff775455962a12e90c7bc792e5b90d39318907669e63">ActivationActType::kSoftsign</a> = 3, 
<br/>
  <a class="el" href="namespacemxnet_1_1cpp.html#a919a622dc07b83d4431e8ff775455962a4918cf5d849692c2bed918bb9e948630">ActivationActType::kTanh</a> = 4
<br/>
 }</td></tr>
<tr class="separator:a919a622dc07b83d4431e8ff775455962"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a8755a4574a3839da2ad93af004fb1ff5"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a8755a4574a3839da2ad93af004fb1ff5">ConvolutionCudnnTune</a> { <a class="el" href="namespacemxnet_1_1cpp.html#a8755a4574a3839da2ad93af004fb1ff5a35c3ace1970663a16e5c65baa5941b13">ConvolutionCudnnTune::kNone</a> = 0, 
<a class="el" href="namespacemxnet_1_1cpp.html#a8755a4574a3839da2ad93af004fb1ff5a3ce44e130de6ca8e948584251bd77987">ConvolutionCudnnTune::kFastest</a> = 1, 
<a class="el" href="namespacemxnet_1_1cpp.html#a8755a4574a3839da2ad93af004fb1ff5a4ccc61daf45abfd4a8dd419c4123dd30">ConvolutionCudnnTune::kLimited_workspace</a> = 2, 
<a class="el" href="namespacemxnet_1_1cpp.html#a8755a4574a3839da2ad93af004fb1ff5acc9ab5e60ac2a9a675ba64bf4bb49dc8">ConvolutionCudnnTune::kOff</a> = 3
 }</td></tr>
<tr class="separator:a8755a4574a3839da2ad93af004fb1ff5"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7b419f5293a7706c76becfe735a9946b"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a7b419f5293a7706c76becfe735a9946b">ConvolutionLayout</a> { <br/>
  <a class="el" href="namespacemxnet_1_1cpp.html#a7b419f5293a7706c76becfe735a9946ba35c3ace1970663a16e5c65baa5941b13">ConvolutionLayout::kNone</a> = 0, 
<a class="el" href="namespacemxnet_1_1cpp.html#a7b419f5293a7706c76becfe735a9946baf0e34dad85df0415c577fc810d54a111">ConvolutionLayout::kNCDHW</a> = 1, 
<a class="el" href="namespacemxnet_1_1cpp.html#a7b419f5293a7706c76becfe735a9946bacaf70f83fa10041f93bb2ee89848d4b9">ConvolutionLayout::kNCHW</a> = 2, 
<a class="el" href="namespacemxnet_1_1cpp.html#a7b419f5293a7706c76becfe735a9946babed1add3caa07f613b3384a819d440c2">ConvolutionLayout::kNCW</a> = 3, 
<br/>
  <a class="el" href="namespacemxnet_1_1cpp.html#a7b419f5293a7706c76becfe735a9946ba65b2b3c8eed83e59b3cb6a8c1a30a5c8">ConvolutionLayout::kNDHWC</a> = 4, 
<a class="el" href="namespacemxnet_1_1cpp.html#a7b419f5293a7706c76becfe735a9946baf6d739344f54ea3cddfa1f02f7f39b0a">ConvolutionLayout::kNHWC</a> = 5
<br/>
 }</td></tr>
<tr class="separator:a7b419f5293a7706c76becfe735a9946b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9c9a4644f19e7ed3c729165de2e963ab"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a9c9a4644f19e7ed3c729165de2e963ab">UpSamplingSampleType</a> { <a class="el" href="namespacemxnet_1_1cpp.html#a9c9a4644f19e7ed3c729165de2e963aba03cb956599b7a2edbf1537556a6b4f01">UpSamplingSampleType::kBilinear</a> = 0, 
<a class="el" href="namespacemxnet_1_1cpp.html#a9c9a4644f19e7ed3c729165de2e963abae52c2066ca63eef7fada2eefb5c7f31c">UpSamplingSampleType::kNearest</a> = 1
 }</td></tr>
<tr class="separator:a9c9a4644f19e7ed3c729165de2e963ab"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:afce90445dba4ab6be903251cb0c960ef"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#afce90445dba4ab6be903251cb0c960ef">UpSamplingMultiInputMode</a> { <a class="el" href="namespacemxnet_1_1cpp.html#afce90445dba4ab6be903251cb0c960efa07f24210ce07b41cf8370dd8e9a3eb70">UpSamplingMultiInputMode::kConcat</a> = 0, 
<a class="el" href="namespacemxnet_1_1cpp.html#afce90445dba4ab6be903251cb0c960efaa1dc5fbfa16754d1e628d66381725617">UpSamplingMultiInputMode::kSum</a> = 1
 }</td></tr>
<tr class="separator:afce90445dba4ab6be903251cb0c960ef"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a3cc3a1d19b3bf567326c77e263038a0e"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a3cc3a1d19b3bf567326c77e263038a0e">DropoutMode</a> { <a class="el" href="namespacemxnet_1_1cpp.html#a3cc3a1d19b3bf567326c77e263038a0ea65b982518fe25240c767960a6b981903">DropoutMode::kAlways</a> = 0, 
<a class="el" href="namespacemxnet_1_1cpp.html#a3cc3a1d19b3bf567326c77e263038a0eabae2199a6d43c4c6ccd0e74727c02a64">DropoutMode::kTraining</a> = 1
 }</td></tr>
<tr class="separator:a3cc3a1d19b3bf567326c77e263038a0e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a08bbd5633680ffa58dae3cab685e2ebf"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a08bbd5633680ffa58dae3cab685e2ebf">SoftmaxActivationMode</a> { <a class="el" href="namespacemxnet_1_1cpp.html#a08bbd5633680ffa58dae3cab685e2ebfacbab887403bd90909c675dd375c049ab">SoftmaxActivationMode::kChannel</a> = 0, 
<a class="el" href="namespacemxnet_1_1cpp.html#a08bbd5633680ffa58dae3cab685e2ebfa63f56d9e95d7b447075aef94444c4c96">SoftmaxActivationMode::kInstance</a> = 1
 }</td></tr>
<tr class="separator:a08bbd5633680ffa58dae3cab685e2ebf"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab261a86c931574327d82188c75f93d1a"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#ab261a86c931574327d82188c75f93d1a">PadMode</a> { <a class="el" href="namespacemxnet_1_1cpp.html#ab261a86c931574327d82188c75f93d1aa043b62a71551e8b511099802b2b59a98">PadMode::kConstant</a> = 0, 
<a class="el" href="namespacemxnet_1_1cpp.html#ab261a86c931574327d82188c75f93d1aa0a9e7b78276726f559419b53f1b48378">PadMode::kEdge</a> = 1, 
<a class="el" href="namespacemxnet_1_1cpp.html#ab261a86c931574327d82188c75f93d1aa349d0a80f99eef391838f790093367fa">PadMode::kReflect</a> = 2
 }</td></tr>
<tr class="separator:ab261a86c931574327d82188c75f93d1a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aad64d459f3652d3ec3cf37c460aa8ee0"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#aad64d459f3652d3ec3cf37c460aa8ee0">LeakyReLUActType</a> { <br/>
  <a class="el" href="namespacemxnet_1_1cpp.html#aad64d459f3652d3ec3cf37c460aa8ee0a069cf87f2d4b99d9f62876a74404b1d3">LeakyReLUActType::kElu</a> = 0, 
<a class="el" href="namespacemxnet_1_1cpp.html#aad64d459f3652d3ec3cf37c460aa8ee0a3620dd046c3b58ec17570ae64aa325eb">LeakyReLUActType::kLeaky</a> = 1, 
<a class="el" href="namespacemxnet_1_1cpp.html#aad64d459f3652d3ec3cf37c460aa8ee0a22d7f1f62bdd3e103915dee419726669">LeakyReLUActType::kPrelu</a> = 2, 
<a class="el" href="namespacemxnet_1_1cpp.html#aad64d459f3652d3ec3cf37c460aa8ee0ade7fea8780fce6ceb9441318d2d11d9b">LeakyReLUActType::kRrelu</a> = 3, 
<br/>
  <a class="el" href="namespacemxnet_1_1cpp.html#aad64d459f3652d3ec3cf37c460aa8ee0a7fa55f9e443e4480962965fbc282c2d1">LeakyReLUActType::kSelu</a> = 4
<br/>
 }</td></tr>
<tr class="separator:aad64d459f3652d3ec3cf37c460aa8ee0"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a98745f0114674ef8fa60b2a35a877a2c"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a98745f0114674ef8fa60b2a35a877a2c">GridGeneratorTransformType</a> { <a class="el" href="namespacemxnet_1_1cpp.html#a98745f0114674ef8fa60b2a35a877a2cac3af1341756d0c5a66c8ea473dc38927">GridGeneratorTransformType::kAffine</a> = 0, 
<a class="el" href="namespacemxnet_1_1cpp.html#a98745f0114674ef8fa60b2a35a877a2ca7150a1272fb5e8267858ab706061e68d">GridGeneratorTransformType::kWarp</a> = 1
 }</td></tr>
<tr class="separator:a98745f0114674ef8fa60b2a35a877a2c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7dc4e3b741dfffc9295e1f8fbcb51c2e"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a7dc4e3b741dfffc9295e1f8fbcb51c2e">Pooling_v1PoolType</a> { <a class="el" href="namespacemxnet_1_1cpp.html#a7dc4e3b741dfffc9295e1f8fbcb51c2eaa22c1525680159c49e69ff9c43d1d01b">Pooling_v1PoolType::kAvg</a> = 0, 
<a class="el" href="namespacemxnet_1_1cpp.html#a7dc4e3b741dfffc9295e1f8fbcb51c2eaa0b1ac8aae6b1cfbbe89085c642b3b4b">Pooling_v1PoolType::kMax</a> = 1, 
<a class="el" href="namespacemxnet_1_1cpp.html#a7dc4e3b741dfffc9295e1f8fbcb51c2eaa1dc5fbfa16754d1e628d66381725617">Pooling_v1PoolType::kSum</a> = 2
 }</td></tr>
<tr class="separator:a7dc4e3b741dfffc9295e1f8fbcb51c2e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac8e6f64dc9bca9d9388d34d5153cb094"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#ac8e6f64dc9bca9d9388d34d5153cb094">Pooling_v1PoolingConvention</a> { <a class="el" href="namespacemxnet_1_1cpp.html#ac8e6f64dc9bca9d9388d34d5153cb094aa60924e124da4d51bd4dc74c8f85b158">Pooling_v1PoolingConvention::kFull</a> = 0, 
<a class="el" href="namespacemxnet_1_1cpp.html#ac8e6f64dc9bca9d9388d34d5153cb094a4d3576c37e6f03700bad4345238fffa0">Pooling_v1PoolingConvention::kValid</a> = 1
 }</td></tr>
<tr class="separator:ac8e6f64dc9bca9d9388d34d5153cb094"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae39119fed3c83726a0a2ea89b506661d"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#ae39119fed3c83726a0a2ea89b506661d">RNNMode</a> { <a class="el" href="namespacemxnet_1_1cpp.html#ae39119fed3c83726a0a2ea89b506661da5ea3f9d5c30c8d9f95be38d63711f8f1">RNNMode::kGru</a> = 0, 
<a class="el" href="namespacemxnet_1_1cpp.html#ae39119fed3c83726a0a2ea89b506661da355b4b6ce6fdae03f3b946c79515b713">RNNMode::kLstm</a> = 1, 
<a class="el" href="namespacemxnet_1_1cpp.html#ae39119fed3c83726a0a2ea89b506661dadff62ec61167055b8101cf576ff9d3e8">RNNMode::kRnn_relu</a> = 2, 
<a class="el" href="namespacemxnet_1_1cpp.html#ae39119fed3c83726a0a2ea89b506661da93ae2f9c92a50dd27b3a4bec79e2e8ef">RNNMode::kRnn_tanh</a> = 3
 }</td></tr>
<tr class="separator:ae39119fed3c83726a0a2ea89b506661d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa32f4a10a37f253f9d102cfc96a9eafc"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#aa32f4a10a37f253f9d102cfc96a9eafc">Convolution_v1CudnnTune</a> { <a class="el" href="namespacemxnet_1_1cpp.html#aa32f4a10a37f253f9d102cfc96a9eafca35c3ace1970663a16e5c65baa5941b13">Convolution_v1CudnnTune::kNone</a> = 0, 
<a class="el" href="namespacemxnet_1_1cpp.html#aa32f4a10a37f253f9d102cfc96a9eafca3ce44e130de6ca8e948584251bd77987">Convolution_v1CudnnTune::kFastest</a> = 1, 
<a class="el" href="namespacemxnet_1_1cpp.html#aa32f4a10a37f253f9d102cfc96a9eafca4ccc61daf45abfd4a8dd419c4123dd30">Convolution_v1CudnnTune::kLimited_workspace</a> = 2, 
<a class="el" href="namespacemxnet_1_1cpp.html#aa32f4a10a37f253f9d102cfc96a9eafcacc9ab5e60ac2a9a675ba64bf4bb49dc8">Convolution_v1CudnnTune::kOff</a> = 3
 }</td></tr>
<tr class="separator:aa32f4a10a37f253f9d102cfc96a9eafc"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a97217f563c768120cd8db19573938635"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a97217f563c768120cd8db19573938635">Convolution_v1Layout</a> { <br/>
  <a class="el" href="namespacemxnet_1_1cpp.html#a97217f563c768120cd8db19573938635a35c3ace1970663a16e5c65baa5941b13">Convolution_v1Layout::kNone</a> = 0, 
<a class="el" href="namespacemxnet_1_1cpp.html#a97217f563c768120cd8db19573938635af0e34dad85df0415c577fc810d54a111">Convolution_v1Layout::kNCDHW</a> = 1, 
<a class="el" href="namespacemxnet_1_1cpp.html#a97217f563c768120cd8db19573938635acaf70f83fa10041f93bb2ee89848d4b9">Convolution_v1Layout::kNCHW</a> = 2, 
<a class="el" href="namespacemxnet_1_1cpp.html#a97217f563c768120cd8db19573938635a65b2b3c8eed83e59b3cb6a8c1a30a5c8">Convolution_v1Layout::kNDHWC</a> = 3, 
<br/>
  <a class="el" href="namespacemxnet_1_1cpp.html#a97217f563c768120cd8db19573938635af6d739344f54ea3cddfa1f02f7f39b0a">Convolution_v1Layout::kNHWC</a> = 4
<br/>
 }</td></tr>
<tr class="separator:a97217f563c768120cd8db19573938635"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a0ff49861ba295abeac5d545bfa16b0aa"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a0ff49861ba295abeac5d545bfa16b0aa">SpatialTransformerTransformType</a> { <a class="el" href="namespacemxnet_1_1cpp.html#a0ff49861ba295abeac5d545bfa16b0aaac3af1341756d0c5a66c8ea473dc38927">SpatialTransformerTransformType::kAffine</a> = 0
 }</td></tr>
<tr class="separator:a0ff49861ba295abeac5d545bfa16b0aa"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a20ce4a2b1581ec74fc957d816d1e19ce"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a20ce4a2b1581ec74fc957d816d1e19ce">SpatialTransformerSamplerType</a> { <a class="el" href="namespacemxnet_1_1cpp.html#a20ce4a2b1581ec74fc957d816d1e19cea03cb956599b7a2edbf1537556a6b4f01">SpatialTransformerSamplerType::kBilinear</a> = 0
 }</td></tr>
<tr class="separator:a20ce4a2b1581ec74fc957d816d1e19ce"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae708904c6ad7046fcecfc6c6b7e0ac73"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#ae708904c6ad7046fcecfc6c6b7e0ac73">SoftmaxOutputNormalization</a> { <a class="el" href="namespacemxnet_1_1cpp.html#ae708904c6ad7046fcecfc6c6b7e0ac73ae8d28b6b417e276d0d4a33304cd9e6e3">SoftmaxOutputNormalization::kBatch</a> = 0, 
<a class="el" href="namespacemxnet_1_1cpp.html#ae708904c6ad7046fcecfc6c6b7e0ac73af2655c2dee87cb9b0646f678a630394b">SoftmaxOutputNormalization::kNull</a> = 1, 
<a class="el" href="namespacemxnet_1_1cpp.html#ae708904c6ad7046fcecfc6c6b7e0ac73a4d3576c37e6f03700bad4345238fffa0">SoftmaxOutputNormalization::kValid</a> = 2
 }</td></tr>
<tr class="separator:ae708904c6ad7046fcecfc6c6b7e0ac73"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:abac2e8c934c7bd4416728b351fcbae5b"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#abac2e8c934c7bd4416728b351fcbae5b">SoftmaxNormalization</a> { <a class="el" href="namespacemxnet_1_1cpp.html#abac2e8c934c7bd4416728b351fcbae5bae8d28b6b417e276d0d4a33304cd9e6e3">SoftmaxNormalization::kBatch</a> = 0, 
<a class="el" href="namespacemxnet_1_1cpp.html#abac2e8c934c7bd4416728b351fcbae5baf2655c2dee87cb9b0646f678a630394b">SoftmaxNormalization::kNull</a> = 1, 
<a class="el" href="namespacemxnet_1_1cpp.html#abac2e8c934c7bd4416728b351fcbae5ba4d3576c37e6f03700bad4345238fffa0">SoftmaxNormalization::kValid</a> = 2
 }</td></tr>
<tr class="separator:abac2e8c934c7bd4416728b351fcbae5b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a92b87bed551457a3d444a28fd3c7c84f"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a92b87bed551457a3d444a28fd3c7c84f">L2NormalizationMode</a> { <a class="el" href="namespacemxnet_1_1cpp.html#a92b87bed551457a3d444a28fd3c7c84facbab887403bd90909c675dd375c049ab">L2NormalizationMode::kChannel</a> = 0, 
<a class="el" href="namespacemxnet_1_1cpp.html#a92b87bed551457a3d444a28fd3c7c84fa63f56d9e95d7b447075aef94444c4c96">L2NormalizationMode::kInstance</a> = 1, 
<a class="el" href="namespacemxnet_1_1cpp.html#a92b87bed551457a3d444a28fd3c7c84fa83fe4465949392cd595c66cd0992bf4f">L2NormalizationMode::kSpatial</a> = 2
 }</td></tr>
<tr class="separator:a92b87bed551457a3d444a28fd3c7c84f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a0f8c7551de879673caa593f74e8ebca6"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a0f8c7551de879673caa593f74e8ebca6">MakeLossNormalization</a> { <a class="el" href="namespacemxnet_1_1cpp.html#a0f8c7551de879673caa593f74e8ebca6ae8d28b6b417e276d0d4a33304cd9e6e3">MakeLossNormalization::kBatch</a> = 0, 
<a class="el" href="namespacemxnet_1_1cpp.html#a0f8c7551de879673caa593f74e8ebca6af2655c2dee87cb9b0646f678a630394b">MakeLossNormalization::kNull</a> = 1, 
<a class="el" href="namespacemxnet_1_1cpp.html#a0f8c7551de879673caa593f74e8ebca6a4d3576c37e6f03700bad4345238fffa0">MakeLossNormalization::kValid</a> = 2
 }</td></tr>
<tr class="separator:a0f8c7551de879673caa593f74e8ebca6"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af52dc7c5b66e9ee04b37f39cde0fcc5a"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1NDArray.html">NDArray</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#af52dc7c5b66e9ee04b37f39cde0fcc5a">_default_monitor_func</a> (const <a class="el" href="classmxnet_1_1cpp_1_1NDArray.html">NDArray</a> &amp;x)</td></tr>
<tr class="memdesc:af52dc7c5b66e9ee04b37f39cde0fcc5a"><td class="mdescLeft"> </td><td class="mdescRight">Default function for monitor that computes statistics of the input tensor, which is the mean absolute |x|/size(x)  <a href="#af52dc7c5b66e9ee04b37f39cde0fcc5a">More...</a><br/></td></tr>
<tr class="separator:af52dc7c5b66e9ee04b37f39cde0fcc5a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a56bcf615f032f8ca632e0ed3d56223a0"><td align="right" class="memItemLeft" valign="top">std::ostream &amp; </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a56bcf615f032f8ca632e0ed3d56223a0">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classmxnet_1_1cpp_1_1NDArray.html">NDArray</a> &amp;ndarray)</td></tr>
<tr class="separator:a56bcf615f032f8ca632e0ed3d56223a0"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a97005a6afb32b3706d7dbe12e8c7a139"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a97005a6afb32b3706d7dbe12e8c7a139">khatri_rao</a> (const std::string &amp;symbol_name, const std::vector&lt; <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> &gt; &amp;args)</td></tr>
<tr class="separator:a97005a6afb32b3706d7dbe12e8c7a139"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa4569bf622fc0b5109a958998451d785"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#aa4569bf622fc0b5109a958998451d785">Custom</a> (const std::string &amp;symbol_name, const std::vector&lt; <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> &gt; &amp;data, const std::string &amp;op_type)</td></tr>
<tr class="separator:aa4569bf622fc0b5109a958998451d785"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7c0ee006ec9b8e56d40fc177992a6a1b"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a7c0ee006ec9b8e56d40fc177992a6a1b">broadcast_power</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> lhs, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> rhs)</td></tr>
<tr class="separator:a7c0ee006ec9b8e56d40fc177992a6a1b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7f4654e21bde6164640644943955eb66"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a7f4654e21bde6164640644943955eb66">broadcast_maximum</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> lhs, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> rhs)</td></tr>
<tr class="separator:a7f4654e21bde6164640644943955eb66"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a54a975ffe796834cff9534c8773f9a43"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a54a975ffe796834cff9534c8773f9a43">broadcast_minimum</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> lhs, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> rhs)</td></tr>
<tr class="separator:a54a975ffe796834cff9534c8773f9a43"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:adf4d0a7d7fb688d675713f068fc6cc8e"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#adf4d0a7d7fb688d675713f068fc6cc8e">broadcast_hypot</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> lhs, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> rhs)</td></tr>
<tr class="separator:adf4d0a7d7fb688d675713f068fc6cc8e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7b26f5f8ccd20fe25f32d7fd18888c5b"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a7b26f5f8ccd20fe25f32d7fd18888c5b">Reshape</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> shape=<a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>(), bool <a class="el" href="namespacemxnet_1_1cpp.html#a76348d0263ce3ff577c3bf7333674160">reverse</a>=false, <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> target_shape=<a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>(), bool keep_highest=false)</td></tr>
<tr class="separator:a7b26f5f8ccd20fe25f32d7fd18888c5b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa3470d98c61a10ac5a1c583304ca81e9"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#aa3470d98c61a10ac5a1c583304ca81e9">Flatten</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:aa3470d98c61a10ac5a1c583304ca81e9"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a159e3b3996fcfbc2881330aa6373a7db"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a159e3b3996fcfbc2881330aa6373a7db">transpose</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> axes=<a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>())</td></tr>
<tr class="separator:a159e3b3996fcfbc2881330aa6373a7db"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a91ad2b6dbe27c48818774c11e2b5b742"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a91ad2b6dbe27c48818774c11e2b5b742">expand_dims</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, int axis)</td></tr>
<tr class="separator:a91ad2b6dbe27c48818774c11e2b5b742"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a558a6483730916ff934a4cc992915cd4"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a558a6483730916ff934a4cc992915cd4">slice</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> begin, <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> end, <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> step=<a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>())</td></tr>
<tr class="separator:a558a6483730916ff934a4cc992915cd4"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1fd30630137204361b04675f70b217bc"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a1fd30630137204361b04675f70b217bc">slice_axis</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, int axis, int begin, dmlc::optional&lt; int &gt; end)</td></tr>
<tr class="separator:a1fd30630137204361b04675f70b217bc"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a25256ed685760f4b284dd018f21096da"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a25256ed685760f4b284dd018f21096da">slice_like</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> shape_like, <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> axes=<a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>())</td></tr>
<tr class="separator:a25256ed685760f4b284dd018f21096da"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a27262dd0794c017d77f20fab5d9fe715"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a27262dd0794c017d77f20fab5d9fe715">clip</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> a_min, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> a_max)</td></tr>
<tr class="separator:a27262dd0794c017d77f20fab5d9fe715"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4653aa86f2c35187bd9d4f152e1ab253"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a4653aa86f2c35187bd9d4f152e1ab253">repeat</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, int repeats, dmlc::optional&lt; int &gt; axis=dmlc::optional&lt; int &gt;())</td></tr>
<tr class="separator:a4653aa86f2c35187bd9d4f152e1ab253"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af04fa0ca4da5bce545b8294d4f1a4174"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#af04fa0ca4da5bce545b8294d4f1a4174">tile</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> reps)</td></tr>
<tr class="separator:af04fa0ca4da5bce545b8294d4f1a4174"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a76348d0263ce3ff577c3bf7333674160"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a76348d0263ce3ff577c3bf7333674160">reverse</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> axis)</td></tr>
<tr class="separator:a76348d0263ce3ff577c3bf7333674160"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a282577d4c4952b15afb4a84891f9f5ed"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a282577d4c4952b15afb4a84891f9f5ed">stack</a> (const std::string &amp;symbol_name, const std::vector&lt; <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> &gt; &amp;data, int num_args, int axis=0)</td></tr>
<tr class="separator:a282577d4c4952b15afb4a84891f9f5ed"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a191d9896dfcd9cf280007acfeb54ac69"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a191d9896dfcd9cf280007acfeb54ac69">squeeze</a> (const std::string &amp;symbol_name, const std::vector&lt; <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> &gt; &amp;data, dmlc::optional&lt; <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> &gt; axis=dmlc::optional&lt; <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> &gt;())</td></tr>
<tr class="separator:a191d9896dfcd9cf280007acfeb54ac69"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a8e1dce205b0d9379ef709ee6878501e6"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a8e1dce205b0d9379ef709ee6878501e6">depth_to_space</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, int block_size)</td></tr>
<tr class="separator:a8e1dce205b0d9379ef709ee6878501e6"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab8bce3987c7b40b428cdb091068102a0"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#ab8bce3987c7b40b428cdb091068102a0">space_to_depth</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, int block_size)</td></tr>
<tr class="separator:ab8bce3987c7b40b428cdb091068102a0"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a71d184875ccdfcd9046a0520c5c29899"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a71d184875ccdfcd9046a0520c5c29899">zeros_like</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:a71d184875ccdfcd9046a0520c5c29899"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a053cb533e3262bf393fd868a92e37f2f"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a053cb533e3262bf393fd868a92e37f2f">ones_like</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:a053cb533e3262bf393fd868a92e37f2f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a857af56895efd5feaa3276b6903f8cfa"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a857af56895efd5feaa3276b6903f8cfa">broadcast_add</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> lhs, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> rhs)</td></tr>
<tr class="separator:a857af56895efd5feaa3276b6903f8cfa"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa329d1598ba167a8cf14b76341cda2c2"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#aa329d1598ba167a8cf14b76341cda2c2">broadcast_sub</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> lhs, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> rhs)</td></tr>
<tr class="separator:aa329d1598ba167a8cf14b76341cda2c2"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a8475ebccc1fca543aeacd8e520f98489"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a8475ebccc1fca543aeacd8e520f98489">broadcast_mul</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> lhs, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> rhs)</td></tr>
<tr class="separator:a8475ebccc1fca543aeacd8e520f98489"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a0783d947ab56edb881cbef1174df0464"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a0783d947ab56edb881cbef1174df0464">broadcast_div</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> lhs, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> rhs)</td></tr>
<tr class="separator:a0783d947ab56edb881cbef1174df0464"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:afd1c090ff5c5af038780ef5542266243"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#afd1c090ff5c5af038780ef5542266243">broadcast_mod</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> lhs, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> rhs)</td></tr>
<tr class="separator:afd1c090ff5c5af038780ef5542266243"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a198f7c7f5d15e284b75d3675c7c6faab"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a198f7c7f5d15e284b75d3675c7c6faab">add_n</a> (const std::string &amp;symbol_name, const std::vector&lt; <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> &gt; &amp;args)</td></tr>
<tr class="separator:a198f7c7f5d15e284b75d3675c7c6faab"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae6b8b033ea83e25bc0822c87a78f23d6"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#ae6b8b033ea83e25bc0822c87a78f23d6">argmax</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, dmlc::optional&lt; int &gt; axis=dmlc::optional&lt; int &gt;(), bool keepdims=false)</td></tr>
<tr class="separator:ae6b8b033ea83e25bc0822c87a78f23d6"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:abc1b7a27d05bb8e4ae3b29f3870905a8"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#abc1b7a27d05bb8e4ae3b29f3870905a8">argmin</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, dmlc::optional&lt; int &gt; axis=dmlc::optional&lt; int &gt;(), bool keepdims=false)</td></tr>
<tr class="separator:abc1b7a27d05bb8e4ae3b29f3870905a8"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a8c000f6d54bdad0b6d863f03e20a9dc6"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a8c000f6d54bdad0b6d863f03e20a9dc6">argmax_channel</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:a8c000f6d54bdad0b6d863f03e20a9dc6"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a0f5fae458553ff92bb0b5308263cf76e"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a0f5fae458553ff92bb0b5308263cf76e">pick</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> index, dmlc::optional&lt; int &gt; axis=dmlc::optional&lt; int &gt;(-1), bool keepdims=false, <a class="el" href="namespacemxnet_1_1cpp.html#a30fd3a240ebc436ddb671d0c33d5bdc3">PickMode</a> mode=<a class="el" href="namespacemxnet_1_1cpp.html#a30fd3a240ebc436ddb671d0c33d5bdc3ae2867cadc2a39b014e89d241b72f3a75">PickMode::kClip</a>)</td></tr>
<tr class="separator:a0f5fae458553ff92bb0b5308263cf76e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a14538ccec46c260488aa78c6b23ad898"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a14538ccec46c260488aa78c6b23ad898">dot</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> lhs, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> rhs, bool transpose_a=false, bool transpose_b=false, <a class="el" href="namespacemxnet_1_1cpp.html#aa5dbdd69827034fc43c16cf350db7e1e">DotForwardStype</a> forward_stype=<a class="el" href="namespacemxnet_1_1cpp.html#aa5dbdd69827034fc43c16cf350db7e1ea35c3ace1970663a16e5c65baa5941b13">DotForwardStype::kNone</a>)</td></tr>
<tr class="separator:a14538ccec46c260488aa78c6b23ad898"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad6517a533737c0980bdc4d0074682f33"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#ad6517a533737c0980bdc4d0074682f33">batch_dot</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> lhs, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> rhs, bool transpose_a=false, bool transpose_b=false, <a class="el" href="namespacemxnet_1_1cpp.html#a45bddc3aa629f2554f95429b0a270a16">Batch_dotForwardStype</a> forward_stype=<a class="el" href="namespacemxnet_1_1cpp.html#aa5dbdd69827034fc43c16cf350db7e1ea35c3ace1970663a16e5c65baa5941b13">Batch_dotForwardStype::kNone</a>)</td></tr>
<tr class="separator:ad6517a533737c0980bdc4d0074682f33"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af8a5a31dd642ff81cca32b096b1f4c9d"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#af8a5a31dd642ff81cca32b096b1f4c9d">relu</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:af8a5a31dd642ff81cca32b096b1f4c9d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a814727890ac1a094385eaba1ec51424c"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a814727890ac1a094385eaba1ec51424c">sigmoid</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:a814727890ac1a094385eaba1ec51424c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a839623f90b9f4d3834b7b234bb3a187f"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a839623f90b9f4d3834b7b234bb3a187f">hard_sigmoid</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> alpha=0.2, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> beta=0.5)</td></tr>
<tr class="separator:a839623f90b9f4d3834b7b234bb3a187f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4cef537eb471a1f52e8c539553052bd2"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a4cef537eb471a1f52e8c539553052bd2">softsign</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:a4cef537eb471a1f52e8c539553052bd2"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:adad94b7c3a0a17f4b9c01073cc162d0e"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#adad94b7c3a0a17f4b9c01073cc162d0e">BlockGrad</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:adad94b7c3a0a17f4b9c01073cc162d0e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a87534525f3cf07a8efca32e5be5b4865"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a87534525f3cf07a8efca32e5be5b4865">make_loss</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:a87534525f3cf07a8efca32e5be5b4865"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af32748021b75072cf7a18fc19306ff8f"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#af32748021b75072cf7a18fc19306ff8f">reshape_like</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> lhs, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> rhs)</td></tr>
<tr class="separator:af32748021b75072cf7a18fc19306ff8f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a758e473aa6a402a906790bd79054440a"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a758e473aa6a402a906790bd79054440a">shape_array</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, dmlc::optional&lt; int &gt; lhs_begin=dmlc::optional&lt; int &gt;(), dmlc::optional&lt; int &gt; lhs_end=dmlc::optional&lt; int &gt;(), dmlc::optional&lt; int &gt; rhs_begin=dmlc::optional&lt; int &gt;(), dmlc::optional&lt; int &gt; rhs_end=dmlc::optional&lt; int &gt;())</td></tr>
<tr class="separator:a758e473aa6a402a906790bd79054440a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab36b34848f6d0dad9f6ba2523499e58f"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#ab36b34848f6d0dad9f6ba2523499e58f">size_array</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:ab36b34848f6d0dad9f6ba2523499e58f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a94162c291a79b5ecaa19f88acce92b84"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a94162c291a79b5ecaa19f88acce92b84">Cast</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="namespacemxnet_1_1cpp.html#a8e907a5fbbe4ec21628e500b34a5f35d">CastDtype</a> dtype)</td></tr>
<tr class="separator:a94162c291a79b5ecaa19f88acce92b84"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7357e06979b835b0a9fa03a43a729c3e"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a7357e06979b835b0a9fa03a43a729c3e">negative</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:a7357e06979b835b0a9fa03a43a729c3e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab66c850dfcfb6313bac6e13c24107fde"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#ab66c850dfcfb6313bac6e13c24107fde">reciprocal</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:ab66c850dfcfb6313bac6e13c24107fde"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:accf8d710dd8d06612f9e7944d1183d3f"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#accf8d710dd8d06612f9e7944d1183d3f">abs</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:accf8d710dd8d06612f9e7944d1183d3f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae1ea721e794c312bbb79429979219670"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#ae1ea721e794c312bbb79429979219670">sign</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:ae1ea721e794c312bbb79429979219670"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1f0d1f332bc2577a0349b780efda622d"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a1f0d1f332bc2577a0349b780efda622d">round</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:a1f0d1f332bc2577a0349b780efda622d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a46ec41d23cb8ec65c75cbca9ac3f1e04"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a46ec41d23cb8ec65c75cbca9ac3f1e04">rint</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:a46ec41d23cb8ec65c75cbca9ac3f1e04"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a59b0f43135f5642458c3952410abdb9e"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a59b0f43135f5642458c3952410abdb9e">ceil</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:a59b0f43135f5642458c3952410abdb9e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab4a01c682ea7f62223804ed33615048a"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#ab4a01c682ea7f62223804ed33615048a">floor</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:ab4a01c682ea7f62223804ed33615048a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a308aaabadc48791c4924c8a71cba8ca4"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a308aaabadc48791c4924c8a71cba8ca4">trunc</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:a308aaabadc48791c4924c8a71cba8ca4"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:acae3f2a8b1b2882faa9fd0db7332e555"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#acae3f2a8b1b2882faa9fd0db7332e555">fix</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:acae3f2a8b1b2882faa9fd0db7332e555"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a3b37dc5985254f4eda64f9fc74a24de3"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a3b37dc5985254f4eda64f9fc74a24de3">square</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:a3b37dc5985254f4eda64f9fc74a24de3"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a64eb6f5b502c17ee27062b042a062c15"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a64eb6f5b502c17ee27062b042a062c15">sqrt</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:a64eb6f5b502c17ee27062b042a062c15"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a83e44804082cf10a5bae940d5a09a3cf"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a83e44804082cf10a5bae940d5a09a3cf">rsqrt</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:a83e44804082cf10a5bae940d5a09a3cf"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ade9a6900e4402ff2d60530060400dd72"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#ade9a6900e4402ff2d60530060400dd72">cbrt</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:ade9a6900e4402ff2d60530060400dd72"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a972e0dadef2c71b91dc3685789d94ab4"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a972e0dadef2c71b91dc3685789d94ab4">rcbrt</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:a972e0dadef2c71b91dc3685789d94ab4"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af9cfdd6329c237d4b9ee144c24f51900"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#af9cfdd6329c237d4b9ee144c24f51900">exp</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:af9cfdd6329c237d4b9ee144c24f51900"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a580a36e5a8e2a0626a10f7966f505444"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a580a36e5a8e2a0626a10f7966f505444">log</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:a580a36e5a8e2a0626a10f7966f505444"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4d08dc59931f382ffd3115f13ca75276"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a4d08dc59931f382ffd3115f13ca75276">log10</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:a4d08dc59931f382ffd3115f13ca75276"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a054a0670ab0a98dd68468aca47cb94c4"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a054a0670ab0a98dd68468aca47cb94c4">log2</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:a054a0670ab0a98dd68468aca47cb94c4"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab08eb3c129e947100a42bbba98aa110a"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#ab08eb3c129e947100a42bbba98aa110a">log1p</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:ab08eb3c129e947100a42bbba98aa110a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6bc44d0e8ab9f520f92dac705665958b"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a6bc44d0e8ab9f520f92dac705665958b">expm1</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:a6bc44d0e8ab9f520f92dac705665958b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a0a9aa2fcd720ec0c0540a6a8ad47a8c7"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a0a9aa2fcd720ec0c0540a6a8ad47a8c7">gamma</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:a0a9aa2fcd720ec0c0540a6a8ad47a8c7"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a0eaf6490fbf9c17dc08c878e4f632a82"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a0eaf6490fbf9c17dc08c878e4f632a82">gammaln</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:a0eaf6490fbf9c17dc08c878e4f632a82"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af359ed0c12f1e1a811c1cd42a038e2c4"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#af359ed0c12f1e1a811c1cd42a038e2c4">logical_not</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:af359ed0c12f1e1a811c1cd42a038e2c4"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:acb4fccaa546283e233c15b46f6465443"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#acb4fccaa546283e233c15b46f6465443">sum</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, dmlc::optional&lt; <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> &gt; axis=dmlc::optional&lt; <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> &gt;(), bool keepdims=false, bool exclude=false)</td></tr>
<tr class="separator:acb4fccaa546283e233c15b46f6465443"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a54884055c968a6fcb737b772c82c5519"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a54884055c968a6fcb737b772c82c5519">mean</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, dmlc::optional&lt; <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> &gt; axis=dmlc::optional&lt; <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> &gt;(), bool keepdims=false, bool exclude=false)</td></tr>
<tr class="separator:a54884055c968a6fcb737b772c82c5519"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af84dd35dd17a1675a342c52708da9902"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#af84dd35dd17a1675a342c52708da9902">prod</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, dmlc::optional&lt; <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> &gt; axis=dmlc::optional&lt; <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> &gt;(), bool keepdims=false, bool exclude=false)</td></tr>
<tr class="separator:af84dd35dd17a1675a342c52708da9902"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a64e41923c4d0e2e201e0837c320e8c32"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a64e41923c4d0e2e201e0837c320e8c32">nansum</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, dmlc::optional&lt; <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> &gt; axis=dmlc::optional&lt; <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> &gt;(), bool keepdims=false, bool exclude=false)</td></tr>
<tr class="separator:a64e41923c4d0e2e201e0837c320e8c32"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:afb57e17a490b7a4e60e1e3543b165ec3"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#afb57e17a490b7a4e60e1e3543b165ec3">nanprod</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, dmlc::optional&lt; <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> &gt; axis=dmlc::optional&lt; <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> &gt;(), bool keepdims=false, bool exclude=false)</td></tr>
<tr class="separator:afb57e17a490b7a4e60e1e3543b165ec3"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aaa1d63d156390ab52fd96a9ad1e0c314"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#aaa1d63d156390ab52fd96a9ad1e0c314">max</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, dmlc::optional&lt; <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> &gt; axis=dmlc::optional&lt; <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> &gt;(), bool keepdims=false, bool exclude=false)</td></tr>
<tr class="separator:aaa1d63d156390ab52fd96a9ad1e0c314"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa42fcdd6b63c85b812018cbadb4ac521"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#aa42fcdd6b63c85b812018cbadb4ac521">min</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, dmlc::optional&lt; <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> &gt; axis=dmlc::optional&lt; <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> &gt;(), bool keepdims=false, bool exclude=false)</td></tr>
<tr class="separator:aa42fcdd6b63c85b812018cbadb4ac521"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a85cc565eca8e7b366cb7875afe6e9456"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a85cc565eca8e7b366cb7875afe6e9456">broadcast_axis</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> axis=<a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>(), <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> size=<a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>())</td></tr>
<tr class="separator:a85cc565eca8e7b366cb7875afe6e9456"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1ec5a8cf851e1b5ab222d7901fcede7c"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a1ec5a8cf851e1b5ab222d7901fcede7c">broadcast_to</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> shape=<a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>())</td></tr>
<tr class="separator:a1ec5a8cf851e1b5ab222d7901fcede7c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac03d576fd1307e3f1e6a63a6447e7d0d"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#ac03d576fd1307e3f1e6a63a6447e7d0d">broadcast_like</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> lhs, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> rhs)</td></tr>
<tr class="separator:ac03d576fd1307e3f1e6a63a6447e7d0d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af7eecf137de8b1f769b0ca0f189a148a"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#af7eecf137de8b1f769b0ca0f189a148a">norm</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, int ord=2, dmlc::optional&lt; <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> &gt; axis=dmlc::optional&lt; <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> &gt;(), bool keepdims=false)</td></tr>
<tr class="separator:af7eecf137de8b1f769b0ca0f189a148a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9316e5d42a968b40458cb89d2481727c"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a9316e5d42a968b40458cb89d2481727c">topk</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, dmlc::optional&lt; int &gt; axis=dmlc::optional&lt; int &gt;(-1), int k=1, <a class="el" href="namespacemxnet_1_1cpp.html#a3d86bd343a0a3b4d7f1205cadaf24855">TopkRetTyp</a> ret_typ=<a class="el" href="namespacemxnet_1_1cpp.html#a3d86bd343a0a3b4d7f1205cadaf24855ac514f90edc83d38e3527476bbfb8e5e8">TopkRetTyp::kIndices</a>, bool is_ascend=false, <a class="el" href="namespacemxnet_1_1cpp.html#a992f67b993b07623d888ddcf01f9ddc3">TopkDtype</a> dtype=<a class="el" href="namespacemxnet_1_1cpp.html#a8e907a5fbbe4ec21628e500b34a5f35da9a78d6a569d086b524c3caf8c2522f96">TopkDtype::kFloat32</a>)</td></tr>
<tr class="separator:a9316e5d42a968b40458cb89d2481727c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2c2db6021bb4a9fd444b4905bf639f6d"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a2c2db6021bb4a9fd444b4905bf639f6d">sort</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, dmlc::optional&lt; int &gt; axis=dmlc::optional&lt; int &gt;(-1), bool is_ascend=true)</td></tr>
<tr class="separator:a2c2db6021bb4a9fd444b4905bf639f6d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:abaf0ff49d19c04690a7632562ee8bbf9"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#abaf0ff49d19c04690a7632562ee8bbf9">argsort</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, dmlc::optional&lt; int &gt; axis=dmlc::optional&lt; int &gt;(-1), bool is_ascend=true, <a class="el" href="namespacemxnet_1_1cpp.html#ae9d179e796188c53f2d2a36dfde2bd7a">ArgsortDtype</a> dtype=<a class="el" href="namespacemxnet_1_1cpp.html#a8e907a5fbbe4ec21628e500b34a5f35da9a78d6a569d086b524c3caf8c2522f96">ArgsortDtype::kFloat32</a>)</td></tr>
<tr class="separator:abaf0ff49d19c04690a7632562ee8bbf9"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9dc86a3606afe7cc7ed8d028f58cddc5"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a9dc86a3606afe7cc7ed8d028f58cddc5">elemwise_add</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> lhs, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> rhs)</td></tr>
<tr class="separator:a9dc86a3606afe7cc7ed8d028f58cddc5"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a77452970fd3d028295db976f8720a553"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a77452970fd3d028295db976f8720a553">elemwise_sub</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> lhs, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> rhs)</td></tr>
<tr class="separator:a77452970fd3d028295db976f8720a553"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a83ef847676bdcba737c0aa0e42ec93cb"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a83ef847676bdcba737c0aa0e42ec93cb">elemwise_mul</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> lhs, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> rhs)</td></tr>
<tr class="separator:a83ef847676bdcba737c0aa0e42ec93cb"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a3a21ba4707a30004aed65f61e10feae8"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a3a21ba4707a30004aed65f61e10feae8">elemwise_div</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> lhs, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> rhs)</td></tr>
<tr class="separator:a3a21ba4707a30004aed65f61e10feae8"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a0987ecb278115a257e0f61394b0814c7"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a0987ecb278115a257e0f61394b0814c7">Embedding</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> weight, int input_dim, int output_dim, <a class="el" href="namespacemxnet_1_1cpp.html#a3c80705d63347982667fc541ad5bf845">EmbeddingDtype</a> dtype=<a class="el" href="namespacemxnet_1_1cpp.html#a8e907a5fbbe4ec21628e500b34a5f35da9a78d6a569d086b524c3caf8c2522f96">EmbeddingDtype::kFloat32</a>, bool sparse_grad=false)</td></tr>
<tr class="separator:a0987ecb278115a257e0f61394b0814c7"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa1a8cb38168a5258ec78a8e0956261c0"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#aa1a8cb38168a5258ec78a8e0956261c0">take</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> a, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> indices, int axis=0, <a class="el" href="namespacemxnet_1_1cpp.html#ab8b82422d329aa4497e6891590633325">TakeMode</a> mode=<a class="el" href="namespacemxnet_1_1cpp.html#a30fd3a240ebc436ddb671d0c33d5bdc3ae2867cadc2a39b014e89d241b72f3a75">TakeMode::kClip</a>)</td></tr>
<tr class="separator:aa1a8cb38168a5258ec78a8e0956261c0"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac2ca26e7aa7ee6e517ea01112832ea88"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#ac2ca26e7aa7ee6e517ea01112832ea88">batch_take</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> a, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> indices)</td></tr>
<tr class="separator:ac2ca26e7aa7ee6e517ea01112832ea88"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9e910ba1e5b10fdc19d0d807ef263c14"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a9e910ba1e5b10fdc19d0d807ef263c14">one_hot</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> indices, int depth, double on_value=1, double off_value=0, <a class="el" href="namespacemxnet_1_1cpp.html#a38cfaf4948f45cc4e6e46fbef0f6b8c2">One_hotDtype</a> dtype=<a class="el" href="namespacemxnet_1_1cpp.html#a8e907a5fbbe4ec21628e500b34a5f35da9a78d6a569d086b524c3caf8c2522f96">One_hotDtype::kFloat32</a>)</td></tr>
<tr class="separator:a9e910ba1e5b10fdc19d0d807ef263c14"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:acd565231b1fc500ac5808ac049e5d31e"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#acd565231b1fc500ac5808ac049e5d31e">gather_nd</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> indices)</td></tr>
<tr class="separator:acd565231b1fc500ac5808ac049e5d31e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab7d9f3f1e538d870956ea70c2b1c95e8"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#ab7d9f3f1e538d870956ea70c2b1c95e8">scatter_nd</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> indices, <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> shape)</td></tr>
<tr class="separator:ab7d9f3f1e538d870956ea70c2b1c95e8"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a397580a170a0a58c4fa82369c3bac6c1"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a397580a170a0a58c4fa82369c3bac6c1">broadcast_equal</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> lhs, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> rhs)</td></tr>
<tr class="separator:a397580a170a0a58c4fa82369c3bac6c1"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a3a5f26e36cb9fa3c9388bab2109cde07"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a3a5f26e36cb9fa3c9388bab2109cde07">broadcast_not_equal</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> lhs, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> rhs)</td></tr>
<tr class="separator:a3a5f26e36cb9fa3c9388bab2109cde07"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa2b7c2b713266388570a2e836fdf6a7a"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#aa2b7c2b713266388570a2e836fdf6a7a">broadcast_greater</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> lhs, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> rhs)</td></tr>
<tr class="separator:aa2b7c2b713266388570a2e836fdf6a7a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:acc2f9980021108b8467be695fe15e9e0"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#acc2f9980021108b8467be695fe15e9e0">broadcast_greater_equal</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> lhs, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> rhs)</td></tr>
<tr class="separator:acc2f9980021108b8467be695fe15e9e0"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:afbf2da9ec297c21d8e910d5fec9162fa"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#afbf2da9ec297c21d8e910d5fec9162fa">broadcast_lesser</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> lhs, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> rhs)</td></tr>
<tr class="separator:afbf2da9ec297c21d8e910d5fec9162fa"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:adc49c8c0a60443e640a9243f5f02af71"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#adc49c8c0a60443e640a9243f5f02af71">broadcast_lesser_equal</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> lhs, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> rhs)</td></tr>
<tr class="separator:adc49c8c0a60443e640a9243f5f02af71"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a0192130745dc20317d49491a37a5f952"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a0192130745dc20317d49491a37a5f952">broadcast_logical_and</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> lhs, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> rhs)</td></tr>
<tr class="separator:a0192130745dc20317d49491a37a5f952"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:abab1833009eb1be2bf8a7de9edb98e46"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#abab1833009eb1be2bf8a7de9edb98e46">broadcast_logical_or</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> lhs, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> rhs)</td></tr>
<tr class="separator:abab1833009eb1be2bf8a7de9edb98e46"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad04bcd4646bb3251bf8304389f1e4588"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#ad04bcd4646bb3251bf8304389f1e4588">broadcast_logical_xor</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> lhs, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> rhs)</td></tr>
<tr class="separator:ad04bcd4646bb3251bf8304389f1e4588"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a92ce214592b710caf84e4bb891641342"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a92ce214592b710caf84e4bb891641342">diag</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, dmlc::optional&lt; int &gt; k=dmlc::optional&lt; int &gt;(0))</td></tr>
<tr class="separator:a92ce214592b710caf84e4bb891641342"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5b247c5c4425fb127b5b99634efd11fd"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a5b247c5c4425fb127b5b99634efd11fd">where</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> condition, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> x, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> y)</td></tr>
<tr class="separator:a5b247c5c4425fb127b5b99634efd11fd"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a3fe03556ba0c297e94e53b47bb4452bc"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a3fe03556ba0c297e94e53b47bb4452bc">smooth_l1</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> scalar)</td></tr>
<tr class="separator:a3fe03556ba0c297e94e53b47bb4452bc"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae071452dc28d12aeb785c9b94d8f83d8"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#ae071452dc28d12aeb785c9b94d8f83d8">cast_storage</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="namespacemxnet_1_1cpp.html#aac92e2f3642173e36bb79eb4854728ff">Cast_storageStype</a> stype)</td></tr>
<tr class="separator:ae071452dc28d12aeb785c9b94d8f83d8"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a86ed9f253317ed4bd414507e296274e2"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a86ed9f253317ed4bd414507e296274e2">sin</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:a86ed9f253317ed4bd414507e296274e2"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a27d67a7fa628351ad6c11cb0a72b2cfb"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a27d67a7fa628351ad6c11cb0a72b2cfb">cos</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:a27d67a7fa628351ad6c11cb0a72b2cfb"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9a60483ca0304c89eed9c3cdc4bc9f9e"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a9a60483ca0304c89eed9c3cdc4bc9f9e">tan</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:a9a60483ca0304c89eed9c3cdc4bc9f9e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a83f1b49ee746d95b35455db325cb43b2"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a83f1b49ee746d95b35455db325cb43b2">arcsin</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:a83f1b49ee746d95b35455db325cb43b2"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2184715822af3bd29d821432032bd40d"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a2184715822af3bd29d821432032bd40d">arccos</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:a2184715822af3bd29d821432032bd40d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac11da62275a42842ed73b5ddebc3cb3e"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#ac11da62275a42842ed73b5ddebc3cb3e">arctan</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:ac11da62275a42842ed73b5ddebc3cb3e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af70569cfb0277bee3427b02edd4963cc"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#af70569cfb0277bee3427b02edd4963cc">degrees</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:af70569cfb0277bee3427b02edd4963cc"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a413e3d0f2b11b02be475cab94cfb2fa1"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a413e3d0f2b11b02be475cab94cfb2fa1">radians</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:a413e3d0f2b11b02be475cab94cfb2fa1"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a74af4ade5fd6940e4001d46d14b55112"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a74af4ade5fd6940e4001d46d14b55112">sinh</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:a74af4ade5fd6940e4001d46d14b55112"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1447e9ca11b50f9692c5fe4d12dd89e8"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a1447e9ca11b50f9692c5fe4d12dd89e8">cosh</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:a1447e9ca11b50f9692c5fe4d12dd89e8"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a06e84f93bdc83cac7bb8d74cdb1bf941"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a06e84f93bdc83cac7bb8d74cdb1bf941">tanh</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:a06e84f93bdc83cac7bb8d74cdb1bf941"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac3e49781b6a98c88ca180cf0ea2efeda"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#ac3e49781b6a98c88ca180cf0ea2efeda">arcsinh</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:ac3e49781b6a98c88ca180cf0ea2efeda"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a770fe932da849a51041d4c81fb5813eb"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a770fe932da849a51041d4c81fb5813eb">arccosh</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:a770fe932da849a51041d4c81fb5813eb"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab3405be554e12ac47416461e1d01c135"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#ab3405be554e12ac47416461e1d01c135">arctanh</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:ab3405be554e12ac47416461e1d01c135"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a800c66c6506c33a9cd23d3f3d208bdcb"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a800c66c6506c33a9cd23d3f3d208bdcb">Pooling</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> kernel=<a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>(), <a class="el" href="namespacemxnet_1_1cpp.html#a44ef744b314acdba218a7405f56e00be">PoolingPoolType</a> pool_type=<a class="el" href="namespacemxnet_1_1cpp.html#a44ef744b314acdba218a7405f56e00beaa0b1ac8aae6b1cfbbe89085c642b3b4b">PoolingPoolType::kMax</a>, bool global_pool=false, bool cudnn_off=false, <a class="el" href="namespacemxnet_1_1cpp.html#abaf9ea614ede3210454943dd3130c5cd">PoolingPoolingConvention</a> pooling_convention=<a class="el" href="namespacemxnet_1_1cpp.html#abaf9ea614ede3210454943dd3130c5cda4d3576c37e6f03700bad4345238fffa0">PoolingPoolingConvention::kValid</a>, <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> stride=<a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>(), <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> pad=<a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>(), dmlc::optional&lt; int &gt; p_value=dmlc::optional&lt; int &gt;(), dmlc::optional&lt; bool &gt; count_include_pad=dmlc::optional&lt; bool &gt;())</td></tr>
<tr class="separator:a800c66c6506c33a9cd23d3f3d208bdcb"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a0b5a88497c964061b72953a700681895"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a0b5a88497c964061b72953a700681895">softmax</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, int axis=-1, dmlc::optional&lt; double &gt; temperature=dmlc::optional&lt; double &gt;())</td></tr>
<tr class="separator:a0b5a88497c964061b72953a700681895"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a88c6135b2e3c7eacc2da0aeb52332bd4"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a88c6135b2e3c7eacc2da0aeb52332bd4">log_softmax</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, int axis=-1, dmlc::optional&lt; double &gt; temperature=dmlc::optional&lt; double &gt;())</td></tr>
<tr class="separator:a88c6135b2e3c7eacc2da0aeb52332bd4"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aefff3268cf067e42c177e88591f7df99"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#aefff3268cf067e42c177e88591f7df99">Deconvolution</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> weight, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> bias, <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> kernel, uint32_t num_filter, <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> stride=<a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>(), <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> dilate=<a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>(), <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> pad=<a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>(), <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> adj=<a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>(), <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> target_shape=<a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>(), uint32_t num_group=1, uint64_t workspace=512, bool no_bias=true, <a class="el" href="namespacemxnet_1_1cpp.html#ae25c98b47a52531322d1622509c0e84d">DeconvolutionCudnnTune</a> cudnn_tune=<a class="el" href="namespacemxnet_1_1cpp.html#aa5dbdd69827034fc43c16cf350db7e1ea35c3ace1970663a16e5c65baa5941b13">DeconvolutionCudnnTune::kNone</a>, bool cudnn_off=false, <a class="el" href="namespacemxnet_1_1cpp.html#a63a3b219f6bced4a550ed4bc5207e997">DeconvolutionLayout</a> layout=<a class="el" href="namespacemxnet_1_1cpp.html#aa5dbdd69827034fc43c16cf350db7e1ea35c3ace1970663a16e5c65baa5941b13">DeconvolutionLayout::kNone</a>)</td></tr>
<tr class="separator:aefff3268cf067e42c177e88591f7df99"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae0e34284b668c02ac1ae643db2ca4377"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#ae0e34284b668c02ac1ae643db2ca4377">Activation</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="namespacemxnet_1_1cpp.html#a919a622dc07b83d4431e8ff775455962">ActivationActType</a> act_type)</td></tr>
<tr class="separator:ae0e34284b668c02ac1ae643db2ca4377"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7a48ca9bedc133b0c335d2fe54a3acec"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a7a48ca9bedc133b0c335d2fe54a3acec">BatchNorm</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> <a class="el" href="namespacemxnet_1_1cpp.html#a0a9aa2fcd720ec0c0540a6a8ad47a8c7">gamma</a>, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> beta, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> moving_mean, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> moving_var, double eps=0.001, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> momentum=0.9, bool fix_gamma=true, bool use_global_stats=false, bool output_mean_var=false, int axis=1, bool cudnn_off=false)</td></tr>
<tr class="separator:a7a48ca9bedc133b0c335d2fe54a3acec"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1ad654fc47d82ee0f1c5ae172d29b1f6"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a1ad654fc47d82ee0f1c5ae172d29b1f6">Convolution</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> weight, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> bias, <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> kernel, uint32_t num_filter, <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> stride=<a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>(), <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> dilate=<a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>(), <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> pad=<a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>(), uint32_t num_group=1, uint64_t workspace=1024, bool no_bias=false, <a class="el" href="namespacemxnet_1_1cpp.html#a8755a4574a3839da2ad93af004fb1ff5">ConvolutionCudnnTune</a> cudnn_tune=<a class="el" href="namespacemxnet_1_1cpp.html#aa5dbdd69827034fc43c16cf350db7e1ea35c3ace1970663a16e5c65baa5941b13">ConvolutionCudnnTune::kNone</a>, bool cudnn_off=false, <a class="el" href="namespacemxnet_1_1cpp.html#a7b419f5293a7706c76becfe735a9946b">ConvolutionLayout</a> layout=<a class="el" href="namespacemxnet_1_1cpp.html#aa5dbdd69827034fc43c16cf350db7e1ea35c3ace1970663a16e5c65baa5941b13">ConvolutionLayout::kNone</a>)</td></tr>
<tr class="separator:a1ad654fc47d82ee0f1c5ae172d29b1f6"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac02c4b9e4c60499b3931d120ef51eca3"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#ac02c4b9e4c60499b3931d120ef51eca3">UpSampling</a> (const std::string &amp;symbol_name, const std::vector&lt; <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> &gt; &amp;data, uint32_t scale, <a class="el" href="namespacemxnet_1_1cpp.html#a9c9a4644f19e7ed3c729165de2e963ab">UpSamplingSampleType</a> sample_type, int num_args, uint32_t num_filter=0, <a class="el" href="namespacemxnet_1_1cpp.html#afce90445dba4ab6be903251cb0c960ef">UpSamplingMultiInputMode</a> multi_input_mode=<a class="el" href="namespacemxnet_1_1cpp.html#afce90445dba4ab6be903251cb0c960efa07f24210ce07b41cf8370dd8e9a3eb70">UpSamplingMultiInputMode::kConcat</a>, uint64_t workspace=512)</td></tr>
<tr class="separator:ac02c4b9e4c60499b3931d120ef51eca3"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a58ec45705c88219a949dd3dfb11ce058"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a58ec45705c88219a949dd3dfb11ce058">Concat</a> (const std::string &amp;symbol_name, const std::vector&lt; <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> &gt; &amp;data, int num_args, int dim=1)</td></tr>
<tr class="separator:a58ec45705c88219a949dd3dfb11ce058"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a837a8ec6d76f03fc7085b5e6588eb53c"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a837a8ec6d76f03fc7085b5e6588eb53c">LayerNorm</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> <a class="el" href="namespacemxnet_1_1cpp.html#a0a9aa2fcd720ec0c0540a6a8ad47a8c7">gamma</a>, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> beta, int axis=-1, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> eps=1e-05, bool output_mean_var=false)</td></tr>
<tr class="separator:a837a8ec6d76f03fc7085b5e6588eb53c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1110128eb77f14f6cf35f002b5b0c288"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a1110128eb77f14f6cf35f002b5b0c288">LRN</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, uint32_t nsize, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> alpha=0.0001, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> beta=0.75, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> knorm=2)</td></tr>
<tr class="separator:a1110128eb77f14f6cf35f002b5b0c288"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6688c8cb305077987c5caae840e29540"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a6688c8cb305077987c5caae840e29540">Dropout</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> p=0.5, <a class="el" href="namespacemxnet_1_1cpp.html#a3cc3a1d19b3bf567326c77e263038a0e">DropoutMode</a> mode=<a class="el" href="namespacemxnet_1_1cpp.html#a3cc3a1d19b3bf567326c77e263038a0eabae2199a6d43c4c6ccd0e74727c02a64">DropoutMode::kTraining</a>, <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> axes=<a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>())</td></tr>
<tr class="separator:a6688c8cb305077987c5caae840e29540"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a58de1c65842e8b5421c9960ed3a6f8e8"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a58de1c65842e8b5421c9960ed3a6f8e8">SoftmaxActivation</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="namespacemxnet_1_1cpp.html#a08bbd5633680ffa58dae3cab685e2ebf">SoftmaxActivationMode</a> mode=<a class="el" href="namespacemxnet_1_1cpp.html#a08bbd5633680ffa58dae3cab685e2ebfa63f56d9e95d7b447075aef94444c4c96">SoftmaxActivationMode::kInstance</a>)</td></tr>
<tr class="separator:a58de1c65842e8b5421c9960ed3a6f8e8"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af2bb88b8ee157f34c2c538334b1ae7cc"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#af2bb88b8ee157f34c2c538334b1ae7cc">FullyConnected</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> weight, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> bias, int num_hidden, bool no_bias=false, bool flatten=true)</td></tr>
<tr class="separator:af2bb88b8ee157f34c2c538334b1ae7cc"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a55dd6c1f44abfaf30cf60fd099ef511c"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a55dd6c1f44abfaf30cf60fd099ef511c">Pad</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="namespacemxnet_1_1cpp.html#ab261a86c931574327d82188c75f93d1a">PadMode</a> mode, <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> pad_width, double constant_value=0)</td></tr>
<tr class="separator:a55dd6c1f44abfaf30cf60fd099ef511c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:afd094b64ffc4a3a77b1d2d52d86834b5"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#afd094b64ffc4a3a77b1d2d52d86834b5">LeakyReLU</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> <a class="el" href="namespacemxnet_1_1cpp.html#a0a9aa2fcd720ec0c0540a6a8ad47a8c7">gamma</a>, <a class="el" href="namespacemxnet_1_1cpp.html#aad64d459f3652d3ec3cf37c460aa8ee0">LeakyReLUActType</a> act_type=<a class="el" href="namespacemxnet_1_1cpp.html#aad64d459f3652d3ec3cf37c460aa8ee0a3620dd046c3b58ec17570ae64aa325eb">LeakyReLUActType::kLeaky</a>, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> slope=0.25, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> lower_bound=0.125, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> upper_bound=0.334)</td></tr>
<tr class="separator:afd094b64ffc4a3a77b1d2d52d86834b5"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:afcb2337221cd6de68df05fb28683e398"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#afcb2337221cd6de68df05fb28683e398">SwapAxis</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, uint32_t dim1=0, uint32_t dim2=0)</td></tr>
<tr class="separator:afcb2337221cd6de68df05fb28683e398"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a038dcc0c2387bd718379bb8a53e43728"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a038dcc0c2387bd718379bb8a53e43728">BatchNorm_v1</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> <a class="el" href="namespacemxnet_1_1cpp.html#a0a9aa2fcd720ec0c0540a6a8ad47a8c7">gamma</a>, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> beta, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> eps=0.001, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> momentum=0.9, bool fix_gamma=true, bool use_global_stats=false, bool output_mean_var=false)</td></tr>
<tr class="separator:a038dcc0c2387bd718379bb8a53e43728"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9a45e59107b4d972d026627fa7f25e63"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a9a45e59107b4d972d026627fa7f25e63">softmax_cross_entropy</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> label)</td></tr>
<tr class="separator:a9a45e59107b4d972d026627fa7f25e63"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9cde2fb30690b60d2659a4e4e56ab910"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a9cde2fb30690b60d2659a4e4e56ab910">LinearRegressionOutput</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> label, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> grad_scale=1)</td></tr>
<tr class="separator:a9cde2fb30690b60d2659a4e4e56ab910"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a343358c8da2a0fd8cf79e97dab50a94d"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a343358c8da2a0fd8cf79e97dab50a94d">MAERegressionOutput</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> label, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> grad_scale=1)</td></tr>
<tr class="separator:a343358c8da2a0fd8cf79e97dab50a94d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a29dec6f8e234fee06c02c64ddba3de1b"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a29dec6f8e234fee06c02c64ddba3de1b">LogisticRegressionOutput</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> label, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> grad_scale=1)</td></tr>
<tr class="separator:a29dec6f8e234fee06c02c64ddba3de1b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a14ef7f6f4e3e5952dedfbd42b02d2831"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a14ef7f6f4e3e5952dedfbd42b02d2831">IdentityAttachKLSparseReg</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> sparseness_target=0.1, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> penalty=0.001, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> momentum=0.9)</td></tr>
<tr class="separator:a14ef7f6f4e3e5952dedfbd42b02d2831"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac506a85a7f6e1903fb8ee802db0c65be"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#ac506a85a7f6e1903fb8ee802db0c65be">signsgd_update</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> weight, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> grad, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> lr, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> wd=0, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> rescale_grad=1, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> clip_gradient=-1)</td></tr>
<tr class="separator:ac506a85a7f6e1903fb8ee802db0c65be"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6120815ac0de2ae15c44b827b0edf9ce"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a6120815ac0de2ae15c44b827b0edf9ce">signum_update</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> weight, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> grad, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mom, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> lr, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> momentum=0, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> wd=0, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> rescale_grad=1, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> clip_gradient=-1, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> wd_lh=0)</td></tr>
<tr class="separator:a6120815ac0de2ae15c44b827b0edf9ce"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4b5be9332d99264e24de75c0025adf6e"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a4b5be9332d99264e24de75c0025adf6e">sgd_update</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> weight, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> grad, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> lr, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> wd=0, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> rescale_grad=1, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> clip_gradient=-1, bool lazy_update=true)</td></tr>
<tr class="separator:a4b5be9332d99264e24de75c0025adf6e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a26ad240c6e162aee5209319b26d774b5"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a26ad240c6e162aee5209319b26d774b5">sgd_mom_update</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> weight, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> grad, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mom, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> lr, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> momentum=0, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> wd=0, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> rescale_grad=1, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> clip_gradient=-1, bool lazy_update=true)</td></tr>
<tr class="separator:a26ad240c6e162aee5209319b26d774b5"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab7eb6765323ad891149d3709a4933f27"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#ab7eb6765323ad891149d3709a4933f27">mp_sgd_update</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> weight, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> grad, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> weight32, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> lr, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> wd=0, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> rescale_grad=1, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> clip_gradient=-1, bool lazy_update=true)</td></tr>
<tr class="separator:ab7eb6765323ad891149d3709a4933f27"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2e5c614842a25263659a0e743f2982bf"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a2e5c614842a25263659a0e743f2982bf">mp_sgd_mom_update</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> weight, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> grad, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mom, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> weight32, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> lr, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> momentum=0, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> wd=0, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> rescale_grad=1, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> clip_gradient=-1, bool lazy_update=true)</td></tr>
<tr class="separator:a2e5c614842a25263659a0e743f2982bf"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6bf2167ad08a5ffa15df5a8743241adb"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a6bf2167ad08a5ffa15df5a8743241adb">ftml_update</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> weight, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> grad, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> d, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> v, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> z, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> lr, int t, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> beta1=0.6, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> beta2=0.999, double epsilon=1e-08, mx_float wd=0, mx_float rescale_grad=1, mx_float clip_grad=-1)</td></tr>
<tr class="separator:a6bf2167ad08a5ffa15df5a8743241adb"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6b729f4fac2b1e7b50f39b2723af43f1"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a6b729f4fac2b1e7b50f39b2723af43f1">adam_update</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> weight, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> grad, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> <a class="el" href="namespacemxnet_1_1cpp.html#a54884055c968a6fcb737b772c82c5519">mean</a>, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> var, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> lr, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> beta1=0.9, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> beta2=0.999, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> epsilon=1e-08, mx_float wd=0, mx_float rescale_grad=1, mx_float clip_gradient=-1, bool lazy_update=true)</td></tr>
<tr class="separator:a6b729f4fac2b1e7b50f39b2723af43f1"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7a41621e2256fb5d94ed5b5221a6db8f"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a7a41621e2256fb5d94ed5b5221a6db8f">rmsprop_update</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> weight, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> grad, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> n, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> lr, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> gamma1=0.95, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> epsilon=1e-08, mx_float wd=0, mx_float rescale_grad=1, mx_float clip_gradient=-1, mx_float clip_weights=-1)</td></tr>
<tr class="separator:a7a41621e2256fb5d94ed5b5221a6db8f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aef74bbe21576cee5e6d567b84e613a70"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#aef74bbe21576cee5e6d567b84e613a70">rmspropalex_update</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> weight, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> grad, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> n, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> g, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> delta, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> lr, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> gamma1=0.95, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> gamma2=0.9, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> epsilon=1e-08, mx_float wd=0, mx_float rescale_grad=1, mx_float clip_gradient=-1, mx_float clip_weights=-1)</td></tr>
<tr class="separator:aef74bbe21576cee5e6d567b84e613a70"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa2905ae0daecb7e5853fd5d841978756"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#aa2905ae0daecb7e5853fd5d841978756">ftrl_update</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> weight, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> grad, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> z, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> n, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> lr, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> lamda1=0.01, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> beta=1, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> wd=0, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> rescale_grad=1, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> clip_gradient=-1)</td></tr>
<tr class="separator:aa2905ae0daecb7e5853fd5d841978756"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6a8afcdb74cfc8eb33a58e89d9534699"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a6a8afcdb74cfc8eb33a58e89d9534699">SliceChannel</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, int num_outputs, int axis=1, bool squeeze_axis=false)</td></tr>
<tr class="separator:a6a8afcdb74cfc8eb33a58e89d9534699"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5541e08fbfa3d0b49e1f3e63b36c001b"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a5541e08fbfa3d0b49e1f3e63b36c001b">InstanceNorm</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> <a class="el" href="namespacemxnet_1_1cpp.html#a0a9aa2fcd720ec0c0540a6a8ad47a8c7">gamma</a>, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> beta, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> eps=0.001)</td></tr>
<tr class="separator:a5541e08fbfa3d0b49e1f3e63b36c001b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6ba557fafd479004873f1c6afa6b497c"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a6ba557fafd479004873f1c6afa6b497c">GridGenerator</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="namespacemxnet_1_1cpp.html#a98745f0114674ef8fa60b2a35a877a2c">GridGeneratorTransformType</a> transform_type, <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> target_shape=<a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>(0, 0))</td></tr>
<tr class="separator:a6ba557fafd479004873f1c6afa6b497c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae29f3e882b99e31695e999819658c6aa"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#ae29f3e882b99e31695e999819658c6aa">Pooling_v1</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> kernel=<a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>(), <a class="el" href="namespacemxnet_1_1cpp.html#a7dc4e3b741dfffc9295e1f8fbcb51c2e">Pooling_v1PoolType</a> pool_type=<a class="el" href="namespacemxnet_1_1cpp.html#a44ef744b314acdba218a7405f56e00beaa0b1ac8aae6b1cfbbe89085c642b3b4b">Pooling_v1PoolType::kMax</a>, bool global_pool=false, <a class="el" href="namespacemxnet_1_1cpp.html#ac8e6f64dc9bca9d9388d34d5153cb094">Pooling_v1PoolingConvention</a> pooling_convention=<a class="el" href="namespacemxnet_1_1cpp.html#abaf9ea614ede3210454943dd3130c5cda4d3576c37e6f03700bad4345238fffa0">Pooling_v1PoolingConvention::kValid</a>, <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> stride=<a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>(), <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> pad=<a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>())</td></tr>
<tr class="separator:ae29f3e882b99e31695e999819658c6aa"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a3124c45d4c48a007d773a35168733a37"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a3124c45d4c48a007d773a35168733a37">RNN</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> parameters, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> state, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> state_cell, uint32_t state_size, uint32_t num_layers, <a class="el" href="namespacemxnet_1_1cpp.html#ae39119fed3c83726a0a2ea89b506661d">RNNMode</a> mode, bool bidirectional=false, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> p=0, bool state_outputs=false, dmlc::optional&lt; int &gt; projection_size=dmlc::optional&lt; int &gt;(), dmlc::optional&lt; double &gt; lstm_state_clip_min=dmlc::optional&lt; double &gt;(), dmlc::optional&lt; double &gt; lstm_state_clip_max=dmlc::optional&lt; double &gt;(), bool lstm_state_clip_nan=false)</td></tr>
<tr class="separator:a3124c45d4c48a007d773a35168733a37"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:abb9c18ff76114a00e17e147da71ef75b"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#abb9c18ff76114a00e17e147da71ef75b">Convolution_v1</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> weight, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> bias, <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> kernel, uint32_t num_filter, <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> stride=<a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>(), <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> dilate=<a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>(), <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> pad=<a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>(), uint32_t num_group=1, uint64_t workspace=1024, bool no_bias=false, <a class="el" href="namespacemxnet_1_1cpp.html#aa32f4a10a37f253f9d102cfc96a9eafc">Convolution_v1CudnnTune</a> cudnn_tune=<a class="el" href="namespacemxnet_1_1cpp.html#aa5dbdd69827034fc43c16cf350db7e1ea35c3ace1970663a16e5c65baa5941b13">Convolution_v1CudnnTune::kNone</a>, bool cudnn_off=false, <a class="el" href="namespacemxnet_1_1cpp.html#a97217f563c768120cd8db19573938635">Convolution_v1Layout</a> layout=<a class="el" href="namespacemxnet_1_1cpp.html#aa5dbdd69827034fc43c16cf350db7e1ea35c3ace1970663a16e5c65baa5941b13">Convolution_v1Layout::kNone</a>)</td></tr>
<tr class="separator:abb9c18ff76114a00e17e147da71ef75b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a39f7204c05fea075591fe9aa424d95aa"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a39f7204c05fea075591fe9aa424d95aa">Crop</a> (const std::string &amp;symbol_name, const std::vector&lt; <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> &gt; &amp;data, int num_args, <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> offset=<a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>(0, 0), <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> h_w=<a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>(0, 0), bool center_crop=false)</td></tr>
<tr class="separator:a39f7204c05fea075591fe9aa424d95aa"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a64276cac6005f45bbbe1f2b4f00e2316"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a64276cac6005f45bbbe1f2b4f00e2316">SequenceReverse</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> sequence_length, bool use_sequence_length=false, int axis=0)</td></tr>
<tr class="separator:a64276cac6005f45bbbe1f2b4f00e2316"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a33597bd1c2770b9cba161f7ad2171879"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a33597bd1c2770b9cba161f7ad2171879">SpatialTransformer</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> loc, <a class="el" href="namespacemxnet_1_1cpp.html#a0ff49861ba295abeac5d545bfa16b0aa">SpatialTransformerTransformType</a> transform_type, <a class="el" href="namespacemxnet_1_1cpp.html#a20ce4a2b1581ec74fc957d816d1e19ce">SpatialTransformerSamplerType</a> sampler_type, <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> target_shape=<a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>(0, 0))</td></tr>
<tr class="separator:a33597bd1c2770b9cba161f7ad2171879"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a91a94bf31170afd035f7cc85351eaf98"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a91a94bf31170afd035f7cc85351eaf98">SoftmaxOutput</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> label, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> grad_scale=1, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> ignore_label=-1, bool multi_output=false, bool use_ignore=false, bool preserve_shape=false, <a class="el" href="namespacemxnet_1_1cpp.html#ae708904c6ad7046fcecfc6c6b7e0ac73">SoftmaxOutputNormalization</a> normalization=<a class="el" href="namespacemxnet_1_1cpp.html#ae708904c6ad7046fcecfc6c6b7e0ac73af2655c2dee87cb9b0646f678a630394b">SoftmaxOutputNormalization::kNull</a>, bool out_grad=false, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> smooth_alpha=0)</td></tr>
<tr class="separator:a91a94bf31170afd035f7cc85351eaf98"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5c43bc2921ee5db9ddd94f2418e79abc"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a5c43bc2921ee5db9ddd94f2418e79abc">Softmax</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> grad_scale=1, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> ignore_label=-1, bool multi_output=false, bool use_ignore=false, bool preserve_shape=false, <a class="el" href="namespacemxnet_1_1cpp.html#abac2e8c934c7bd4416728b351fcbae5b">SoftmaxNormalization</a> normalization=<a class="el" href="namespacemxnet_1_1cpp.html#ae708904c6ad7046fcecfc6c6b7e0ac73af2655c2dee87cb9b0646f678a630394b">SoftmaxNormalization::kNull</a>, bool out_grad=false, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> smooth_alpha=0)</td></tr>
<tr class="separator:a5c43bc2921ee5db9ddd94f2418e79abc"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac4bda567b553b5e0b7b2bf26206e4b3a"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#ac4bda567b553b5e0b7b2bf26206e4b3a">BilinearSampler</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> grid)</td></tr>
<tr class="separator:ac4bda567b553b5e0b7b2bf26206e4b3a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a13294121c39bafaa2c9c233fd8f25fc2"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a13294121c39bafaa2c9c233fd8f25fc2">ROIPooling</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> rois, <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> pooled_size, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> spatial_scale)</td></tr>
<tr class="separator:a13294121c39bafaa2c9c233fd8f25fc2"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4566fd03b43aee1681141cea8c9d87a0"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a4566fd03b43aee1681141cea8c9d87a0">SequenceLast</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> sequence_length, bool use_sequence_length=false, int axis=0)</td></tr>
<tr class="separator:a4566fd03b43aee1681141cea8c9d87a0"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a38d13c13c0be0010e704a30430dff2b0"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a38d13c13c0be0010e704a30430dff2b0">L2Normalization</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> eps=1e-10, L2NormalizationMode mode=L2NormalizationMode::kInstance)</td></tr>
<tr class="separator:a38d13c13c0be0010e704a30430dff2b0"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2b71f8b455ec59d0d9101d320ba77321"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a2b71f8b455ec59d0d9101d320ba77321">MakeLoss</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> grad_scale=1, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> valid_thresh=0, <a class="el" href="namespacemxnet_1_1cpp.html#a0f8c7551de879673caa593f74e8ebca6">MakeLossNormalization</a> normalization=<a class="el" href="namespacemxnet_1_1cpp.html#ae708904c6ad7046fcecfc6c6b7e0ac73af2655c2dee87cb9b0646f678a630394b">MakeLossNormalization::kNull</a>)</td></tr>
<tr class="separator:a2b71f8b455ec59d0d9101d320ba77321"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9bb4aa662eea7cdf0e29eeb966a22ba4"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a9bb4aa662eea7cdf0e29eeb966a22ba4">SVMOutput</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> label, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> margin=1, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> regularization_coefficient=1, bool use_linear=false)</td></tr>
<tr class="separator:a9bb4aa662eea7cdf0e29eeb966a22ba4"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a84d2bda6af522d5cf84cf54b74c5aaac"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a84d2bda6af522d5cf84cf54b74c5aaac">Correlation</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data1, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data2, uint32_t kernel_size=1, uint32_t max_displacement=1, uint32_t stride1=1, uint32_t stride2=1, uint32_t pad_size=0, bool is_multiply=true)</td></tr>
<tr class="separator:a84d2bda6af522d5cf84cf54b74c5aaac"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a90663714055325d9150b772a6ef0a1d6"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a90663714055325d9150b772a6ef0a1d6">SequenceMask</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> sequence_length, bool use_sequence_length=false, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> value=0, int axis=0)</td></tr>
<tr class="separator:a90663714055325d9150b772a6ef0a1d6"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a633ba7fbface59da4f043148847c2c9e"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a633ba7fbface59da4f043148847c2c9e">choose_element_0index</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> lhs, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> rhs)</td></tr>
<tr class="separator:a633ba7fbface59da4f043148847c2c9e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af977c7bf3bb24f5ebe973dcb41680244"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#af977c7bf3bb24f5ebe973dcb41680244">fill_element_0index</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> lhs, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mhs, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> rhs)</td></tr>
<tr class="separator:af977c7bf3bb24f5ebe973dcb41680244"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6ec5b3c7c995f8548c955a13459e91a9"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a6ec5b3c7c995f8548c955a13459e91a9">khatri_rao</a> (const std::vector&lt; <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> &gt; &amp;args)</td></tr>
<tr class="separator:a6ec5b3c7c995f8548c955a13459e91a9"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7667f538b000216fade42cb15ba39a8f"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a7667f538b000216fade42cb15ba39a8f">Custom</a> (const std::vector&lt; <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> &gt; &amp;data, const std::string &amp;op_type)</td></tr>
<tr class="separator:a7667f538b000216fade42cb15ba39a8f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4397288fa6203e86f00c250c015229d5"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a4397288fa6203e86f00c250c015229d5">broadcast_power</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> lhs, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> rhs)</td></tr>
<tr class="separator:a4397288fa6203e86f00c250c015229d5"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a726537cde6ac90b58e866b9644503ace"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a726537cde6ac90b58e866b9644503ace">broadcast_maximum</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> lhs, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> rhs)</td></tr>
<tr class="separator:a726537cde6ac90b58e866b9644503ace"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5a265c2191b41da0ede87a63eb0bcdff"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a5a265c2191b41da0ede87a63eb0bcdff">broadcast_minimum</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> lhs, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> rhs)</td></tr>
<tr class="separator:a5a265c2191b41da0ede87a63eb0bcdff"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a832a57607cf12279e93a0349a0615e1e"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a832a57607cf12279e93a0349a0615e1e">broadcast_hypot</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> lhs, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> rhs)</td></tr>
<tr class="separator:a832a57607cf12279e93a0349a0615e1e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2d6a926184549a62111ec07592575471"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a2d6a926184549a62111ec07592575471">Reshape</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> shape=<a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>(), bool <a class="el" href="namespacemxnet_1_1cpp.html#a76348d0263ce3ff577c3bf7333674160">reverse</a>=false, <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> target_shape=<a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>(), bool keep_highest=false)</td></tr>
<tr class="separator:a2d6a926184549a62111ec07592575471"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad503b97061cd6b0e2424e4f9d032e816"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#ad503b97061cd6b0e2424e4f9d032e816">Flatten</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:ad503b97061cd6b0e2424e4f9d032e816"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7e5b6a53565d55a8b8e1c98f95b4547b"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a7e5b6a53565d55a8b8e1c98f95b4547b">transpose</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> axes=<a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>())</td></tr>
<tr class="separator:a7e5b6a53565d55a8b8e1c98f95b4547b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ada9ddaa3e0be235d25df55558ef350c5"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#ada9ddaa3e0be235d25df55558ef350c5">expand_dims</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, int axis)</td></tr>
<tr class="separator:ada9ddaa3e0be235d25df55558ef350c5"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad2fa3bd92fa801376d12ea5bc4e83521"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#ad2fa3bd92fa801376d12ea5bc4e83521">slice</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> begin, <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> end, <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> step=<a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>())</td></tr>
<tr class="separator:ad2fa3bd92fa801376d12ea5bc4e83521"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a000616c91bc1d6318553e27d58698b74"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a000616c91bc1d6318553e27d58698b74">slice_axis</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, int axis, int begin, dmlc::optional&lt; int &gt; end)</td></tr>
<tr class="separator:a000616c91bc1d6318553e27d58698b74"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad9c0bcdbd71633a994588e6d5ac64149"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#ad9c0bcdbd71633a994588e6d5ac64149">slice_like</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> shape_like, <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> axes=<a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>())</td></tr>
<tr class="separator:ad9c0bcdbd71633a994588e6d5ac64149"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a82601afa30b710cc1b184f9819c3cc4e"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a82601afa30b710cc1b184f9819c3cc4e">clip</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> a_min, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> a_max)</td></tr>
<tr class="separator:a82601afa30b710cc1b184f9819c3cc4e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9fc591da8cc66efbc5a9730c4595b8c2"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a9fc591da8cc66efbc5a9730c4595b8c2">repeat</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, int repeats, dmlc::optional&lt; int &gt; axis=dmlc::optional&lt; int &gt;())</td></tr>
<tr class="separator:a9fc591da8cc66efbc5a9730c4595b8c2"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aef94ad2c501f07193638bcf581a9fcb5"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#aef94ad2c501f07193638bcf581a9fcb5">tile</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> reps)</td></tr>
<tr class="separator:aef94ad2c501f07193638bcf581a9fcb5"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:acede888b37e618502b093e8ebbcdd255"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#acede888b37e618502b093e8ebbcdd255">reverse</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> axis)</td></tr>
<tr class="separator:acede888b37e618502b093e8ebbcdd255"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af42af48d0b7dcde4e027c84e4dcb1206"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#af42af48d0b7dcde4e027c84e4dcb1206">stack</a> (const std::vector&lt; <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> &gt; &amp;data, int num_args, int axis=0)</td></tr>
<tr class="separator:af42af48d0b7dcde4e027c84e4dcb1206"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aad07b802cc93e4013de3721651c9132d"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#aad07b802cc93e4013de3721651c9132d">squeeze</a> (const std::vector&lt; <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> &gt; &amp;data, dmlc::optional&lt; <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> &gt; axis=dmlc::optional&lt; <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> &gt;())</td></tr>
<tr class="separator:aad07b802cc93e4013de3721651c9132d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6a897b4e1c81d9f47a8d4da5be7f1d2e"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a6a897b4e1c81d9f47a8d4da5be7f1d2e">depth_to_space</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, int block_size)</td></tr>
<tr class="separator:a6a897b4e1c81d9f47a8d4da5be7f1d2e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4616a04f60e88f94591dfb2332f65544"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a4616a04f60e88f94591dfb2332f65544">space_to_depth</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, int block_size)</td></tr>
<tr class="separator:a4616a04f60e88f94591dfb2332f65544"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a3cccee07dd82261d6325ceb08fbf3fe3"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a3cccee07dd82261d6325ceb08fbf3fe3">zeros_like</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:a3cccee07dd82261d6325ceb08fbf3fe3"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a457ca5ac74ed9713761c55f9c2eace46"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a457ca5ac74ed9713761c55f9c2eace46">ones_like</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:a457ca5ac74ed9713761c55f9c2eace46"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac5d476176e65f464bdbd82263305bd9d"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#ac5d476176e65f464bdbd82263305bd9d">broadcast_add</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> lhs, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> rhs)</td></tr>
<tr class="separator:ac5d476176e65f464bdbd82263305bd9d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac17077658ee116a287bc8668b92ca0f0"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#ac17077658ee116a287bc8668b92ca0f0">broadcast_sub</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> lhs, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> rhs)</td></tr>
<tr class="separator:ac17077658ee116a287bc8668b92ca0f0"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aea844ba6ad33ef20e6ea3a63a8a38c52"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#aea844ba6ad33ef20e6ea3a63a8a38c52">broadcast_mul</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> lhs, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> rhs)</td></tr>
<tr class="separator:aea844ba6ad33ef20e6ea3a63a8a38c52"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2085b9c86dc039fca8fa0954104d7680"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a2085b9c86dc039fca8fa0954104d7680">broadcast_div</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> lhs, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> rhs)</td></tr>
<tr class="separator:a2085b9c86dc039fca8fa0954104d7680"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a263b21f0f1bfb904cdd3e6c47ed90e6d"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a263b21f0f1bfb904cdd3e6c47ed90e6d">broadcast_mod</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> lhs, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> rhs)</td></tr>
<tr class="separator:a263b21f0f1bfb904cdd3e6c47ed90e6d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae6756558ed8d683ca36e34807d4276c9"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#ae6756558ed8d683ca36e34807d4276c9">add_n</a> (const std::vector&lt; <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> &gt; &amp;args)</td></tr>
<tr class="separator:ae6756558ed8d683ca36e34807d4276c9"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5845ab343136c5886f9b07634ce8a7e9"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a5845ab343136c5886f9b07634ce8a7e9">argmax</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, dmlc::optional&lt; int &gt; axis=dmlc::optional&lt; int &gt;(), bool keepdims=false)</td></tr>
<tr class="separator:a5845ab343136c5886f9b07634ce8a7e9"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7c44748e789575d0b9c7a9e268e1e9b6"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a7c44748e789575d0b9c7a9e268e1e9b6">argmin</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, dmlc::optional&lt; int &gt; axis=dmlc::optional&lt; int &gt;(), bool keepdims=false)</td></tr>
<tr class="separator:a7c44748e789575d0b9c7a9e268e1e9b6"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:afb2a56ed90bd0bb455100596658f56b6"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#afb2a56ed90bd0bb455100596658f56b6">argmax_channel</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:afb2a56ed90bd0bb455100596658f56b6"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a71433df39ed119974e03369b11974781"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a71433df39ed119974e03369b11974781">pick</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> index, dmlc::optional&lt; int &gt; axis=dmlc::optional&lt; int &gt;(-1), bool keepdims=false, <a class="el" href="namespacemxnet_1_1cpp.html#a30fd3a240ebc436ddb671d0c33d5bdc3">PickMode</a> mode=<a class="el" href="namespacemxnet_1_1cpp.html#a30fd3a240ebc436ddb671d0c33d5bdc3ae2867cadc2a39b014e89d241b72f3a75">PickMode::kClip</a>)</td></tr>
<tr class="separator:a71433df39ed119974e03369b11974781"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a0917025ca6b94c2ec34960af88e1d5a1"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a0917025ca6b94c2ec34960af88e1d5a1">dot</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> lhs, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> rhs, bool transpose_a=false, bool transpose_b=false, <a class="el" href="namespacemxnet_1_1cpp.html#aa5dbdd69827034fc43c16cf350db7e1e">DotForwardStype</a> forward_stype=<a class="el" href="namespacemxnet_1_1cpp.html#aa5dbdd69827034fc43c16cf350db7e1ea35c3ace1970663a16e5c65baa5941b13">DotForwardStype::kNone</a>)</td></tr>
<tr class="separator:a0917025ca6b94c2ec34960af88e1d5a1"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a645c26abadf60e2e669218b375f8de8a"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a645c26abadf60e2e669218b375f8de8a">batch_dot</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> lhs, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> rhs, bool transpose_a=false, bool transpose_b=false, <a class="el" href="namespacemxnet_1_1cpp.html#a45bddc3aa629f2554f95429b0a270a16">Batch_dotForwardStype</a> forward_stype=<a class="el" href="namespacemxnet_1_1cpp.html#aa5dbdd69827034fc43c16cf350db7e1ea35c3ace1970663a16e5c65baa5941b13">Batch_dotForwardStype::kNone</a>)</td></tr>
<tr class="separator:a645c26abadf60e2e669218b375f8de8a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7b4c34e40a23912627b965bbc00131f0"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a7b4c34e40a23912627b965bbc00131f0">relu</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:a7b4c34e40a23912627b965bbc00131f0"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a363a584748a70171a6af7caac561f771"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a363a584748a70171a6af7caac561f771">sigmoid</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:a363a584748a70171a6af7caac561f771"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a733bbbf5bde5141809a8be8e5ba9f4c2"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a733bbbf5bde5141809a8be8e5ba9f4c2">hard_sigmoid</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> alpha=0.2, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> beta=0.5)</td></tr>
<tr class="separator:a733bbbf5bde5141809a8be8e5ba9f4c2"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a985feb01bb14fb5ef55b356fe7466eda"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a985feb01bb14fb5ef55b356fe7466eda">softsign</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:a985feb01bb14fb5ef55b356fe7466eda"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a906c010c5b4b27cb35fac092e8752cb8"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a906c010c5b4b27cb35fac092e8752cb8">BlockGrad</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:a906c010c5b4b27cb35fac092e8752cb8"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a16ab7f08889ce658c3e8260458cb1143"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a16ab7f08889ce658c3e8260458cb1143">make_loss</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:a16ab7f08889ce658c3e8260458cb1143"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a91e7e87913992cb4bd413c3ab6a3a2fa"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a91e7e87913992cb4bd413c3ab6a3a2fa">reshape_like</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> lhs, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> rhs)</td></tr>
<tr class="separator:a91e7e87913992cb4bd413c3ab6a3a2fa"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae34a439176afd8a619da3bab534ef83a"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#ae34a439176afd8a619da3bab534ef83a">shape_array</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, dmlc::optional&lt; int &gt; lhs_begin=dmlc::optional&lt; int &gt;(), dmlc::optional&lt; int &gt; lhs_end=dmlc::optional&lt; int &gt;(), dmlc::optional&lt; int &gt; rhs_begin=dmlc::optional&lt; int &gt;(), dmlc::optional&lt; int &gt; rhs_end=dmlc::optional&lt; int &gt;())</td></tr>
<tr class="separator:ae34a439176afd8a619da3bab534ef83a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5a52dd70cab3aae46299fe690a415f12"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a5a52dd70cab3aae46299fe690a415f12">size_array</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:a5a52dd70cab3aae46299fe690a415f12"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a84aa19568d46821fa363c07d4693543f"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a84aa19568d46821fa363c07d4693543f">Cast</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="namespacemxnet_1_1cpp.html#a8e907a5fbbe4ec21628e500b34a5f35d">CastDtype</a> dtype)</td></tr>
<tr class="separator:a84aa19568d46821fa363c07d4693543f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a79d571267e32c41b46aefc11bae47884"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a79d571267e32c41b46aefc11bae47884">negative</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:a79d571267e32c41b46aefc11bae47884"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a370fe4b2e23600010dc3ad531b109769"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a370fe4b2e23600010dc3ad531b109769">reciprocal</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:a370fe4b2e23600010dc3ad531b109769"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae269ce90b13e450b6e9bf4575e58401a"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#ae269ce90b13e450b6e9bf4575e58401a">abs</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:ae269ce90b13e450b6e9bf4575e58401a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a04100daf8a349bc8427de9ad8fc34d59"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a04100daf8a349bc8427de9ad8fc34d59">sign</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:a04100daf8a349bc8427de9ad8fc34d59"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a712b4d43ded153ed7b3291b2daa2145e"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a712b4d43ded153ed7b3291b2daa2145e">round</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:a712b4d43ded153ed7b3291b2daa2145e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac3efddb7a6385fdb48afd9978f24225e"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#ac3efddb7a6385fdb48afd9978f24225e">rint</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:ac3efddb7a6385fdb48afd9978f24225e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1d09981c1d29d06094f0375bf359c611"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a1d09981c1d29d06094f0375bf359c611">ceil</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:a1d09981c1d29d06094f0375bf359c611"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab1b48af1f465a9282bc6e0709ccef36c"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#ab1b48af1f465a9282bc6e0709ccef36c">floor</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:ab1b48af1f465a9282bc6e0709ccef36c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a757f20c97f47b0f6f720df6686d97cf9"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a757f20c97f47b0f6f720df6686d97cf9">trunc</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:a757f20c97f47b0f6f720df6686d97cf9"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9fdd2c357d6e02a795232469b71870a6"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a9fdd2c357d6e02a795232469b71870a6">fix</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:a9fdd2c357d6e02a795232469b71870a6"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af59dc76acf7ba30af0ad766ea088113e"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#af59dc76acf7ba30af0ad766ea088113e">square</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:af59dc76acf7ba30af0ad766ea088113e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af4b5f03a9d0fa1011cd5b315cd9d8bb4"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#af4b5f03a9d0fa1011cd5b315cd9d8bb4">sqrt</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:af4b5f03a9d0fa1011cd5b315cd9d8bb4"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac6ffc5b821537fb9b7ab687cef75519c"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#ac6ffc5b821537fb9b7ab687cef75519c">rsqrt</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:ac6ffc5b821537fb9b7ab687cef75519c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a34848991e9ca10bcc8e952eafdf68c5a"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a34848991e9ca10bcc8e952eafdf68c5a">cbrt</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:a34848991e9ca10bcc8e952eafdf68c5a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a758557e50929ad4a53c1d05f8e7b1afa"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a758557e50929ad4a53c1d05f8e7b1afa">rcbrt</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:a758557e50929ad4a53c1d05f8e7b1afa"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7180e751ec056919b26c7235354a3452"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a7180e751ec056919b26c7235354a3452">exp</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:a7180e751ec056919b26c7235354a3452"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a0d787f18713d6f542ecda83ed6eb4a79"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a0d787f18713d6f542ecda83ed6eb4a79">log</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:a0d787f18713d6f542ecda83ed6eb4a79"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5a5514cf2f1b37b5a7c1072bff83bf96"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a5a5514cf2f1b37b5a7c1072bff83bf96">log10</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:a5a5514cf2f1b37b5a7c1072bff83bf96"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae103fdff44ce1c9654fac5f5c0fc09a3"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#ae103fdff44ce1c9654fac5f5c0fc09a3">log2</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:ae103fdff44ce1c9654fac5f5c0fc09a3"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a8184ba619a38ccf1d143c06b606e80a2"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a8184ba619a38ccf1d143c06b606e80a2">log1p</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:a8184ba619a38ccf1d143c06b606e80a2"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4475973b83abcaef7a8147fd1d7354d9"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a4475973b83abcaef7a8147fd1d7354d9">expm1</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:a4475973b83abcaef7a8147fd1d7354d9"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a06ca3719f4aabea2454d530af6c9bc14"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a06ca3719f4aabea2454d530af6c9bc14">gamma</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:a06ca3719f4aabea2454d530af6c9bc14"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac46fe72a34cb678aed506bb9eb51d9db"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#ac46fe72a34cb678aed506bb9eb51d9db">gammaln</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:ac46fe72a34cb678aed506bb9eb51d9db"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae986d6433f47471ec06f7c2d45495639"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#ae986d6433f47471ec06f7c2d45495639">logical_not</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:ae986d6433f47471ec06f7c2d45495639"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac84c546676d48eae71fe9997e232a148"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#ac84c546676d48eae71fe9997e232a148">sum</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, dmlc::optional&lt; <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> &gt; axis=dmlc::optional&lt; <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> &gt;(), bool keepdims=false, bool exclude=false)</td></tr>
<tr class="separator:ac84c546676d48eae71fe9997e232a148"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:afd2d122473461f1f64f29b478a6d2569"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#afd2d122473461f1f64f29b478a6d2569">mean</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, dmlc::optional&lt; <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> &gt; axis=dmlc::optional&lt; <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> &gt;(), bool keepdims=false, bool exclude=false)</td></tr>
<tr class="separator:afd2d122473461f1f64f29b478a6d2569"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a561746f1a9bf11e5e3c488248cd73973"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a561746f1a9bf11e5e3c488248cd73973">prod</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, dmlc::optional&lt; <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> &gt; axis=dmlc::optional&lt; <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> &gt;(), bool keepdims=false, bool exclude=false)</td></tr>
<tr class="separator:a561746f1a9bf11e5e3c488248cd73973"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5b86040bbbd97c0e325c50fb8bb6bfe1"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a5b86040bbbd97c0e325c50fb8bb6bfe1">nansum</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, dmlc::optional&lt; <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> &gt; axis=dmlc::optional&lt; <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> &gt;(), bool keepdims=false, bool exclude=false)</td></tr>
<tr class="separator:a5b86040bbbd97c0e325c50fb8bb6bfe1"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa9cc44c642e6b8cbb5c175d4766c01f5"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#aa9cc44c642e6b8cbb5c175d4766c01f5">nanprod</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, dmlc::optional&lt; <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> &gt; axis=dmlc::optional&lt; <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> &gt;(), bool keepdims=false, bool exclude=false)</td></tr>
<tr class="separator:aa9cc44c642e6b8cbb5c175d4766c01f5"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1d16c7416b5924dd35a23ade7d465b52"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a1d16c7416b5924dd35a23ade7d465b52">max</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, dmlc::optional&lt; <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> &gt; axis=dmlc::optional&lt; <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> &gt;(), bool keepdims=false, bool exclude=false)</td></tr>
<tr class="separator:a1d16c7416b5924dd35a23ade7d465b52"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a92583837ea8e7e5d54564655703d48a4"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a92583837ea8e7e5d54564655703d48a4">min</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, dmlc::optional&lt; <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> &gt; axis=dmlc::optional&lt; <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> &gt;(), bool keepdims=false, bool exclude=false)</td></tr>
<tr class="separator:a92583837ea8e7e5d54564655703d48a4"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a8077f0726ac5436b8abcb8621cc7171c"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a8077f0726ac5436b8abcb8621cc7171c">broadcast_axis</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> axis=<a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>(), <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> size=<a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>())</td></tr>
<tr class="separator:a8077f0726ac5436b8abcb8621cc7171c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7443d6c979ea61d91b01d2e41d555151"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a7443d6c979ea61d91b01d2e41d555151">broadcast_to</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> shape=<a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>())</td></tr>
<tr class="separator:a7443d6c979ea61d91b01d2e41d555151"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a0df09f5077c94cfce1695ec778bdcf79"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a0df09f5077c94cfce1695ec778bdcf79">broadcast_like</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> lhs, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> rhs)</td></tr>
<tr class="separator:a0df09f5077c94cfce1695ec778bdcf79"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a114145f016a9c2d5aa9be37a3c67fe1e"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a114145f016a9c2d5aa9be37a3c67fe1e">norm</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, int ord=2, dmlc::optional&lt; <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> &gt; axis=dmlc::optional&lt; <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> &gt;(), bool keepdims=false)</td></tr>
<tr class="separator:a114145f016a9c2d5aa9be37a3c67fe1e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2cb1728a95b30486ece5317bdd12dbe0"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a2cb1728a95b30486ece5317bdd12dbe0">topk</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, dmlc::optional&lt; int &gt; axis=dmlc::optional&lt; int &gt;(-1), int k=1, <a class="el" href="namespacemxnet_1_1cpp.html#a3d86bd343a0a3b4d7f1205cadaf24855">TopkRetTyp</a> ret_typ=<a class="el" href="namespacemxnet_1_1cpp.html#a3d86bd343a0a3b4d7f1205cadaf24855ac514f90edc83d38e3527476bbfb8e5e8">TopkRetTyp::kIndices</a>, bool is_ascend=false, <a class="el" href="namespacemxnet_1_1cpp.html#a992f67b993b07623d888ddcf01f9ddc3">TopkDtype</a> dtype=<a class="el" href="namespacemxnet_1_1cpp.html#a8e907a5fbbe4ec21628e500b34a5f35da9a78d6a569d086b524c3caf8c2522f96">TopkDtype::kFloat32</a>)</td></tr>
<tr class="separator:a2cb1728a95b30486ece5317bdd12dbe0"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aeb4f996f23cdac3f5a3d2bf2eb507fb8"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#aeb4f996f23cdac3f5a3d2bf2eb507fb8">sort</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, dmlc::optional&lt; int &gt; axis=dmlc::optional&lt; int &gt;(-1), bool is_ascend=true)</td></tr>
<tr class="separator:aeb4f996f23cdac3f5a3d2bf2eb507fb8"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4c4f3ce514cc11731819fcae1e40d575"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a4c4f3ce514cc11731819fcae1e40d575">argsort</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, dmlc::optional&lt; int &gt; axis=dmlc::optional&lt; int &gt;(-1), bool is_ascend=true, <a class="el" href="namespacemxnet_1_1cpp.html#ae9d179e796188c53f2d2a36dfde2bd7a">ArgsortDtype</a> dtype=<a class="el" href="namespacemxnet_1_1cpp.html#a8e907a5fbbe4ec21628e500b34a5f35da9a78d6a569d086b524c3caf8c2522f96">ArgsortDtype::kFloat32</a>)</td></tr>
<tr class="separator:a4c4f3ce514cc11731819fcae1e40d575"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a11744b6b7d915633107650990dd00148"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a11744b6b7d915633107650990dd00148">elemwise_add</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> lhs, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> rhs)</td></tr>
<tr class="separator:a11744b6b7d915633107650990dd00148"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a348c1ba14a3a9c8adfbac8570c1c8cbf"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a348c1ba14a3a9c8adfbac8570c1c8cbf">elemwise_sub</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> lhs, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> rhs)</td></tr>
<tr class="separator:a348c1ba14a3a9c8adfbac8570c1c8cbf"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a0076b96722559b32d5812aad03c5498a"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a0076b96722559b32d5812aad03c5498a">elemwise_mul</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> lhs, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> rhs)</td></tr>
<tr class="separator:a0076b96722559b32d5812aad03c5498a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1d09f5f44e0dc4d06a98760325a7209d"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a1d09f5f44e0dc4d06a98760325a7209d">elemwise_div</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> lhs, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> rhs)</td></tr>
<tr class="separator:a1d09f5f44e0dc4d06a98760325a7209d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9cc796ff537ca3c3b5a06f7b78df5c5b"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a9cc796ff537ca3c3b5a06f7b78df5c5b">Embedding</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> weight, int input_dim, int output_dim, <a class="el" href="namespacemxnet_1_1cpp.html#a3c80705d63347982667fc541ad5bf845">EmbeddingDtype</a> dtype=<a class="el" href="namespacemxnet_1_1cpp.html#a8e907a5fbbe4ec21628e500b34a5f35da9a78d6a569d086b524c3caf8c2522f96">EmbeddingDtype::kFloat32</a>, bool sparse_grad=false)</td></tr>
<tr class="separator:a9cc796ff537ca3c3b5a06f7b78df5c5b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4e3b22b06d6a4942606eabcb732c0385"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a4e3b22b06d6a4942606eabcb732c0385">take</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> a, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> indices, int axis=0, <a class="el" href="namespacemxnet_1_1cpp.html#ab8b82422d329aa4497e6891590633325">TakeMode</a> mode=<a class="el" href="namespacemxnet_1_1cpp.html#a30fd3a240ebc436ddb671d0c33d5bdc3ae2867cadc2a39b014e89d241b72f3a75">TakeMode::kClip</a>)</td></tr>
<tr class="separator:a4e3b22b06d6a4942606eabcb732c0385"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a69f187e1e2a56b1e753b32faefd8ab4d"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a69f187e1e2a56b1e753b32faefd8ab4d">batch_take</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> a, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> indices)</td></tr>
<tr class="separator:a69f187e1e2a56b1e753b32faefd8ab4d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a35c04a9ebe97b9bf13a1f2928b464c6e"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a35c04a9ebe97b9bf13a1f2928b464c6e">one_hot</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> indices, int depth, double on_value=1, double off_value=0, <a class="el" href="namespacemxnet_1_1cpp.html#a38cfaf4948f45cc4e6e46fbef0f6b8c2">One_hotDtype</a> dtype=<a class="el" href="namespacemxnet_1_1cpp.html#a8e907a5fbbe4ec21628e500b34a5f35da9a78d6a569d086b524c3caf8c2522f96">One_hotDtype::kFloat32</a>)</td></tr>
<tr class="separator:a35c04a9ebe97b9bf13a1f2928b464c6e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:afcd3b39a77f6f9d8478b9341001fd271"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#afcd3b39a77f6f9d8478b9341001fd271">gather_nd</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> indices)</td></tr>
<tr class="separator:afcd3b39a77f6f9d8478b9341001fd271"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab9ec3a53eddee3f24f4608c1f0123ae5"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#ab9ec3a53eddee3f24f4608c1f0123ae5">scatter_nd</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> indices, <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> shape)</td></tr>
<tr class="separator:ab9ec3a53eddee3f24f4608c1f0123ae5"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aaf8dd7668f17fe459a9d9edab573ed90"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#aaf8dd7668f17fe459a9d9edab573ed90">broadcast_equal</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> lhs, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> rhs)</td></tr>
<tr class="separator:aaf8dd7668f17fe459a9d9edab573ed90"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6dc13b57ff1b662e87be40840bc33e37"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a6dc13b57ff1b662e87be40840bc33e37">broadcast_not_equal</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> lhs, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> rhs)</td></tr>
<tr class="separator:a6dc13b57ff1b662e87be40840bc33e37"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad57f372bc112aedf9f4b3e3d04f6606a"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#ad57f372bc112aedf9f4b3e3d04f6606a">broadcast_greater</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> lhs, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> rhs)</td></tr>
<tr class="separator:ad57f372bc112aedf9f4b3e3d04f6606a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a083c0e37f65cc2b54adba5c75d4db7f2"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a083c0e37f65cc2b54adba5c75d4db7f2">broadcast_greater_equal</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> lhs, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> rhs)</td></tr>
<tr class="separator:a083c0e37f65cc2b54adba5c75d4db7f2"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a39d4af014a63e11085a8890a75abbb53"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a39d4af014a63e11085a8890a75abbb53">broadcast_lesser</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> lhs, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> rhs)</td></tr>
<tr class="separator:a39d4af014a63e11085a8890a75abbb53"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad14ffebee29ee1452d791923a509b528"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#ad14ffebee29ee1452d791923a509b528">broadcast_lesser_equal</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> lhs, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> rhs)</td></tr>
<tr class="separator:ad14ffebee29ee1452d791923a509b528"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a48ae9c6b14dce45db7694174c67b0739"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a48ae9c6b14dce45db7694174c67b0739">broadcast_logical_and</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> lhs, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> rhs)</td></tr>
<tr class="separator:a48ae9c6b14dce45db7694174c67b0739"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad735a6ed1f2da599e2a9f6884bcad272"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#ad735a6ed1f2da599e2a9f6884bcad272">broadcast_logical_or</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> lhs, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> rhs)</td></tr>
<tr class="separator:ad735a6ed1f2da599e2a9f6884bcad272"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af2fba0518de7e593837ab5a2f73fdc2b"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#af2fba0518de7e593837ab5a2f73fdc2b">broadcast_logical_xor</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> lhs, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> rhs)</td></tr>
<tr class="separator:af2fba0518de7e593837ab5a2f73fdc2b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a33cbdc4ccd7233cd4b7762b410ac04e8"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a33cbdc4ccd7233cd4b7762b410ac04e8">diag</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, dmlc::optional&lt; int &gt; k=dmlc::optional&lt; int &gt;(0))</td></tr>
<tr class="separator:a33cbdc4ccd7233cd4b7762b410ac04e8"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2345fcd1e2232a7b4f3b21416f71b151"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a2345fcd1e2232a7b4f3b21416f71b151">where</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> condition, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> x, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> y)</td></tr>
<tr class="separator:a2345fcd1e2232a7b4f3b21416f71b151"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a29ce9a8a70e7853377a65aabc41483fb"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a29ce9a8a70e7853377a65aabc41483fb">smooth_l1</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> scalar)</td></tr>
<tr class="separator:a29ce9a8a70e7853377a65aabc41483fb"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a11465bdfd897d56e7f3452e442393f92"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a11465bdfd897d56e7f3452e442393f92">cast_storage</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="namespacemxnet_1_1cpp.html#aac92e2f3642173e36bb79eb4854728ff">Cast_storageStype</a> stype)</td></tr>
<tr class="separator:a11465bdfd897d56e7f3452e442393f92"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:abfdb853df16f749a6cdf033f45c7b7fb"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#abfdb853df16f749a6cdf033f45c7b7fb">sin</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:abfdb853df16f749a6cdf033f45c7b7fb"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af6bfbb4921ebbb4ad15349ddffa1142a"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#af6bfbb4921ebbb4ad15349ddffa1142a">cos</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:af6bfbb4921ebbb4ad15349ddffa1142a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a058cbde68708560604f8d8ab299a41fb"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a058cbde68708560604f8d8ab299a41fb">tan</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:a058cbde68708560604f8d8ab299a41fb"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab5e1c9afb36308e15becec2d3da1eb14"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#ab5e1c9afb36308e15becec2d3da1eb14">arcsin</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:ab5e1c9afb36308e15becec2d3da1eb14"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac929f416184542490856da5dceb576e0"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#ac929f416184542490856da5dceb576e0">arccos</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:ac929f416184542490856da5dceb576e0"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af6acbdebc6651f65467047dba8c513f8"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#af6acbdebc6651f65467047dba8c513f8">arctan</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:af6acbdebc6651f65467047dba8c513f8"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a459d2873fa5ad23b9c65de57cf8f405c"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a459d2873fa5ad23b9c65de57cf8f405c">degrees</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:a459d2873fa5ad23b9c65de57cf8f405c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2d8acb8fde9c8865b0aa5b869ed2e16b"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a2d8acb8fde9c8865b0aa5b869ed2e16b">radians</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:a2d8acb8fde9c8865b0aa5b869ed2e16b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:abe11f1abc4a9939760060286bf6d0764"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#abe11f1abc4a9939760060286bf6d0764">sinh</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:abe11f1abc4a9939760060286bf6d0764"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad767ecc1945ee3167f06956973bd44e2"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#ad767ecc1945ee3167f06956973bd44e2">cosh</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:ad767ecc1945ee3167f06956973bd44e2"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6fc758629ea0443dd943f0c5f03e3fb3"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a6fc758629ea0443dd943f0c5f03e3fb3">tanh</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:a6fc758629ea0443dd943f0c5f03e3fb3"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a3adaa6bd5111a3861d0d95d53695a1f7"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a3adaa6bd5111a3861d0d95d53695a1f7">arcsinh</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:a3adaa6bd5111a3861d0d95d53695a1f7"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af6e15db07037f9720aa48fd14a936435"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#af6e15db07037f9720aa48fd14a936435">arccosh</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:af6e15db07037f9720aa48fd14a936435"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4adf7ce32bade72c150b55f04171ea13"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a4adf7ce32bade72c150b55f04171ea13">arctanh</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data)</td></tr>
<tr class="separator:a4adf7ce32bade72c150b55f04171ea13"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4cbbb4de915456440868d7666b86ce62"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a4cbbb4de915456440868d7666b86ce62">Pooling</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> kernel=<a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>(), <a class="el" href="namespacemxnet_1_1cpp.html#a44ef744b314acdba218a7405f56e00be">PoolingPoolType</a> pool_type=<a class="el" href="namespacemxnet_1_1cpp.html#a44ef744b314acdba218a7405f56e00beaa0b1ac8aae6b1cfbbe89085c642b3b4b">PoolingPoolType::kMax</a>, bool global_pool=false, bool cudnn_off=false, <a class="el" href="namespacemxnet_1_1cpp.html#abaf9ea614ede3210454943dd3130c5cd">PoolingPoolingConvention</a> pooling_convention=<a class="el" href="namespacemxnet_1_1cpp.html#abaf9ea614ede3210454943dd3130c5cda4d3576c37e6f03700bad4345238fffa0">PoolingPoolingConvention::kValid</a>, <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> stride=<a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>(), <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> pad=<a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>(), dmlc::optional&lt; int &gt; p_value=dmlc::optional&lt; int &gt;(), dmlc::optional&lt; bool &gt; count_include_pad=dmlc::optional&lt; bool &gt;())</td></tr>
<tr class="separator:a4cbbb4de915456440868d7666b86ce62"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a28f560dc313748091ad850d7a8a7f915"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a28f560dc313748091ad850d7a8a7f915">softmax</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, int axis=-1, dmlc::optional&lt; double &gt; temperature=dmlc::optional&lt; double &gt;())</td></tr>
<tr class="separator:a28f560dc313748091ad850d7a8a7f915"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac2e7d47cefba9918b648d84313aecce4"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#ac2e7d47cefba9918b648d84313aecce4">log_softmax</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, int axis=-1, dmlc::optional&lt; double &gt; temperature=dmlc::optional&lt; double &gt;())</td></tr>
<tr class="separator:ac2e7d47cefba9918b648d84313aecce4"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7cbaa38ed15a8000f8339c26764c7c2a"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a7cbaa38ed15a8000f8339c26764c7c2a">Deconvolution</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> weight, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> bias, <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> kernel, uint32_t num_filter, <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> stride=<a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>(), <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> dilate=<a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>(), <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> pad=<a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>(), <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> adj=<a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>(), <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> target_shape=<a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>(), uint32_t num_group=1, uint64_t workspace=512, bool no_bias=true, <a class="el" href="namespacemxnet_1_1cpp.html#ae25c98b47a52531322d1622509c0e84d">DeconvolutionCudnnTune</a> cudnn_tune=<a class="el" href="namespacemxnet_1_1cpp.html#aa5dbdd69827034fc43c16cf350db7e1ea35c3ace1970663a16e5c65baa5941b13">DeconvolutionCudnnTune::kNone</a>, bool cudnn_off=false, <a class="el" href="namespacemxnet_1_1cpp.html#a63a3b219f6bced4a550ed4bc5207e997">DeconvolutionLayout</a> layout=<a class="el" href="namespacemxnet_1_1cpp.html#aa5dbdd69827034fc43c16cf350db7e1ea35c3ace1970663a16e5c65baa5941b13">DeconvolutionLayout::kNone</a>)</td></tr>
<tr class="separator:a7cbaa38ed15a8000f8339c26764c7c2a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a8f7f8ab7d8134216349d7e4275baf4d7"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a8f7f8ab7d8134216349d7e4275baf4d7">Activation</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="namespacemxnet_1_1cpp.html#a919a622dc07b83d4431e8ff775455962">ActivationActType</a> act_type)</td></tr>
<tr class="separator:a8f7f8ab7d8134216349d7e4275baf4d7"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab30261f412bbc66c92742f5cb3b4843b"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#ab30261f412bbc66c92742f5cb3b4843b">BatchNorm</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> <a class="el" href="namespacemxnet_1_1cpp.html#a0a9aa2fcd720ec0c0540a6a8ad47a8c7">gamma</a>, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> beta, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> moving_mean, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> moving_var, double eps=0.001, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> momentum=0.9, bool fix_gamma=true, bool use_global_stats=false, bool output_mean_var=false, int axis=1, bool cudnn_off=false)</td></tr>
<tr class="separator:ab30261f412bbc66c92742f5cb3b4843b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6fee92325f3980187796296454894020"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a6fee92325f3980187796296454894020">Convolution</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> weight, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> bias, <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> kernel, uint32_t num_filter, <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> stride=<a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>(), <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> dilate=<a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>(), <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> pad=<a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>(), uint32_t num_group=1, uint64_t workspace=1024, bool no_bias=false, <a class="el" href="namespacemxnet_1_1cpp.html#a8755a4574a3839da2ad93af004fb1ff5">ConvolutionCudnnTune</a> cudnn_tune=<a class="el" href="namespacemxnet_1_1cpp.html#aa5dbdd69827034fc43c16cf350db7e1ea35c3ace1970663a16e5c65baa5941b13">ConvolutionCudnnTune::kNone</a>, bool cudnn_off=false, <a class="el" href="namespacemxnet_1_1cpp.html#a7b419f5293a7706c76becfe735a9946b">ConvolutionLayout</a> layout=<a class="el" href="namespacemxnet_1_1cpp.html#aa5dbdd69827034fc43c16cf350db7e1ea35c3ace1970663a16e5c65baa5941b13">ConvolutionLayout::kNone</a>)</td></tr>
<tr class="separator:a6fee92325f3980187796296454894020"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a34b5385f8b52334cfedaa5a7f4ce68c9"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a34b5385f8b52334cfedaa5a7f4ce68c9">UpSampling</a> (const std::vector&lt; <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> &gt; &amp;data, uint32_t scale, <a class="el" href="namespacemxnet_1_1cpp.html#a9c9a4644f19e7ed3c729165de2e963ab">UpSamplingSampleType</a> sample_type, int num_args, uint32_t num_filter=0, <a class="el" href="namespacemxnet_1_1cpp.html#afce90445dba4ab6be903251cb0c960ef">UpSamplingMultiInputMode</a> multi_input_mode=<a class="el" href="namespacemxnet_1_1cpp.html#afce90445dba4ab6be903251cb0c960efa07f24210ce07b41cf8370dd8e9a3eb70">UpSamplingMultiInputMode::kConcat</a>, uint64_t workspace=512)</td></tr>
<tr class="separator:a34b5385f8b52334cfedaa5a7f4ce68c9"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a44eb74174eaae169df46a0594eeb1b08"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a44eb74174eaae169df46a0594eeb1b08">Concat</a> (const std::vector&lt; <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> &gt; &amp;data, int num_args, int dim=1)</td></tr>
<tr class="separator:a44eb74174eaae169df46a0594eeb1b08"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a093e0eb27a7bb61634444974e9400f67"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a093e0eb27a7bb61634444974e9400f67">LayerNorm</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> <a class="el" href="namespacemxnet_1_1cpp.html#a0a9aa2fcd720ec0c0540a6a8ad47a8c7">gamma</a>, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> beta, int axis=-1, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> eps=1e-05, bool output_mean_var=false)</td></tr>
<tr class="separator:a093e0eb27a7bb61634444974e9400f67"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:afa46e4eb9198e8a5d2ffdffa10d77f3d"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#afa46e4eb9198e8a5d2ffdffa10d77f3d">LRN</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, uint32_t nsize, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> alpha=0.0001, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> beta=0.75, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> knorm=2)</td></tr>
<tr class="separator:afa46e4eb9198e8a5d2ffdffa10d77f3d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:abb9455afcffeccf46087775d334ffad7"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#abb9455afcffeccf46087775d334ffad7">Dropout</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> p=0.5, <a class="el" href="namespacemxnet_1_1cpp.html#a3cc3a1d19b3bf567326c77e263038a0e">DropoutMode</a> mode=<a class="el" href="namespacemxnet_1_1cpp.html#a3cc3a1d19b3bf567326c77e263038a0eabae2199a6d43c4c6ccd0e74727c02a64">DropoutMode::kTraining</a>, <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> axes=<a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>())</td></tr>
<tr class="separator:abb9455afcffeccf46087775d334ffad7"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a259eac5a8f0f3dbe37d2708e1c81abf4"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a259eac5a8f0f3dbe37d2708e1c81abf4">SoftmaxActivation</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="namespacemxnet_1_1cpp.html#a08bbd5633680ffa58dae3cab685e2ebf">SoftmaxActivationMode</a> mode=<a class="el" href="namespacemxnet_1_1cpp.html#a08bbd5633680ffa58dae3cab685e2ebfa63f56d9e95d7b447075aef94444c4c96">SoftmaxActivationMode::kInstance</a>)</td></tr>
<tr class="separator:a259eac5a8f0f3dbe37d2708e1c81abf4"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aed810c3bb5b7d35b4870bb12beb9620b"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#aed810c3bb5b7d35b4870bb12beb9620b">FullyConnected</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> weight, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> bias, int num_hidden, bool no_bias=false, bool flatten=true)</td></tr>
<tr class="separator:aed810c3bb5b7d35b4870bb12beb9620b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7f6a1f50318d64d45a5556c969fdfe1d"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a7f6a1f50318d64d45a5556c969fdfe1d">Pad</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="namespacemxnet_1_1cpp.html#ab261a86c931574327d82188c75f93d1a">PadMode</a> mode, <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> pad_width, double constant_value=0)</td></tr>
<tr class="separator:a7f6a1f50318d64d45a5556c969fdfe1d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:acbf6201925b98b3b055eac9fa6cdc0c6"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#acbf6201925b98b3b055eac9fa6cdc0c6">LeakyReLU</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> <a class="el" href="namespacemxnet_1_1cpp.html#a0a9aa2fcd720ec0c0540a6a8ad47a8c7">gamma</a>, <a class="el" href="namespacemxnet_1_1cpp.html#aad64d459f3652d3ec3cf37c460aa8ee0">LeakyReLUActType</a> act_type=<a class="el" href="namespacemxnet_1_1cpp.html#aad64d459f3652d3ec3cf37c460aa8ee0a3620dd046c3b58ec17570ae64aa325eb">LeakyReLUActType::kLeaky</a>, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> slope=0.25, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> lower_bound=0.125, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> upper_bound=0.334)</td></tr>
<tr class="separator:acbf6201925b98b3b055eac9fa6cdc0c6"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:abb2365de281fa565de27fc0e8ae6211e"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#abb2365de281fa565de27fc0e8ae6211e">SwapAxis</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, uint32_t dim1=0, uint32_t dim2=0)</td></tr>
<tr class="separator:abb2365de281fa565de27fc0e8ae6211e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa1cb8af78b859b2656be285343fb7ac4"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#aa1cb8af78b859b2656be285343fb7ac4">BatchNorm_v1</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> <a class="el" href="namespacemxnet_1_1cpp.html#a0a9aa2fcd720ec0c0540a6a8ad47a8c7">gamma</a>, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> beta, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> eps=0.001, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> momentum=0.9, bool fix_gamma=true, bool use_global_stats=false, bool output_mean_var=false)</td></tr>
<tr class="separator:aa1cb8af78b859b2656be285343fb7ac4"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:abf57185c13c3163e7537759fc519ea33"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#abf57185c13c3163e7537759fc519ea33">softmax_cross_entropy</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> label)</td></tr>
<tr class="separator:abf57185c13c3163e7537759fc519ea33"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:afcbbe84c18e89e4c03a994f2438ea821"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#afcbbe84c18e89e4c03a994f2438ea821">LinearRegressionOutput</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> label, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> grad_scale=1)</td></tr>
<tr class="separator:afcbbe84c18e89e4c03a994f2438ea821"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7de42fe56f402ed2ed64c0324310e2e2"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a7de42fe56f402ed2ed64c0324310e2e2">MAERegressionOutput</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> label, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> grad_scale=1)</td></tr>
<tr class="separator:a7de42fe56f402ed2ed64c0324310e2e2"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a3d6693f2e767412417f87ccf82582de0"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a3d6693f2e767412417f87ccf82582de0">LogisticRegressionOutput</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> label, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> grad_scale=1)</td></tr>
<tr class="separator:a3d6693f2e767412417f87ccf82582de0"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a102418bba419088e913ab8cfa6e24d69"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a102418bba419088e913ab8cfa6e24d69">IdentityAttachKLSparseReg</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> sparseness_target=0.1, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> penalty=0.001, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> momentum=0.9)</td></tr>
<tr class="separator:a102418bba419088e913ab8cfa6e24d69"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab37ca50a86731d14d5f337f4ec7a22b3"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#ab37ca50a86731d14d5f337f4ec7a22b3">signsgd_update</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> weight, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> grad, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> lr, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> wd=0, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> rescale_grad=1, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> clip_gradient=-1)</td></tr>
<tr class="separator:ab37ca50a86731d14d5f337f4ec7a22b3"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2250806e349b6fab16dbb1e2892fe907"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a2250806e349b6fab16dbb1e2892fe907">signum_update</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> weight, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> grad, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mom, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> lr, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> momentum=0, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> wd=0, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> rescale_grad=1, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> clip_gradient=-1, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> wd_lh=0)</td></tr>
<tr class="separator:a2250806e349b6fab16dbb1e2892fe907"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:afbcd2e7ea8aaa409748a99785ad7101e"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#afbcd2e7ea8aaa409748a99785ad7101e">sgd_update</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> weight, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> grad, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> lr, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> wd=0, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> rescale_grad=1, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> clip_gradient=-1, bool lazy_update=true)</td></tr>
<tr class="separator:afbcd2e7ea8aaa409748a99785ad7101e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab438e11e3f3ecfbc0a1a490bc6a96efa"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#ab438e11e3f3ecfbc0a1a490bc6a96efa">sgd_mom_update</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> weight, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> grad, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mom, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> lr, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> momentum=0, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> wd=0, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> rescale_grad=1, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> clip_gradient=-1, bool lazy_update=true)</td></tr>
<tr class="separator:ab438e11e3f3ecfbc0a1a490bc6a96efa"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9941ee833dfee8eeb7af773dec8243fe"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a9941ee833dfee8eeb7af773dec8243fe">mp_sgd_update</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> weight, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> grad, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> weight32, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> lr, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> wd=0, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> rescale_grad=1, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> clip_gradient=-1, bool lazy_update=true)</td></tr>
<tr class="separator:a9941ee833dfee8eeb7af773dec8243fe"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a53f827d8b1865bd5003138db6ee98218"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a53f827d8b1865bd5003138db6ee98218">mp_sgd_mom_update</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> weight, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> grad, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mom, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> weight32, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> lr, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> momentum=0, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> wd=0, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> rescale_grad=1, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> clip_gradient=-1, bool lazy_update=true)</td></tr>
<tr class="separator:a53f827d8b1865bd5003138db6ee98218"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac5cce010ff2b5aeddc0886cc02022628"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#ac5cce010ff2b5aeddc0886cc02022628">ftml_update</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> weight, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> grad, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> d, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> v, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> z, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> lr, int t, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> beta1=0.6, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> beta2=0.999, double epsilon=1e-08, mx_float wd=0, mx_float rescale_grad=1, mx_float clip_grad=-1)</td></tr>
<tr class="separator:ac5cce010ff2b5aeddc0886cc02022628"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a56c1bc1a4d31e9767d156cc5e3da3866"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a56c1bc1a4d31e9767d156cc5e3da3866">adam_update</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> weight, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> grad, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> <a class="el" href="namespacemxnet_1_1cpp.html#a54884055c968a6fcb737b772c82c5519">mean</a>, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> var, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> lr, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> beta1=0.9, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> beta2=0.999, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> epsilon=1e-08, mx_float wd=0, mx_float rescale_grad=1, mx_float clip_gradient=-1, bool lazy_update=true)</td></tr>
<tr class="separator:a56c1bc1a4d31e9767d156cc5e3da3866"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7f932eae14c6a0d1f2f76ee06990a0d0"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a7f932eae14c6a0d1f2f76ee06990a0d0">rmsprop_update</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> weight, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> grad, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> n, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> lr, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> gamma1=0.95, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> epsilon=1e-08, mx_float wd=0, mx_float rescale_grad=1, mx_float clip_gradient=-1, mx_float clip_weights=-1)</td></tr>
<tr class="separator:a7f932eae14c6a0d1f2f76ee06990a0d0"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a3c19fd898bed06f082d7086826b01c7c"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a3c19fd898bed06f082d7086826b01c7c">rmspropalex_update</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> weight, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> grad, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> n, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> g, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> delta, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> lr, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> gamma1=0.95, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> gamma2=0.9, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> epsilon=1e-08, mx_float wd=0, mx_float rescale_grad=1, mx_float clip_gradient=-1, mx_float clip_weights=-1)</td></tr>
<tr class="separator:a3c19fd898bed06f082d7086826b01c7c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a037d389f35c483f5fc83436986884547"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a037d389f35c483f5fc83436986884547">ftrl_update</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> weight, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> grad, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> z, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> n, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> lr, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> lamda1=0.01, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> beta=1, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> wd=0, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> rescale_grad=1, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> clip_gradient=-1)</td></tr>
<tr class="separator:a037d389f35c483f5fc83436986884547"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1649d07b09ce8eece2e28d4de0586691"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a1649d07b09ce8eece2e28d4de0586691">SliceChannel</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, int num_outputs, int axis=1, bool squeeze_axis=false)</td></tr>
<tr class="separator:a1649d07b09ce8eece2e28d4de0586691"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae3362668d61945e47ee8b9f46e529ae6"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#ae3362668d61945e47ee8b9f46e529ae6">InstanceNorm</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> <a class="el" href="namespacemxnet_1_1cpp.html#a0a9aa2fcd720ec0c0540a6a8ad47a8c7">gamma</a>, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> beta, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> eps=0.001)</td></tr>
<tr class="separator:ae3362668d61945e47ee8b9f46e529ae6"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad6e1c5da8364f84e285d6139bbbc721f"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#ad6e1c5da8364f84e285d6139bbbc721f">GridGenerator</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="namespacemxnet_1_1cpp.html#a98745f0114674ef8fa60b2a35a877a2c">GridGeneratorTransformType</a> transform_type, <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> target_shape=<a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>(0, 0))</td></tr>
<tr class="separator:ad6e1c5da8364f84e285d6139bbbc721f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:acf4b40f6c651421d5af75362083290c5"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#acf4b40f6c651421d5af75362083290c5">Pooling_v1</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> kernel=<a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>(), <a class="el" href="namespacemxnet_1_1cpp.html#a7dc4e3b741dfffc9295e1f8fbcb51c2e">Pooling_v1PoolType</a> pool_type=<a class="el" href="namespacemxnet_1_1cpp.html#a44ef744b314acdba218a7405f56e00beaa0b1ac8aae6b1cfbbe89085c642b3b4b">Pooling_v1PoolType::kMax</a>, bool global_pool=false, <a class="el" href="namespacemxnet_1_1cpp.html#ac8e6f64dc9bca9d9388d34d5153cb094">Pooling_v1PoolingConvention</a> pooling_convention=<a class="el" href="namespacemxnet_1_1cpp.html#abaf9ea614ede3210454943dd3130c5cda4d3576c37e6f03700bad4345238fffa0">Pooling_v1PoolingConvention::kValid</a>, <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> stride=<a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>(), <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> pad=<a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>())</td></tr>
<tr class="separator:acf4b40f6c651421d5af75362083290c5"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a3406b9c4299950f15689fd7e0b9f475e"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a3406b9c4299950f15689fd7e0b9f475e">RNN</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> parameters, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> state, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> state_cell, uint32_t state_size, uint32_t num_layers, <a class="el" href="namespacemxnet_1_1cpp.html#ae39119fed3c83726a0a2ea89b506661d">RNNMode</a> mode, bool bidirectional=false, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> p=0, bool state_outputs=false, dmlc::optional&lt; int &gt; projection_size=dmlc::optional&lt; int &gt;(), dmlc::optional&lt; double &gt; lstm_state_clip_min=dmlc::optional&lt; double &gt;(), dmlc::optional&lt; double &gt; lstm_state_clip_max=dmlc::optional&lt; double &gt;(), bool lstm_state_clip_nan=false)</td></tr>
<tr class="separator:a3406b9c4299950f15689fd7e0b9f475e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a872ee945307a72ef57b9946958b26e9b"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a872ee945307a72ef57b9946958b26e9b">Convolution_v1</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> weight, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> bias, <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> kernel, uint32_t num_filter, <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> stride=<a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>(), <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> dilate=<a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>(), <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> pad=<a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>(), uint32_t num_group=1, uint64_t workspace=1024, bool no_bias=false, <a class="el" href="namespacemxnet_1_1cpp.html#aa32f4a10a37f253f9d102cfc96a9eafc">Convolution_v1CudnnTune</a> cudnn_tune=<a class="el" href="namespacemxnet_1_1cpp.html#aa5dbdd69827034fc43c16cf350db7e1ea35c3ace1970663a16e5c65baa5941b13">Convolution_v1CudnnTune::kNone</a>, bool cudnn_off=false, <a class="el" href="namespacemxnet_1_1cpp.html#a97217f563c768120cd8db19573938635">Convolution_v1Layout</a> layout=<a class="el" href="namespacemxnet_1_1cpp.html#aa5dbdd69827034fc43c16cf350db7e1ea35c3ace1970663a16e5c65baa5941b13">Convolution_v1Layout::kNone</a>)</td></tr>
<tr class="separator:a872ee945307a72ef57b9946958b26e9b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a15aac6f62d48528ff0e41eeac0912327"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a15aac6f62d48528ff0e41eeac0912327">Crop</a> (const std::vector&lt; <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> &gt; &amp;data, int num_args, <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> offset=<a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>(0, 0), <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> h_w=<a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>(0, 0), bool center_crop=false)</td></tr>
<tr class="separator:a15aac6f62d48528ff0e41eeac0912327"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a042d45fccd1db23d69fc5e05c49df21f"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a042d45fccd1db23d69fc5e05c49df21f">SequenceReverse</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> sequence_length, bool use_sequence_length=false, int axis=0)</td></tr>
<tr class="separator:a042d45fccd1db23d69fc5e05c49df21f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5e34e5f58fe70a5b2260ee11acda3b26"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a5e34e5f58fe70a5b2260ee11acda3b26">SpatialTransformer</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> loc, <a class="el" href="namespacemxnet_1_1cpp.html#a0ff49861ba295abeac5d545bfa16b0aa">SpatialTransformerTransformType</a> transform_type, <a class="el" href="namespacemxnet_1_1cpp.html#a20ce4a2b1581ec74fc957d816d1e19ce">SpatialTransformerSamplerType</a> sampler_type, <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> target_shape=<a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>(0, 0))</td></tr>
<tr class="separator:a5e34e5f58fe70a5b2260ee11acda3b26"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5ec4377c6f25f29b8321f21efec43bf8"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a5ec4377c6f25f29b8321f21efec43bf8">SoftmaxOutput</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> label, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> grad_scale=1, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> ignore_label=-1, bool multi_output=false, bool use_ignore=false, bool preserve_shape=false, <a class="el" href="namespacemxnet_1_1cpp.html#ae708904c6ad7046fcecfc6c6b7e0ac73">SoftmaxOutputNormalization</a> normalization=<a class="el" href="namespacemxnet_1_1cpp.html#ae708904c6ad7046fcecfc6c6b7e0ac73af2655c2dee87cb9b0646f678a630394b">SoftmaxOutputNormalization::kNull</a>, bool out_grad=false, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> smooth_alpha=0)</td></tr>
<tr class="separator:a5ec4377c6f25f29b8321f21efec43bf8"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aecb7320878e120e7164b6db540c184c4"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#aecb7320878e120e7164b6db540c184c4">Softmax</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> grad_scale=1, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> ignore_label=-1, bool multi_output=false, bool use_ignore=false, bool preserve_shape=false, <a class="el" href="namespacemxnet_1_1cpp.html#abac2e8c934c7bd4416728b351fcbae5b">SoftmaxNormalization</a> normalization=<a class="el" href="namespacemxnet_1_1cpp.html#ae708904c6ad7046fcecfc6c6b7e0ac73af2655c2dee87cb9b0646f678a630394b">SoftmaxNormalization::kNull</a>, bool out_grad=false, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> smooth_alpha=0)</td></tr>
<tr class="separator:aecb7320878e120e7164b6db540c184c4"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a697fcbff4756f58328820e697b4c2e6a"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a697fcbff4756f58328820e697b4c2e6a">BilinearSampler</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> grid)</td></tr>
<tr class="separator:a697fcbff4756f58328820e697b4c2e6a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac28bbe9ec60d45820a7404d409aa7f8f"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#ac28bbe9ec60d45820a7404d409aa7f8f">ROIPooling</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> rois, <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> pooled_size, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> spatial_scale)</td></tr>
<tr class="separator:ac28bbe9ec60d45820a7404d409aa7f8f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a35734beff2899c26ee62c9ce6c13b5ae"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a35734beff2899c26ee62c9ce6c13b5ae">SequenceLast</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> sequence_length, bool use_sequence_length=false, int axis=0)</td></tr>
<tr class="separator:a35734beff2899c26ee62c9ce6c13b5ae"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa4fa4bb8aef8f707869fdd41953ca2f7"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#aa4fa4bb8aef8f707869fdd41953ca2f7">L2Normalization</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> eps=1e-10, L2NormalizationMode mode=L2NormalizationMode::kInstance)</td></tr>
<tr class="separator:aa4fa4bb8aef8f707869fdd41953ca2f7"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a8139976df058af27379fe0eb1f8e24f4"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a8139976df058af27379fe0eb1f8e24f4">MakeLoss</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> grad_scale=1, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> valid_thresh=0, <a class="el" href="namespacemxnet_1_1cpp.html#a0f8c7551de879673caa593f74e8ebca6">MakeLossNormalization</a> normalization=<a class="el" href="namespacemxnet_1_1cpp.html#ae708904c6ad7046fcecfc6c6b7e0ac73af2655c2dee87cb9b0646f678a630394b">MakeLossNormalization::kNull</a>)</td></tr>
<tr class="separator:a8139976df058af27379fe0eb1f8e24f4"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6851ce98be905130b0807873e1c51f17"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a6851ce98be905130b0807873e1c51f17">SVMOutput</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> label, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> margin=1, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> regularization_coefficient=1, bool use_linear=false)</td></tr>
<tr class="separator:a6851ce98be905130b0807873e1c51f17"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad9c0c80b7c1aa1d5728d5cddf267a210"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#ad9c0c80b7c1aa1d5728d5cddf267a210">Correlation</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data1, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data2, uint32_t kernel_size=1, uint32_t max_displacement=1, uint32_t stride1=1, uint32_t stride2=1, uint32_t pad_size=0, bool is_multiply=true)</td></tr>
<tr class="separator:ad9c0c80b7c1aa1d5728d5cddf267a210"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4853a8cd35759c1b5d1e481366df9bee"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a4853a8cd35759c1b5d1e481366df9bee">SequenceMask</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> sequence_length, bool use_sequence_length=false, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> value=0, int axis=0)</td></tr>
<tr class="separator:a4853a8cd35759c1b5d1e481366df9bee"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4fe1a7bf6c9b53bde75dc23cb36853e7"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a4fe1a7bf6c9b53bde75dc23cb36853e7">choose_element_0index</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> lhs, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> rhs)</td></tr>
<tr class="separator:a4fe1a7bf6c9b53bde75dc23cb36853e7"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2d831f1a544ca07c5355dac626926a91"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a2d831f1a544ca07c5355dac626926a91">fill_element_0index</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> lhs, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mhs, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> rhs)</td></tr>
<tr class="separator:a2d831f1a544ca07c5355dac626926a91"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:adf6edcf76da5f7bd268eb4dcbdc8538a"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#adf6edcf76da5f7bd268eb4dcbdc8538a">_Plus</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> lhs, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> rhs)</td></tr>
<tr class="separator:adf6edcf76da5f7bd268eb4dcbdc8538a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5cd0b9b4e929d55da482e0a616cb3ac0"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a5cd0b9b4e929d55da482e0a616cb3ac0">_Mul</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> lhs, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> rhs)</td></tr>
<tr class="separator:a5cd0b9b4e929d55da482e0a616cb3ac0"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a08662bacc9a9a3935b9cc0e0ac0af397"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a08662bacc9a9a3935b9cc0e0ac0af397">_Minus</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> lhs, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> rhs)</td></tr>
<tr class="separator:a08662bacc9a9a3935b9cc0e0ac0af397"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aafc94488768fddc81e4bf7a6513c3d53"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#aafc94488768fddc81e4bf7a6513c3d53">_Div</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> lhs, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> rhs)</td></tr>
<tr class="separator:aafc94488768fddc81e4bf7a6513c3d53"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac3e2151372e9a19057a062755254ff56"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#ac3e2151372e9a19057a062755254ff56">_Mod</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> lhs, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> rhs)</td></tr>
<tr class="separator:ac3e2151372e9a19057a062755254ff56"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a77c28ff73891debeb69a99b1b35d84b5"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a77c28ff73891debeb69a99b1b35d84b5">_Power</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> lhs, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> rhs)</td></tr>
<tr class="separator:a77c28ff73891debeb69a99b1b35d84b5"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a36df72e0b01ec278c4fd12568aecb5f9"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a36df72e0b01ec278c4fd12568aecb5f9">_Maximum</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> lhs, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> rhs)</td></tr>
<tr class="separator:a36df72e0b01ec278c4fd12568aecb5f9"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a65c4fa6348c6ffbe06a2e5b5f26a32e9"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a65c4fa6348c6ffbe06a2e5b5f26a32e9">_Minimum</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> lhs, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> rhs)</td></tr>
<tr class="separator:a65c4fa6348c6ffbe06a2e5b5f26a32e9"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6c5c547100513efb8c4a1de19152c715"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a6c5c547100513efb8c4a1de19152c715">_PlusScalar</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> lhs, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> scalar)</td></tr>
<tr class="separator:a6c5c547100513efb8c4a1de19152c715"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a02b18bf7c3f2beb4db696db1396ca801"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a02b18bf7c3f2beb4db696db1396ca801">_MinusScalar</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> lhs, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> scalar)</td></tr>
<tr class="separator:a02b18bf7c3f2beb4db696db1396ca801"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:adc14d741eec9cd6e56c83772fb91155e"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#adc14d741eec9cd6e56c83772fb91155e">_RMinusScalar</a> (<a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> scalar, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> rhs)</td></tr>
<tr class="separator:adc14d741eec9cd6e56c83772fb91155e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a413b21fdfe408a86fc66663806e34fb0"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a413b21fdfe408a86fc66663806e34fb0">_MulScalar</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> lhs, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> scalar)</td></tr>
<tr class="separator:a413b21fdfe408a86fc66663806e34fb0"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:abd35f4aea1d59d116f442a9a198f7f08"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#abd35f4aea1d59d116f442a9a198f7f08">_DivScalar</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> lhs, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> scalar)</td></tr>
<tr class="separator:abd35f4aea1d59d116f442a9a198f7f08"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4a2b073fef987ff1c4056f772a4ef525"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a4a2b073fef987ff1c4056f772a4ef525">_RDivScalar</a> (<a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> scalar, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> rhs)</td></tr>
<tr class="separator:a4a2b073fef987ff1c4056f772a4ef525"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a650147b3f97450afdbcd8f16c993843f"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a650147b3f97450afdbcd8f16c993843f">_ModScalar</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> lhs, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> scalar)</td></tr>
<tr class="separator:a650147b3f97450afdbcd8f16c993843f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a02670e4bae0b199a6de5fb66abecbb36"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a02670e4bae0b199a6de5fb66abecbb36">_RModScalar</a> (<a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> scalar, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> rhs)</td></tr>
<tr class="separator:a02670e4bae0b199a6de5fb66abecbb36"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab1c47b376e97268139a91113fa786a58"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#ab1c47b376e97268139a91113fa786a58">_PowerScalar</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> lhs, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> scalar)</td></tr>
<tr class="separator:ab1c47b376e97268139a91113fa786a58"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:abad2524b5c52c6f8dbe0bfa3c64200fa"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#abad2524b5c52c6f8dbe0bfa3c64200fa">_RPowerScalar</a> (<a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> scalar, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> rhs)</td></tr>
<tr class="separator:abad2524b5c52c6f8dbe0bfa3c64200fa"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:acfa6b946c2c1b6d67847a0d5ad33c7b9"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#acfa6b946c2c1b6d67847a0d5ad33c7b9">_MaximumScalar</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> lhs, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> scalar)</td></tr>
<tr class="separator:acfa6b946c2c1b6d67847a0d5ad33c7b9"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a39a1269e963b9ccd81b03ca2e7903b17"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a39a1269e963b9ccd81b03ca2e7903b17">_MinimumScalar</a> (<a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> lhs, <a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> scalar)</td></tr>
<tr class="separator:a39a1269e963b9ccd81b03ca2e7903b17"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a442bf3433dca1839065262e06fa7bf57"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a442bf3433dca1839065262e06fa7bf57">Crop</a> (const std::string &amp;symbol_name, int num_args, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> crop_like, <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> offset=<a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>(0, 0), <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> h_w=<a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>(0, 0), bool center_crop=false)</td></tr>
<tr class="separator:a442bf3433dca1839065262e06fa7bf57"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac524fa9c4a7b5d48c362108fee918c54"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#ac524fa9c4a7b5d48c362108fee918c54">Activation</a> (const std::string &amp;symbol_name, <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> data, const std::string &amp;act_type)</td></tr>
<tr class="memdesc:ac524fa9c4a7b5d48c362108fee918c54"><td class="mdescLeft"> </td><td class="mdescRight">Apply activation function to input. Softmax Activation is only available with CUDNN on GPUand will be computed at each location across channel if input is 4D.  <a href="#ac524fa9c4a7b5d48c362108fee918c54">More...</a><br/></td></tr>
<tr class="separator:ac524fa9c4a7b5d48c362108fee918c54"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a70dfe73858728880adc2f777c0a55d68"><td align="right" class="memItemLeft" valign="top">std::ostream &amp; </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a70dfe73858728880adc2f777c0a55d68">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> &amp;shape)</td></tr>
<tr class="memdesc:a70dfe73858728880adc2f777c0a55d68"><td class="mdescLeft"> </td><td class="mdescRight">allow string printing of the shape  <a href="#a70dfe73858728880adc2f777c0a55d68">More...</a><br/></td></tr>
<tr class="separator:a70dfe73858728880adc2f777c0a55d68"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aaab80b2ff315a4fa9c5c6782a6b372d8"><td align="right" class="memItemLeft" valign="top">std::istream &amp; </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#aaab80b2ff315a4fa9c5c6782a6b372d8">operator&gt;&gt;</a> (std::istream &amp;is, <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> &amp;shape)</td></tr>
<tr class="memdesc:aaab80b2ff315a4fa9c5c6782a6b372d8"><td class="mdescLeft"> </td><td class="mdescRight">read shape from the istream  <a href="#aaab80b2ff315a4fa9c5c6782a6b372d8">More...</a><br/></td></tr>
<tr class="separator:aaab80b2ff315a4fa9c5c6782a6b372d8"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af7ac3062c79e5700205043f94e7029ad"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#af7ac3062c79e5700205043f94e7029ad">operator+</a> (<a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> lhs, const <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> &amp;rhs)</td></tr>
<tr class="separator:af7ac3062c79e5700205043f94e7029ad"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4a500d425fad80171b91185fa781b937"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a4a500d425fad80171b91185fa781b937">operator-</a> (<a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> lhs, const <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> &amp;rhs)</td></tr>
<tr class="separator:a4a500d425fad80171b91185fa781b937"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae76138e7d064b0f17638b365c27425f6"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#ae76138e7d064b0f17638b365c27425f6">operator*</a> (<a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> lhs, const <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> &amp;rhs)</td></tr>
<tr class="separator:ae76138e7d064b0f17638b365c27425f6"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6e10e5bdac4feca95f2a2cc4050ccb29"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a6e10e5bdac4feca95f2a2cc4050ccb29">operator/</a> (<a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> lhs, const <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> &amp;rhs)</td></tr>
<tr class="separator:a6e10e5bdac4feca95f2a2cc4050ccb29"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9dd3c680ffa337cc97981ada80645880"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html#a9dd3c680ffa337cc97981ada80645880">operator%</a> (<a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> lhs, const <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> &amp;rhs)</td></tr>
<tr class="separator:a9dd3c680ffa337cc97981ada80645880"><td class="memSeparator" colspan="2"> </td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ae3c39bf39510741647c969f5409bb5d4"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">typedef unsigned <a class="el" href="namespacemxnet_1_1cpp.html#ae3c39bf39510741647c969f5409bb5d4">mxnet::cpp::index_t</a></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a class="anchor" id="a16a22578671e5ebcf8addb2275c317bc"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">typedef std::function&lt;<a class="el" href="classmxnet_1_1cpp_1_1Optimizer.html">Optimizer</a>*()&gt; <a class="el" href="namespacemxnet_1_1cpp.html#a16a22578671e5ebcf8addb2275c317bc">mxnet::cpp::OptimizerCreator</a></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="a919a622dc07b83d4431e8ff775455962"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="namespacemxnet_1_1cpp.html#a919a622dc07b83d4431e8ff775455962">mxnet::cpp::ActivationActType</a></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Activation function to be applied. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a919a622dc07b83d4431e8ff775455962a067892a9ea619b2c378e06000c9763af"></a>kRelu </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a919a622dc07b83d4431e8ff775455962ac00732693e14261bf9c2a4612a7f9bf9"></a>kSigmoid </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a919a622dc07b83d4431e8ff775455962a16649b2702b00ce7861366cbe7079e0f"></a>kSoftrelu </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a919a622dc07b83d4431e8ff775455962a12e90c7bc792e5b90d39318907669e63"></a>kSoftsign </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a919a622dc07b83d4431e8ff775455962a4918cf5d849692c2bed918bb9e948630"></a>kTanh </td><td class="fielddoc">
</td></tr>
</table>
</div>
</div>
<a class="anchor" id="ae9d179e796188c53f2d2a36dfde2bd7a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="namespacemxnet_1_1cpp.html#ae9d179e796188c53f2d2a36dfde2bd7a">mxnet::cpp::ArgsortDtype</a></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>DType of the output indices. It is only valid when ret_typ is "indices" or "both". An error will be raised if the selected data type cannot precisely </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ae9d179e796188c53f2d2a36dfde2bd7aa907b19d7a9943987059cdc540f11e440"></a>kFloat16 </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ae9d179e796188c53f2d2a36dfde2bd7aa9a78d6a569d086b524c3caf8c2522f96"></a>kFloat32 </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ae9d179e796188c53f2d2a36dfde2bd7aa78f9bf284cc7269efe0093b7c505feaa"></a>kFloat64 </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ae9d179e796188c53f2d2a36dfde2bd7aa10c09f8bff3c372f21cd8a13e01ae941"></a>kInt32 </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ae9d179e796188c53f2d2a36dfde2bd7aa11f076c48d8c2d080d2b9fbf5bf1725c"></a>kUint8 </td><td class="fielddoc">
</td></tr>
</table>
</div>
</div>
<a class="anchor" id="a45bddc3aa629f2554f95429b0a270a16"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="namespacemxnet_1_1cpp.html#a45bddc3aa629f2554f95429b0a270a16">mxnet::cpp::Batch_dotForwardStype</a></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>The desired storage type of the forward output given by user, if thecombination of input storage types and this hint does not matchany implemented ones, the dot operator will perform fallback operationand still produce an output of the </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a45bddc3aa629f2554f95429b0a270a16a35c3ace1970663a16e5c65baa5941b13"></a>kNone </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a45bddc3aa629f2554f95429b0a270a16a1775d6a702cfd3b6e09439e44566b877"></a>kCsr </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a45bddc3aa629f2554f95429b0a270a16a6867faeaa475fda467e48267db2bb8a8"></a>kDefault </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a45bddc3aa629f2554f95429b0a270a16a362f1e9fcc0ffe1058a27f4a6f22aa15"></a>kRow_sparse </td><td class="fielddoc">
</td></tr>
</table>
</div>
</div>
<a class="anchor" id="aac92e2f3642173e36bb79eb4854728ff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="namespacemxnet_1_1cpp.html#aac92e2f3642173e36bb79eb4854728ff">mxnet::cpp::Cast_storageStype</a></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Output storage type. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="aac92e2f3642173e36bb79eb4854728ffa1775d6a702cfd3b6e09439e44566b877"></a>kCsr </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aac92e2f3642173e36bb79eb4854728ffa6867faeaa475fda467e48267db2bb8a8"></a>kDefault </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aac92e2f3642173e36bb79eb4854728ffa362f1e9fcc0ffe1058a27f4a6f22aa15"></a>kRow_sparse </td><td class="fielddoc">
</td></tr>
</table>
</div>
</div>
<a class="anchor" id="a8e907a5fbbe4ec21628e500b34a5f35d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="namespacemxnet_1_1cpp.html#a8e907a5fbbe4ec21628e500b34a5f35d">mxnet::cpp::CastDtype</a></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Output data type. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a8e907a5fbbe4ec21628e500b34a5f35da907b19d7a9943987059cdc540f11e440"></a>kFloat16 </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8e907a5fbbe4ec21628e500b34a5f35da9a78d6a569d086b524c3caf8c2522f96"></a>kFloat32 </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8e907a5fbbe4ec21628e500b34a5f35da78f9bf284cc7269efe0093b7c505feaa"></a>kFloat64 </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8e907a5fbbe4ec21628e500b34a5f35da10c09f8bff3c372f21cd8a13e01ae941"></a>kInt32 </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8e907a5fbbe4ec21628e500b34a5f35da22c776007533004e22da8e6bdd888b33"></a>kInt64 </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8e907a5fbbe4ec21628e500b34a5f35daf112965031ccac10c07073b4e7430107"></a>kInt8 </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8e907a5fbbe4ec21628e500b34a5f35da11f076c48d8c2d080d2b9fbf5bf1725c"></a>kUint8 </td><td class="fielddoc">
</td></tr>
</table>
</div>
</div>
<a class="anchor" id="aa32f4a10a37f253f9d102cfc96a9eafc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="namespacemxnet_1_1cpp.html#aa32f4a10a37f253f9d102cfc96a9eafc">mxnet::cpp::Convolution_v1CudnnTune</a></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Whether to pick convolution algo by running performance test. Leads to higher startup time but may give faster speed. Options are: 'off': no tuning 'limited_workspace': run test and pick the fastest algorithm that doesn't 'fastest': pick the fastest algorithm and ignore workspace limit. If set to None (default), behavior is determined by environment variable MXNET_CUDNN_AUTOTUNE_DEFAULT: 0 for off, 1 for limited workspace (default), 2 for fastest. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="aa32f4a10a37f253f9d102cfc96a9eafca35c3ace1970663a16e5c65baa5941b13"></a>kNone </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aa32f4a10a37f253f9d102cfc96a9eafca3ce44e130de6ca8e948584251bd77987"></a>kFastest </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aa32f4a10a37f253f9d102cfc96a9eafca4ccc61daf45abfd4a8dd419c4123dd30"></a>kLimited_workspace </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aa32f4a10a37f253f9d102cfc96a9eafcacc9ab5e60ac2a9a675ba64bf4bb49dc8"></a>kOff </td><td class="fielddoc">
</td></tr>
</table>
</div>
</div>
<a class="anchor" id="a97217f563c768120cd8db19573938635"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="namespacemxnet_1_1cpp.html#a97217f563c768120cd8db19573938635">mxnet::cpp::Convolution_v1Layout</a></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Set layout for input, output and weight. Empty for default layout: NCHW for 2d and NCDHW for 3d. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a97217f563c768120cd8db19573938635a35c3ace1970663a16e5c65baa5941b13"></a>kNone </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a97217f563c768120cd8db19573938635af0e34dad85df0415c577fc810d54a111"></a>kNCDHW </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a97217f563c768120cd8db19573938635acaf70f83fa10041f93bb2ee89848d4b9"></a>kNCHW </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a97217f563c768120cd8db19573938635a65b2b3c8eed83e59b3cb6a8c1a30a5c8"></a>kNDHWC </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a97217f563c768120cd8db19573938635af6d739344f54ea3cddfa1f02f7f39b0a"></a>kNHWC </td><td class="fielddoc">
</td></tr>
</table>
</div>
</div>
<a class="anchor" id="a8755a4574a3839da2ad93af004fb1ff5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="namespacemxnet_1_1cpp.html#a8755a4574a3839da2ad93af004fb1ff5">mxnet::cpp::ConvolutionCudnnTune</a></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Whether to pick convolution algo by running performance test. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a8755a4574a3839da2ad93af004fb1ff5a35c3ace1970663a16e5c65baa5941b13"></a>kNone </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8755a4574a3839da2ad93af004fb1ff5a3ce44e130de6ca8e948584251bd77987"></a>kFastest </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8755a4574a3839da2ad93af004fb1ff5a4ccc61daf45abfd4a8dd419c4123dd30"></a>kLimited_workspace </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8755a4574a3839da2ad93af004fb1ff5acc9ab5e60ac2a9a675ba64bf4bb49dc8"></a>kOff </td><td class="fielddoc">
</td></tr>
</table>
</div>
</div>
<a class="anchor" id="a7b419f5293a7706c76becfe735a9946b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="namespacemxnet_1_1cpp.html#a7b419f5293a7706c76becfe735a9946b">mxnet::cpp::ConvolutionLayout</a></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Set layout for input, output and weight. Empty for default layout: NCW for 1d, NCHW for 2d and NCDHW for 3d.NHWC and NDHWC are </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a7b419f5293a7706c76becfe735a9946ba35c3ace1970663a16e5c65baa5941b13"></a>kNone </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7b419f5293a7706c76becfe735a9946baf0e34dad85df0415c577fc810d54a111"></a>kNCDHW </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7b419f5293a7706c76becfe735a9946bacaf70f83fa10041f93bb2ee89848d4b9"></a>kNCHW </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7b419f5293a7706c76becfe735a9946babed1add3caa07f613b3384a819d440c2"></a>kNCW </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7b419f5293a7706c76becfe735a9946ba65b2b3c8eed83e59b3cb6a8c1a30a5c8"></a>kNDHWC </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7b419f5293a7706c76becfe735a9946baf6d739344f54ea3cddfa1f02f7f39b0a"></a>kNHWC </td><td class="fielddoc">
</td></tr>
</table>
</div>
</div>
<a class="anchor" id="ae25c98b47a52531322d1622509c0e84d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="namespacemxnet_1_1cpp.html#ae25c98b47a52531322d1622509c0e84d">mxnet::cpp::DeconvolutionCudnnTune</a></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Whether to pick convolution algorithm by running performance test. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ae25c98b47a52531322d1622509c0e84da35c3ace1970663a16e5c65baa5941b13"></a>kNone </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ae25c98b47a52531322d1622509c0e84da3ce44e130de6ca8e948584251bd77987"></a>kFastest </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ae25c98b47a52531322d1622509c0e84da4ccc61daf45abfd4a8dd419c4123dd30"></a>kLimited_workspace </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ae25c98b47a52531322d1622509c0e84dacc9ab5e60ac2a9a675ba64bf4bb49dc8"></a>kOff </td><td class="fielddoc">
</td></tr>
</table>
</div>
</div>
<a class="anchor" id="a63a3b219f6bced4a550ed4bc5207e997"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="namespacemxnet_1_1cpp.html#a63a3b219f6bced4a550ed4bc5207e997">mxnet::cpp::DeconvolutionLayout</a></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Set layout for input, output and weight. Empty for default layout, NCW for 1d, </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a63a3b219f6bced4a550ed4bc5207e997a35c3ace1970663a16e5c65baa5941b13"></a>kNone </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a63a3b219f6bced4a550ed4bc5207e997af0e34dad85df0415c577fc810d54a111"></a>kNCDHW </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a63a3b219f6bced4a550ed4bc5207e997acaf70f83fa10041f93bb2ee89848d4b9"></a>kNCHW </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a63a3b219f6bced4a550ed4bc5207e997abed1add3caa07f613b3384a819d440c2"></a>kNCW </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a63a3b219f6bced4a550ed4bc5207e997a65b2b3c8eed83e59b3cb6a8c1a30a5c8"></a>kNDHWC </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a63a3b219f6bced4a550ed4bc5207e997af6d739344f54ea3cddfa1f02f7f39b0a"></a>kNHWC </td><td class="fielddoc">
</td></tr>
</table>
</div>
</div>
<a class="anchor" id="a65c3def958cbb9d09c7f56082a5257d6"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="namespacemxnet_1_1cpp.html#a65c3def958cbb9d09c7f56082a5257d6">mxnet::cpp::DeviceType</a></td>
</tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a65c3def958cbb9d09c7f56082a5257d6a9705bd4da252932c6c64160d1ea7dbae"></a>kCPU </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a65c3def958cbb9d09c7f56082a5257d6a98a378997114516ab326b392a1668158"></a>kGPU </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a65c3def958cbb9d09c7f56082a5257d6abe32f7c482f2fb25e142b3834524252a"></a>kCPUPinned </td><td class="fielddoc">
</td></tr>
</table>
</div>
</div>
<a class="anchor" id="aa5dbdd69827034fc43c16cf350db7e1e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="namespacemxnet_1_1cpp.html#aa5dbdd69827034fc43c16cf350db7e1e">mxnet::cpp::DotForwardStype</a></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>The desired storage type of the forward output given by user, if thecombination of input storage types and this hint does not matchany implemented ones, the dot operator will perform fallback operationand still produce an output of the </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="aa5dbdd69827034fc43c16cf350db7e1ea35c3ace1970663a16e5c65baa5941b13"></a>kNone </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aa5dbdd69827034fc43c16cf350db7e1ea1775d6a702cfd3b6e09439e44566b877"></a>kCsr </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aa5dbdd69827034fc43c16cf350db7e1ea6867faeaa475fda467e48267db2bb8a8"></a>kDefault </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aa5dbdd69827034fc43c16cf350db7e1ea362f1e9fcc0ffe1058a27f4a6f22aa15"></a>kRow_sparse </td><td class="fielddoc">
</td></tr>
</table>
</div>
</div>
<a class="anchor" id="a3cc3a1d19b3bf567326c77e263038a0e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="namespacemxnet_1_1cpp.html#a3cc3a1d19b3bf567326c77e263038a0e">mxnet::cpp::DropoutMode</a></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Whether to only turn on dropout during training or to also turn on for </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a3cc3a1d19b3bf567326c77e263038a0ea65b982518fe25240c767960a6b981903"></a>kAlways </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a3cc3a1d19b3bf567326c77e263038a0eabae2199a6d43c4c6ccd0e74727c02a64"></a>kTraining </td><td class="fielddoc">
</td></tr>
</table>
</div>
</div>
<a class="anchor" id="a3c80705d63347982667fc541ad5bf845"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="namespacemxnet_1_1cpp.html#a3c80705d63347982667fc541ad5bf845">mxnet::cpp::EmbeddingDtype</a></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Data type of weight. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a3c80705d63347982667fc541ad5bf845a907b19d7a9943987059cdc540f11e440"></a>kFloat16 </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a3c80705d63347982667fc541ad5bf845a9a78d6a569d086b524c3caf8c2522f96"></a>kFloat32 </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a3c80705d63347982667fc541ad5bf845a78f9bf284cc7269efe0093b7c505feaa"></a>kFloat64 </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a3c80705d63347982667fc541ad5bf845a10c09f8bff3c372f21cd8a13e01ae941"></a>kInt32 </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a3c80705d63347982667fc541ad5bf845a22c776007533004e22da8e6bdd888b33"></a>kInt64 </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a3c80705d63347982667fc541ad5bf845af112965031ccac10c07073b4e7430107"></a>kInt8 </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a3c80705d63347982667fc541ad5bf845a11f076c48d8c2d080d2b9fbf5bf1725c"></a>kUint8 </td><td class="fielddoc">
</td></tr>
</table>
</div>
</div>
<a class="anchor" id="a98745f0114674ef8fa60b2a35a877a2c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="namespacemxnet_1_1cpp.html#a98745f0114674ef8fa60b2a35a877a2c">mxnet::cpp::GridGeneratorTransformType</a></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>The type of transformation. For <code>affine</code>, input data should be an affine matrix of size (batch, 6). For <code>warp</code>, input data should be an optical flow of size </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a98745f0114674ef8fa60b2a35a877a2cac3af1341756d0c5a66c8ea473dc38927"></a>kAffine </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a98745f0114674ef8fa60b2a35a877a2ca7150a1272fb5e8267858ab706061e68d"></a>kWarp </td><td class="fielddoc">
</td></tr>
</table>
</div>
</div>
<a class="anchor" id="a92b87bed551457a3d444a28fd3c7c84f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="namespacemxnet_1_1cpp.html#a92b87bed551457a3d444a28fd3c7c84f">mxnet::cpp::L2NormalizationMode</a></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Specify the dimension along which to compute L2 norm. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a92b87bed551457a3d444a28fd3c7c84facbab887403bd90909c675dd375c049ab"></a>kChannel </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a92b87bed551457a3d444a28fd3c7c84fa63f56d9e95d7b447075aef94444c4c96"></a>kInstance </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a92b87bed551457a3d444a28fd3c7c84fa83fe4465949392cd595c66cd0992bf4f"></a>kSpatial </td><td class="fielddoc">
</td></tr>
</table>
</div>
</div>
<a class="anchor" id="aad64d459f3652d3ec3cf37c460aa8ee0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="namespacemxnet_1_1cpp.html#aad64d459f3652d3ec3cf37c460aa8ee0">mxnet::cpp::LeakyReLUActType</a></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Activation function to be applied. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="aad64d459f3652d3ec3cf37c460aa8ee0a069cf87f2d4b99d9f62876a74404b1d3"></a>kElu </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aad64d459f3652d3ec3cf37c460aa8ee0a3620dd046c3b58ec17570ae64aa325eb"></a>kLeaky </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aad64d459f3652d3ec3cf37c460aa8ee0a22d7f1f62bdd3e103915dee419726669"></a>kPrelu </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aad64d459f3652d3ec3cf37c460aa8ee0ade7fea8780fce6ceb9441318d2d11d9b"></a>kRrelu </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aad64d459f3652d3ec3cf37c460aa8ee0a7fa55f9e443e4480962965fbc282c2d1"></a>kSelu </td><td class="fielddoc">
</td></tr>
</table>
</div>
</div>
<a class="anchor" id="a0f8c7551de879673caa593f74e8ebca6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="namespacemxnet_1_1cpp.html#a0f8c7551de879673caa593f74e8ebca6">mxnet::cpp::MakeLossNormalization</a></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>If this is set to null, the output gradient will not be normalized. If this is set to batch, the output gradient will be divided by the batch size. If this is set to valid, the output gradient will be divided by the number of valid input </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a0f8c7551de879673caa593f74e8ebca6ae8d28b6b417e276d0d4a33304cd9e6e3"></a>kBatch </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a0f8c7551de879673caa593f74e8ebca6af2655c2dee87cb9b0646f678a630394b"></a>kNull </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a0f8c7551de879673caa593f74e8ebca6a4d3576c37e6f03700bad4345238fffa0"></a>kValid </td><td class="fielddoc">
</td></tr>
</table>
</div>
</div>
<a class="anchor" id="a38cfaf4948f45cc4e6e46fbef0f6b8c2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="namespacemxnet_1_1cpp.html#a38cfaf4948f45cc4e6e46fbef0f6b8c2">mxnet::cpp::One_hotDtype</a></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>DType of the output </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a38cfaf4948f45cc4e6e46fbef0f6b8c2a907b19d7a9943987059cdc540f11e440"></a>kFloat16 </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a38cfaf4948f45cc4e6e46fbef0f6b8c2a9a78d6a569d086b524c3caf8c2522f96"></a>kFloat32 </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a38cfaf4948f45cc4e6e46fbef0f6b8c2a78f9bf284cc7269efe0093b7c505feaa"></a>kFloat64 </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a38cfaf4948f45cc4e6e46fbef0f6b8c2a10c09f8bff3c372f21cd8a13e01ae941"></a>kInt32 </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a38cfaf4948f45cc4e6e46fbef0f6b8c2a22c776007533004e22da8e6bdd888b33"></a>kInt64 </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a38cfaf4948f45cc4e6e46fbef0f6b8c2af112965031ccac10c07073b4e7430107"></a>kInt8 </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a38cfaf4948f45cc4e6e46fbef0f6b8c2a11f076c48d8c2d080d2b9fbf5bf1725c"></a>kUint8 </td><td class="fielddoc">
</td></tr>
</table>
</div>
</div>
<a class="anchor" id="ae1e49a337d45c7071defefda2ec91845"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="namespacemxnet_1_1cpp.html#ae1e49a337d45c7071defefda2ec91845">mxnet::cpp::OpReqType</a></td>
</tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ae1e49a337d45c7071defefda2ec91845aefc84e1f8e37df690eb120d7f85f2cb2"></a>kNullOp </td><td class="fielddoc">
<p>no operation, do not write anything </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ae1e49a337d45c7071defefda2ec91845aeeb7170b414b47800f504038816d5b68"></a>kWriteTo </td><td class="fielddoc">
<p>write gradient to provided space </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ae1e49a337d45c7071defefda2ec91845aae1754f69deaa9fe7d2d37479126d08d"></a>kWriteInplace </td><td class="fielddoc">
<p>perform an inplace write, Target shares memory with one of input arguments. This option only happen when </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ae1e49a337d45c7071defefda2ec91845a00aae45e4e69f21765e2ff3ecea6ac81"></a>kAddTo </td><td class="fielddoc">
<p>add to the provided space </p>
</td></tr>
</table>
</div>
</div>
<a class="anchor" id="ab261a86c931574327d82188c75f93d1a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="namespacemxnet_1_1cpp.html#ab261a86c931574327d82188c75f93d1a">mxnet::cpp::PadMode</a></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Padding type to use. "constant" pads with <code>constant_value</code> "edge" pads using the edge values of the input array "reflect" pads by reflecting values with </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ab261a86c931574327d82188c75f93d1aa043b62a71551e8b511099802b2b59a98"></a>kConstant </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab261a86c931574327d82188c75f93d1aa0a9e7b78276726f559419b53f1b48378"></a>kEdge </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab261a86c931574327d82188c75f93d1aa349d0a80f99eef391838f790093367fa"></a>kReflect </td><td class="fielddoc">
</td></tr>
</table>
</div>
</div>
<a class="anchor" id="a30fd3a240ebc436ddb671d0c33d5bdc3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="namespacemxnet_1_1cpp.html#a30fd3a240ebc436ddb671d0c33d5bdc3">mxnet::cpp::PickMode</a></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Specify how out-of-bound indices behave. Default is "clip". "clip" means clip to the range. So, if all indices mentioned are too large, they are replaced by the index that addresses the last element along an axis. "wrap" means to wrap </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a30fd3a240ebc436ddb671d0c33d5bdc3ae2867cadc2a39b014e89d241b72f3a75"></a>kClip </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a30fd3a240ebc436ddb671d0c33d5bdc3af6574e59f887a486b1b8d8a7c3cf3f83"></a>kWrap </td><td class="fielddoc">
</td></tr>
</table>
</div>
</div>
<a class="anchor" id="ac8e6f64dc9bca9d9388d34d5153cb094"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="namespacemxnet_1_1cpp.html#ac8e6f64dc9bca9d9388d34d5153cb094">mxnet::cpp::Pooling_v1PoolingConvention</a></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Pooling convention to be applied. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ac8e6f64dc9bca9d9388d34d5153cb094aa60924e124da4d51bd4dc74c8f85b158"></a>kFull </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ac8e6f64dc9bca9d9388d34d5153cb094a4d3576c37e6f03700bad4345238fffa0"></a>kValid </td><td class="fielddoc">
</td></tr>
</table>
</div>
</div>
<a class="anchor" id="a7dc4e3b741dfffc9295e1f8fbcb51c2e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="namespacemxnet_1_1cpp.html#a7dc4e3b741dfffc9295e1f8fbcb51c2e">mxnet::cpp::Pooling_v1PoolType</a></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Pooling type to be applied. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a7dc4e3b741dfffc9295e1f8fbcb51c2eaa22c1525680159c49e69ff9c43d1d01b"></a>kAvg </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7dc4e3b741dfffc9295e1f8fbcb51c2eaa0b1ac8aae6b1cfbbe89085c642b3b4b"></a>kMax </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7dc4e3b741dfffc9295e1f8fbcb51c2eaa1dc5fbfa16754d1e628d66381725617"></a>kSum </td><td class="fielddoc">
</td></tr>
</table>
</div>
</div>
<a class="anchor" id="abaf9ea614ede3210454943dd3130c5cd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="namespacemxnet_1_1cpp.html#abaf9ea614ede3210454943dd3130c5cd">mxnet::cpp::PoolingPoolingConvention</a></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Pooling convention to be applied. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="abaf9ea614ede3210454943dd3130c5cdaa60924e124da4d51bd4dc74c8f85b158"></a>kFull </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="abaf9ea614ede3210454943dd3130c5cda4d3576c37e6f03700bad4345238fffa0"></a>kValid </td><td class="fielddoc">
</td></tr>
</table>
</div>
</div>
<a class="anchor" id="a44ef744b314acdba218a7405f56e00be"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="namespacemxnet_1_1cpp.html#a44ef744b314acdba218a7405f56e00be">mxnet::cpp::PoolingPoolType</a></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Pooling type to be applied. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a44ef744b314acdba218a7405f56e00beaa22c1525680159c49e69ff9c43d1d01b"></a>kAvg </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a44ef744b314acdba218a7405f56e00beaf724eae0207adfdb7859ce8226b495f2"></a>kLp </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a44ef744b314acdba218a7405f56e00beaa0b1ac8aae6b1cfbbe89085c642b3b4b"></a>kMax </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a44ef744b314acdba218a7405f56e00beaa1dc5fbfa16754d1e628d66381725617"></a>kSum </td><td class="fielddoc">
</td></tr>
</table>
</div>
</div>
<a class="anchor" id="ae39119fed3c83726a0a2ea89b506661d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="namespacemxnet_1_1cpp.html#ae39119fed3c83726a0a2ea89b506661d">mxnet::cpp::RNNMode</a></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>the type of RNN to compute </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ae39119fed3c83726a0a2ea89b506661da5ea3f9d5c30c8d9f95be38d63711f8f1"></a>kGru </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ae39119fed3c83726a0a2ea89b506661da355b4b6ce6fdae03f3b946c79515b713"></a>kLstm </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ae39119fed3c83726a0a2ea89b506661dadff62ec61167055b8101cf576ff9d3e8"></a>kRnn_relu </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ae39119fed3c83726a0a2ea89b506661da93ae2f9c92a50dd27b3a4bec79e2e8ef"></a>kRnn_tanh </td><td class="fielddoc">
</td></tr>
</table>
</div>
</div>
<a class="anchor" id="a08bbd5633680ffa58dae3cab685e2ebf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="namespacemxnet_1_1cpp.html#a08bbd5633680ffa58dae3cab685e2ebf">mxnet::cpp::SoftmaxActivationMode</a></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Specifies how to compute the softmax. If set to <code>instance</code>, it computes softmax for each instance. If set to <code>channel</code>, It computes cross channel </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a08bbd5633680ffa58dae3cab685e2ebfacbab887403bd90909c675dd375c049ab"></a>kChannel </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a08bbd5633680ffa58dae3cab685e2ebfa63f56d9e95d7b447075aef94444c4c96"></a>kInstance </td><td class="fielddoc">
</td></tr>
</table>
</div>
</div>
<a class="anchor" id="abac2e8c934c7bd4416728b351fcbae5b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="namespacemxnet_1_1cpp.html#abac2e8c934c7bd4416728b351fcbae5b">mxnet::cpp::SoftmaxNormalization</a></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Normalizes the gradient. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="abac2e8c934c7bd4416728b351fcbae5bae8d28b6b417e276d0d4a33304cd9e6e3"></a>kBatch </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="abac2e8c934c7bd4416728b351fcbae5baf2655c2dee87cb9b0646f678a630394b"></a>kNull </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="abac2e8c934c7bd4416728b351fcbae5ba4d3576c37e6f03700bad4345238fffa0"></a>kValid </td><td class="fielddoc">
</td></tr>
</table>
</div>
</div>
<a class="anchor" id="ae708904c6ad7046fcecfc6c6b7e0ac73"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="namespacemxnet_1_1cpp.html#ae708904c6ad7046fcecfc6c6b7e0ac73">mxnet::cpp::SoftmaxOutputNormalization</a></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Normalizes the gradient. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ae708904c6ad7046fcecfc6c6b7e0ac73ae8d28b6b417e276d0d4a33304cd9e6e3"></a>kBatch </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ae708904c6ad7046fcecfc6c6b7e0ac73af2655c2dee87cb9b0646f678a630394b"></a>kNull </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ae708904c6ad7046fcecfc6c6b7e0ac73a4d3576c37e6f03700bad4345238fffa0"></a>kValid </td><td class="fielddoc">
</td></tr>
</table>
</div>
</div>
<a class="anchor" id="a20ce4a2b1581ec74fc957d816d1e19ce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="namespacemxnet_1_1cpp.html#a20ce4a2b1581ec74fc957d816d1e19ce">mxnet::cpp::SpatialTransformerSamplerType</a></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>sampling type </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a20ce4a2b1581ec74fc957d816d1e19cea03cb956599b7a2edbf1537556a6b4f01"></a>kBilinear </td><td class="fielddoc">
</td></tr>
</table>
</div>
</div>
<a class="anchor" id="a0ff49861ba295abeac5d545bfa16b0aa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="namespacemxnet_1_1cpp.html#a0ff49861ba295abeac5d545bfa16b0aa">mxnet::cpp::SpatialTransformerTransformType</a></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>transformation type </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a0ff49861ba295abeac5d545bfa16b0aaac3af1341756d0c5a66c8ea473dc38927"></a>kAffine </td><td class="fielddoc">
</td></tr>
</table>
</div>
</div>
<a class="anchor" id="ab8b82422d329aa4497e6891590633325"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="namespacemxnet_1_1cpp.html#ab8b82422d329aa4497e6891590633325">mxnet::cpp::TakeMode</a></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Specify how out-of-bound indices bahave. Default is "clip". "clip" means clip to the range. So, if all indices mentioned are too large, they are replaced by the index that addresses the last element along an axis. "wrap" means to wrap </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ab8b82422d329aa4497e6891590633325ae2867cadc2a39b014e89d241b72f3a75"></a>kClip </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab8b82422d329aa4497e6891590633325a3538405b5d9916e92ac29b5f5458a88a"></a>kRaise </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab8b82422d329aa4497e6891590633325af6574e59f887a486b1b8d8a7c3cf3f83"></a>kWrap </td><td class="fielddoc">
</td></tr>
</table>
</div>
</div>
<a class="anchor" id="a992f67b993b07623d888ddcf01f9ddc3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="namespacemxnet_1_1cpp.html#a992f67b993b07623d888ddcf01f9ddc3">mxnet::cpp::TopkDtype</a></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>DType of the output indices when ret_typ is "indices" or "both". An error will </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a992f67b993b07623d888ddcf01f9ddc3a907b19d7a9943987059cdc540f11e440"></a>kFloat16 </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a992f67b993b07623d888ddcf01f9ddc3a9a78d6a569d086b524c3caf8c2522f96"></a>kFloat32 </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a992f67b993b07623d888ddcf01f9ddc3a78f9bf284cc7269efe0093b7c505feaa"></a>kFloat64 </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a992f67b993b07623d888ddcf01f9ddc3a10c09f8bff3c372f21cd8a13e01ae941"></a>kInt32 </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a992f67b993b07623d888ddcf01f9ddc3a11f076c48d8c2d080d2b9fbf5bf1725c"></a>kUint8 </td><td class="fielddoc">
</td></tr>
</table>
</div>
</div>
<a class="anchor" id="a3d86bd343a0a3b4d7f1205cadaf24855"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="namespacemxnet_1_1cpp.html#a3d86bd343a0a3b4d7f1205cadaf24855">mxnet::cpp::TopkRetTyp</a></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>The return type. "value" means to return the top k values, "indices" means to return the indices of the top k values, "mask" means to return a mask array containing 0 and 1. 1 means the top k values. "both" means to return a list of both values and </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a3d86bd343a0a3b4d7f1205cadaf24855a4f968049bc5e5f7c6e0d89946366fff2"></a>kBoth </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a3d86bd343a0a3b4d7f1205cadaf24855ac514f90edc83d38e3527476bbfb8e5e8"></a>kIndices </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a3d86bd343a0a3b4d7f1205cadaf24855a9ff0f8feb708b8d7fabfe8682b22b201"></a>kMask </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a3d86bd343a0a3b4d7f1205cadaf24855a83de3546ca2d3aa334f69240ecbaff07"></a>kValue </td><td class="fielddoc">
</td></tr>
</table>
</div>
</div>
<a class="anchor" id="afce90445dba4ab6be903251cb0c960ef"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="namespacemxnet_1_1cpp.html#afce90445dba4ab6be903251cb0c960ef">mxnet::cpp::UpSamplingMultiInputMode</a></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>How to handle multiple input. concat means concatenate upsampled images along the channel dimension. sum means add all images together, only available for </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="afce90445dba4ab6be903251cb0c960efa07f24210ce07b41cf8370dd8e9a3eb70"></a>kConcat </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="afce90445dba4ab6be903251cb0c960efaa1dc5fbfa16754d1e628d66381725617"></a>kSum </td><td class="fielddoc">
</td></tr>
</table>
</div>
</div>
<a class="anchor" id="a9c9a4644f19e7ed3c729165de2e963ab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="namespacemxnet_1_1cpp.html#a9c9a4644f19e7ed3c729165de2e963ab">mxnet::cpp::UpSamplingSampleType</a></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>upsampling method </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a9c9a4644f19e7ed3c729165de2e963aba03cb956599b7a2edbf1537556a6b4f01"></a>kBilinear </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9c9a4644f19e7ed3c729165de2e963abae52c2066ca63eef7fada2eefb5c7f31c"></a>kNearest </td><td class="fielddoc">
</td></tr>
</table>
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="af52dc7c5b66e9ee04b37f39cde0fcc5a"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1NDArray.html">NDArray</a> mxnet::cpp::_default_monitor_func </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="classmxnet_1_1cpp_1_1NDArray.html">NDArray</a> &amp; </td>
<td class="paramname"><em>x</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Default function for monitor that computes statistics of the input tensor, which is the mean absolute |x|/size(x) </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">x</td><td>The input tensor </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The statistics of the input tensor </dd></dl>
</div>
</div>
<a class="anchor" id="aafc94488768fddc81e4bf7a6513c3d53"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::_Div </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>rhs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a class="anchor" id="abd35f4aea1d59d116f442a9a198f7f08"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::_DivScalar </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>scalar</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a class="anchor" id="a36df72e0b01ec278c4fd12568aecb5f9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::_Maximum </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>rhs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a class="anchor" id="acfa6b946c2c1b6d67847a0d5ad33c7b9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::_MaximumScalar </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>scalar</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a class="anchor" id="a65c4fa6348c6ffbe06a2e5b5f26a32e9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::_Minimum </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>rhs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a class="anchor" id="a39a1269e963b9ccd81b03ca2e7903b17"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::_MinimumScalar </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>scalar</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a class="anchor" id="a08662bacc9a9a3935b9cc0e0ac0af397"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::_Minus </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>rhs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a class="anchor" id="a02b18bf7c3f2beb4db696db1396ca801"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::_MinusScalar </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>scalar</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a class="anchor" id="ac3e2151372e9a19057a062755254ff56"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::_Mod </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>rhs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a class="anchor" id="a650147b3f97450afdbcd8f16c993843f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::_ModScalar </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>scalar</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a class="anchor" id="a5cd0b9b4e929d55da482e0a616cb3ac0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::_Mul </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>rhs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a class="anchor" id="a413b21fdfe408a86fc66663806e34fb0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::_MulScalar </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>scalar</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a class="anchor" id="adf6edcf76da5f7bd268eb4dcbdc8538a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::_Plus </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>rhs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a class="anchor" id="a6c5c547100513efb8c4a1de19152c715"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::_PlusScalar </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>scalar</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a class="anchor" id="a77c28ff73891debeb69a99b1b35d84b5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::_Power </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>rhs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a class="anchor" id="ab1c47b376e97268139a91113fa786a58"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::_PowerScalar </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>scalar</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a class="anchor" id="a4a2b073fef987ff1c4056f772a4ef525"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::_RDivScalar </td>
<td>(</td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>scalar</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>rhs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a class="anchor" id="adc14d741eec9cd6e56c83772fb91155e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::_RMinusScalar </td>
<td>(</td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>scalar</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>rhs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a class="anchor" id="a02670e4bae0b199a6de5fb66abecbb36"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::_RModScalar </td>
<td>(</td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>scalar</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>rhs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a class="anchor" id="abad2524b5c52c6f8dbe0bfa3c64200fa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::_RPowerScalar </td>
<td>(</td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>scalar</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>rhs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a class="anchor" id="accf8d710dd8d06612f9e7944d1183d3f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::abs </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns element-wise absolute value of the input. </p><pre class="fragment">   Example::

   abs([-2, 0, 3]) = [2, 0, 3]

   The storage type of ``abs`` output depends upon the input storage type:

   - abs(default) = default
   - abs(row_sparse) = row_sparse
   - abs(csr) = csr



   Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L668
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>The input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="ae269ce90b13e450b6e9bf4575e58401a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::abs </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns element-wise absolute value of the input. </p><pre class="fragment">   Example::

   abs([-2, 0, 3]) = [2, 0, 3]

   The storage type of ``abs`` output depends upon the input storage type:

   - abs(default) = default
   - abs(row_sparse) = row_sparse
   - abs(csr) = csr



   Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L668
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>The input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="ac524fa9c4a7b5d48c362108fee918c54"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::Activation </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>act_type</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Apply activation function to input. Softmax Activation is only available with CUDNN on GPUand will be computed at each location across channel if input is 4D. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol. </td></tr>
<tr><td class="paramname">data</td><td>Input data to activation function. </td></tr>
<tr><td class="paramname">act_type</td><td>Activation function to be applied. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="ae0e34284b668c02ac1ae643db2ca4377"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::Activation </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespacemxnet_1_1cpp.html#a919a622dc07b83d4431e8ff775455962">ActivationActType</a> </td>
<td class="paramname"><em>act_type</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Applies an activation function element-wise to the input. </p><pre class="fragment">   The following activation functions are supported:

   - `relu`: Rectified Linear Unit, :math:`y = max(x, 0)`
   - `sigmoid`: :math:`y = \frac{1}{1 + exp(-x)}`
   - `tanh`: Hyperbolic tangent, :math:`y = \frac{exp(x) - exp(-x)}{exp(x) +
   - `softrelu`: Soft ReLU, or SoftPlus, :math:`y = log(1 + exp(x))`
   - `softsign`: :math:`y = \frac{x}{1 + abs(x)}`



   Defined in src/operator/nn/activation.cc:L184
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>The input array. </td></tr>
<tr><td class="paramname">act_type</td><td>Activation function to be applied. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a8f7f8ab7d8134216349d7e4275baf4d7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::Activation </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespacemxnet_1_1cpp.html#a919a622dc07b83d4431e8ff775455962">ActivationActType</a> </td>
<td class="paramname"><em>act_type</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Applies an activation function element-wise to the input. </p><pre class="fragment">   The following activation functions are supported:

   - `relu`: Rectified Linear Unit, :math:`y = max(x, 0)`
   - `sigmoid`: :math:`y = \frac{1}{1 + exp(-x)}`
   - `tanh`: Hyperbolic tangent, :math:`y = \frac{exp(x) - exp(-x)}{exp(x) +
   - `softrelu`: Soft ReLU, or SoftPlus, :math:`y = log(1 + exp(x))`
   - `softsign`: :math:`y = \frac{x}{1 + abs(x)}`



   Defined in src/operator/nn/activation.cc:L184
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>The input array. </td></tr>
<tr><td class="paramname">act_type</td><td>Activation function to be applied. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a6b729f4fac2b1e7b50f39b2723af43f1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::adam_update </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>weight</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>grad</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>mean</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>var</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>lr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>beta1</em> = <code>0.9</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>beta2</em> = <code>0.999</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>epsilon</em> = <code>1e-08</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>wd</em> = <code>0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>rescale_grad</em> = <code>1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>clip_gradient</em> = <code>-1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>lazy_update</em> = <code>true</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Update function for Adam optimizer. Adam is seen as a generalization of AdaGrad.</p>
<p>Adam update consists of the following steps, where g represents gradient and m, are 1st and 2nd order moment estimates (mean and variance).</p>
<p>.. math::</p>
<p>g_t =  J(W_{t-1})\ m_t =  m_{t-1} + (1 - ) g_t\ v_t =  v_{t-1} + (1 - ) g_t^2\ W_t = W_{t-1} -  { m_t }{ { v_t } +  }</p>
<p>It updates the weights using::</p>
<p>m = beta1*m + (1-beta1)*grad v = beta2*v + (1-beta2)*(grad**2) w += - learning_rate * m / (sqrt(v) + epsilon)</p>
<p>However, if grad's storage type is <code>row_sparse</code>, <code>lazy_update</code> is True and type of weight is the same as those of m and v, only the row slices whose indices appear in grad.indices are updated (for w, m</p>
<p>for row in grad.indices: m[row] = beta1*m[row] + (1-beta1)*grad[row] v[row] = beta2*v[row] + (1-beta2)*(grad[row]**2) w[row] += - learning_rate * m[row] / (sqrt(v[row]) + epsilon)</p>
<pre class="fragment">   Defined in src/operator/optimizer_op.cc:L495
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">weight</td><td>Weight </td></tr>
<tr><td class="paramname">grad</td><td>Gradient </td></tr>
<tr><td class="paramname">mean</td><td>Moving mean </td></tr>
<tr><td class="paramname">var</td><td>Moving variance </td></tr>
<tr><td class="paramname">lr</td><td>Learning rate </td></tr>
<tr><td class="paramname">beta1</td><td>The decay rate for the 1st moment estimates. </td></tr>
<tr><td class="paramname">beta2</td><td>The decay rate for the 2nd moment estimates. </td></tr>
<tr><td class="paramname">epsilon</td><td>A small constant for numerical stability. </td></tr>
<tr><td class="paramname">wd</td><td>Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of </td></tr>
<tr><td class="paramname">rescale_grad</td><td>Rescale gradient to grad = rescale_grad*grad. </td></tr>
<tr><td class="paramname">clip_gradient</td><td>Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, </td></tr>
<tr><td class="paramname">lazy_update</td><td>If true, lazy updates are applied if gradient's stype is row_sparse </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a56c1bc1a4d31e9767d156cc5e3da3866"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::adam_update </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>weight</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>grad</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>mean</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>var</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>lr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>beta1</em> = <code>0.9</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>beta2</em> = <code>0.999</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>epsilon</em> = <code>1e-08</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>wd</em> = <code>0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>rescale_grad</em> = <code>1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>clip_gradient</em> = <code>-1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>lazy_update</em> = <code>true</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Update function for Adam optimizer. Adam is seen as a generalization of AdaGrad.</p>
<p>Adam update consists of the following steps, where g represents gradient and m, are 1st and 2nd order moment estimates (mean and variance).</p>
<p>.. math::</p>
<p>g_t =  J(W_{t-1})\ m_t =  m_{t-1} + (1 - ) g_t\ v_t =  v_{t-1} + (1 - ) g_t^2\ W_t = W_{t-1} -  { m_t }{ { v_t } +  }</p>
<p>It updates the weights using::</p>
<p>m = beta1*m + (1-beta1)*grad v = beta2*v + (1-beta2)*(grad**2) w += - learning_rate * m / (sqrt(v) + epsilon)</p>
<p>However, if grad's storage type is <code>row_sparse</code>, <code>lazy_update</code> is True and type of weight is the same as those of m and v, only the row slices whose indices appear in grad.indices are updated (for w, m</p>
<p>for row in grad.indices: m[row] = beta1*m[row] + (1-beta1)*grad[row] v[row] = beta2*v[row] + (1-beta2)*(grad[row]**2) w[row] += - learning_rate * m[row] / (sqrt(v[row]) + epsilon)</p>
<pre class="fragment">   Defined in src/operator/optimizer_op.cc:L495
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">weight</td><td>Weight </td></tr>
<tr><td class="paramname">grad</td><td>Gradient </td></tr>
<tr><td class="paramname">mean</td><td>Moving mean </td></tr>
<tr><td class="paramname">var</td><td>Moving variance </td></tr>
<tr><td class="paramname">lr</td><td>Learning rate </td></tr>
<tr><td class="paramname">beta1</td><td>The decay rate for the 1st moment estimates. </td></tr>
<tr><td class="paramname">beta2</td><td>The decay rate for the 2nd moment estimates. </td></tr>
<tr><td class="paramname">epsilon</td><td>A small constant for numerical stability. </td></tr>
<tr><td class="paramname">wd</td><td>Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of </td></tr>
<tr><td class="paramname">rescale_grad</td><td>Rescale gradient to grad = rescale_grad*grad. </td></tr>
<tr><td class="paramname">clip_gradient</td><td>Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, </td></tr>
<tr><td class="paramname">lazy_update</td><td>If true, lazy updates are applied if gradient's stype is row_sparse </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a198f7c7f5d15e284b75d3675c7c6faab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::add_n </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const std::vector&lt; <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> &gt; &amp; </td>
<td class="paramname"><em>args</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Adds all input arguments element-wise. </p><pre class="fragment">   .. math::
   add\_n(a_1, a_2, ..., a_n) = a_1 + a_2 + ... + a_n

   ``add_n`` is potentially more efficient than calling ``add`` by `n` times.

   The storage type of ``add_n`` output depends on storage types of inputs

   - add_n(row_sparse, row_sparse, ..) = row_sparse
   - add_n(default, csr, default) = default
   - add_n(any input combinations longer than 4 (&gt;4) with at least one default
   - otherwise, ``add_n`` falls all inputs back to default storage and generates



   Defined in src/operator/tensor/elemwise_sum.cc:L156
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">args</td><td>Positional input arguments </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="ae6756558ed8d683ca36e34807d4276c9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::add_n </td>
<td>(</td>
<td class="paramtype">const std::vector&lt; <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> &gt; &amp; </td>
<td class="paramname"><em>args</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Adds all input arguments element-wise. </p><pre class="fragment">   .. math::
   add\_n(a_1, a_2, ..., a_n) = a_1 + a_2 + ... + a_n

   ``add_n`` is potentially more efficient than calling ``add`` by `n` times.

   The storage type of ``add_n`` output depends on storage types of inputs

   - add_n(row_sparse, row_sparse, ..) = row_sparse
   - add_n(default, csr, default) = default
   - add_n(any input combinations longer than 4 (&gt;4) with at least one default
   - otherwise, ``add_n`` falls all inputs back to default storage and generates



   Defined in src/operator/tensor/elemwise_sum.cc:L156
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">args</td><td>Positional input arguments </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a2184715822af3bd29d821432032bd40d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::arccos </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns element-wise inverse cosine of the input array. </p><pre class="fragment">   The input should be in range `[-1, 1]`.
   The output is in the closed interval :math:`[0, \pi]`

   .. math::
   arccos([-1, -.707, 0, .707, 1]) = [\pi, 3\pi/4, \pi/2, \pi/4, 0]

   The storage type of ``arccos`` output is always dense



   Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L123
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>The input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="ac929f416184542490856da5dceb576e0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::arccos </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns element-wise inverse cosine of the input array. </p><pre class="fragment">   The input should be in range `[-1, 1]`.
   The output is in the closed interval :math:`[0, \pi]`

   .. math::
   arccos([-1, -.707, 0, .707, 1]) = [\pi, 3\pi/4, \pi/2, \pi/4, 0]

   The storage type of ``arccos`` output is always dense



   Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L123
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>The input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a770fe932da849a51041d4c81fb5813eb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::arccosh </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns the element-wise inverse hyperbolic cosine of the input array, \ computed element-wise.</p>
<p>The storage type of <code>arccosh</code> output is always dense</p>
<pre class="fragment">   Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L264
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>The input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="af6e15db07037f9720aa48fd14a936435"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::arccosh </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns the element-wise inverse hyperbolic cosine of the input array, \ computed element-wise.</p>
<p>The storage type of <code>arccosh</code> output is always dense</p>
<pre class="fragment">   Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L264
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>The input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a83f1b49ee746d95b35455db325cb43b2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::arcsin </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns element-wise inverse sine of the input array. </p><pre class="fragment">   The input should be in the range `[-1, 1]`.
   The output is in the closed interval of [:math:`-\pi/2`, :math:`\pi/2`].

   .. math::
   arcsin([-1, -.707, 0, .707, 1]) = [-\pi/2, -\pi/4, 0, \pi/4, \pi/2]

   The storage type of ``arcsin`` output depends upon the input storage type:

   - arcsin(default) = default
   - arcsin(row_sparse) = row_sparse
   - arcsin(csr) = csr



   Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L104
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>The input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="ab5e1c9afb36308e15becec2d3da1eb14"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::arcsin </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns element-wise inverse sine of the input array. </p><pre class="fragment">   The input should be in the range `[-1, 1]`.
   The output is in the closed interval of [:math:`-\pi/2`, :math:`\pi/2`].

   .. math::
   arcsin([-1, -.707, 0, .707, 1]) = [-\pi/2, -\pi/4, 0, \pi/4, \pi/2]

   The storage type of ``arcsin`` output depends upon the input storage type:

   - arcsin(default) = default
   - arcsin(row_sparse) = row_sparse
   - arcsin(csr) = csr



   Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L104
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>The input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="ac3e49781b6a98c88ca180cf0ea2efeda"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::arcsinh </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns the element-wise inverse hyperbolic sine of the input array, \ computed element-wise.</p>
<p>The storage type of <code>arcsinh</code> output depends upon the input storage type:</p>
<ul>
<li>arcsinh(default) = default</li>
<li>arcsinh(row_sparse) = row_sparse</li>
<li>arcsinh(csr) = csr</li>
</ul>
<pre class="fragment">   Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L250
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>The input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a3adaa6bd5111a3861d0d95d53695a1f7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::arcsinh </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns the element-wise inverse hyperbolic sine of the input array, \ computed element-wise.</p>
<p>The storage type of <code>arcsinh</code> output depends upon the input storage type:</p>
<ul>
<li>arcsinh(default) = default</li>
<li>arcsinh(row_sparse) = row_sparse</li>
<li>arcsinh(csr) = csr</li>
</ul>
<pre class="fragment">   Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L250
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>The input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="ac11da62275a42842ed73b5ddebc3cb3e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::arctan </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns element-wise inverse tangent of the input array. </p><pre class="fragment">   The output is in the closed interval :math:`[-\pi/2, \pi/2]`

   .. math::
   arctan([-1, 0, 1]) = [-\pi/4, 0, \pi/4]

   The storage type of ``arctan`` output depends upon the input storage type:

   - arctan(default) = default
   - arctan(row_sparse) = row_sparse
   - arctan(csr) = csr



   Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L144
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>The input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="af6acbdebc6651f65467047dba8c513f8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::arctan </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns element-wise inverse tangent of the input array. </p><pre class="fragment">   The output is in the closed interval :math:`[-\pi/2, \pi/2]`

   .. math::
   arctan([-1, 0, 1]) = [-\pi/4, 0, \pi/4]

   The storage type of ``arctan`` output depends upon the input storage type:

   - arctan(default) = default
   - arctan(row_sparse) = row_sparse
   - arctan(csr) = csr



   Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L144
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>The input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="ab3405be554e12ac47416461e1d01c135"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::arctanh </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns the element-wise inverse hyperbolic tangent of the input array, \ computed element-wise.</p>
<p>The storage type of <code>arctanh</code> output depends upon the input storage type:</p>
<ul>
<li>arctanh(default) = default</li>
<li>arctanh(row_sparse) = row_sparse</li>
<li>arctanh(csr) = csr</li>
</ul>
<pre class="fragment">   Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L281
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>The input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a4adf7ce32bade72c150b55f04171ea13"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::arctanh </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns the element-wise inverse hyperbolic tangent of the input array, \ computed element-wise.</p>
<p>The storage type of <code>arctanh</code> output depends upon the input storage type:</p>
<ul>
<li>arctanh(default) = default</li>
<li>arctanh(row_sparse) = row_sparse</li>
<li>arctanh(csr) = csr</li>
</ul>
<pre class="fragment">   Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L281
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>The input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="ae6b8b033ea83e25bc0822c87a78f23d6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::argmax </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">dmlc::optional&lt; int &gt; </td>
<td class="paramname"><em>axis</em> = <code>dmlc::optional&lt;int&gt;()</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>keepdims</em> = <code>false</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns indices of the maximum values along an axis. </p><pre class="fragment">   In the case of multiple occurrences of maximum values, the indices
   are returned.

   Examples::

   x = [[ 0.,  1.,  2.],
   [ 3.,  4.,  5.]]

   // argmax along axis 0
   argmax(x, axis=0) = [ 1.,  1.,  1.]

   // argmax along axis 1
   argmax(x, axis=1) = [ 2.,  2.]

   // argmax along axis 1 keeping same dims as an input array
   argmax(x, axis=1, keepdims=True) = [[ 2.],
   [ 2.]]



   Defined in src/operator/tensor/broadcast_reduce_op_index.cc:L52
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>The input </td></tr>
<tr><td class="paramname">axis</td><td>The axis along which to perform the reduction. Negative values means indexing from right to left. `<code>Requires axis to be set as int, because global \param keepdims If this is set to</code>True`, the reduced axis is left in the result as </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a5845ab343136c5886f9b07634ce8a7e9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::argmax </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">dmlc::optional&lt; int &gt; </td>
<td class="paramname"><em>axis</em> = <code>dmlc::optional&lt;int&gt;()</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>keepdims</em> = <code>false</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns indices of the maximum values along an axis. </p><pre class="fragment">   In the case of multiple occurrences of maximum values, the indices
   are returned.

   Examples::

   x = [[ 0.,  1.,  2.],
   [ 3.,  4.,  5.]]

   // argmax along axis 0
   argmax(x, axis=0) = [ 1.,  1.,  1.]

   // argmax along axis 1
   argmax(x, axis=1) = [ 2.,  2.]

   // argmax along axis 1 keeping same dims as an input array
   argmax(x, axis=1, keepdims=True) = [[ 2.],
   [ 2.]]



   Defined in src/operator/tensor/broadcast_reduce_op_index.cc:L52
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>The input </td></tr>
<tr><td class="paramname">axis</td><td>The axis along which to perform the reduction. Negative values means indexing from right to left. `<code>Requires axis to be set as int, because global \param keepdims If this is set to</code>True`, the reduced axis is left in the result as </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a8c000f6d54bdad0b6d863f03e20a9dc6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::argmax_channel </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns argmax indices of each channel from the input array. </p><pre class="fragment">   The result will be an NDArray of shape (num_channel,).

   In case of multiple occurrences of the maximum values, the indices
   are returned.

   Examples::

   x = [[ 0.,  1.,  2.],
   [ 3.,  4.,  5.]]

   argmax_channel(x) = [ 2.,  2.]



   Defined in src/operator/tensor/broadcast_reduce_op_index.cc:L97
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>The input array </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="afb2a56ed90bd0bb455100596658f56b6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::argmax_channel </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns argmax indices of each channel from the input array. </p><pre class="fragment">   The result will be an NDArray of shape (num_channel,).

   In case of multiple occurrences of the maximum values, the indices
   are returned.

   Examples::

   x = [[ 0.,  1.,  2.],
   [ 3.,  4.,  5.]]

   argmax_channel(x) = [ 2.,  2.]



   Defined in src/operator/tensor/broadcast_reduce_op_index.cc:L97
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>The input array </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="abc1b7a27d05bb8e4ae3b29f3870905a8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::argmin </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">dmlc::optional&lt; int &gt; </td>
<td class="paramname"><em>axis</em> = <code>dmlc::optional&lt;int&gt;()</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>keepdims</em> = <code>false</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns indices of the minimum values along an axis. </p><pre class="fragment">   In the case of multiple occurrences of minimum values, the indices
   are returned.

   Examples::

   x = [[ 0.,  1.,  2.],
   [ 3.,  4.,  5.]]

   // argmin along axis 0
   argmin(x, axis=0) = [ 0.,  0.,  0.]

   // argmin along axis 1
   argmin(x, axis=1) = [ 0.,  0.]

   // argmin along axis 1 keeping same dims as an input array
   argmin(x, axis=1, keepdims=True) = [[ 0.],
   [ 0.]]



   Defined in src/operator/tensor/broadcast_reduce_op_index.cc:L77
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>The input </td></tr>
<tr><td class="paramname">axis</td><td>The axis along which to perform the reduction. Negative values means indexing from right to left. `<code>Requires axis to be set as int, because global \param keepdims If this is set to</code>True`, the reduced axis is left in the result as </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a7c44748e789575d0b9c7a9e268e1e9b6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::argmin </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">dmlc::optional&lt; int &gt; </td>
<td class="paramname"><em>axis</em> = <code>dmlc::optional&lt;int&gt;()</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>keepdims</em> = <code>false</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns indices of the minimum values along an axis. </p><pre class="fragment">   In the case of multiple occurrences of minimum values, the indices
   are returned.

   Examples::

   x = [[ 0.,  1.,  2.],
   [ 3.,  4.,  5.]]

   // argmin along axis 0
   argmin(x, axis=0) = [ 0.,  0.,  0.]

   // argmin along axis 1
   argmin(x, axis=1) = [ 0.,  0.]

   // argmin along axis 1 keeping same dims as an input array
   argmin(x, axis=1, keepdims=True) = [[ 0.],
   [ 0.]]



   Defined in src/operator/tensor/broadcast_reduce_op_index.cc:L77
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>The input </td></tr>
<tr><td class="paramname">axis</td><td>The axis along which to perform the reduction. Negative values means indexing from right to left. `<code>Requires axis to be set as int, because global \param keepdims If this is set to</code>True`, the reduced axis is left in the result as </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="abaf0ff49d19c04690a7632562ee8bbf9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::argsort </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">dmlc::optional&lt; int &gt; </td>
<td class="paramname"><em>axis</em> = <code>dmlc::optional&lt;int&gt;(-1)</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>is_ascend</em> = <code>true</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespacemxnet_1_1cpp.html#ae9d179e796188c53f2d2a36dfde2bd7a">ArgsortDtype</a> </td>
<td class="paramname"><em>dtype</em> = <code><a class="el" href="namespacemxnet_1_1cpp.html#a8e907a5fbbe4ec21628e500b34a5f35da9a78d6a569d086b524c3caf8c2522f96">ArgsortDtype::kFloat32</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns the indices that would sort an input array along the given axis. </p><pre class="fragment">   This function performs sorting along the given axis and returns an array of
   as an input array that index data in sorted order.

   Examples::

   x = [[ 0.3,  0.2,  0.4],
   [ 0.1,  0.3,  0.2]]

   // sort along axis -1
   argsort(x) = [[ 1.,  0.,  2.],
   [ 0.,  2.,  1.]]

   // sort along axis 0
   argsort(x, axis=0) = [[ 1.,  0.,  1.]
   [ 0.,  1.,  0.]]

   // flatten and then sort
   argsort(x) = [ 3.,  1.,  5.,  0.,  4.,  2.]


   Defined in src/operator/tensor/ordering_op.cc:L177
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>The input array </td></tr>
<tr><td class="paramname">axis</td><td>Axis along which to sort the input tensor. If not given, the flattened </td></tr>
<tr><td class="paramname">is_ascend</td><td>Whether to sort in ascending or descending order. </td></tr>
<tr><td class="paramname">dtype</td><td>DType of the output indices. It is only valid when ret_typ is "indices" or "both". An error will be raised if the selected data type cannot precisely </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a4c4f3ce514cc11731819fcae1e40d575"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::argsort </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">dmlc::optional&lt; int &gt; </td>
<td class="paramname"><em>axis</em> = <code>dmlc::optional&lt;int&gt;(-1)</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>is_ascend</em> = <code>true</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespacemxnet_1_1cpp.html#ae9d179e796188c53f2d2a36dfde2bd7a">ArgsortDtype</a> </td>
<td class="paramname"><em>dtype</em> = <code><a class="el" href="namespacemxnet_1_1cpp.html#a8e907a5fbbe4ec21628e500b34a5f35da9a78d6a569d086b524c3caf8c2522f96">ArgsortDtype::kFloat32</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns the indices that would sort an input array along the given axis. </p><pre class="fragment">   This function performs sorting along the given axis and returns an array of
   as an input array that index data in sorted order.

   Examples::

   x = [[ 0.3,  0.2,  0.4],
   [ 0.1,  0.3,  0.2]]

   // sort along axis -1
   argsort(x) = [[ 1.,  0.,  2.],
   [ 0.,  2.,  1.]]

   // sort along axis 0
   argsort(x, axis=0) = [[ 1.,  0.,  1.]
   [ 0.,  1.,  0.]]

   // flatten and then sort
   argsort(x) = [ 3.,  1.,  5.,  0.,  4.,  2.]


   Defined in src/operator/tensor/ordering_op.cc:L177
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>The input array </td></tr>
<tr><td class="paramname">axis</td><td>Axis along which to sort the input tensor. If not given, the flattened </td></tr>
<tr><td class="paramname">is_ascend</td><td>Whether to sort in ascending or descending order. </td></tr>
<tr><td class="paramname">dtype</td><td>DType of the output indices. It is only valid when ret_typ is "indices" or "both". An error will be raised if the selected data type cannot precisely </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="ad6517a533737c0980bdc4d0074682f33"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::batch_dot </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>rhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>transpose_a</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>transpose_b</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespacemxnet_1_1cpp.html#a45bddc3aa629f2554f95429b0a270a16">Batch_dotForwardStype</a> </td>
<td class="paramname"><em>forward_stype</em> = <code><a class="el" href="namespacemxnet_1_1cpp.html#aa5dbdd69827034fc43c16cf350db7e1ea35c3ace1970663a16e5c65baa5941b13">Batch_dotForwardStype::kNone</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Batchwise dot product. </p><pre class="fragment">   ``batch_dot`` is used to compute dot product of ``x`` and ``y`` when ``x`` and
   ``y`` are data in batch, namely 3D arrays in shape of `(batch_size, :, :)`.

   For example, given ``x`` with shape `(batch_size, n, m)` and ``y`` with shape
   `(batch_size, m, k)`, the result array will have shape `(batch_size, n, k)`,
   which is computed by::

   batch_dot(x,y)[i,:,:] = dot(x[i,:,:], y[i,:,:])



   Defined in src/operator/tensor/dot.cc:L125
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">lhs</td><td>The first input </td></tr>
<tr><td class="paramname">rhs</td><td>The second input </td></tr>
<tr><td class="paramname">transpose_a</td><td>If true then transpose the first input before dot. </td></tr>
<tr><td class="paramname">transpose_b</td><td>If true then transpose the second input before dot. </td></tr>
<tr><td class="paramname">forward_stype</td><td>The desired storage type of the forward output given by user, if thecombination of input storage types and this hint does not matchany implemented ones, the dot operator will perform fallback operationand still </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a645c26abadf60e2e669218b375f8de8a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::batch_dot </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>rhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>transpose_a</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>transpose_b</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespacemxnet_1_1cpp.html#a45bddc3aa629f2554f95429b0a270a16">Batch_dotForwardStype</a> </td>
<td class="paramname"><em>forward_stype</em> = <code><a class="el" href="namespacemxnet_1_1cpp.html#aa5dbdd69827034fc43c16cf350db7e1ea35c3ace1970663a16e5c65baa5941b13">Batch_dotForwardStype::kNone</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Batchwise dot product. </p><pre class="fragment">   ``batch_dot`` is used to compute dot product of ``x`` and ``y`` when ``x`` and
   ``y`` are data in batch, namely 3D arrays in shape of `(batch_size, :, :)`.

   For example, given ``x`` with shape `(batch_size, n, m)` and ``y`` with shape
   `(batch_size, m, k)`, the result array will have shape `(batch_size, n, k)`,
   which is computed by::

   batch_dot(x,y)[i,:,:] = dot(x[i,:,:], y[i,:,:])



   Defined in src/operator/tensor/dot.cc:L125
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">lhs</td><td>The first input </td></tr>
<tr><td class="paramname">rhs</td><td>The second input </td></tr>
<tr><td class="paramname">transpose_a</td><td>If true then transpose the first input before dot. </td></tr>
<tr><td class="paramname">transpose_b</td><td>If true then transpose the second input before dot. </td></tr>
<tr><td class="paramname">forward_stype</td><td>The desired storage type of the forward output given by user, if thecombination of input storage types and this hint does not matchany implemented ones, the dot operator will perform fallback operationand still </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="ac2ca26e7aa7ee6e517ea01112832ea88"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::batch_take </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>a</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>indices</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Takes elements from a data batch. </p><pre class="fragment">   .. note::
   `batch_take` is deprecated. Use `pick` instead.

   Given an input array of shape ``(d0, d1)`` and indices of shape ``(i0,)``, the
   an output array of shape ``(i0,)`` with::

   output[i] = input[i, indices[i]]

   Examples::

   x = [[ 1.,  2.],
   [ 3.,  4.],
   [ 5.,  6.]]

   // takes elements with specified indices
   batch_take(x, [0,1,0]) = [ 1.  4.  5.]



   Defined in src/operator/tensor/indexing_op.cc:L490
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">a</td><td>The input array </td></tr>
<tr><td class="paramname">indices</td><td>The index array </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a69f187e1e2a56b1e753b32faefd8ab4d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::batch_take </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>a</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>indices</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Takes elements from a data batch. </p><pre class="fragment">   .. note::
   `batch_take` is deprecated. Use `pick` instead.

   Given an input array of shape ``(d0, d1)`` and indices of shape ``(i0,)``, the
   an output array of shape ``(i0,)`` with::

   output[i] = input[i, indices[i]]

   Examples::

   x = [[ 1.,  2.],
   [ 3.,  4.],
   [ 5.,  6.]]

   // takes elements with specified indices
   batch_take(x, [0,1,0]) = [ 1.  4.  5.]



   Defined in src/operator/tensor/indexing_op.cc:L490
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">a</td><td>The input array </td></tr>
<tr><td class="paramname">indices</td><td>The index array </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a7a48ca9bedc133b0c335d2fe54a3acec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::BatchNorm </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>gamma</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>beta</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>moving_mean</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>moving_var</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double </td>
<td class="paramname"><em>eps</em> = <code>0.001</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>momentum</em> = <code>0.9</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>fix_gamma</em> = <code>true</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>use_global_stats</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>output_mean_var</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>axis</em> = <code>1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>cudnn_off</em> = <code>false</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Batch normalization. </p><pre class="fragment">   Normalizes a data batch by mean and variance, and applies a scale ``gamma`` as
   well as offset ``beta``.

   Assume the input has more than one dimension and we normalize along axis 1.
   We first compute the mean and variance along this axis:

   .. math::

   data\_mean[i] = mean(data[:,i,:,...]) \\
   data\_var[i] = var(data[:,i,:,...])

   Then compute the normalized output, which has the same shape as input, as

   .. math::

   out[:,i,:,...] = \frac{data[:,i,:,...] -

   Both *mean* and *var* returns a scalar by treating the input as a vector.

   Assume the input has size *k* on axis 1, then both ``gamma`` and ``beta``
   have shape *(k,)*. If ``output_mean_var`` is set to be true, then outputs both
   the inverse of ``data_var``, which are needed for the backward pass. Note that
   two outputs are blocked.

   Besides the inputs and the outputs, this operator accepts two auxiliary
   states, ``moving_mean`` and ``moving_var``, which are *k*-length
   vectors. They are global statistics for the whole dataset, which are updated
   by::

   moving_mean = moving_mean * momentum + data_mean * (1 - momentum)
   moving_var = moving_var * momentum + data_var * (1 - momentum)

   If ``use_global_stats`` is set to be true, then ``moving_mean`` and
   ``moving_var`` are used instead of ``data_mean`` and ``data_var`` to compute
   the output. It is often used during inference.

   The parameter ``axis`` specifies which axis of the input shape denotes
   the 'channel' (separately normalized groups).  The default is 1.  Specifying -1
   axis to be the last item in the input shape.

   Both ``gamma`` and ``beta`` are learnable parameters. But if ``fix_gamma`` is
   then set ``gamma`` to 1 and its gradient to 0.

   Note::

   When fix_gamma is set to True, no sparse support is provided. If fix_gamma is
   the sparse tensors will fallback.



   Defined in src/operator/nn/batch_norm.cc:L574
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>Input data to batch normalization </td></tr>
<tr><td class="paramname">gamma</td><td>gamma array </td></tr>
<tr><td class="paramname">beta</td><td>beta array </td></tr>
<tr><td class="paramname">moving_mean</td><td>running mean of input </td></tr>
<tr><td class="paramname">moving_var</td><td>running variance of input </td></tr>
<tr><td class="paramname">eps</td><td>Epsilon to prevent div 0. Must be no less than CUDNN_BN_MIN_EPSILON defined </td></tr>
<tr><td class="paramname">momentum</td><td>Momentum for moving average </td></tr>
<tr><td class="paramname">fix_gamma</td><td>Fix gamma while training </td></tr>
<tr><td class="paramname">use_global_stats</td><td>Whether use global moving statistics instead of local </td></tr>
<tr><td class="paramname">output_mean_var</td><td>Output the mean and inverse std </td></tr>
<tr><td class="paramname">axis</td><td>Specify which shape axis the channel is specified </td></tr>
<tr><td class="paramname">cudnn_off</td><td>Do not select CUDNN operator, if available </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="ab30261f412bbc66c92742f5cb3b4843b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::BatchNorm </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>gamma</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>beta</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>moving_mean</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>moving_var</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double </td>
<td class="paramname"><em>eps</em> = <code>0.001</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>momentum</em> = <code>0.9</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>fix_gamma</em> = <code>true</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>use_global_stats</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>output_mean_var</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>axis</em> = <code>1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>cudnn_off</em> = <code>false</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Batch normalization. </p><pre class="fragment">   Normalizes a data batch by mean and variance, and applies a scale ``gamma`` as
   well as offset ``beta``.

   Assume the input has more than one dimension and we normalize along axis 1.
   We first compute the mean and variance along this axis:

   .. math::

   data\_mean[i] = mean(data[:,i,:,...]) \\
   data\_var[i] = var(data[:,i,:,...])

   Then compute the normalized output, which has the same shape as input, as

   .. math::

   out[:,i,:,...] = \frac{data[:,i,:,...] -

   Both *mean* and *var* returns a scalar by treating the input as a vector.

   Assume the input has size *k* on axis 1, then both ``gamma`` and ``beta``
   have shape *(k,)*. If ``output_mean_var`` is set to be true, then outputs both
   the inverse of ``data_var``, which are needed for the backward pass. Note that
   two outputs are blocked.

   Besides the inputs and the outputs, this operator accepts two auxiliary
   states, ``moving_mean`` and ``moving_var``, which are *k*-length
   vectors. They are global statistics for the whole dataset, which are updated
   by::

   moving_mean = moving_mean * momentum + data_mean * (1 - momentum)
   moving_var = moving_var * momentum + data_var * (1 - momentum)

   If ``use_global_stats`` is set to be true, then ``moving_mean`` and
   ``moving_var`` are used instead of ``data_mean`` and ``data_var`` to compute
   the output. It is often used during inference.

   The parameter ``axis`` specifies which axis of the input shape denotes
   the 'channel' (separately normalized groups).  The default is 1.  Specifying -1
   axis to be the last item in the input shape.

   Both ``gamma`` and ``beta`` are learnable parameters. But if ``fix_gamma`` is
   then set ``gamma`` to 1 and its gradient to 0.

   Note::

   When fix_gamma is set to True, no sparse support is provided. If fix_gamma is
   the sparse tensors will fallback.



   Defined in src/operator/nn/batch_norm.cc:L574
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>Input data to batch normalization </td></tr>
<tr><td class="paramname">gamma</td><td>gamma array </td></tr>
<tr><td class="paramname">beta</td><td>beta array </td></tr>
<tr><td class="paramname">moving_mean</td><td>running mean of input </td></tr>
<tr><td class="paramname">moving_var</td><td>running variance of input </td></tr>
<tr><td class="paramname">eps</td><td>Epsilon to prevent div 0. Must be no less than CUDNN_BN_MIN_EPSILON defined </td></tr>
<tr><td class="paramname">momentum</td><td>Momentum for moving average </td></tr>
<tr><td class="paramname">fix_gamma</td><td>Fix gamma while training </td></tr>
<tr><td class="paramname">use_global_stats</td><td>Whether use global moving statistics instead of local </td></tr>
<tr><td class="paramname">output_mean_var</td><td>Output the mean and inverse std </td></tr>
<tr><td class="paramname">axis</td><td>Specify which shape axis the channel is specified </td></tr>
<tr><td class="paramname">cudnn_off</td><td>Do not select CUDNN operator, if available </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a038dcc0c2387bd718379bb8a53e43728"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::BatchNorm_v1 </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>gamma</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>beta</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>eps</em> = <code>0.001</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>momentum</em> = <code>0.9</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>fix_gamma</em> = <code>true</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>use_global_stats</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>output_mean_var</em> = <code>false</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Batch normalization. </p><pre class="fragment">   This operator is DEPRECATED. Perform BatchNorm on the input.

   Normalizes a data batch by mean and variance, and applies a scale ``gamma`` as
   well as offset ``beta``.

   Assume the input has more than one dimension and we normalize along axis 1.
   We first compute the mean and variance along this axis:

   .. math::

   data\_mean[i] = mean(data[:,i,:,...]) \\
   data\_var[i] = var(data[:,i,:,...])

   Then compute the normalized output, which has the same shape as input, as

   .. math::

   out[:,i,:,...] = \frac{data[:,i,:,...] -

   Both *mean* and *var* returns a scalar by treating the input as a vector.

   Assume the input has size *k* on axis 1, then both ``gamma`` and ``beta``
   have shape *(k,)*. If ``output_mean_var`` is set to be true, then outputs both
   ``data_var`` as well, which are needed for the backward pass.

   Besides the inputs and the outputs, this operator accepts two auxiliary
   states, ``moving_mean`` and ``moving_var``, which are *k*-length
   vectors. They are global statistics for the whole dataset, which are updated
   by::

   moving_mean = moving_mean * momentum + data_mean * (1 - momentum)
   moving_var = moving_var * momentum + data_var * (1 - momentum)

   If ``use_global_stats`` is set to be true, then ``moving_mean`` and
   ``moving_var`` are used instead of ``data_mean`` and ``data_var`` to compute
   the output. It is often used during inference.

   Both ``gamma`` and ``beta`` are learnable parameters. But if ``fix_gamma`` is
   then set ``gamma`` to 1 and its gradient to 0.

   There's no sparse support for this operator, and it will exhibit problematic
   sparse tensors.



   Defined in src/operator/batch_norm_v1.cc:L95
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>Input data to batch normalization </td></tr>
<tr><td class="paramname">gamma</td><td>gamma array </td></tr>
<tr><td class="paramname">beta</td><td>beta array </td></tr>
<tr><td class="paramname">eps</td><td>Epsilon to prevent div 0 </td></tr>
<tr><td class="paramname">momentum</td><td>Momentum for moving average </td></tr>
<tr><td class="paramname">fix_gamma</td><td>Fix gamma while training </td></tr>
<tr><td class="paramname">use_global_stats</td><td>Whether use global moving statistics instead of local </td></tr>
<tr><td class="paramname">output_mean_var</td><td>Output All,normal mean and var </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="aa1cb8af78b859b2656be285343fb7ac4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::BatchNorm_v1 </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>gamma</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>beta</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>eps</em> = <code>0.001</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>momentum</em> = <code>0.9</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>fix_gamma</em> = <code>true</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>use_global_stats</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>output_mean_var</em> = <code>false</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Batch normalization. </p><pre class="fragment">   This operator is DEPRECATED. Perform BatchNorm on the input.

   Normalizes a data batch by mean and variance, and applies a scale ``gamma`` as
   well as offset ``beta``.

   Assume the input has more than one dimension and we normalize along axis 1.
   We first compute the mean and variance along this axis:

   .. math::

   data\_mean[i] = mean(data[:,i,:,...]) \\
   data\_var[i] = var(data[:,i,:,...])

   Then compute the normalized output, which has the same shape as input, as

   .. math::

   out[:,i,:,...] = \frac{data[:,i,:,...] -

   Both *mean* and *var* returns a scalar by treating the input as a vector.

   Assume the input has size *k* on axis 1, then both ``gamma`` and ``beta``
   have shape *(k,)*. If ``output_mean_var`` is set to be true, then outputs both
   ``data_var`` as well, which are needed for the backward pass.

   Besides the inputs and the outputs, this operator accepts two auxiliary
   states, ``moving_mean`` and ``moving_var``, which are *k*-length
   vectors. They are global statistics for the whole dataset, which are updated
   by::

   moving_mean = moving_mean * momentum + data_mean * (1 - momentum)
   moving_var = moving_var * momentum + data_var * (1 - momentum)

   If ``use_global_stats`` is set to be true, then ``moving_mean`` and
   ``moving_var`` are used instead of ``data_mean`` and ``data_var`` to compute
   the output. It is often used during inference.

   Both ``gamma`` and ``beta`` are learnable parameters. But if ``fix_gamma`` is
   then set ``gamma`` to 1 and its gradient to 0.

   There's no sparse support for this operator, and it will exhibit problematic
   sparse tensors.



   Defined in src/operator/batch_norm_v1.cc:L95
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>Input data to batch normalization </td></tr>
<tr><td class="paramname">gamma</td><td>gamma array </td></tr>
<tr><td class="paramname">beta</td><td>beta array </td></tr>
<tr><td class="paramname">eps</td><td>Epsilon to prevent div 0 </td></tr>
<tr><td class="paramname">momentum</td><td>Momentum for moving average </td></tr>
<tr><td class="paramname">fix_gamma</td><td>Fix gamma while training </td></tr>
<tr><td class="paramname">use_global_stats</td><td>Whether use global moving statistics instead of local </td></tr>
<tr><td class="paramname">output_mean_var</td><td>Output All,normal mean and var </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="ac4bda567b553b5e0b7b2bf26206e4b3a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::BilinearSampler </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>grid</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Applies bilinear sampling to input feature map. </p><pre class="fragment">   Bilinear Sampling is the key of  [NIPS2015] \"Spatial Transformer Networks\".
   except that the operator has the backward pass.

   Given :math:`data` and :math:`grid`, then the output is computed by

   .. math::
   x_{src} = grid[batch, 0, y_{dst}, x_{dst}] \\
   y_{src} = grid[batch, 1, y_{dst}, x_{dst}] \\
   output[batch, channel, y_{dst}, x_{dst}] = G(data[batch, channel, y_{src},

   :math:`x_{dst}`, :math:`y_{dst}` enumerate all spatial locations in
   The out-boundary points will be padded with zeros.The shape of the output will

   The operator assumes that :math:`data` has 'NCHW' layout and :math:`grid` has

   BilinearSampler often cooperates with GridGenerator which generates sampling
   GridGenerator supports two kinds of transformation: ``affine`` and ``warp``.
   If users want to design a CustomOp to manipulate :math:`grid`, please firstly

   Example 1::

   ## Zoom out data two times
   data = array([[[[1, 4, 3, 6],
   [1, 8, 8, 9],
   [0, 4, 1, 5],
   [1, 0, 1, 3]]]])

   affine_matrix = array([[2, 0, 0],
   [0, 2, 0]])

   affine_matrix = reshape(affine_matrix, shape=(1, 6))

   grid = GridGenerator(data=affine_matrix, transform_type='affine',

   out = BilinearSampler(data, grid)

   out
   [[[[ 0,   0,     0,   0],
   [ 0,   3.5,   6.5, 0],
   [ 0,   1.25,  2.5, 0],
   [ 0,   0,     0,   0]]]


   Example 2::

   ## shift data horizontally by -1 pixel

   data = array([[[[1, 4, 3, 6],
   [1, 8, 8, 9],
   [0, 4, 1, 5],
   [1, 0, 1, 3]]]])

   warp_maxtrix = array([[[[1, 1, 1, 1],
   [1, 1, 1, 1],
   [1, 1, 1, 1],
   [1, 1, 1, 1]],
   [[0, 0, 0, 0],
   [0, 0, 0, 0],
   [0, 0, 0, 0],
   [0, 0, 0, 0]]]])

   grid = GridGenerator(data=warp_matrix, transform_type='warp')
   out = BilinearSampler(data, grid)

   out
   [[[[ 4,  3,  6,  0],
   [ 8,  8,  9,  0],
   [ 4,  1,  5,  0],
   [ 0,  1,  3,  0]]]


   Defined in src/operator/bilinear_sampler.cc:L245
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>Input data to the BilinearsamplerOp. </td></tr>
<tr><td class="paramname">grid</td><td>Input grid to the BilinearsamplerOp.grid has two channels: x_src, y_src </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a697fcbff4756f58328820e697b4c2e6a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::BilinearSampler </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>grid</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Applies bilinear sampling to input feature map. </p><pre class="fragment">   Bilinear Sampling is the key of  [NIPS2015] \"Spatial Transformer Networks\".
   except that the operator has the backward pass.

   Given :math:`data` and :math:`grid`, then the output is computed by

   .. math::
   x_{src} = grid[batch, 0, y_{dst}, x_{dst}] \\
   y_{src} = grid[batch, 1, y_{dst}, x_{dst}] \\
   output[batch, channel, y_{dst}, x_{dst}] = G(data[batch, channel, y_{src},

   :math:`x_{dst}`, :math:`y_{dst}` enumerate all spatial locations in
   The out-boundary points will be padded with zeros.The shape of the output will

   The operator assumes that :math:`data` has 'NCHW' layout and :math:`grid` has

   BilinearSampler often cooperates with GridGenerator which generates sampling
   GridGenerator supports two kinds of transformation: ``affine`` and ``warp``.
   If users want to design a CustomOp to manipulate :math:`grid`, please firstly

   Example 1::

   ## Zoom out data two times
   data = array([[[[1, 4, 3, 6],
   [1, 8, 8, 9],
   [0, 4, 1, 5],
   [1, 0, 1, 3]]]])

   affine_matrix = array([[2, 0, 0],
   [0, 2, 0]])

   affine_matrix = reshape(affine_matrix, shape=(1, 6))

   grid = GridGenerator(data=affine_matrix, transform_type='affine',

   out = BilinearSampler(data, grid)

   out
   [[[[ 0,   0,     0,   0],
   [ 0,   3.5,   6.5, 0],
   [ 0,   1.25,  2.5, 0],
   [ 0,   0,     0,   0]]]


   Example 2::

   ## shift data horizontally by -1 pixel

   data = array([[[[1, 4, 3, 6],
   [1, 8, 8, 9],
   [0, 4, 1, 5],
   [1, 0, 1, 3]]]])

   warp_maxtrix = array([[[[1, 1, 1, 1],
   [1, 1, 1, 1],
   [1, 1, 1, 1],
   [1, 1, 1, 1]],
   [[0, 0, 0, 0],
   [0, 0, 0, 0],
   [0, 0, 0, 0],
   [0, 0, 0, 0]]]])

   grid = GridGenerator(data=warp_matrix, transform_type='warp')
   out = BilinearSampler(data, grid)

   out
   [[[[ 4,  3,  6,  0],
   [ 8,  8,  9,  0],
   [ 4,  1,  5,  0],
   [ 0,  1,  3,  0]]]


   Defined in src/operator/bilinear_sampler.cc:L245
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>Input data to the BilinearsamplerOp. </td></tr>
<tr><td class="paramname">grid</td><td>Input grid to the BilinearsamplerOp.grid has two channels: x_src, y_src </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="adad94b7c3a0a17f4b9c01073cc162d0e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::BlockGrad </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Stops gradient computation. </p><pre class="fragment">   Stops the accumulated gradient of the inputs from flowing through this operator
   in the backward direction. In other words, this operator prevents the
   of its inputs to be taken into account for computing gradients.

   Example::

   v1 = [1, 2]
   v2 = [0, 1]
   a = Variable('a')
   b = Variable('b')
   b_stop_grad = stop_gradient(3 * b)
   loss = MakeLoss(b_stop_grad + a)

   executor = loss.simple_bind(ctx=cpu(), a=(1,2), b=(1,2))
   executor.forward(is_train=True, a=v1, b=v2)
   executor.outputs
   [ 1.  5.]

   executor.backward()
   executor.grad_arrays
   [ 0.  0.]
   [ 1.  1.]



   Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L265
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>The input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a906c010c5b4b27cb35fac092e8752cb8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::BlockGrad </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Stops gradient computation. </p><pre class="fragment">   Stops the accumulated gradient of the inputs from flowing through this operator
   in the backward direction. In other words, this operator prevents the
   of its inputs to be taken into account for computing gradients.

   Example::

   v1 = [1, 2]
   v2 = [0, 1]
   a = Variable('a')
   b = Variable('b')
   b_stop_grad = stop_gradient(3 * b)
   loss = MakeLoss(b_stop_grad + a)

   executor = loss.simple_bind(ctx=cpu(), a=(1,2), b=(1,2))
   executor.forward(is_train=True, a=v1, b=v2)
   executor.outputs
   [ 1.  5.]

   executor.backward()
   executor.grad_arrays
   [ 0.  0.]
   [ 1.  1.]



   Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L265
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>The input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a857af56895efd5feaa3276b6903f8cfa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::broadcast_add </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>rhs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns element-wise sum of the input arrays with broadcasting. </p><pre class="fragment">   `broadcast_plus` is an alias to the function `broadcast_add`.

   Example::

   x = [[ 1.,  1.,  1.],
   [ 1.,  1.,  1.]]

   y = [[ 0.],
   [ 1.]]

   broadcast_add(x, y) = [[ 1.,  1.,  1.],
   [ 2.,  2.,  2.]]

   broadcast_plus(x, y) = [[ 1.,  1.,  1.],
   [ 2.,  2.,  2.]]

   Supported sparse operations:

   broadcast_add(csr, dense(1D)) = dense
   broadcast_add(dense(1D), csr) = dense



   Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L58
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">lhs</td><td>First input to the function </td></tr>
<tr><td class="paramname">rhs</td><td>Second input to the function </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="ac5d476176e65f464bdbd82263305bd9d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::broadcast_add </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>rhs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns element-wise sum of the input arrays with broadcasting. </p><pre class="fragment">   `broadcast_plus` is an alias to the function `broadcast_add`.

   Example::

   x = [[ 1.,  1.,  1.],
   [ 1.,  1.,  1.]]

   y = [[ 0.],
   [ 1.]]

   broadcast_add(x, y) = [[ 1.,  1.,  1.],
   [ 2.,  2.,  2.]]

   broadcast_plus(x, y) = [[ 1.,  1.,  1.],
   [ 2.,  2.,  2.]]

   Supported sparse operations:

   broadcast_add(csr, dense(1D)) = dense
   broadcast_add(dense(1D), csr) = dense



   Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L58
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">lhs</td><td>First input to the function </td></tr>
<tr><td class="paramname">rhs</td><td>Second input to the function </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a85cc565eca8e7b366cb7875afe6e9456"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::broadcast_axis </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> </td>
<td class="paramname"><em>axis</em> = <code><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>()</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> </td>
<td class="paramname"><em>size</em> = <code><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Broadcasts the input array over particular axes. </p><pre class="fragment">   Broadcasting is allowed on axes with size 1, such as from `(2,1,3,1)` to
   `(2,8,3,9)`. Elements will be duplicated on the broadcasted axes.

   Example::

   // given x of shape (1,2,1)
   x = [[[ 1.],
   [ 2.]]]

   // broadcast x on on axis 2
   broadcast_axis(x, axis=2, size=3) = [[[ 1.,  1.,  1.],
   [ 2.,  2.,  2.]]]
   // broadcast x on on axes 0 and 2
   broadcast_axis(x, axis=(0,2), size=(2,3)) = [[[ 1.,  1.,  1.],
   [ 2.,  2.,  2.]],
   [[ 1.,  1.,  1.],
   [ 2.,  2.,  2.]]]


   Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L237
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>The input </td></tr>
<tr><td class="paramname">axis</td><td>The axes to perform the broadcasting. </td></tr>
<tr><td class="paramname">size</td><td>Target sizes of the broadcasting axes. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a8077f0726ac5436b8abcb8621cc7171c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::broadcast_axis </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> </td>
<td class="paramname"><em>axis</em> = <code><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>()</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> </td>
<td class="paramname"><em>size</em> = <code><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Broadcasts the input array over particular axes. </p><pre class="fragment">   Broadcasting is allowed on axes with size 1, such as from `(2,1,3,1)` to
   `(2,8,3,9)`. Elements will be duplicated on the broadcasted axes.

   Example::

   // given x of shape (1,2,1)
   x = [[[ 1.],
   [ 2.]]]

   // broadcast x on on axis 2
   broadcast_axis(x, axis=2, size=3) = [[[ 1.,  1.,  1.],
   [ 2.,  2.,  2.]]]
   // broadcast x on on axes 0 and 2
   broadcast_axis(x, axis=(0,2), size=(2,3)) = [[[ 1.,  1.,  1.],
   [ 2.,  2.,  2.]],
   [[ 1.,  1.,  1.],
   [ 2.,  2.,  2.]]]


   Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L237
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>The input </td></tr>
<tr><td class="paramname">axis</td><td>The axes to perform the broadcasting. </td></tr>
<tr><td class="paramname">size</td><td>Target sizes of the broadcasting axes. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a0783d947ab56edb881cbef1174df0464"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::broadcast_div </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>rhs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns element-wise division of the input arrays with broadcasting. </p><pre class="fragment">   Example::

   x = [[ 6.,  6.,  6.],
   [ 6.,  6.,  6.]]

   y = [[ 2.],
   [ 3.]]

   broadcast_div(x, y) = [[ 3.,  3.,  3.],
   [ 2.,  2.,  2.]]

   Supported sparse operations:

   broadcast_div(csr, dense(1D)) = csr



   Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L187
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">lhs</td><td>First input to the function </td></tr>
<tr><td class="paramname">rhs</td><td>Second input to the function </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a2085b9c86dc039fca8fa0954104d7680"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::broadcast_div </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>rhs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns element-wise division of the input arrays with broadcasting. </p><pre class="fragment">   Example::

   x = [[ 6.,  6.,  6.],
   [ 6.,  6.,  6.]]

   y = [[ 2.],
   [ 3.]]

   broadcast_div(x, y) = [[ 3.,  3.,  3.],
   [ 2.,  2.,  2.]]

   Supported sparse operations:

   broadcast_div(csr, dense(1D)) = csr



   Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L187
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">lhs</td><td>First input to the function </td></tr>
<tr><td class="paramname">rhs</td><td>Second input to the function </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a397580a170a0a58c4fa82369c3bac6c1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::broadcast_equal </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>rhs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns the result of element-wise <b>equal to</b> (==) comparison operation with </p><pre class="fragment">   Example::

   x = [[ 1.,  1.,  1.],
   [ 1.,  1.,  1.]]

   y = [[ 0.],
   [ 1.]]

   broadcast_equal(x, y) = [[ 0.,  0.,  0.],
   [ 1.,  1.,  1.]]



   Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L46
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">lhs</td><td>First input to the function </td></tr>
<tr><td class="paramname">rhs</td><td>Second input to the function </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="aaf8dd7668f17fe459a9d9edab573ed90"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::broadcast_equal </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>rhs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns the result of element-wise <b>equal to</b> (==) comparison operation with </p><pre class="fragment">   Example::

   x = [[ 1.,  1.,  1.],
   [ 1.,  1.,  1.]]

   y = [[ 0.],
   [ 1.]]

   broadcast_equal(x, y) = [[ 0.,  0.,  0.],
   [ 1.,  1.,  1.]]



   Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L46
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">lhs</td><td>First input to the function </td></tr>
<tr><td class="paramname">rhs</td><td>Second input to the function </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="aa2b7c2b713266388570a2e836fdf6a7a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::broadcast_greater </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>rhs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns the result of element-wise <b>greater than</b> (&gt;) comparison operation </p><pre class="fragment">   Example::

   x = [[ 1.,  1.,  1.],
   [ 1.,  1.,  1.]]

   y = [[ 0.],
   [ 1.]]

   broadcast_greater(x, y) = [[ 1.,  1.,  1.],
   [ 0.,  0.,  0.]]



   Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L82
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">lhs</td><td>First input to the function </td></tr>
<tr><td class="paramname">rhs</td><td>Second input to the function </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="ad57f372bc112aedf9f4b3e3d04f6606a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::broadcast_greater </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>rhs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns the result of element-wise <b>greater than</b> (&gt;) comparison operation </p><pre class="fragment">   Example::

   x = [[ 1.,  1.,  1.],
   [ 1.,  1.,  1.]]

   y = [[ 0.],
   [ 1.]]

   broadcast_greater(x, y) = [[ 1.,  1.,  1.],
   [ 0.,  0.,  0.]]



   Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L82
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">lhs</td><td>First input to the function </td></tr>
<tr><td class="paramname">rhs</td><td>Second input to the function </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="acc2f9980021108b8467be695fe15e9e0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::broadcast_greater_equal </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>rhs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns the result of element-wise <b>greater than or equal to</b> (&gt;=) comparison </p><pre class="fragment">   Example::

   x = [[ 1.,  1.,  1.],
   [ 1.,  1.,  1.]]

   y = [[ 0.],
   [ 1.]]

   broadcast_greater_equal(x, y) = [[ 1.,  1.,  1.],
   [ 1.,  1.,  1.]]



   Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L100
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">lhs</td><td>First input to the function </td></tr>
<tr><td class="paramname">rhs</td><td>Second input to the function </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a083c0e37f65cc2b54adba5c75d4db7f2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::broadcast_greater_equal </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>rhs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns the result of element-wise <b>greater than or equal to</b> (&gt;=) comparison </p><pre class="fragment">   Example::

   x = [[ 1.,  1.,  1.],
   [ 1.,  1.,  1.]]

   y = [[ 0.],
   [ 1.]]

   broadcast_greater_equal(x, y) = [[ 1.,  1.,  1.],
   [ 1.,  1.,  1.]]



   Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L100
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">lhs</td><td>First input to the function </td></tr>
<tr><td class="paramname">rhs</td><td>Second input to the function </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="adf4d0a7d7fb688d675713f068fc6cc8e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::broadcast_hypot </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>rhs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns the hypotenuse of a right angled triangle, given its "legs" with broadcasting.</p>
<p>It is equivalent to doing :math:<code>sqrt(x_1^2 + x_2^2)</code>.</p>
<p>Example::</p>
<p>x = [[ 3., 3., 3.]]</p>
<p>y = [[ 4.], [ 4.]]</p>
<p>broadcast_hypot(x, y) = [[ 5., 5., 5.], [ 5., 5., 5.]]</p>
<p>z = [[ 0.], [ 4.]]</p>
<p>broadcast_hypot(x, z) = [[ 3., 3., 3.], [ 5., 5., 5.]]</p>
<pre class="fragment">   Defined in src/operator/tensor/elemwise_binary_broadcast_op_extended.cc:L156
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">lhs</td><td>First input to the function </td></tr>
<tr><td class="paramname">rhs</td><td>Second input to the function </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a832a57607cf12279e93a0349a0615e1e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::broadcast_hypot </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>rhs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns the hypotenuse of a right angled triangle, given its "legs" with broadcasting.</p>
<p>It is equivalent to doing :math:<code>sqrt(x_1^2 + x_2^2)</code>.</p>
<p>Example::</p>
<p>x = [[ 3., 3., 3.]]</p>
<p>y = [[ 4.], [ 4.]]</p>
<p>broadcast_hypot(x, y) = [[ 5., 5., 5.], [ 5., 5., 5.]]</p>
<p>z = [[ 0.], [ 4.]]</p>
<p>broadcast_hypot(x, z) = [[ 3., 3., 3.], [ 5., 5., 5.]]</p>
<pre class="fragment">   Defined in src/operator/tensor/elemwise_binary_broadcast_op_extended.cc:L156
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">lhs</td><td>First input to the function </td></tr>
<tr><td class="paramname">rhs</td><td>Second input to the function </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="afbf2da9ec297c21d8e910d5fec9162fa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::broadcast_lesser </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>rhs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns the result of element-wise <b>lesser than</b> (&lt;) comparison operation </p><pre class="fragment">   Example::

   x = [[ 1.,  1.,  1.],
   [ 1.,  1.,  1.]]

   y = [[ 0.],
   [ 1.]]

   broadcast_lesser(x, y) = [[ 0.,  0.,  0.],
   [ 0.,  0.,  0.]]



   Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L118
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">lhs</td><td>First input to the function </td></tr>
<tr><td class="paramname">rhs</td><td>Second input to the function </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a39d4af014a63e11085a8890a75abbb53"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::broadcast_lesser </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>rhs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns the result of element-wise <b>lesser than</b> (&lt;) comparison operation </p><pre class="fragment">   Example::

   x = [[ 1.,  1.,  1.],
   [ 1.,  1.,  1.]]

   y = [[ 0.],
   [ 1.]]

   broadcast_lesser(x, y) = [[ 0.,  0.,  0.],
   [ 0.,  0.,  0.]]



   Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L118
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">lhs</td><td>First input to the function </td></tr>
<tr><td class="paramname">rhs</td><td>Second input to the function </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="adc49c8c0a60443e640a9243f5f02af71"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::broadcast_lesser_equal </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>rhs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns the result of element-wise <b>lesser than or equal to</b> (&lt;=) comparison </p><pre class="fragment">   Example::

   x = [[ 1.,  1.,  1.],
   [ 1.,  1.,  1.]]

   y = [[ 0.],
   [ 1.]]

   broadcast_lesser_equal(x, y) = [[ 0.,  0.,  0.],
   [ 1.,  1.,  1.]]



   Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L136
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">lhs</td><td>First input to the function </td></tr>
<tr><td class="paramname">rhs</td><td>Second input to the function </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="ad14ffebee29ee1452d791923a509b528"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::broadcast_lesser_equal </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>rhs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns the result of element-wise <b>lesser than or equal to</b> (&lt;=) comparison </p><pre class="fragment">   Example::

   x = [[ 1.,  1.,  1.],
   [ 1.,  1.,  1.]]

   y = [[ 0.],
   [ 1.]]

   broadcast_lesser_equal(x, y) = [[ 0.,  0.,  0.],
   [ 1.,  1.,  1.]]



   Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L136
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">lhs</td><td>First input to the function </td></tr>
<tr><td class="paramname">rhs</td><td>Second input to the function </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="ac03d576fd1307e3f1e6a63a6447e7d0d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::broadcast_like </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>rhs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Broadcasts lhs to have the same shape as rhs. </p><pre class="fragment">   Broadcasting is a mechanism that allows NDArrays to perform arithmetic
   with arrays of different shapes efficiently without creating multiple copies of
   Also see, `Broadcasting
   &lt;https://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&gt;`_ for more

   Broadcasting is allowed on axes with size 1, such as from `(2,1,3,1)` to
   `(2,8,3,9)`. Elements will be duplicated on the broadcasted axes.

   For example::

   broadcast_like([[1,2,3]], [[5,6,7],[7,8,9]]) = [[ 1.,  2.,  3.],
   [ 1.,  2.,  3.]])



   Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L312
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">lhs</td><td>First input. </td></tr>
<tr><td class="paramname">rhs</td><td>Second input. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a0df09f5077c94cfce1695ec778bdcf79"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::broadcast_like </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>rhs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Broadcasts lhs to have the same shape as rhs. </p><pre class="fragment">   Broadcasting is a mechanism that allows NDArrays to perform arithmetic
   with arrays of different shapes efficiently without creating multiple copies of
   Also see, `Broadcasting
   &lt;https://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&gt;`_ for more

   Broadcasting is allowed on axes with size 1, such as from `(2,1,3,1)` to
   `(2,8,3,9)`. Elements will be duplicated on the broadcasted axes.

   For example::

   broadcast_like([[1,2,3]], [[5,6,7],[7,8,9]]) = [[ 1.,  2.,  3.],
   [ 1.,  2.,  3.]])



   Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L312
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">lhs</td><td>First input. </td></tr>
<tr><td class="paramname">rhs</td><td>Second input. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a0192130745dc20317d49491a37a5f952"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::broadcast_logical_and </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>rhs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns the result of element-wise <b>logical and</b> with broadcasting. </p><pre class="fragment">   Example::

   x = [[ 1.,  1.,  1.],
   [ 1.,  1.,  1.]]

   y = [[ 0.],
   [ 1.]]

   broadcast_logical_and(x, y) = [[ 0.,  0.,  0.],
   [ 1.,  1.,  1.]]



   Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L154
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">lhs</td><td>First input to the function </td></tr>
<tr><td class="paramname">rhs</td><td>Second input to the function </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a48ae9c6b14dce45db7694174c67b0739"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::broadcast_logical_and </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>rhs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns the result of element-wise <b>logical and</b> with broadcasting. </p><pre class="fragment">   Example::

   x = [[ 1.,  1.,  1.],
   [ 1.,  1.,  1.]]

   y = [[ 0.],
   [ 1.]]

   broadcast_logical_and(x, y) = [[ 0.,  0.,  0.],
   [ 1.,  1.,  1.]]



   Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L154
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">lhs</td><td>First input to the function </td></tr>
<tr><td class="paramname">rhs</td><td>Second input to the function </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="abab1833009eb1be2bf8a7de9edb98e46"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::broadcast_logical_or </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>rhs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns the result of element-wise <b>logical or</b> with broadcasting. </p><pre class="fragment">   Example::

   x = [[ 1.,  1.,  0.],
   [ 1.,  1.,  0.]]

   y = [[ 1.],
   [ 0.]]

   broadcast_logical_or(x, y) = [[ 1.,  1.,  1.],
   [ 1.,  1.,  0.]]



   Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L172
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">lhs</td><td>First input to the function </td></tr>
<tr><td class="paramname">rhs</td><td>Second input to the function </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="ad735a6ed1f2da599e2a9f6884bcad272"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::broadcast_logical_or </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>rhs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns the result of element-wise <b>logical or</b> with broadcasting. </p><pre class="fragment">   Example::

   x = [[ 1.,  1.,  0.],
   [ 1.,  1.,  0.]]

   y = [[ 1.],
   [ 0.]]

   broadcast_logical_or(x, y) = [[ 1.,  1.,  1.],
   [ 1.,  1.,  0.]]



   Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L172
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">lhs</td><td>First input to the function </td></tr>
<tr><td class="paramname">rhs</td><td>Second input to the function </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="ad04bcd4646bb3251bf8304389f1e4588"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::broadcast_logical_xor </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>rhs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns the result of element-wise <b>logical xor</b> with broadcasting. </p><pre class="fragment">   Example::

   x = [[ 1.,  1.,  0.],
   [ 1.,  1.,  0.]]

   y = [[ 1.],
   [ 0.]]

   broadcast_logical_xor(x, y) = [[ 0.,  0.,  1.],
   [ 1.,  1.,  0.]]



   Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L190
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">lhs</td><td>First input to the function </td></tr>
<tr><td class="paramname">rhs</td><td>Second input to the function </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="af2fba0518de7e593837ab5a2f73fdc2b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::broadcast_logical_xor </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>rhs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns the result of element-wise <b>logical xor</b> with broadcasting. </p><pre class="fragment">   Example::

   x = [[ 1.,  1.,  0.],
   [ 1.,  1.,  0.]]

   y = [[ 1.],
   [ 0.]]

   broadcast_logical_xor(x, y) = [[ 0.,  0.,  1.],
   [ 1.,  1.,  0.]]



   Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L190
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">lhs</td><td>First input to the function </td></tr>
<tr><td class="paramname">rhs</td><td>Second input to the function </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a7f4654e21bde6164640644943955eb66"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::broadcast_maximum </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>rhs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns element-wise maximum of the input arrays with broadcasting. </p><pre class="fragment">   This function compares two input arrays and returns a new array having the

   Example::

   x = [[ 1.,  1.,  1.],
   [ 1.,  1.,  1.]]

   y = [[ 0.],
   [ 1.]]

   broadcast_maximum(x, y) = [[ 1.,  1.,  1.],
   [ 1.,  1.,  1.]]



   Defined in src/operator/tensor/elemwise_binary_broadcast_op_extended.cc:L80
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">lhs</td><td>First input to the function </td></tr>
<tr><td class="paramname">rhs</td><td>Second input to the function </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a726537cde6ac90b58e866b9644503ace"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::broadcast_maximum </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>rhs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns element-wise maximum of the input arrays with broadcasting. </p><pre class="fragment">   This function compares two input arrays and returns a new array having the

   Example::

   x = [[ 1.,  1.,  1.],
   [ 1.,  1.,  1.]]

   y = [[ 0.],
   [ 1.]]

   broadcast_maximum(x, y) = [[ 1.,  1.,  1.],
   [ 1.,  1.,  1.]]



   Defined in src/operator/tensor/elemwise_binary_broadcast_op_extended.cc:L80
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">lhs</td><td>First input to the function </td></tr>
<tr><td class="paramname">rhs</td><td>Second input to the function </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a54a975ffe796834cff9534c8773f9a43"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::broadcast_minimum </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>rhs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns element-wise minimum of the input arrays with broadcasting. </p><pre class="fragment">   This function compares two input arrays and returns a new array having the

   Example::

   x = [[ 1.,  1.,  1.],
   [ 1.,  1.,  1.]]

   y = [[ 0.],
   [ 1.]]

   broadcast_maximum(x, y) = [[ 0.,  0.,  0.],
   [ 1.,  1.,  1.]]



   Defined in src/operator/tensor/elemwise_binary_broadcast_op_extended.cc:L115
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">lhs</td><td>First input to the function </td></tr>
<tr><td class="paramname">rhs</td><td>Second input to the function </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a5a265c2191b41da0ede87a63eb0bcdff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::broadcast_minimum </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>rhs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns element-wise minimum of the input arrays with broadcasting. </p><pre class="fragment">   This function compares two input arrays and returns a new array having the

   Example::

   x = [[ 1.,  1.,  1.],
   [ 1.,  1.,  1.]]

   y = [[ 0.],
   [ 1.]]

   broadcast_maximum(x, y) = [[ 0.,  0.,  0.],
   [ 1.,  1.,  1.]]



   Defined in src/operator/tensor/elemwise_binary_broadcast_op_extended.cc:L115
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">lhs</td><td>First input to the function </td></tr>
<tr><td class="paramname">rhs</td><td>Second input to the function </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="afd1c090ff5c5af038780ef5542266243"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::broadcast_mod </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>rhs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns element-wise modulo of the input arrays with broadcasting. </p><pre class="fragment">   Example::

   x = [[ 8.,  8.,  8.],
   [ 8.,  8.,  8.]]

   y = [[ 2.],
   [ 3.]]

   broadcast_mod(x, y) = [[ 0.,  0.,  0.],
   [ 2.,  2.,  2.]]



   Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L222
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">lhs</td><td>First input to the function </td></tr>
<tr><td class="paramname">rhs</td><td>Second input to the function </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a263b21f0f1bfb904cdd3e6c47ed90e6d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::broadcast_mod </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>rhs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns element-wise modulo of the input arrays with broadcasting. </p><pre class="fragment">   Example::

   x = [[ 8.,  8.,  8.],
   [ 8.,  8.,  8.]]

   y = [[ 2.],
   [ 3.]]

   broadcast_mod(x, y) = [[ 0.,  0.,  0.],
   [ 2.,  2.,  2.]]



   Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L222
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">lhs</td><td>First input to the function </td></tr>
<tr><td class="paramname">rhs</td><td>Second input to the function </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a8475ebccc1fca543aeacd8e520f98489"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::broadcast_mul </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>rhs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns element-wise product of the input arrays with broadcasting. </p><pre class="fragment">   Example::

   x = [[ 1.,  1.,  1.],
   [ 1.,  1.,  1.]]

   y = [[ 0.],
   [ 1.]]

   broadcast_mul(x, y) = [[ 0.,  0.,  0.],
   [ 1.,  1.,  1.]]

   Supported sparse operations:

   broadcast_mul(csr, dense(1D)) = csr



   Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L146
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">lhs</td><td>First input to the function </td></tr>
<tr><td class="paramname">rhs</td><td>Second input to the function </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="aea844ba6ad33ef20e6ea3a63a8a38c52"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::broadcast_mul </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>rhs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns element-wise product of the input arrays with broadcasting. </p><pre class="fragment">   Example::

   x = [[ 1.,  1.,  1.],
   [ 1.,  1.,  1.]]

   y = [[ 0.],
   [ 1.]]

   broadcast_mul(x, y) = [[ 0.,  0.,  0.],
   [ 1.,  1.,  1.]]

   Supported sparse operations:

   broadcast_mul(csr, dense(1D)) = csr



   Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L146
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">lhs</td><td>First input to the function </td></tr>
<tr><td class="paramname">rhs</td><td>Second input to the function </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a3a5f26e36cb9fa3c9388bab2109cde07"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::broadcast_not_equal </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>rhs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns the result of element-wise <b>not equal to</b> (!=) comparison operation </p><pre class="fragment">   Example::

   x = [[ 1.,  1.,  1.],
   [ 1.,  1.,  1.]]

   y = [[ 0.],
   [ 1.]]

   broadcast_not_equal(x, y) = [[ 1.,  1.,  1.],
   [ 0.,  0.,  0.]]



   Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L64
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">lhs</td><td>First input to the function </td></tr>
<tr><td class="paramname">rhs</td><td>Second input to the function </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a6dc13b57ff1b662e87be40840bc33e37"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::broadcast_not_equal </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>rhs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns the result of element-wise <b>not equal to</b> (!=) comparison operation </p><pre class="fragment">   Example::

   x = [[ 1.,  1.,  1.],
   [ 1.,  1.,  1.]]

   y = [[ 0.],
   [ 1.]]

   broadcast_not_equal(x, y) = [[ 1.,  1.,  1.],
   [ 0.,  0.,  0.]]



   Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L64
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">lhs</td><td>First input to the function </td></tr>
<tr><td class="paramname">rhs</td><td>Second input to the function </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a7c0ee006ec9b8e56d40fc177992a6a1b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::broadcast_power </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>rhs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns result of first array elements raised to powers from second array, </p><pre class="fragment">   Example::

   x = [[ 1.,  1.,  1.],
   [ 1.,  1.,  1.]]

   y = [[ 0.],
   [ 1.]]

   broadcast_power(x, y) = [[ 2.,  2.,  2.],
   [ 4.,  4.,  4.]]



   Defined in src/operator/tensor/elemwise_binary_broadcast_op_extended.cc:L45
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">lhs</td><td>First input to the function </td></tr>
<tr><td class="paramname">rhs</td><td>Second input to the function </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a4397288fa6203e86f00c250c015229d5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::broadcast_power </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>rhs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns result of first array elements raised to powers from second array, </p><pre class="fragment">   Example::

   x = [[ 1.,  1.,  1.],
   [ 1.,  1.,  1.]]

   y = [[ 0.],
   [ 1.]]

   broadcast_power(x, y) = [[ 2.,  2.,  2.],
   [ 4.,  4.,  4.]]



   Defined in src/operator/tensor/elemwise_binary_broadcast_op_extended.cc:L45
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">lhs</td><td>First input to the function </td></tr>
<tr><td class="paramname">rhs</td><td>Second input to the function </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="aa329d1598ba167a8cf14b76341cda2c2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::broadcast_sub </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>rhs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns element-wise difference of the input arrays with broadcasting. </p><pre class="fragment">   `broadcast_minus` is an alias to the function `broadcast_sub`.

   Example::

   x = [[ 1.,  1.,  1.],
   [ 1.,  1.,  1.]]

   y = [[ 0.],
   [ 1.]]

   broadcast_sub(x, y) = [[ 1.,  1.,  1.],
   [ 0.,  0.,  0.]]

   broadcast_minus(x, y) = [[ 1.,  1.,  1.],
   [ 0.,  0.,  0.]]

   Supported sparse operations:

   broadcast_sub/minus(csr, dense(1D)) = dense
   broadcast_sub/minus(dense(1D), csr) = dense



   Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L106
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">lhs</td><td>First input to the function </td></tr>
<tr><td class="paramname">rhs</td><td>Second input to the function </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="ac17077658ee116a287bc8668b92ca0f0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::broadcast_sub </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>rhs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns element-wise difference of the input arrays with broadcasting. </p><pre class="fragment">   `broadcast_minus` is an alias to the function `broadcast_sub`.

   Example::

   x = [[ 1.,  1.,  1.],
   [ 1.,  1.,  1.]]

   y = [[ 0.],
   [ 1.]]

   broadcast_sub(x, y) = [[ 1.,  1.,  1.],
   [ 0.,  0.,  0.]]

   broadcast_minus(x, y) = [[ 1.,  1.,  1.],
   [ 0.,  0.,  0.]]

   Supported sparse operations:

   broadcast_sub/minus(csr, dense(1D)) = dense
   broadcast_sub/minus(dense(1D), csr) = dense



   Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L106
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">lhs</td><td>First input to the function </td></tr>
<tr><td class="paramname">rhs</td><td>Second input to the function </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a1ec5a8cf851e1b5ab222d7901fcede7c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::broadcast_to </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> </td>
<td class="paramname"><em>shape</em> = <code><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Broadcasts the input array to a new shape. </p><pre class="fragment">   Broadcasting is a mechanism that allows NDArrays to perform arithmetic
   with arrays of different shapes efficiently without creating multiple copies of
   Also see, `Broadcasting
   &lt;https://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&gt;`_ for more

   Broadcasting is allowed on axes with size 1, such as from `(2,1,3,1)` to
   `(2,8,3,9)`. Elements will be duplicated on the broadcasted axes.

   For example::

   broadcast_to([[1,2,3]], shape=(2,3)) = [[ 1.,  2.,  3.],
   [ 1.,  2.,  3.]])

   The dimension which you do not want to change can also be kept as `0` which
   So with `shape=(2,0)`, we will obtain the same result as in the above example.



   Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L261
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>The input </td></tr>
<tr><td class="paramname">shape</td><td>The shape of the desired array. We can set the dim to zero if it's same as the original. E.g <code>A = broadcast_to(B, shape=(10, 0, 0))</code> has the same </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a7443d6c979ea61d91b01d2e41d555151"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::broadcast_to </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> </td>
<td class="paramname"><em>shape</em> = <code><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Broadcasts the input array to a new shape. </p><pre class="fragment">   Broadcasting is a mechanism that allows NDArrays to perform arithmetic
   with arrays of different shapes efficiently without creating multiple copies of
   Also see, `Broadcasting
   &lt;https://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&gt;`_ for more

   Broadcasting is allowed on axes with size 1, such as from `(2,1,3,1)` to
   `(2,8,3,9)`. Elements will be duplicated on the broadcasted axes.

   For example::

   broadcast_to([[1,2,3]], shape=(2,3)) = [[ 1.,  2.,  3.],
   [ 1.,  2.,  3.]])

   The dimension which you do not want to change can also be kept as `0` which
   So with `shape=(2,0)`, we will obtain the same result as in the above example.



   Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L261
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>The input </td></tr>
<tr><td class="paramname">shape</td><td>The shape of the desired array. We can set the dim to zero if it's same as the original. E.g <code>A = broadcast_to(B, shape=(10, 0, 0))</code> has the same </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a94162c291a79b5ecaa19f88acce92b84"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::Cast </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespacemxnet_1_1cpp.html#a8e907a5fbbe4ec21628e500b34a5f35d">CastDtype</a> </td>
<td class="paramname"><em>dtype</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Casts all elements of the input to a new type. </p><pre class="fragment">   .. note:: ``Cast`` is deprecated. Use ``cast`` instead.

   Example::

   cast([0.9, 1.3], dtype='int32') = [0, 1]
   cast([1e20, 11.1], dtype='float16') = [inf, 11.09375]
   cast([300, 11.1, 10.9, -1, -3], dtype='uint8') = [44, 11, 10, 255, 253]



   Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L594
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>The input. </td></tr>
<tr><td class="paramname">dtype</td><td>Output data type. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a84aa19568d46821fa363c07d4693543f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::Cast </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespacemxnet_1_1cpp.html#a8e907a5fbbe4ec21628e500b34a5f35d">CastDtype</a> </td>
<td class="paramname"><em>dtype</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Casts all elements of the input to a new type. </p><pre class="fragment">   .. note:: ``Cast`` is deprecated. Use ``cast`` instead.

   Example::

   cast([0.9, 1.3], dtype='int32') = [0, 1]
   cast([1e20, 11.1], dtype='float16') = [inf, 11.09375]
   cast([300, 11.1, 10.9, -1, -3], dtype='uint8') = [44, 11, 10, 255, 253]



   Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L594
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>The input. </td></tr>
<tr><td class="paramname">dtype</td><td>Output data type. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="ae071452dc28d12aeb785c9b94d8f83d8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::cast_storage </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespacemxnet_1_1cpp.html#aac92e2f3642173e36bb79eb4854728ff">Cast_storageStype</a> </td>
<td class="paramname"><em>stype</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Casts tensor storage type to the new type. </p><pre class="fragment">   When an NDArray with default storage type is cast to csr or row_sparse storage,
   the result is compact, which means:

   - for csr, zero values will not be retained
   - for row_sparse, row slices of all zeros will not be retained

   The storage type of ``cast_storage`` output depends on stype parameter:

   - cast_storage(csr, 'default') = default
   - cast_storage(row_sparse, 'default') = default
   - cast_storage(default, 'csr') = csr
   - cast_storage(default, 'row_sparse') = row_sparse
   - cast_storage(csr, 'csr') = csr
   - cast_storage(row_sparse, 'row_sparse') = row_sparse

   Example::

   dense = [[ 0.,  1.,  0.],
   [ 2.,  0.,  3.],
   [ 0.,  0.,  0.],
   [ 0.,  0.,  0.]]

   # cast to row_sparse storage type
   rsp = cast_storage(dense, 'row_sparse')
   rsp.indices = [0, 1]
   rsp.values = [[ 0.,  1.,  0.],
   [ 2.,  0.,  3.]]

   # cast to csr storage type
   csr = cast_storage(dense, 'csr')
   csr.indices = [1, 0, 2]
   csr.values = [ 1.,  2.,  3.]
   csr.indptr = [0, 1, 3, 3, 3]



   Defined in src/operator/tensor/cast_storage.cc:L71
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>The input. </td></tr>
<tr><td class="paramname">stype</td><td>Output storage type. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a11465bdfd897d56e7f3452e442393f92"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::cast_storage </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespacemxnet_1_1cpp.html#aac92e2f3642173e36bb79eb4854728ff">Cast_storageStype</a> </td>
<td class="paramname"><em>stype</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Casts tensor storage type to the new type. </p><pre class="fragment">   When an NDArray with default storage type is cast to csr or row_sparse storage,
   the result is compact, which means:

   - for csr, zero values will not be retained
   - for row_sparse, row slices of all zeros will not be retained

   The storage type of ``cast_storage`` output depends on stype parameter:

   - cast_storage(csr, 'default') = default
   - cast_storage(row_sparse, 'default') = default
   - cast_storage(default, 'csr') = csr
   - cast_storage(default, 'row_sparse') = row_sparse
   - cast_storage(csr, 'csr') = csr
   - cast_storage(row_sparse, 'row_sparse') = row_sparse

   Example::

   dense = [[ 0.,  1.,  0.],
   [ 2.,  0.,  3.],
   [ 0.,  0.,  0.],
   [ 0.,  0.,  0.]]

   # cast to row_sparse storage type
   rsp = cast_storage(dense, 'row_sparse')
   rsp.indices = [0, 1]
   rsp.values = [[ 0.,  1.,  0.],
   [ 2.,  0.,  3.]]

   # cast to csr storage type
   csr = cast_storage(dense, 'csr')
   csr.indices = [1, 0, 2]
   csr.values = [ 1.,  2.,  3.]
   csr.indptr = [0, 1, 3, 3, 3]



   Defined in src/operator/tensor/cast_storage.cc:L71
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>The input. </td></tr>
<tr><td class="paramname">stype</td><td>Output storage type. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="ade9a6900e4402ff2d60530060400dd72"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::cbrt </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns element-wise cube-root value of the input. </p><pre class="fragment">   .. math::
   cbrt(x) = \sqrt[3]{x}

   Example::

   cbrt([1, 8, -125]) = [1, 2, -5]

   The storage type of ``cbrt`` output depends upon the input storage type:

   - cbrt(default) = default
   - cbrt(row_sparse) = row_sparse
   - cbrt(csr) = csr



   Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L889
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>The input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a34848991e9ca10bcc8e952eafdf68c5a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::cbrt </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns element-wise cube-root value of the input. </p><pre class="fragment">   .. math::
   cbrt(x) = \sqrt[3]{x}

   Example::

   cbrt([1, 8, -125]) = [1, 2, -5]

   The storage type of ``cbrt`` output depends upon the input storage type:

   - cbrt(default) = default
   - cbrt(row_sparse) = row_sparse
   - cbrt(csr) = csr



   Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L889
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>The input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a59b0f43135f5642458c3952410abdb9e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::ceil </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns element-wise ceiling of the input. </p><pre class="fragment">   The ceil of the scalar x is the smallest integer i, such that i &gt;= x.

   Example::

   ceil([-2.1, -1.9, 1.5, 1.9, 2.1]) = [-2., -1.,  2.,  2.,  3.]

   The storage type of ``ceil`` output depends upon the input storage type:

   - ceil(default) = default
   - ceil(row_sparse) = row_sparse
   - ceil(csr) = csr



   Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L746
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>The input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a1d09981c1d29d06094f0375bf359c611"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::ceil </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns element-wise ceiling of the input. </p><pre class="fragment">   The ceil of the scalar x is the smallest integer i, such that i &gt;= x.

   Example::

   ceil([-2.1, -1.9, 1.5, 1.9, 2.1]) = [-2., -1.,  2.,  2.,  3.]

   The storage type of ``ceil`` output depends upon the input storage type:

   - ceil(default) = default
   - ceil(row_sparse) = row_sparse
   - ceil(csr) = csr



   Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L746
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>The input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a633ba7fbface59da4f043148847c2c9e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::choose_element_0index </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>rhs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Choose one element from each line(row for python, column for R/Julia) in lhs according to index indicated by rhs. This function assume rhs uses 0-based </p><dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">lhs</td><td>Left operand to the function. </td></tr>
<tr><td class="paramname">rhs</td><td>Right operand to the function. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a4fe1a7bf6c9b53bde75dc23cb36853e7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::choose_element_0index </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>rhs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Choose one element from each line(row for python, column for R/Julia) in lhs according to index indicated by rhs. This function assume rhs uses 0-based </p><dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">lhs</td><td>Left operand to the function. </td></tr>
<tr><td class="paramname">rhs</td><td>Right operand to the function. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a27262dd0794c017d77f20fab5d9fe715"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::clip </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>a_min</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>a_max</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Clips (limits) the values in an array. </p><pre class="fragment">   Given an interval, values outside the interval are clipped to the interval
   Clipping ``x`` between `a_min` and `a_x` would be::

   clip(x, a_min, a_max) = max(min(x, a_max), a_min))

   Example::

   x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

   clip(x,1,8) = [ 1.,  1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  8.]

   The storage type of ``clip`` output depends on storage types of inputs and the
   parameter values:

   - clip(default) = default
   - clip(row_sparse, a_min &lt;= 0, a_max &gt;= 0) = row_sparse
   - clip(csr, a_min &lt;= 0, a_max &gt;= 0) = csr
   - clip(row_sparse, a_min &lt; 0, a_max &lt; 0) = default
   - clip(row_sparse, a_min &gt; 0, a_max &gt; 0) = default
   - clip(csr, a_min &lt; 0, a_max &lt; 0) = csr
   - clip(csr, a_min &gt; 0, a_max &gt; 0) = csr



   Defined in src/operator/tensor/matrix_op.cc:L618
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>Input array. </td></tr>
<tr><td class="paramname">a_min</td><td>Minimum value </td></tr>
<tr><td class="paramname">a_max</td><td>Maximum value </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a82601afa30b710cc1b184f9819c3cc4e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::clip </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>a_min</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>a_max</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Clips (limits) the values in an array. </p><pre class="fragment">   Given an interval, values outside the interval are clipped to the interval
   Clipping ``x`` between `a_min` and `a_x` would be::

   clip(x, a_min, a_max) = max(min(x, a_max), a_min))

   Example::

   x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

   clip(x,1,8) = [ 1.,  1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  8.]

   The storage type of ``clip`` output depends on storage types of inputs and the
   parameter values:

   - clip(default) = default
   - clip(row_sparse, a_min &lt;= 0, a_max &gt;= 0) = row_sparse
   - clip(csr, a_min &lt;= 0, a_max &gt;= 0) = csr
   - clip(row_sparse, a_min &lt; 0, a_max &lt; 0) = default
   - clip(row_sparse, a_min &gt; 0, a_max &gt; 0) = default
   - clip(csr, a_min &lt; 0, a_max &lt; 0) = csr
   - clip(csr, a_min &gt; 0, a_max &gt; 0) = csr



   Defined in src/operator/tensor/matrix_op.cc:L618
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>Input array. </td></tr>
<tr><td class="paramname">a_min</td><td>Minimum value </td></tr>
<tr><td class="paramname">a_max</td><td>Maximum value </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a58ec45705c88219a949dd3dfb11ce058"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::Concat </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const std::vector&lt; <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> &gt; &amp; </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>num_args</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>dim</em> = <code>1</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Joins input arrays along a given axis. </p><pre class="fragment">   .. note:: `Concat` is deprecated. Use `concat` instead.

   The dimensions of the input arrays should be the same except the axis along
   which they will be concatenated.
   The dimension of the output array along the concatenated axis will be equal
   to the sum of the corresponding dimensions of the input arrays.

   The storage type of ``concat`` output depends on storage types of inputs

   - concat(csr, csr, ..., csr, dim=0) = csr
   - otherwise, ``concat`` generates output with default storage

   Example::

   x = [[1,1],[2,2]]
   y = [[3,3],[4,4],[5,5]]
   z = [[6,6], [7,7],[8,8]]

   concat(x,y,z,dim=0) = [[ 1.,  1.],
   [ 2.,  2.],
   [ 3.,  3.],
   [ 4.,  4.],
   [ 5.,  5.],
   [ 6.,  6.],
   [ 7.,  7.],
   [ 8.,  8.]]

   Note that you cannot concat x,y,z along dimension 1 since dimension
   0 is not the same for all the input arrays.

   concat(y,z,dim=1) = [[ 3.,  3.,  6.,  6.],
   [ 4.,  4.,  7.,  7.],
   [ 5.,  5.,  8.,  8.]]



   Defined in src/operator/nn/concat.cc:L368
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>List of arrays to concatenate </td></tr>
<tr><td class="paramname">num_args</td><td>Number of inputs to be concated. </td></tr>
<tr><td class="paramname">dim</td><td>the dimension to be concated. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a44eb74174eaae169df46a0594eeb1b08"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::Concat </td>
<td>(</td>
<td class="paramtype">const std::vector&lt; <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> &gt; &amp; </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>num_args</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>dim</em> = <code>1</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Joins input arrays along a given axis. </p><pre class="fragment">   .. note:: `Concat` is deprecated. Use `concat` instead.

   The dimensions of the input arrays should be the same except the axis along
   which they will be concatenated.
   The dimension of the output array along the concatenated axis will be equal
   to the sum of the corresponding dimensions of the input arrays.

   The storage type of ``concat`` output depends on storage types of inputs

   - concat(csr, csr, ..., csr, dim=0) = csr
   - otherwise, ``concat`` generates output with default storage

   Example::

   x = [[1,1],[2,2]]
   y = [[3,3],[4,4],[5,5]]
   z = [[6,6], [7,7],[8,8]]

   concat(x,y,z,dim=0) = [[ 1.,  1.],
   [ 2.,  2.],
   [ 3.,  3.],
   [ 4.,  4.],
   [ 5.,  5.],
   [ 6.,  6.],
   [ 7.,  7.],
   [ 8.,  8.]]

   Note that you cannot concat x,y,z along dimension 1 since dimension
   0 is not the same for all the input arrays.

   concat(y,z,dim=1) = [[ 3.,  3.,  6.,  6.],
   [ 4.,  4.,  7.,  7.],
   [ 5.,  5.,  8.,  8.]]



   Defined in src/operator/nn/concat.cc:L368
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>List of arrays to concatenate </td></tr>
<tr><td class="paramname">num_args</td><td>Number of inputs to be concated. </td></tr>
<tr><td class="paramname">dim</td><td>the dimension to be concated. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a1ad654fc47d82ee0f1c5ae172d29b1f6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::Convolution </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>weight</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>bias</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> </td>
<td class="paramname"><em>kernel</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint32_t </td>
<td class="paramname"><em>num_filter</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> </td>
<td class="paramname"><em>stride</em> = <code><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>()</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> </td>
<td class="paramname"><em>dilate</em> = <code><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>()</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> </td>
<td class="paramname"><em>pad</em> = <code><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>()</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint32_t </td>
<td class="paramname"><em>num_group</em> = <code>1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint64_t </td>
<td class="paramname"><em>workspace</em> = <code>1024</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>no_bias</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespacemxnet_1_1cpp.html#a8755a4574a3839da2ad93af004fb1ff5">ConvolutionCudnnTune</a> </td>
<td class="paramname"><em>cudnn_tune</em> = <code><a class="el" href="namespacemxnet_1_1cpp.html#aa5dbdd69827034fc43c16cf350db7e1ea35c3ace1970663a16e5c65baa5941b13">ConvolutionCudnnTune::kNone</a></code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>cudnn_off</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespacemxnet_1_1cpp.html#a7b419f5293a7706c76becfe735a9946b">ConvolutionLayout</a> </td>
<td class="paramname"><em>layout</em> = <code><a class="el" href="namespacemxnet_1_1cpp.html#aa5dbdd69827034fc43c16cf350db7e1ea35c3ace1970663a16e5c65baa5941b13">ConvolutionLayout::kNone</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Compute <em>N</em>-D convolution on *(N+2)*-D input. </p><pre class="fragment">   In the 2-D convolution, given input data with shape *(batch_size,
   channel, height, width)*, the output is computed by

   .. math::

   out[n,i,:,:] = bias[i] + \sum_{j=0}^{channel} data[n,j,:,:] \star
   weight[i,j,:,:]

   where :math:`\star` is the 2-D cross-correlation operator.

   For general 2-D convolution, the shapes are

   - **data**: *(batch_size, channel, height, width)*
   - **weight**: *(num_filter, channel, kernel[0], kernel[1])*
   - **bias**: *(num_filter,)*
   - **out**: *(batch_size, num_filter, out_height, out_width)*.

   Define::

   f(x,k,p,s,d) = floor((x+2*p-d*(k-1)-1)/s)+1

   then we have::

   out_height=f(height, kernel[0], pad[0], stride[0], dilate[0])
   out_width=f(width, kernel[1], pad[1], stride[1], dilate[1])

   If ``no_bias`` is set to be true, then the ``bias`` term is ignored.

   The default data ``layout`` is *NCHW*, namely *(batch_size, channel, height,
   width)*. We can choose other layouts such as *NWC*.

   If ``num_group`` is larger than 1, denoted by *g*, then split the input ``data``
   evenly into *g* parts along the channel axis, and also evenly split ``weight``
   along the first dimension. Next compute the convolution on the *i*-th part of
   the data with the *i*-th weight part. The output is obtained by concatenating
   the *g* results.

   1-D convolution does not have *height* dimension but only *width* in space.

   - **data**: *(batch_size, channel, width)*
   - **weight**: *(num_filter, channel, kernel[0])*
   - **bias**: *(num_filter,)*
   - **out**: *(batch_size, num_filter, out_width)*.

   3-D convolution adds an additional *depth* dimension besides *height* and
   *width*. The shapes are

   - **data**: *(batch_size, channel, depth, height, width)*
   - **weight**: *(num_filter, channel, kernel[0], kernel[1], kernel[2])*
   - **bias**: *(num_filter,)*
   - **out**: *(batch_size, num_filter, out_depth, out_height, out_width)*.

   Both ``weight`` and ``bias`` are learnable parameters.

   There are other options to tune the performance.

   - **cudnn_tune**: enable this option leads to higher startup time but may give
   faster speed. Options are

   - **off**: no tuning
   - **limited_workspace**:run test and pick the fastest algorithm that doesn't
   exceed workspace limit.
   - **fastest**: pick the fastest algorithm and ignore workspace limit.
   - **None** (default): the behavior is determined by environment variable
   ``MXNET_CUDNN_AUTOTUNE_DEFAULT``. 0 for off, 1 for limited workspace
   (default), 2 for fastest.

   - **workspace**: A large number leads to more (GPU) memory usage but may improve
   the performance.



   Defined in src/operator/nn/convolution.cc:L474
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>Input data to the ConvolutionOp. </td></tr>
<tr><td class="paramname">weight</td><td>Weight matrix. </td></tr>
<tr><td class="paramname">bias</td><td>Bias parameter. </td></tr>
<tr><td class="paramname">kernel</td><td>Convolution kernel size: (w,), (h, w) or (d, h, w) </td></tr>
<tr><td class="paramname">num_filter</td><td>Convolution filter(channel) number </td></tr>
<tr><td class="paramname">stride</td><td>Convolution stride: (w,), (h, w) or (d, h, w). Defaults to 1 for each </td></tr>
<tr><td class="paramname">dilate</td><td>Convolution dilate: (w,), (h, w) or (d, h, w). Defaults to 1 for each </td></tr>
<tr><td class="paramname">pad</td><td><a class="el" href="classmxnet_1_1cpp_1_1Zero.html">Zero</a> pad for convolution: (w,), (h, w) or (d, h, w). Defaults to no padding. </td></tr>
<tr><td class="paramname">num_group</td><td>Number of group partitions. </td></tr>
<tr><td class="paramname">workspace</td><td>Maximum temporary workspace allowed (MB) in convolution.This parameter has two usages. When CUDNN is not used, it determines the effective batch size of the convolution kernel. When CUDNN is used, it controls the maximum temporary storage used for tuning the best CUDNN kernel when </td></tr>
<tr><td class="paramname">no_bias</td><td>Whether to disable bias parameter. </td></tr>
<tr><td class="paramname">cudnn_tune</td><td>Whether to pick convolution algo by running performance test. </td></tr>
<tr><td class="paramname">cudnn_off</td><td>Turn off cudnn for this layer. </td></tr>
<tr><td class="paramname">layout</td><td>Set layout for input, output and weight. Empty for default layout: NCW for 1d, NCHW for 2d and NCDHW for 3d.NHWC and NDHWC are </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a6fee92325f3980187796296454894020"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::Convolution </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>weight</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>bias</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> </td>
<td class="paramname"><em>kernel</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint32_t </td>
<td class="paramname"><em>num_filter</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> </td>
<td class="paramname"><em>stride</em> = <code><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>()</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> </td>
<td class="paramname"><em>dilate</em> = <code><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>()</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> </td>
<td class="paramname"><em>pad</em> = <code><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>()</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint32_t </td>
<td class="paramname"><em>num_group</em> = <code>1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint64_t </td>
<td class="paramname"><em>workspace</em> = <code>1024</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>no_bias</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespacemxnet_1_1cpp.html#a8755a4574a3839da2ad93af004fb1ff5">ConvolutionCudnnTune</a> </td>
<td class="paramname"><em>cudnn_tune</em> = <code><a class="el" href="namespacemxnet_1_1cpp.html#aa5dbdd69827034fc43c16cf350db7e1ea35c3ace1970663a16e5c65baa5941b13">ConvolutionCudnnTune::kNone</a></code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>cudnn_off</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespacemxnet_1_1cpp.html#a7b419f5293a7706c76becfe735a9946b">ConvolutionLayout</a> </td>
<td class="paramname"><em>layout</em> = <code><a class="el" href="namespacemxnet_1_1cpp.html#aa5dbdd69827034fc43c16cf350db7e1ea35c3ace1970663a16e5c65baa5941b13">ConvolutionLayout::kNone</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Compute <em>N</em>-D convolution on *(N+2)*-D input. </p><pre class="fragment">   In the 2-D convolution, given input data with shape *(batch_size,
   channel, height, width)*, the output is computed by

   .. math::

   out[n,i,:,:] = bias[i] + \sum_{j=0}^{channel} data[n,j,:,:] \star
   weight[i,j,:,:]

   where :math:`\star` is the 2-D cross-correlation operator.

   For general 2-D convolution, the shapes are

   - **data**: *(batch_size, channel, height, width)*
   - **weight**: *(num_filter, channel, kernel[0], kernel[1])*
   - **bias**: *(num_filter,)*
   - **out**: *(batch_size, num_filter, out_height, out_width)*.

   Define::

   f(x,k,p,s,d) = floor((x+2*p-d*(k-1)-1)/s)+1

   then we have::

   out_height=f(height, kernel[0], pad[0], stride[0], dilate[0])
   out_width=f(width, kernel[1], pad[1], stride[1], dilate[1])

   If ``no_bias`` is set to be true, then the ``bias`` term is ignored.

   The default data ``layout`` is *NCHW*, namely *(batch_size, channel, height,
   width)*. We can choose other layouts such as *NWC*.

   If ``num_group`` is larger than 1, denoted by *g*, then split the input ``data``
   evenly into *g* parts along the channel axis, and also evenly split ``weight``
   along the first dimension. Next compute the convolution on the *i*-th part of
   the data with the *i*-th weight part. The output is obtained by concatenating
   the *g* results.

   1-D convolution does not have *height* dimension but only *width* in space.

   - **data**: *(batch_size, channel, width)*
   - **weight**: *(num_filter, channel, kernel[0])*
   - **bias**: *(num_filter,)*
   - **out**: *(batch_size, num_filter, out_width)*.

   3-D convolution adds an additional *depth* dimension besides *height* and
   *width*. The shapes are

   - **data**: *(batch_size, channel, depth, height, width)*
   - **weight**: *(num_filter, channel, kernel[0], kernel[1], kernel[2])*
   - **bias**: *(num_filter,)*
   - **out**: *(batch_size, num_filter, out_depth, out_height, out_width)*.

   Both ``weight`` and ``bias`` are learnable parameters.

   There are other options to tune the performance.

   - **cudnn_tune**: enable this option leads to higher startup time but may give
   faster speed. Options are

   - **off**: no tuning
   - **limited_workspace**:run test and pick the fastest algorithm that doesn't
   exceed workspace limit.
   - **fastest**: pick the fastest algorithm and ignore workspace limit.
   - **None** (default): the behavior is determined by environment variable
   ``MXNET_CUDNN_AUTOTUNE_DEFAULT``. 0 for off, 1 for limited workspace
   (default), 2 for fastest.

   - **workspace**: A large number leads to more (GPU) memory usage but may improve
   the performance.



   Defined in src/operator/nn/convolution.cc:L474
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>Input data to the ConvolutionOp. </td></tr>
<tr><td class="paramname">weight</td><td>Weight matrix. </td></tr>
<tr><td class="paramname">bias</td><td>Bias parameter. </td></tr>
<tr><td class="paramname">kernel</td><td>Convolution kernel size: (w,), (h, w) or (d, h, w) </td></tr>
<tr><td class="paramname">num_filter</td><td>Convolution filter(channel) number </td></tr>
<tr><td class="paramname">stride</td><td>Convolution stride: (w,), (h, w) or (d, h, w). Defaults to 1 for each </td></tr>
<tr><td class="paramname">dilate</td><td>Convolution dilate: (w,), (h, w) or (d, h, w). Defaults to 1 for each </td></tr>
<tr><td class="paramname">pad</td><td><a class="el" href="classmxnet_1_1cpp_1_1Zero.html">Zero</a> pad for convolution: (w,), (h, w) or (d, h, w). Defaults to no padding. </td></tr>
<tr><td class="paramname">num_group</td><td>Number of group partitions. </td></tr>
<tr><td class="paramname">workspace</td><td>Maximum temporary workspace allowed (MB) in convolution.This parameter has two usages. When CUDNN is not used, it determines the effective batch size of the convolution kernel. When CUDNN is used, it controls the maximum temporary storage used for tuning the best CUDNN kernel when </td></tr>
<tr><td class="paramname">no_bias</td><td>Whether to disable bias parameter. </td></tr>
<tr><td class="paramname">cudnn_tune</td><td>Whether to pick convolution algo by running performance test. </td></tr>
<tr><td class="paramname">cudnn_off</td><td>Turn off cudnn for this layer. </td></tr>
<tr><td class="paramname">layout</td><td>Set layout for input, output and weight. Empty for default layout: NCW for 1d, NCHW for 2d and NCDHW for 3d.NHWC and NDHWC are </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="abb9c18ff76114a00e17e147da71ef75b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::Convolution_v1 </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>weight</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>bias</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> </td>
<td class="paramname"><em>kernel</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint32_t </td>
<td class="paramname"><em>num_filter</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> </td>
<td class="paramname"><em>stride</em> = <code><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>()</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> </td>
<td class="paramname"><em>dilate</em> = <code><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>()</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> </td>
<td class="paramname"><em>pad</em> = <code><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>()</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint32_t </td>
<td class="paramname"><em>num_group</em> = <code>1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint64_t </td>
<td class="paramname"><em>workspace</em> = <code>1024</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>no_bias</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespacemxnet_1_1cpp.html#aa32f4a10a37f253f9d102cfc96a9eafc">Convolution_v1CudnnTune</a> </td>
<td class="paramname"><em>cudnn_tune</em> = <code><a class="el" href="namespacemxnet_1_1cpp.html#aa5dbdd69827034fc43c16cf350db7e1ea35c3ace1970663a16e5c65baa5941b13">Convolution_v1CudnnTune::kNone</a></code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>cudnn_off</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespacemxnet_1_1cpp.html#a97217f563c768120cd8db19573938635">Convolution_v1Layout</a> </td>
<td class="paramname"><em>layout</em> = <code><a class="el" href="namespacemxnet_1_1cpp.html#aa5dbdd69827034fc43c16cf350db7e1ea35c3ace1970663a16e5c65baa5941b13">Convolution_v1Layout::kNone</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>This operator is DEPRECATED. Apply convolution to input then add a bias. </p><dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>Input data to the ConvolutionV1Op. </td></tr>
<tr><td class="paramname">weight</td><td>Weight matrix. </td></tr>
<tr><td class="paramname">bias</td><td>Bias parameter. </td></tr>
<tr><td class="paramname">kernel</td><td>convolution kernel size: (h, w) or (d, h, w) </td></tr>
<tr><td class="paramname">num_filter</td><td>convolution filter(channel) number </td></tr>
<tr><td class="paramname">stride</td><td>convolution stride: (h, w) or (d, h, w) </td></tr>
<tr><td class="paramname">dilate</td><td>convolution dilate: (h, w) or (d, h, w) </td></tr>
<tr><td class="paramname">pad</td><td>pad for convolution: (h, w) or (d, h, w) </td></tr>
<tr><td class="paramname">num_group</td><td>Number of group partitions. Equivalent to slicing input into num_group partitions, apply convolution on each, then concatenate the results </td></tr>
<tr><td class="paramname">workspace</td><td>Maximum temporary workspace allowed for convolution (MB).This parameter determines the effective batch size of the convolution kernel, which may be smaller than the given batch size. Also, the workspace will be </td></tr>
<tr><td class="paramname">no_bias</td><td>Whether to disable bias parameter. </td></tr>
<tr><td class="paramname">cudnn_tune</td><td>Whether to pick convolution algo by running performance test. Leads to higher startup time but may give faster speed. Options are: 'off': no tuning 'limited_workspace': run test and pick the fastest algorithm that doesn't 'fastest': pick the fastest algorithm and ignore workspace limit. If set to None (default), behavior is determined by environment variable MXNET_CUDNN_AUTOTUNE_DEFAULT: 0 for off, 1 for limited workspace (default), 2 for fastest. </td></tr>
<tr><td class="paramname">cudnn_off</td><td>Turn off cudnn for this layer. </td></tr>
<tr><td class="paramname">layout</td><td>Set layout for input, output and weight. Empty for default layout: NCHW for 2d and NCDHW for 3d. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a872ee945307a72ef57b9946958b26e9b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::Convolution_v1 </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>weight</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>bias</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> </td>
<td class="paramname"><em>kernel</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint32_t </td>
<td class="paramname"><em>num_filter</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> </td>
<td class="paramname"><em>stride</em> = <code><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>()</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> </td>
<td class="paramname"><em>dilate</em> = <code><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>()</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> </td>
<td class="paramname"><em>pad</em> = <code><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>()</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint32_t </td>
<td class="paramname"><em>num_group</em> = <code>1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint64_t </td>
<td class="paramname"><em>workspace</em> = <code>1024</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>no_bias</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespacemxnet_1_1cpp.html#aa32f4a10a37f253f9d102cfc96a9eafc">Convolution_v1CudnnTune</a> </td>
<td class="paramname"><em>cudnn_tune</em> = <code><a class="el" href="namespacemxnet_1_1cpp.html#aa5dbdd69827034fc43c16cf350db7e1ea35c3ace1970663a16e5c65baa5941b13">Convolution_v1CudnnTune::kNone</a></code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>cudnn_off</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespacemxnet_1_1cpp.html#a97217f563c768120cd8db19573938635">Convolution_v1Layout</a> </td>
<td class="paramname"><em>layout</em> = <code><a class="el" href="namespacemxnet_1_1cpp.html#aa5dbdd69827034fc43c16cf350db7e1ea35c3ace1970663a16e5c65baa5941b13">Convolution_v1Layout::kNone</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>This operator is DEPRECATED. Apply convolution to input then add a bias. </p><dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>Input data to the ConvolutionV1Op. </td></tr>
<tr><td class="paramname">weight</td><td>Weight matrix. </td></tr>
<tr><td class="paramname">bias</td><td>Bias parameter. </td></tr>
<tr><td class="paramname">kernel</td><td>convolution kernel size: (h, w) or (d, h, w) </td></tr>
<tr><td class="paramname">num_filter</td><td>convolution filter(channel) number </td></tr>
<tr><td class="paramname">stride</td><td>convolution stride: (h, w) or (d, h, w) </td></tr>
<tr><td class="paramname">dilate</td><td>convolution dilate: (h, w) or (d, h, w) </td></tr>
<tr><td class="paramname">pad</td><td>pad for convolution: (h, w) or (d, h, w) </td></tr>
<tr><td class="paramname">num_group</td><td>Number of group partitions. Equivalent to slicing input into num_group partitions, apply convolution on each, then concatenate the results </td></tr>
<tr><td class="paramname">workspace</td><td>Maximum temporary workspace allowed for convolution (MB).This parameter determines the effective batch size of the convolution kernel, which may be smaller than the given batch size. Also, the workspace will be </td></tr>
<tr><td class="paramname">no_bias</td><td>Whether to disable bias parameter. </td></tr>
<tr><td class="paramname">cudnn_tune</td><td>Whether to pick convolution algo by running performance test. Leads to higher startup time but may give faster speed. Options are: 'off': no tuning 'limited_workspace': run test and pick the fastest algorithm that doesn't 'fastest': pick the fastest algorithm and ignore workspace limit. If set to None (default), behavior is determined by environment variable MXNET_CUDNN_AUTOTUNE_DEFAULT: 0 for off, 1 for limited workspace (default), 2 for fastest. </td></tr>
<tr><td class="paramname">cudnn_off</td><td>Turn off cudnn for this layer. </td></tr>
<tr><td class="paramname">layout</td><td>Set layout for input, output and weight. Empty for default layout: NCHW for 2d and NCDHW for 3d. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a84d2bda6af522d5cf84cf54b74c5aaac"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::Correlation </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data1</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data2</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint32_t </td>
<td class="paramname"><em>kernel_size</em> = <code>1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint32_t </td>
<td class="paramname"><em>max_displacement</em> = <code>1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint32_t </td>
<td class="paramname"><em>stride1</em> = <code>1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint32_t </td>
<td class="paramname"><em>stride2</em> = <code>1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint32_t </td>
<td class="paramname"><em>pad_size</em> = <code>0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>is_multiply</em> = <code>true</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Applies correlation to inputs. </p><pre class="fragment">   The correlation layer performs multiplicative patch comparisons between two

   Given two multi-channel feature maps :math:`f_{1}, f_{2}`, with :math:`w`,
   the correlation layer lets the network compare each patch from :math:`f_{1}`

   For now we consider only a single comparison of two patches. The 'correlation'
   :math:`x_{2}` in the second map is then defined as:

   .. math::

   c(x_{1}, x_{2}) = \sum_{o \in [-k,k] \times [-k,k]} &lt;f_{1}(x_{1} + o),

   for a square patch of size :math:`K:=2k+1`.

   Note that the equation above is identical to one step of a convolution in
   neural networks, but instead of convolving data with a filter, it convolves
   data. For this reason, it has no training weights.

   Computing :math:`c(x_{1}, x_{2})` involves :math:`c * K^{2}` multiplications.

   Given a maximum displacement :math:`d`, for each location :math:`x_{1}` it
   computes correlations :math:`c(x_{1}, x_{2})` only in a neighborhood of size
   by limiting the range of :math:`x_{2}`. We use strides :math:`s_{1}, s_{2}`, to
   quantize :math:`x_{1}` globally and to quantize :math:`x_{2}` within the
   centered around :math:`x_{1}`.

   The final output is defined by the following expression:

   .. math::
   out[n, q, i, j] = c(x_{i, j}, x_{q})

   where :math:`i` and :math:`j` enumerate spatial locations in :math:`f_{1}`, and


   Defined in src/operator/correlation.cc:L198
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data1</td><td>Input data1 to the correlation. </td></tr>
<tr><td class="paramname">data2</td><td>Input data2 to the correlation. </td></tr>
<tr><td class="paramname">kernel_size</td><td>kernel size for Correlation must be an odd number </td></tr>
<tr><td class="paramname">max_displacement</td><td>Max displacement of Correlation </td></tr>
<tr><td class="paramname">stride1</td><td>stride1 quantize data1 globally </td></tr>
<tr><td class="paramname">stride2</td><td>stride2 quantize data2 within the neighborhood centered around data1 </td></tr>
<tr><td class="paramname">pad_size</td><td>pad for Correlation </td></tr>
<tr><td class="paramname">is_multiply</td><td>operation type is either multiplication or subduction </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="ad9c0c80b7c1aa1d5728d5cddf267a210"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::Correlation </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data1</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data2</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint32_t </td>
<td class="paramname"><em>kernel_size</em> = <code>1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint32_t </td>
<td class="paramname"><em>max_displacement</em> = <code>1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint32_t </td>
<td class="paramname"><em>stride1</em> = <code>1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint32_t </td>
<td class="paramname"><em>stride2</em> = <code>1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint32_t </td>
<td class="paramname"><em>pad_size</em> = <code>0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>is_multiply</em> = <code>true</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Applies correlation to inputs. </p><pre class="fragment">   The correlation layer performs multiplicative patch comparisons between two

   Given two multi-channel feature maps :math:`f_{1}, f_{2}`, with :math:`w`,
   the correlation layer lets the network compare each patch from :math:`f_{1}`

   For now we consider only a single comparison of two patches. The 'correlation'
   :math:`x_{2}` in the second map is then defined as:

   .. math::

   c(x_{1}, x_{2}) = \sum_{o \in [-k,k] \times [-k,k]} &lt;f_{1}(x_{1} + o),

   for a square patch of size :math:`K:=2k+1`.

   Note that the equation above is identical to one step of a convolution in
   neural networks, but instead of convolving data with a filter, it convolves
   data. For this reason, it has no training weights.

   Computing :math:`c(x_{1}, x_{2})` involves :math:`c * K^{2}` multiplications.

   Given a maximum displacement :math:`d`, for each location :math:`x_{1}` it
   computes correlations :math:`c(x_{1}, x_{2})` only in a neighborhood of size
   by limiting the range of :math:`x_{2}`. We use strides :math:`s_{1}, s_{2}`, to
   quantize :math:`x_{1}` globally and to quantize :math:`x_{2}` within the
   centered around :math:`x_{1}`.

   The final output is defined by the following expression:

   .. math::
   out[n, q, i, j] = c(x_{i, j}, x_{q})

   where :math:`i` and :math:`j` enumerate spatial locations in :math:`f_{1}`, and


   Defined in src/operator/correlation.cc:L198
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data1</td><td>Input data1 to the correlation. </td></tr>
<tr><td class="paramname">data2</td><td>Input data2 to the correlation. </td></tr>
<tr><td class="paramname">kernel_size</td><td>kernel size for Correlation must be an odd number </td></tr>
<tr><td class="paramname">max_displacement</td><td>Max displacement of Correlation </td></tr>
<tr><td class="paramname">stride1</td><td>stride1 quantize data1 globally </td></tr>
<tr><td class="paramname">stride2</td><td>stride2 quantize data2 within the neighborhood centered around data1 </td></tr>
<tr><td class="paramname">pad_size</td><td>pad for Correlation </td></tr>
<tr><td class="paramname">is_multiply</td><td>operation type is either multiplication or subduction </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a27d67a7fa628351ad6c11cb0a72b2cfb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::cos </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Computes the element-wise cosine of the input array. </p><pre class="fragment">   The input should be in radians (:math:`2\pi` rad equals 360 degrees).

   .. math::
   cos([0, \pi/4, \pi/2]) = [1, 0.707, 0]

   The storage type of ``cos`` output is always dense



   Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L63
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>The input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="af6bfbb4921ebbb4ad15349ddffa1142a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::cos </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Computes the element-wise cosine of the input array. </p><pre class="fragment">   The input should be in radians (:math:`2\pi` rad equals 360 degrees).

   .. math::
   cos([0, \pi/4, \pi/2]) = [1, 0.707, 0]

   The storage type of ``cos`` output is always dense



   Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L63
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>The input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a1447e9ca11b50f9692c5fe4d12dd89e8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::cosh </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns the hyperbolic cosine of the input array, computed element-wise. </p><pre class="fragment">   .. math::
   cosh(x) = 0.5\times(exp(x) + exp(-x))

   The storage type of ``cosh`` output is always dense



   Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L216
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>The input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="ad767ecc1945ee3167f06956973bd44e2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::cosh </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns the hyperbolic cosine of the input array, computed element-wise. </p><pre class="fragment">   .. math::
   cosh(x) = 0.5\times(exp(x) + exp(-x))

   The storage type of ``cosh`` output is always dense



   Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L216
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>The input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a442bf3433dca1839065262e06fa7bf57"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::Crop </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>num_args</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>crop_like</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> </td>
<td class="paramname"><em>offset</em> = <code><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>(0, 0)</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> </td>
<td class="paramname"><em>h_w</em> = <code><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>(0, 0)</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>center_crop</em> = <code>false</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a class="anchor" id="a39f7204c05fea075591fe9aa424d95aa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::Crop </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const std::vector&lt; <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> &gt; &amp; </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>num_args</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> </td>
<td class="paramname"><em>offset</em> = <code><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>(0,0)</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> </td>
<td class="paramname"><em>h_w</em> = <code><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>(0,0)</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>center_crop</em> = <code>false</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<pre class="fragment">   .. note:: `Crop` is deprecated. Use `slice` instead.

   Crop the 2nd and 3rd dim of input data, with the corresponding size of h_w or
   with width and height of the second input symbol, i.e., with one input, we need
   specify the crop height and width, otherwise the second input symbol's size


   Defined in src/operator/crop.cc:L50
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>Tensor or List of Tensors, the second input will be used as crop_like </td></tr>
<tr><td class="paramname">num_args</td><td>Number of inputs for crop, if equals one, then we will use the h_wfor crop height and width, else if equals two, then we will use the heightand width </td></tr>
<tr><td class="paramname">offset</td><td>crop offset coordinate: (y, x) </td></tr>
<tr><td class="paramname">h_w</td><td>crop height and width: (h, w) </td></tr>
<tr><td class="paramname">center_crop</td><td>If set to true, then it will use be the center_crop,or it will crop </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a15aac6f62d48528ff0e41eeac0912327"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::Crop </td>
<td>(</td>
<td class="paramtype">const std::vector&lt; <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> &gt; &amp; </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>num_args</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> </td>
<td class="paramname"><em>offset</em> = <code><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>(0,0)</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> </td>
<td class="paramname"><em>h_w</em> = <code><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>(0,0)</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>center_crop</em> = <code>false</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<pre class="fragment">   .. note:: `Crop` is deprecated. Use `slice` instead.

   Crop the 2nd and 3rd dim of input data, with the corresponding size of h_w or
   with width and height of the second input symbol, i.e., with one input, we need
   specify the crop height and width, otherwise the second input symbol's size


   Defined in src/operator/crop.cc:L50
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>Tensor or List of Tensors, the second input will be used as crop_like </td></tr>
<tr><td class="paramname">num_args</td><td>Number of inputs for crop, if equals one, then we will use the h_wfor crop height and width, else if equals two, then we will use the heightand width </td></tr>
<tr><td class="paramname">offset</td><td>crop offset coordinate: (y, x) </td></tr>
<tr><td class="paramname">h_w</td><td>crop height and width: (h, w) </td></tr>
<tr><td class="paramname">center_crop</td><td>If set to true, then it will use be the center_crop,or it will crop </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="aa4569bf622fc0b5109a958998451d785"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::Custom </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const std::vector&lt; <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> &gt; &amp; </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>op_type</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Apply a custom operator implemented in a frontend language (like Python). </p><pre class="fragment">   Custom operators should override required methods like `forward` and `backward`.
   The custom operator must be registered before it can be used.
   Please check the tutorial here: /versions/1.3.1/faq/new_op.html.



   Defined in src/operator/custom/custom.cc:L547
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>Input data for the custom operator. </td></tr>
<tr><td class="paramname">op_type</td><td>Name of the custom operator. This is the name that is passed to </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a7667f538b000216fade42cb15ba39a8f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::Custom </td>
<td>(</td>
<td class="paramtype">const std::vector&lt; <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> &gt; &amp; </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>op_type</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Apply a custom operator implemented in a frontend language (like Python). </p><pre class="fragment">   Custom operators should override required methods like `forward` and `backward`.
   The custom operator must be registered before it can be used.
   Please check the tutorial here: /versions/1.3.1/faq/new_op.html.



   Defined in src/operator/custom/custom.cc:L547
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>Input data for the custom operator. </td></tr>
<tr><td class="paramname">op_type</td><td>Name of the custom operator. This is the name that is passed to </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="aefff3268cf067e42c177e88591f7df99"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::Deconvolution </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>weight</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>bias</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> </td>
<td class="paramname"><em>kernel</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint32_t </td>
<td class="paramname"><em>num_filter</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> </td>
<td class="paramname"><em>stride</em> = <code><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>()</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> </td>
<td class="paramname"><em>dilate</em> = <code><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>()</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> </td>
<td class="paramname"><em>pad</em> = <code><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>()</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> </td>
<td class="paramname"><em>adj</em> = <code><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>()</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> </td>
<td class="paramname"><em>target_shape</em> = <code><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>()</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint32_t </td>
<td class="paramname"><em>num_group</em> = <code>1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint64_t </td>
<td class="paramname"><em>workspace</em> = <code>512</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>no_bias</em> = <code>true</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespacemxnet_1_1cpp.html#ae25c98b47a52531322d1622509c0e84d">DeconvolutionCudnnTune</a> </td>
<td class="paramname"><em>cudnn_tune</em> = <code><a class="el" href="namespacemxnet_1_1cpp.html#aa5dbdd69827034fc43c16cf350db7e1ea35c3ace1970663a16e5c65baa5941b13">DeconvolutionCudnnTune::kNone</a></code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>cudnn_off</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespacemxnet_1_1cpp.html#a63a3b219f6bced4a550ed4bc5207e997">DeconvolutionLayout</a> </td>
<td class="paramname"><em>layout</em> = <code><a class="el" href="namespacemxnet_1_1cpp.html#aa5dbdd69827034fc43c16cf350db7e1ea35c3ace1970663a16e5c65baa5941b13">DeconvolutionLayout::kNone</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Computes 1D or 2D transposed convolution (aka fractionally strided convolution) of the input tensor. This operation can be seen as the gradient of Convolution operation with respect to its input. Convolution usually reduces the size of the input. Transposed convolution works the other way, going from a smaller </p><dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>Input tensor to the deconvolution operation. </td></tr>
<tr><td class="paramname">weight</td><td>Weights representing the kernel. </td></tr>
<tr><td class="paramname">bias</td><td>Bias added to the result after the deconvolution operation. </td></tr>
<tr><td class="paramname">kernel</td><td>Deconvolution kernel size: (w,), (h, w) or (d, h, w). This is same as </td></tr>
<tr><td class="paramname">num_filter</td><td>Number of output filters. </td></tr>
<tr><td class="paramname">stride</td><td>The stride used for the corresponding convolution: (w,), (h, w) or (d, </td></tr>
<tr><td class="paramname">dilate</td><td>Dilation factor for each dimension of the input: (w,), (h, w) or (d, h, </td></tr>
<tr><td class="paramname">pad</td><td>The amount of implicit zero padding added during convolution for each dimension of the input: (w,), (h, w) or (d, h, w). <code>(kernel-1)/2</code> is usually a good choice. If <code>target_shape</code> is set, <code>pad</code> will be ignored and a padding </td></tr>
<tr><td class="paramname">adj</td><td>Adjustment for output shape: (w,), (h, w) or (d, h, w). If <code>target_shape</code> </td></tr>
<tr><td class="paramname">target_shape</td><td><a class="el" href="structmxnet_1_1cpp_1_1Shape.html" title="dynamic shape class that can hold shape of arbirary dimension ">Shape</a> of the output tensor: (w,), (h, w) or (d, h, w). </td></tr>
<tr><td class="paramname">num_group</td><td>Number of groups partition. </td></tr>
<tr><td class="paramname">workspace</td><td>Maximum temporary workspace allowed (MB) in deconvolution.This parameter has two usages. When CUDNN is not used, it determines the effective batch size of the deconvolution kernel. When CUDNN is used, it controls the maximum temporary storage used for tuning the best CUDNN kernel when </td></tr>
<tr><td class="paramname">no_bias</td><td>Whether to disable bias parameter. </td></tr>
<tr><td class="paramname">cudnn_tune</td><td>Whether to pick convolution algorithm by running performance test. </td></tr>
<tr><td class="paramname">cudnn_off</td><td>Turn off cudnn for this layer. </td></tr>
<tr><td class="paramname">layout</td><td>Set layout for input, output and weight. Empty for default layout, NCW </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a7cbaa38ed15a8000f8339c26764c7c2a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::Deconvolution </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>weight</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>bias</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> </td>
<td class="paramname"><em>kernel</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint32_t </td>
<td class="paramname"><em>num_filter</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> </td>
<td class="paramname"><em>stride</em> = <code><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>()</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> </td>
<td class="paramname"><em>dilate</em> = <code><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>()</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> </td>
<td class="paramname"><em>pad</em> = <code><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>()</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> </td>
<td class="paramname"><em>adj</em> = <code><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>()</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> </td>
<td class="paramname"><em>target_shape</em> = <code><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>()</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint32_t </td>
<td class="paramname"><em>num_group</em> = <code>1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint64_t </td>
<td class="paramname"><em>workspace</em> = <code>512</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>no_bias</em> = <code>true</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespacemxnet_1_1cpp.html#ae25c98b47a52531322d1622509c0e84d">DeconvolutionCudnnTune</a> </td>
<td class="paramname"><em>cudnn_tune</em> = <code><a class="el" href="namespacemxnet_1_1cpp.html#aa5dbdd69827034fc43c16cf350db7e1ea35c3ace1970663a16e5c65baa5941b13">DeconvolutionCudnnTune::kNone</a></code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>cudnn_off</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespacemxnet_1_1cpp.html#a63a3b219f6bced4a550ed4bc5207e997">DeconvolutionLayout</a> </td>
<td class="paramname"><em>layout</em> = <code><a class="el" href="namespacemxnet_1_1cpp.html#aa5dbdd69827034fc43c16cf350db7e1ea35c3ace1970663a16e5c65baa5941b13">DeconvolutionLayout::kNone</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Computes 1D or 2D transposed convolution (aka fractionally strided convolution) of the input tensor. This operation can be seen as the gradient of Convolution operation with respect to its input. Convolution usually reduces the size of the input. Transposed convolution works the other way, going from a smaller </p><dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>Input tensor to the deconvolution operation. </td></tr>
<tr><td class="paramname">weight</td><td>Weights representing the kernel. </td></tr>
<tr><td class="paramname">bias</td><td>Bias added to the result after the deconvolution operation. </td></tr>
<tr><td class="paramname">kernel</td><td>Deconvolution kernel size: (w,), (h, w) or (d, h, w). This is same as </td></tr>
<tr><td class="paramname">num_filter</td><td>Number of output filters. </td></tr>
<tr><td class="paramname">stride</td><td>The stride used for the corresponding convolution: (w,), (h, w) or (d, </td></tr>
<tr><td class="paramname">dilate</td><td>Dilation factor for each dimension of the input: (w,), (h, w) or (d, h, </td></tr>
<tr><td class="paramname">pad</td><td>The amount of implicit zero padding added during convolution for each dimension of the input: (w,), (h, w) or (d, h, w). <code>(kernel-1)/2</code> is usually a good choice. If <code>target_shape</code> is set, <code>pad</code> will be ignored and a padding </td></tr>
<tr><td class="paramname">adj</td><td>Adjustment for output shape: (w,), (h, w) or (d, h, w). If <code>target_shape</code> </td></tr>
<tr><td class="paramname">target_shape</td><td><a class="el" href="structmxnet_1_1cpp_1_1Shape.html" title="dynamic shape class that can hold shape of arbirary dimension ">Shape</a> of the output tensor: (w,), (h, w) or (d, h, w). </td></tr>
<tr><td class="paramname">num_group</td><td>Number of groups partition. </td></tr>
<tr><td class="paramname">workspace</td><td>Maximum temporary workspace allowed (MB) in deconvolution.This parameter has two usages. When CUDNN is not used, it determines the effective batch size of the deconvolution kernel. When CUDNN is used, it controls the maximum temporary storage used for tuning the best CUDNN kernel when </td></tr>
<tr><td class="paramname">no_bias</td><td>Whether to disable bias parameter. </td></tr>
<tr><td class="paramname">cudnn_tune</td><td>Whether to pick convolution algorithm by running performance test. </td></tr>
<tr><td class="paramname">cudnn_off</td><td>Turn off cudnn for this layer. </td></tr>
<tr><td class="paramname">layout</td><td>Set layout for input, output and weight. Empty for default layout, NCW </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="af70569cfb0277bee3427b02edd4963cc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::degrees </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Converts each element of the input array from radians to degrees. </p><pre class="fragment">   .. math::
   degrees([0, \pi/2, \pi, 3\pi/2, 2\pi]) = [0, 90, 180, 270, 360]

   The storage type of ``degrees`` output depends upon the input storage type:

   - degrees(default) = default
   - degrees(row_sparse) = row_sparse
   - degrees(csr) = csr



   Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L163
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>The input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a459d2873fa5ad23b9c65de57cf8f405c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::degrees </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Converts each element of the input array from radians to degrees. </p><pre class="fragment">   .. math::
   degrees([0, \pi/2, \pi, 3\pi/2, 2\pi]) = [0, 90, 180, 270, 360]

   The storage type of ``degrees`` output depends upon the input storage type:

   - degrees(default) = default
   - degrees(row_sparse) = row_sparse
   - degrees(csr) = csr



   Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L163
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>The input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a8e1dce205b0d9379ef709ee6878501e6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::depth_to_space </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>block_size</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Rearranges(permutes) data from depth into blocks of spatial data. Similar to ONNX DepthToSpace operator: <a href="https://github.com/onnx/onnx/blob/master/docs/Operators.md#DepthToSpace">https://github.com/onnx/onnx/blob/master/docs/Operators.md#DepthToSpace</a>. The output is a new tensor where the values from depth dimension are moved in to height and width dimension. The reverse of this operation is</p>
<p>.. math::</p>
<p>{gather*} x  = reshape(x, [N, block_size, block_size, C / (block_size ^ 2), H * x   = transpose(x , [0, 3, 4, 1, 5, 2]) \ y = reshape(x  , [N, C / (block_size ^ 2), H * block_size, W * {gather*}</p>
<p>where :math:<code>x</code> is an input tensor with default layout as :math:<code>[N, C, H, W]</code>: and :math:<code>y</code> is the output tensor of layout :math:`[N, C / (block_size ^ 2),</p>
<p>Example::</p>
<p>x = [[[[0, 1, 2], [3, 4, 5]], [[6, 7, 8], [9, 10, 11]], [[12, 13, 14], [15, 16, 17]], [[18, 19, 20], [21, 22, 23]]]]</p>
<p>depth_to_space(x, 2) = [[[[0, 6, 1, 7, 2, 8], [12, 18, 13, 19, 14, 20], [3, 9, 4, 10, 5, 11], [15, 21, 16, 22, 17, 23]]]]</p>
<pre class="fragment">   Defined in src/operator/tensor/matrix_op.cc:L945
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>Input ndarray </td></tr>
<tr><td class="paramname">block_size</td><td>Blocks of [block_size. block_size] are moved </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a6a897b4e1c81d9f47a8d4da5be7f1d2e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::depth_to_space </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>block_size</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Rearranges(permutes) data from depth into blocks of spatial data. Similar to ONNX DepthToSpace operator: <a href="https://github.com/onnx/onnx/blob/master/docs/Operators.md#DepthToSpace">https://github.com/onnx/onnx/blob/master/docs/Operators.md#DepthToSpace</a>. The output is a new tensor where the values from depth dimension are moved in to height and width dimension. The reverse of this operation is</p>
<p>.. math::</p>
<p>{gather*} x  = reshape(x, [N, block_size, block_size, C / (block_size ^ 2), H * x   = transpose(x , [0, 3, 4, 1, 5, 2]) \ y = reshape(x  , [N, C / (block_size ^ 2), H * block_size, W * {gather*}</p>
<p>where :math:<code>x</code> is an input tensor with default layout as :math:<code>[N, C, H, W]</code>: and :math:<code>y</code> is the output tensor of layout :math:`[N, C / (block_size ^ 2),</p>
<p>Example::</p>
<p>x = [[[[0, 1, 2], [3, 4, 5]], [[6, 7, 8], [9, 10, 11]], [[12, 13, 14], [15, 16, 17]], [[18, 19, 20], [21, 22, 23]]]]</p>
<p>depth_to_space(x, 2) = [[[[0, 6, 1, 7, 2, 8], [12, 18, 13, 19, 14, 20], [3, 9, 4, 10, 5, 11], [15, 21, 16, 22, 17, 23]]]]</p>
<pre class="fragment">   Defined in src/operator/tensor/matrix_op.cc:L945
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>Input ndarray </td></tr>
<tr><td class="paramname">block_size</td><td>Blocks of [block_size. block_size] are moved </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a92ce214592b710caf84e4bb891641342"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::diag </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">dmlc::optional&lt; int &gt; </td>
<td class="paramname"><em>k</em> = <code>dmlc::optional&lt;int&gt;(0)</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Extracts a diagonal or constructs a diagonal array. </p><pre class="fragment">   ``diag``'s behavior depends on the input array dimensions:

   - 1-D arrays: constructs a 2-D array with the input as its diagonal, all other
   - 2-D arrays: returns elements in the diagonal as a new 1-D array
   - N-D arrays: not supported yet

   Examples::

   x = [[1, 2, 3],
   [4, 5, 6]]

   diag(x) = [1, 5]

   diag(x, k=1) = [2, 6]

   diag(x, k=-1) = [4]

   x = [1, 2, 3]

   diag(x) = [[1, 0, 0],
   [0, 2, 0],
   [0, 0, 3]]

   diag(x, k=1) = [[0, 1, 0],
   [0, 0, 2],
   [0, 0, 0]]

   diag(x, k=-1) = [[0, 0, 0],
   [1, 0, 0],
   [0, 2, 0]]



   Defined in src/operator/tensor/diag_op.cc:L68
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>Input ndarray </td></tr>
<tr><td class="paramname">k</td><td>Diagonal in question. The default is 0. Use k&gt;0 for diagonals above the main diagonal, and k&lt;0 for diagonals below the main diagonal. If input has shape (S0 </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a33cbdc4ccd7233cd4b7762b410ac04e8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::diag </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">dmlc::optional&lt; int &gt; </td>
<td class="paramname"><em>k</em> = <code>dmlc::optional&lt;int&gt;(0)</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Extracts a diagonal or constructs a diagonal array. </p><pre class="fragment">   ``diag``'s behavior depends on the input array dimensions:

   - 1-D arrays: constructs a 2-D array with the input as its diagonal, all other
   - 2-D arrays: returns elements in the diagonal as a new 1-D array
   - N-D arrays: not supported yet

   Examples::

   x = [[1, 2, 3],
   [4, 5, 6]]

   diag(x) = [1, 5]

   diag(x, k=1) = [2, 6]

   diag(x, k=-1) = [4]

   x = [1, 2, 3]

   diag(x) = [[1, 0, 0],
   [0, 2, 0],
   [0, 0, 3]]

   diag(x, k=1) = [[0, 1, 0],
   [0, 0, 2],
   [0, 0, 0]]

   diag(x, k=-1) = [[0, 0, 0],
   [1, 0, 0],
   [0, 2, 0]]



   Defined in src/operator/tensor/diag_op.cc:L68
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>Input ndarray </td></tr>
<tr><td class="paramname">k</td><td>Diagonal in question. The default is 0. Use k&gt;0 for diagonals above the main diagonal, and k&lt;0 for diagonals below the main diagonal. If input has shape (S0 </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a14538ccec46c260488aa78c6b23ad898"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::dot </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>rhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>transpose_a</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>transpose_b</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespacemxnet_1_1cpp.html#aa5dbdd69827034fc43c16cf350db7e1e">DotForwardStype</a> </td>
<td class="paramname"><em>forward_stype</em> = <code><a class="el" href="namespacemxnet_1_1cpp.html#aa5dbdd69827034fc43c16cf350db7e1ea35c3ace1970663a16e5c65baa5941b13">DotForwardStype::kNone</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Dot product of two arrays. </p><pre class="fragment">   ``dot``'s behavior depends on the input array dimensions:

   - 1-D arrays: inner product of vectors
   - 2-D arrays: matrix multiplication
   - N-D arrays: a sum product over the last axis of the first input and the first
   axis of the second input

   For example, given 3-D ``x`` with shape `(n,m,k)` and ``y`` with shape
   result array will have shape `(n,m,r,s)`. It is computed by::

   dot(x,y)[i,j,a,b] = sum(x[i,j,:]*y[:,a,b])

   Example::

   x = reshape([0,1,2,3,4,5,6,7], shape=(2,2,2))
   y = reshape([7,6,5,4,3,2,1,0], shape=(2,2,2))
   dot(x,y)[0,0,1,1] = 0
   sum(x[0,0,:]*y[:,1,1]) = 0

   The storage type of ``dot`` output depends on storage types of inputs,
   forward_stype option for output storage type. Implemented sparse operations

   - dot(default, default, transpose_a=True/False, transpose_b=True/False) =
   - dot(csr, default, transpose_a=True) = default
   - dot(csr, default, transpose_a=True) = row_sparse
   - dot(csr, default) = default
   - dot(csr, row_sparse) = default
   - dot(default, csr) = csr (CPU only)
   - dot(default, csr, forward_stype='default') = default
   - dot(default, csr, transpose_b=True, forward_stype='default') = default

   If the combination of input storage types and forward_stype does not match any
   above patterns, ``dot`` will fallback and generate output with default storage.

   .. Note::

   If the storage type of the lhs is "csr", the storage type of gradient w.r.t rhs
   "row_sparse". Only a subset of optimizers support sparse gradients, including
   and Adam. Note that by default lazy updates is turned on, which may perform
   from standard updates. For more details, please check the Optimization API at:
   /api/python/optimization/optimization.html



   Defined in src/operator/tensor/dot.cc:L77
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">lhs</td><td>The first input </td></tr>
<tr><td class="paramname">rhs</td><td>The second input </td></tr>
<tr><td class="paramname">transpose_a</td><td>If true then transpose the first input before dot. </td></tr>
<tr><td class="paramname">transpose_b</td><td>If true then transpose the second input before dot. </td></tr>
<tr><td class="paramname">forward_stype</td><td>The desired storage type of the forward output given by user, if thecombination of input storage types and this hint does not matchany implemented ones, the dot operator will perform fallback operationand still </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a0917025ca6b94c2ec34960af88e1d5a1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::dot </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>rhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>transpose_a</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>transpose_b</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespacemxnet_1_1cpp.html#aa5dbdd69827034fc43c16cf350db7e1e">DotForwardStype</a> </td>
<td class="paramname"><em>forward_stype</em> = <code><a class="el" href="namespacemxnet_1_1cpp.html#aa5dbdd69827034fc43c16cf350db7e1ea35c3ace1970663a16e5c65baa5941b13">DotForwardStype::kNone</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Dot product of two arrays. </p><pre class="fragment">   ``dot``'s behavior depends on the input array dimensions:

   - 1-D arrays: inner product of vectors
   - 2-D arrays: matrix multiplication
   - N-D arrays: a sum product over the last axis of the first input and the first
   axis of the second input

   For example, given 3-D ``x`` with shape `(n,m,k)` and ``y`` with shape
   result array will have shape `(n,m,r,s)`. It is computed by::

   dot(x,y)[i,j,a,b] = sum(x[i,j,:]*y[:,a,b])

   Example::

   x = reshape([0,1,2,3,4,5,6,7], shape=(2,2,2))
   y = reshape([7,6,5,4,3,2,1,0], shape=(2,2,2))
   dot(x,y)[0,0,1,1] = 0
   sum(x[0,0,:]*y[:,1,1]) = 0

   The storage type of ``dot`` output depends on storage types of inputs,
   forward_stype option for output storage type. Implemented sparse operations

   - dot(default, default, transpose_a=True/False, transpose_b=True/False) =
   - dot(csr, default, transpose_a=True) = default
   - dot(csr, default, transpose_a=True) = row_sparse
   - dot(csr, default) = default
   - dot(csr, row_sparse) = default
   - dot(default, csr) = csr (CPU only)
   - dot(default, csr, forward_stype='default') = default
   - dot(default, csr, transpose_b=True, forward_stype='default') = default

   If the combination of input storage types and forward_stype does not match any
   above patterns, ``dot`` will fallback and generate output with default storage.

   .. Note::

   If the storage type of the lhs is "csr", the storage type of gradient w.r.t rhs
   "row_sparse". Only a subset of optimizers support sparse gradients, including
   and Adam. Note that by default lazy updates is turned on, which may perform
   from standard updates. For more details, please check the Optimization API at:
   /api/python/optimization/optimization.html



   Defined in src/operator/tensor/dot.cc:L77
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">lhs</td><td>The first input </td></tr>
<tr><td class="paramname">rhs</td><td>The second input </td></tr>
<tr><td class="paramname">transpose_a</td><td>If true then transpose the first input before dot. </td></tr>
<tr><td class="paramname">transpose_b</td><td>If true then transpose the second input before dot. </td></tr>
<tr><td class="paramname">forward_stype</td><td>The desired storage type of the forward output given by user, if thecombination of input storage types and this hint does not matchany implemented ones, the dot operator will perform fallback operationand still </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a6688c8cb305077987c5caae840e29540"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::Dropout </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>p</em> = <code>0.5</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespacemxnet_1_1cpp.html#a3cc3a1d19b3bf567326c77e263038a0e">DropoutMode</a> </td>
<td class="paramname"><em>mode</em> = <code><a class="el" href="namespacemxnet_1_1cpp.html#a3cc3a1d19b3bf567326c77e263038a0eabae2199a6d43c4c6ccd0e74727c02a64">DropoutMode::kTraining</a></code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> </td>
<td class="paramname"><em>axes</em> = <code><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Applies dropout operation to input array. </p><pre class="fragment">   - During training, each element of the input is set to zero with probability p.
   The whole array is rescaled by :math:`1/(1-p)` to keep the expected
   sum of the input unchanged.

   - During testing, this operator does not change the input if mode is 'training'.
   If mode is 'always', the same computaion as during training will be applied.

   Example::

   random.seed(998)
   input_array = array([[3., 0.5,  -0.5,  2., 7.],
   [2., -0.4,   7.,  3., 0.2]])
   a = symbol.Variable('a')
   dropout = symbol.Dropout(a, p = 0.2)
   executor = dropout.simple_bind(a = input_array.shape)

   ## If training
   executor.forward(is_train = True, a = input_array)
   executor.outputs
   [[ 3.75   0.625 -0.     2.5    8.75 ]
   [ 2.5   -0.5    8.75   3.75   0.   ]]

   ## If testing
   executor.forward(is_train = False, a = input_array)
   executor.outputs
   [[ 3.     0.5   -0.5    2.     7.   ]
   [ 2.    -0.4    7.     3.     0.2  ]]


   Defined in src/operator/nn/dropout.cc:L76
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>Input array to which dropout will be applied. </td></tr>
<tr><td class="paramname">p</td><td>Fraction of the input that gets dropped out during training time. </td></tr>
<tr><td class="paramname">mode</td><td>Whether to only turn on dropout during training or to also turn on for </td></tr>
<tr><td class="paramname">axes</td><td>Axes for variational dropout kernel. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="abb9455afcffeccf46087775d334ffad7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::Dropout </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>p</em> = <code>0.5</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespacemxnet_1_1cpp.html#a3cc3a1d19b3bf567326c77e263038a0e">DropoutMode</a> </td>
<td class="paramname"><em>mode</em> = <code><a class="el" href="namespacemxnet_1_1cpp.html#a3cc3a1d19b3bf567326c77e263038a0eabae2199a6d43c4c6ccd0e74727c02a64">DropoutMode::kTraining</a></code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> </td>
<td class="paramname"><em>axes</em> = <code><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Applies dropout operation to input array. </p><pre class="fragment">   - During training, each element of the input is set to zero with probability p.
   The whole array is rescaled by :math:`1/(1-p)` to keep the expected
   sum of the input unchanged.

   - During testing, this operator does not change the input if mode is 'training'.
   If mode is 'always', the same computaion as during training will be applied.

   Example::

   random.seed(998)
   input_array = array([[3., 0.5,  -0.5,  2., 7.],
   [2., -0.4,   7.,  3., 0.2]])
   a = symbol.Variable('a')
   dropout = symbol.Dropout(a, p = 0.2)
   executor = dropout.simple_bind(a = input_array.shape)

   ## If training
   executor.forward(is_train = True, a = input_array)
   executor.outputs
   [[ 3.75   0.625 -0.     2.5    8.75 ]
   [ 2.5   -0.5    8.75   3.75   0.   ]]

   ## If testing
   executor.forward(is_train = False, a = input_array)
   executor.outputs
   [[ 3.     0.5   -0.5    2.     7.   ]
   [ 2.    -0.4    7.     3.     0.2  ]]


   Defined in src/operator/nn/dropout.cc:L76
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>Input array to which dropout will be applied. </td></tr>
<tr><td class="paramname">p</td><td>Fraction of the input that gets dropped out during training time. </td></tr>
<tr><td class="paramname">mode</td><td>Whether to only turn on dropout during training or to also turn on for </td></tr>
<tr><td class="paramname">axes</td><td>Axes for variational dropout kernel. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a9dc86a3606afe7cc7ed8d028f58cddc5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::elemwise_add </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>rhs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Adds arguments element-wise. </p><pre class="fragment">   The storage type of ``elemwise_add`` output depends on storage types of inputs

   - elemwise_add(row_sparse, row_sparse) = row_sparse
   - elemwise_add(csr, csr) = csr
   - elemwise_add(default, csr) = default
   - elemwise_add(csr, default) = default
   - elemwise_add(default, rsp) = default
   - elemwise_add(rsp, default) = default
   - otherwise, ``elemwise_add`` generates output with default storage
</pre><dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">lhs</td><td>first input </td></tr>
<tr><td class="paramname">rhs</td><td>second input </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a11744b6b7d915633107650990dd00148"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::elemwise_add </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>rhs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Adds arguments element-wise. </p><pre class="fragment">   The storage type of ``elemwise_add`` output depends on storage types of inputs

   - elemwise_add(row_sparse, row_sparse) = row_sparse
   - elemwise_add(csr, csr) = csr
   - elemwise_add(default, csr) = default
   - elemwise_add(csr, default) = default
   - elemwise_add(default, rsp) = default
   - elemwise_add(rsp, default) = default
   - otherwise, ``elemwise_add`` generates output with default storage
</pre><dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">lhs</td><td>first input </td></tr>
<tr><td class="paramname">rhs</td><td>second input </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a3a21ba4707a30004aed65f61e10feae8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::elemwise_div </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>rhs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Divides arguments element-wise. </p><pre class="fragment">   The storage type of ``elemwise_div`` output is always dense
</pre><dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">lhs</td><td>first input </td></tr>
<tr><td class="paramname">rhs</td><td>second input </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a1d09f5f44e0dc4d06a98760325a7209d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::elemwise_div </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>rhs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Divides arguments element-wise. </p><pre class="fragment">   The storage type of ``elemwise_div`` output is always dense
</pre><dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">lhs</td><td>first input </td></tr>
<tr><td class="paramname">rhs</td><td>second input </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a83ef847676bdcba737c0aa0e42ec93cb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::elemwise_mul </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>rhs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Multiplies arguments element-wise. </p><pre class="fragment">   The storage type of ``elemwise_mul`` output depends on storage types of inputs

   - elemwise_mul(default, default) = default
   - elemwise_mul(row_sparse, row_sparse) = row_sparse
   - elemwise_mul(default, row_sparse) = row_sparse
   - elemwise_mul(row_sparse, default) = row_sparse
   - elemwise_mul(csr, csr) = csr
   - otherwise, ``elemwise_mul`` generates output with default storage
</pre><dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">lhs</td><td>first input </td></tr>
<tr><td class="paramname">rhs</td><td>second input </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a0076b96722559b32d5812aad03c5498a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::elemwise_mul </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>rhs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Multiplies arguments element-wise. </p><pre class="fragment">   The storage type of ``elemwise_mul`` output depends on storage types of inputs

   - elemwise_mul(default, default) = default
   - elemwise_mul(row_sparse, row_sparse) = row_sparse
   - elemwise_mul(default, row_sparse) = row_sparse
   - elemwise_mul(row_sparse, default) = row_sparse
   - elemwise_mul(csr, csr) = csr
   - otherwise, ``elemwise_mul`` generates output with default storage
</pre><dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">lhs</td><td>first input </td></tr>
<tr><td class="paramname">rhs</td><td>second input </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a77452970fd3d028295db976f8720a553"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::elemwise_sub </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>rhs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Subtracts arguments element-wise. </p><pre class="fragment">   The storage type of ``elemwise_sub`` output depends on storage types of inputs

   - elemwise_sub(row_sparse, row_sparse) = row_sparse
   - elemwise_sub(csr, csr) = csr
   - elemwise_sub(default, csr) = default
   - elemwise_sub(csr, default) = default
   - elemwise_sub(default, rsp) = default
   - elemwise_sub(rsp, default) = default
   - otherwise, ``elemwise_sub`` generates output with default storage
</pre><dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">lhs</td><td>first input </td></tr>
<tr><td class="paramname">rhs</td><td>second input </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a348c1ba14a3a9c8adfbac8570c1c8cbf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::elemwise_sub </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>rhs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Subtracts arguments element-wise. </p><pre class="fragment">   The storage type of ``elemwise_sub`` output depends on storage types of inputs

   - elemwise_sub(row_sparse, row_sparse) = row_sparse
   - elemwise_sub(csr, csr) = csr
   - elemwise_sub(default, csr) = default
   - elemwise_sub(csr, default) = default
   - elemwise_sub(default, rsp) = default
   - elemwise_sub(rsp, default) = default
   - otherwise, ``elemwise_sub`` generates output with default storage
</pre><dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">lhs</td><td>first input </td></tr>
<tr><td class="paramname">rhs</td><td>second input </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a0987ecb278115a257e0f61394b0814c7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::Embedding </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>weight</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>input_dim</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>output_dim</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespacemxnet_1_1cpp.html#a3c80705d63347982667fc541ad5bf845">EmbeddingDtype</a> </td>
<td class="paramname"><em>dtype</em> = <code><a class="el" href="namespacemxnet_1_1cpp.html#a8e907a5fbbe4ec21628e500b34a5f35da9a78d6a569d086b524c3caf8c2522f96">EmbeddingDtype::kFloat32</a></code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>sparse_grad</em> = <code>false</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Maps integer indices to vector representations (embeddings). </p><pre class="fragment">   This operator maps words to real-valued vectors in a high-dimensional space,
   called word embeddings. These embeddings can capture semantic and syntactic
   For example, it has been noted that in the learned embedding spaces, similar
   to be close to each other and dissimilar words far apart.

   For an input array of shape (d1, ..., dK),
   the shape of an output array is (d1, ..., dK, output_dim).
   All the input values should be integers in the range [0, input_dim).

   If the input_dim is ip0 and output_dim is op0, then shape of the embedding
   (ip0, op0).

   By default, if any index mentioned is too large, it is replaced by the index
   the last vector in an embedding matrix.

   Examples::

   input_dim = 4
   output_dim = 5

   // Each row in weight matrix y represents a word. So, y = (w0,w1,w2,w3)
   y = [[  0.,   1.,   2.,   3.,   4.],
   [  5.,   6.,   7.,   8.,   9.],
   [ 10.,  11.,  12.,  13.,  14.],
   [ 15.,  16.,  17.,  18.,  19.]]

   // Input array x represents n-grams(2-gram). So, x = [(w1,w3), (w0,w2)]
   x = [[ 1.,  3.],
   [ 0.,  2.]]

   // Mapped input x to its vector representation y.
   Embedding(x, y, 4, 5) = [[[  5.,   6.,   7.,   8.,   9.],
   [ 15.,  16.,  17.,  18.,  19.]],

   [[  0.,   1.,   2.,   3.,   4.],
   [ 10.,  11.,  12.,  13.,  14.]]]


   The storage type of weight can be either row_sparse or default.

   .. Note::

   If "sparse_grad" is set to True, the storage type of gradient w.r.t weights
   "row_sparse". Only a subset of optimizers support sparse gradients, including
   and Adam. Note that by default lazy updates is turned on, which may perform
   from standard updates. For more details, please check the Optimization API at:
   /api/python/optimization/optimization.html



   Defined in src/operator/tensor/indexing_op.cc:L267
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>The input array to the embedding operator. </td></tr>
<tr><td class="paramname">weight</td><td>The embedding weight matrix. </td></tr>
<tr><td class="paramname">input_dim</td><td>Vocabulary size of the input indices. </td></tr>
<tr><td class="paramname">output_dim</td><td>Dimension of the embedding vectors. </td></tr>
<tr><td class="paramname">dtype</td><td>Data type of weight. </td></tr>
<tr><td class="paramname">sparse_grad</td><td>Compute row sparse gradient in the backward calculation. If set to </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a9cc796ff537ca3c3b5a06f7b78df5c5b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::Embedding </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>weight</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>input_dim</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>output_dim</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespacemxnet_1_1cpp.html#a3c80705d63347982667fc541ad5bf845">EmbeddingDtype</a> </td>
<td class="paramname"><em>dtype</em> = <code><a class="el" href="namespacemxnet_1_1cpp.html#a8e907a5fbbe4ec21628e500b34a5f35da9a78d6a569d086b524c3caf8c2522f96">EmbeddingDtype::kFloat32</a></code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>sparse_grad</em> = <code>false</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Maps integer indices to vector representations (embeddings). </p><pre class="fragment">   This operator maps words to real-valued vectors in a high-dimensional space,
   called word embeddings. These embeddings can capture semantic and syntactic
   For example, it has been noted that in the learned embedding spaces, similar
   to be close to each other and dissimilar words far apart.

   For an input array of shape (d1, ..., dK),
   the shape of an output array is (d1, ..., dK, output_dim).
   All the input values should be integers in the range [0, input_dim).

   If the input_dim is ip0 and output_dim is op0, then shape of the embedding
   (ip0, op0).

   By default, if any index mentioned is too large, it is replaced by the index
   the last vector in an embedding matrix.

   Examples::

   input_dim = 4
   output_dim = 5

   // Each row in weight matrix y represents a word. So, y = (w0,w1,w2,w3)
   y = [[  0.,   1.,   2.,   3.,   4.],
   [  5.,   6.,   7.,   8.,   9.],
   [ 10.,  11.,  12.,  13.,  14.],
   [ 15.,  16.,  17.,  18.,  19.]]

   // Input array x represents n-grams(2-gram). So, x = [(w1,w3), (w0,w2)]
   x = [[ 1.,  3.],
   [ 0.,  2.]]

   // Mapped input x to its vector representation y.
   Embedding(x, y, 4, 5) = [[[  5.,   6.,   7.,   8.,   9.],
   [ 15.,  16.,  17.,  18.,  19.]],

   [[  0.,   1.,   2.,   3.,   4.],
   [ 10.,  11.,  12.,  13.,  14.]]]


   The storage type of weight can be either row_sparse or default.

   .. Note::

   If "sparse_grad" is set to True, the storage type of gradient w.r.t weights
   "row_sparse". Only a subset of optimizers support sparse gradients, including
   and Adam. Note that by default lazy updates is turned on, which may perform
   from standard updates. For more details, please check the Optimization API at:
   /api/python/optimization/optimization.html



   Defined in src/operator/tensor/indexing_op.cc:L267
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>The input array to the embedding operator. </td></tr>
<tr><td class="paramname">weight</td><td>The embedding weight matrix. </td></tr>
<tr><td class="paramname">input_dim</td><td>Vocabulary size of the input indices. </td></tr>
<tr><td class="paramname">output_dim</td><td>Dimension of the embedding vectors. </td></tr>
<tr><td class="paramname">dtype</td><td>Data type of weight. </td></tr>
<tr><td class="paramname">sparse_grad</td><td>Compute row sparse gradient in the backward calculation. If set to </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="af9cfdd6329c237d4b9ee144c24f51900"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::exp </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns element-wise exponential value of the input. </p><pre class="fragment">   .. math::
   exp(x) = e^x \approx 2.718^x

   Example::

   exp([0, 1, 2]) = [1., 2.71828175, 7.38905621]

   The storage type of ``exp`` output is always dense



   Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L929
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>The input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a7180e751ec056919b26c7235354a3452"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::exp </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns element-wise exponential value of the input. </p><pre class="fragment">   .. math::
   exp(x) = e^x \approx 2.718^x

   Example::

   exp([0, 1, 2]) = [1., 2.71828175, 7.38905621]

   The storage type of ``exp`` output is always dense



   Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L929
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>The input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a91ad2b6dbe27c48818774c11e2b5b742"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::expand_dims </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>axis</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Inserts a new axis of size 1 into the array shape </p><pre class="fragment">   For example, given ``x`` with shape ``(2,3,4)``, then ``expand_dims(x, axis=1)``
   will return a new array with shape ``(2,1,3,4)``.



   Defined in src/operator/tensor/matrix_op.cc:L347
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>Source input </td></tr>
<tr><td class="paramname">axis</td><td>Position where new axis is to be inserted. Suppose that the input <code><a class="el" href="classmxnet_1_1cpp_1_1NDArray.html" title="NDArray interface. ">NDArray</a></code>'s dimension is <code>ndim</code>, the range of the inserted axis is `[-ndim, </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="ada9ddaa3e0be235d25df55558ef350c5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::expand_dims </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>axis</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Inserts a new axis of size 1 into the array shape </p><pre class="fragment">   For example, given ``x`` with shape ``(2,3,4)``, then ``expand_dims(x, axis=1)``
   will return a new array with shape ``(2,1,3,4)``.



   Defined in src/operator/tensor/matrix_op.cc:L347
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>Source input </td></tr>
<tr><td class="paramname">axis</td><td>Position where new axis is to be inserted. Suppose that the input <code><a class="el" href="classmxnet_1_1cpp_1_1NDArray.html" title="NDArray interface. ">NDArray</a></code>'s dimension is <code>ndim</code>, the range of the inserted axis is `[-ndim, </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a6bc44d0e8ab9f520f92dac705665958b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::expm1 </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns <code>exp(x) - 1</code> computed element-wise on the input. </p><pre class="fragment">   This function provides greater precision than ``exp(x) - 1`` for small values

   The storage type of ``expm1`` output depends upon the input storage type:

   - expm1(default) = default
   - expm1(row_sparse) = row_sparse
   - expm1(csr) = csr



   Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L1008
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>The input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a4475973b83abcaef7a8147fd1d7354d9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::expm1 </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns <code>exp(x) - 1</code> computed element-wise on the input. </p><pre class="fragment">   This function provides greater precision than ``exp(x) - 1`` for small values

   The storage type of ``expm1`` output depends upon the input storage type:

   - expm1(default) = default
   - expm1(row_sparse) = row_sparse
   - expm1(csr) = csr



   Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L1008
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>The input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="af977c7bf3bb24f5ebe973dcb41680244"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::fill_element_0index </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>mhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>rhs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Fill one element of each line(row for python, column for R/Julia) in lhs according to index indicated by rhs and values indicated by mhs. This function </p><dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">lhs</td><td>Left operand to the function. </td></tr>
<tr><td class="paramname">mhs</td><td>Middle operand to the function. </td></tr>
<tr><td class="paramname">rhs</td><td>Right operand to the function. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a2d831f1a544ca07c5355dac626926a91"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::fill_element_0index </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>mhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>rhs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Fill one element of each line(row for python, column for R/Julia) in lhs according to index indicated by rhs and values indicated by mhs. This function </p><dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">lhs</td><td>Left operand to the function. </td></tr>
<tr><td class="paramname">mhs</td><td>Middle operand to the function. </td></tr>
<tr><td class="paramname">rhs</td><td>Right operand to the function. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="acae3f2a8b1b2882faa9fd0db7332e555"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::fix </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns element-wise rounded value to the nearest \ integer towards zero of the input.</p>
<p>Example::</p>
<p>fix([-2.1, -1.9, 1.9, 2.1]) = [-2., -1., 1., 2.]</p>
<p>The storage type of <code>fix</code> output depends upon the input storage type:</p>
<ul>
<li>fix(default) = default</li>
<li>fix(row_sparse) = row_sparse</li>
<li>fix(csr) = csr</li>
</ul>
<pre class="fragment">   Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L803
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>The input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a9fdd2c357d6e02a795232469b71870a6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::fix </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns element-wise rounded value to the nearest \ integer towards zero of the input.</p>
<p>Example::</p>
<p>fix([-2.1, -1.9, 1.9, 2.1]) = [-2., -1., 1., 2.]</p>
<p>The storage type of <code>fix</code> output depends upon the input storage type:</p>
<ul>
<li>fix(default) = default</li>
<li>fix(row_sparse) = row_sparse</li>
<li>fix(csr) = csr</li>
</ul>
<pre class="fragment">   Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L803
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>The input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="aa3470d98c61a10ac5a1c583304ca81e9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::Flatten </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Flattens the input array into a 2-D array by collapsing the higher dimensions. </p><pre class="fragment">   .. note:: `Flatten` is deprecated. Use `flatten` instead.

   For an input array with shape ``(d1, d2, ..., dk)``, `flatten` operation
   the input array into an output array of shape ``(d1, d2*...*dk)``.

   Note that the bahavior of this function is different from numpy.ndarray.flatten,
   which behaves similar to mxnet.ndarray.reshape((-1,)).

   Example::

   x = [[
   [1,2,3],
   [4,5,6],
   [7,8,9]
   ],
   [    [1,2,3],
   [4,5,6],
   [7,8,9]
   ]],

   flatten(x) = [[ 1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9.],
   [ 1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9.]]



   Defined in src/operator/tensor/matrix_op.cc:L259
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>Input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="ad503b97061cd6b0e2424e4f9d032e816"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::Flatten </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Flattens the input array into a 2-D array by collapsing the higher dimensions. </p><pre class="fragment">   .. note:: `Flatten` is deprecated. Use `flatten` instead.

   For an input array with shape ``(d1, d2, ..., dk)``, `flatten` operation
   the input array into an output array of shape ``(d1, d2*...*dk)``.

   Note that the bahavior of this function is different from numpy.ndarray.flatten,
   which behaves similar to mxnet.ndarray.reshape((-1,)).

   Example::

   x = [[
   [1,2,3],
   [4,5,6],
   [7,8,9]
   ],
   [    [1,2,3],
   [4,5,6],
   [7,8,9]
   ]],

   flatten(x) = [[ 1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9.],
   [ 1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9.]]



   Defined in src/operator/tensor/matrix_op.cc:L259
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>Input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="ab4a01c682ea7f62223804ed33615048a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::floor </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns element-wise floor of the input. </p><pre class="fragment">   The floor of the scalar x is the largest integer i, such that i &lt;= x.

   Example::

   floor([-2.1, -1.9, 1.5, 1.9, 2.1]) = [-3., -2.,  1.,  1.,  2.]

   The storage type of ``floor`` output depends upon the input storage type:

   - floor(default) = default
   - floor(row_sparse) = row_sparse
   - floor(csr) = csr



   Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L765
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>The input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="ab1b48af1f465a9282bc6e0709ccef36c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::floor </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns element-wise floor of the input. </p><pre class="fragment">   The floor of the scalar x is the largest integer i, such that i &lt;= x.

   Example::

   floor([-2.1, -1.9, 1.5, 1.9, 2.1]) = [-3., -2.,  1.,  1.,  2.]

   The storage type of ``floor`` output depends upon the input storage type:

   - floor(default) = default
   - floor(row_sparse) = row_sparse
   - floor(csr) = csr



   Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L765
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>The input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a6bf2167ad08a5ffa15df5a8743241adb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::ftml_update </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>weight</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>grad</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>d</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>v</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>z</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>lr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>t</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>beta1</em> = <code>0.6</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>beta2</em> = <code>0.999</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double </td>
<td class="paramname"><em>epsilon</em> = <code>1e-08</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>wd</em> = <code>0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>rescale_grad</em> = <code>1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>clip_grad</em> = <code>-1</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>The FTML optimizer described in <em>FTML - Follow the Moving Leader in Deep Learning</em>, available at <a href="http://proceedings.mlr.press/v70/zheng17a/zheng17a.pdf">http://proceedings.mlr.press/v70/zheng17a/zheng17a.pdf</a>.</p>
<p>.. math::</p>
<p>g_t =  J(W_{t-1})\ v_t =  v_{t-1} + (1 - ) g_t^2\ d_t = { 1 - ^t }{  } ({ { v_t }{ 1 - ^t } }  = d_t -  d_{t-1} z_t =  z_{ t-1 } + (1 - ^t) g_t -  W_{t-1} W_t = - { z_t }{ d_t }</p>
<pre class="fragment">   Defined in src/operator/optimizer_op.cc:L447
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">weight</td><td>Weight </td></tr>
<tr><td class="paramname">grad</td><td>Gradient </td></tr>
<tr><td class="paramname">d</td><td>Internal state <code>d_t</code> </td></tr>
<tr><td class="paramname">v</td><td>Internal state <code>v_t</code> </td></tr>
<tr><td class="paramname">z</td><td>Internal state <code>z_t</code> </td></tr>
<tr><td class="paramname">lr</td><td>Learning rate. </td></tr>
<tr><td class="paramname">t</td><td>Number of update. </td></tr>
<tr><td class="paramname">beta1</td><td>Generally close to 0.5. </td></tr>
<tr><td class="paramname">beta2</td><td>Generally close to 1. </td></tr>
<tr><td class="paramname">epsilon</td><td>Epsilon to prevent div 0. </td></tr>
<tr><td class="paramname">wd</td><td>Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of </td></tr>
<tr><td class="paramname">rescale_grad</td><td>Rescale gradient to grad = rescale_grad*grad. </td></tr>
<tr><td class="paramname">clip_grad</td><td>Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="ac5cce010ff2b5aeddc0886cc02022628"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::ftml_update </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>weight</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>grad</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>d</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>v</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>z</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>lr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>t</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>beta1</em> = <code>0.6</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>beta2</em> = <code>0.999</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double </td>
<td class="paramname"><em>epsilon</em> = <code>1e-08</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>wd</em> = <code>0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>rescale_grad</em> = <code>1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>clip_grad</em> = <code>-1</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>The FTML optimizer described in <em>FTML - Follow the Moving Leader in Deep Learning</em>, available at <a href="http://proceedings.mlr.press/v70/zheng17a/zheng17a.pdf">http://proceedings.mlr.press/v70/zheng17a/zheng17a.pdf</a>.</p>
<p>.. math::</p>
<p>g_t =  J(W_{t-1})\ v_t =  v_{t-1} + (1 - ) g_t^2\ d_t = { 1 - ^t }{  } ({ { v_t }{ 1 - ^t } }  = d_t -  d_{t-1} z_t =  z_{ t-1 } + (1 - ^t) g_t -  W_{t-1} W_t = - { z_t }{ d_t }</p>
<pre class="fragment">   Defined in src/operator/optimizer_op.cc:L447
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">weight</td><td>Weight </td></tr>
<tr><td class="paramname">grad</td><td>Gradient </td></tr>
<tr><td class="paramname">d</td><td>Internal state <code>d_t</code> </td></tr>
<tr><td class="paramname">v</td><td>Internal state <code>v_t</code> </td></tr>
<tr><td class="paramname">z</td><td>Internal state <code>z_t</code> </td></tr>
<tr><td class="paramname">lr</td><td>Learning rate. </td></tr>
<tr><td class="paramname">t</td><td>Number of update. </td></tr>
<tr><td class="paramname">beta1</td><td>Generally close to 0.5. </td></tr>
<tr><td class="paramname">beta2</td><td>Generally close to 1. </td></tr>
<tr><td class="paramname">epsilon</td><td>Epsilon to prevent div 0. </td></tr>
<tr><td class="paramname">wd</td><td>Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of </td></tr>
<tr><td class="paramname">rescale_grad</td><td>Rescale gradient to grad = rescale_grad*grad. </td></tr>
<tr><td class="paramname">clip_grad</td><td>Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="aa2905ae0daecb7e5853fd5d841978756"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::ftrl_update </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>weight</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>grad</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>z</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>n</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>lr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>lamda1</em> = <code>0.01</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>beta</em> = <code>1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>wd</em> = <code>0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>rescale_grad</em> = <code>1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>clip_gradient</em> = <code>-1</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Update function for Ftrl optimizer. Referenced from <em>Ad Click Prediction: a View from the Trenches</em>, available at <a href="http://dl.acm.org/citation.cfm?id=2488200">http://dl.acm.org/citation.cfm?id=2488200</a>.</p>
<p>It updates the weights using::</p>
<p>rescaled_grad = clip(grad * rescale_grad, clip_gradient) z += rescaled_grad - (sqrt(n + rescaled_grad**2) - sqrt(n)) * weight / n += rescaled_grad**2 w = (sign(z) * lamda1 - z) / ((beta + sqrt(n)) / learning_rate + wd) * (abs(z)</p>
<p>If w, z and n are all of <code>row_sparse</code> storage type, only the row slices whose indices appear in grad.indices are updated (for w, z</p>
<p>for row in grad.indices: rescaled_grad[row] = clip(grad[row] * rescale_grad, clip_gradient) z[row] += rescaled_grad[row] - (sqrt(n[row] + rescaled_grad[row]**2) - n[row] += rescaled_grad[row]**2 w[row] = (sign(z[row]) * lamda1 - z[row]) / ((beta + sqrt(n[row])) /</p>
<pre class="fragment">   Defined in src/operator/optimizer_op.cc:L632
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">weight</td><td>Weight </td></tr>
<tr><td class="paramname">grad</td><td>Gradient </td></tr>
<tr><td class="paramname">z</td><td>z </td></tr>
<tr><td class="paramname">n</td><td>Square of grad </td></tr>
<tr><td class="paramname">lr</td><td>Learning rate </td></tr>
<tr><td class="paramname">lamda1</td><td>The L1 regularization coefficient. </td></tr>
<tr><td class="paramname">beta</td><td>Per-Coordinate Learning Rate beta. </td></tr>
<tr><td class="paramname">wd</td><td>Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of </td></tr>
<tr><td class="paramname">rescale_grad</td><td>Rescale gradient to grad = rescale_grad*grad. </td></tr>
<tr><td class="paramname">clip_gradient</td><td>Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a037d389f35c483f5fc83436986884547"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::ftrl_update </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>weight</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>grad</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>z</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>n</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>lr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>lamda1</em> = <code>0.01</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>beta</em> = <code>1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>wd</em> = <code>0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>rescale_grad</em> = <code>1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>clip_gradient</em> = <code>-1</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Update function for Ftrl optimizer. Referenced from <em>Ad Click Prediction: a View from the Trenches</em>, available at <a href="http://dl.acm.org/citation.cfm?id=2488200">http://dl.acm.org/citation.cfm?id=2488200</a>.</p>
<p>It updates the weights using::</p>
<p>rescaled_grad = clip(grad * rescale_grad, clip_gradient) z += rescaled_grad - (sqrt(n + rescaled_grad**2) - sqrt(n)) * weight / n += rescaled_grad**2 w = (sign(z) * lamda1 - z) / ((beta + sqrt(n)) / learning_rate + wd) * (abs(z)</p>
<p>If w, z and n are all of <code>row_sparse</code> storage type, only the row slices whose indices appear in grad.indices are updated (for w, z</p>
<p>for row in grad.indices: rescaled_grad[row] = clip(grad[row] * rescale_grad, clip_gradient) z[row] += rescaled_grad[row] - (sqrt(n[row] + rescaled_grad[row]**2) - n[row] += rescaled_grad[row]**2 w[row] = (sign(z[row]) * lamda1 - z[row]) / ((beta + sqrt(n[row])) /</p>
<pre class="fragment">   Defined in src/operator/optimizer_op.cc:L632
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">weight</td><td>Weight </td></tr>
<tr><td class="paramname">grad</td><td>Gradient </td></tr>
<tr><td class="paramname">z</td><td>z </td></tr>
<tr><td class="paramname">n</td><td>Square of grad </td></tr>
<tr><td class="paramname">lr</td><td>Learning rate </td></tr>
<tr><td class="paramname">lamda1</td><td>The L1 regularization coefficient. </td></tr>
<tr><td class="paramname">beta</td><td>Per-Coordinate Learning Rate beta. </td></tr>
<tr><td class="paramname">wd</td><td>Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of </td></tr>
<tr><td class="paramname">rescale_grad</td><td>Rescale gradient to grad = rescale_grad*grad. </td></tr>
<tr><td class="paramname">clip_gradient</td><td>Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="af2bb88b8ee157f34c2c538334b1ae7cc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::FullyConnected </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>weight</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>bias</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>num_hidden</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>no_bias</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>flatten</em> = <code>true</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Applies a linear transformation: :math:<code>Y = XW^T + b</code>. </p><pre class="fragment">   If ``flatten`` is set to be true, then the shapes are:

   - **data**: `(batch_size, x1, x2, ..., xn)`
   - **weight**: `(num_hidden, x1 * x2 * ... * xn)`
   - **bias**: `(num_hidden,)`
   - **out**: `(batch_size, num_hidden)`

   If ``flatten`` is set to be false, then the shapes are:

   - **data**: `(x1, x2, ..., xn, input_dim)`
   - **weight**: `(num_hidden, input_dim)`
   - **bias**: `(num_hidden,)`
   - **out**: `(x1, x2, ..., xn, num_hidden)`

   The learnable parameters include both ``weight`` and ``bias``.

   If ``no_bias`` is set to be true, then the ``bias`` term is ignored.

   .. Note::

   The sparse support for FullyConnected is limited to forward evaluation with
   weight and bias, where the length of `weight.indices` and `bias.indices` must
   to `num_hidden`. This could be useful for model inference with `row_sparse`
   trained with importance sampling or noise contrastive estimation.

   To compute linear transformation with 'csr' sparse data, sparse.dot is
   of sparse.FullyConnected.



   Defined in src/operator/nn/fully_connected.cc:L272
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>Input data. </td></tr>
<tr><td class="paramname">weight</td><td>Weight matrix. </td></tr>
<tr><td class="paramname">bias</td><td>Bias parameter. </td></tr>
<tr><td class="paramname">num_hidden</td><td>Number of hidden nodes of the output. </td></tr>
<tr><td class="paramname">no_bias</td><td>Whether to disable bias parameter. </td></tr>
<tr><td class="paramname">flatten</td><td>Whether to collapse all but the first axis of the input data tensor. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="aed810c3bb5b7d35b4870bb12beb9620b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::FullyConnected </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>weight</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>bias</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>num_hidden</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>no_bias</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>flatten</em> = <code>true</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Applies a linear transformation: :math:<code>Y = XW^T + b</code>. </p><pre class="fragment">   If ``flatten`` is set to be true, then the shapes are:

   - **data**: `(batch_size, x1, x2, ..., xn)`
   - **weight**: `(num_hidden, x1 * x2 * ... * xn)`
   - **bias**: `(num_hidden,)`
   - **out**: `(batch_size, num_hidden)`

   If ``flatten`` is set to be false, then the shapes are:

   - **data**: `(x1, x2, ..., xn, input_dim)`
   - **weight**: `(num_hidden, input_dim)`
   - **bias**: `(num_hidden,)`
   - **out**: `(x1, x2, ..., xn, num_hidden)`

   The learnable parameters include both ``weight`` and ``bias``.

   If ``no_bias`` is set to be true, then the ``bias`` term is ignored.

   .. Note::

   The sparse support for FullyConnected is limited to forward evaluation with
   weight and bias, where the length of `weight.indices` and `bias.indices` must
   to `num_hidden`. This could be useful for model inference with `row_sparse`
   trained with importance sampling or noise contrastive estimation.

   To compute linear transformation with 'csr' sparse data, sparse.dot is
   of sparse.FullyConnected.



   Defined in src/operator/nn/fully_connected.cc:L272
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>Input data. </td></tr>
<tr><td class="paramname">weight</td><td>Weight matrix. </td></tr>
<tr><td class="paramname">bias</td><td>Bias parameter. </td></tr>
<tr><td class="paramname">num_hidden</td><td>Number of hidden nodes of the output. </td></tr>
<tr><td class="paramname">no_bias</td><td>Whether to disable bias parameter. </td></tr>
<tr><td class="paramname">flatten</td><td>Whether to collapse all but the first axis of the input data tensor. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a0a9aa2fcd720ec0c0540a6a8ad47a8c7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::gamma </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns the gamma function (extension of the factorial function \ to the reals), computed element-wise on the input array.</p>
<p>The storage type of <code>gamma</code> output is always dense</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>The input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a06ca3719f4aabea2454d530af6c9bc14"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::gamma </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns the gamma function (extension of the factorial function \ to the reals), computed element-wise on the input array.</p>
<p>The storage type of <code>gamma</code> output is always dense</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>The input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a0eaf6490fbf9c17dc08c878e4f632a82"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::gammaln </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns element-wise log of the absolute value of the gamma function \ of the input.</p>
<p>The storage type of <code>gammaln</code> output is always dense</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>The input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="ac46fe72a34cb678aed506bb9eb51d9db"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::gammaln </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns element-wise log of the absolute value of the gamma function \ of the input.</p>
<p>The storage type of <code>gammaln</code> output is always dense</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>The input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="acd565231b1fc500ac5808ac049e5d31e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::gather_nd </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>indices</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Gather elements or slices from <code>data</code> and store to a tensor whose shape is defined by <code>indices</code>.</p>
<p>Given <code>data</code> with shape <code>(X_0, X_1, ..., X_{N-1})</code> and indices with shape <code>(M, Y_0, ..., Y_{K-1})</code>, the output will have shape <code>(Y_0, ..., Y_{K-1}, X_M, where</code>M &lt;= N<code>. If</code>M == N<code>, output shape will simply be</code>(Y_0, ..., Y_{K-1})`.</p>
<p>The elements in output is defined as follows::</p>
<p>output[y_0, ..., y_{K-1}, x_M, ..., x_{N-1}] = data[indices[0, y_0, ..., ..., indices[M-1, y_0, ..., y_{K-1}], x_M, ..., x_{N-1}]</p>
<p>Examples::</p>
<p>data = [[0, 1], [2, 3]] indices = [[1, 1, 0], [0, 1, 0]] gather_nd(data, indices) = [2, 3, 0]</p>
<p>data = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]] indices = [[0, 1], [1, 0]] gather_nd(data, indices) = [[3, 4], [5, 6]]</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>data </td></tr>
<tr><td class="paramname">indices</td><td>indices </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="afcd3b39a77f6f9d8478b9341001fd271"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::gather_nd </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>indices</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Gather elements or slices from <code>data</code> and store to a tensor whose shape is defined by <code>indices</code>.</p>
<p>Given <code>data</code> with shape <code>(X_0, X_1, ..., X_{N-1})</code> and indices with shape <code>(M, Y_0, ..., Y_{K-1})</code>, the output will have shape <code>(Y_0, ..., Y_{K-1}, X_M, where</code>M &lt;= N<code>. If</code>M == N<code>, output shape will simply be</code>(Y_0, ..., Y_{K-1})`.</p>
<p>The elements in output is defined as follows::</p>
<p>output[y_0, ..., y_{K-1}, x_M, ..., x_{N-1}] = data[indices[0, y_0, ..., ..., indices[M-1, y_0, ..., y_{K-1}], x_M, ..., x_{N-1}]</p>
<p>Examples::</p>
<p>data = [[0, 1], [2, 3]] indices = [[1, 1, 0], [0, 1, 0]] gather_nd(data, indices) = [2, 3, 0]</p>
<p>data = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]] indices = [[0, 1], [1, 0]] gather_nd(data, indices) = [[3, 4], [5, 6]]</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>data </td></tr>
<tr><td class="paramname">indices</td><td>indices </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a6ba557fafd479004873f1c6afa6b497c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::GridGenerator </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespacemxnet_1_1cpp.html#a98745f0114674ef8fa60b2a35a877a2c">GridGeneratorTransformType</a> </td>
<td class="paramname"><em>transform_type</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> </td>
<td class="paramname"><em>target_shape</em> = <code><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>(0,0)</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Generates 2D sampling grid for bilinear sampling. </p><dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>Input data to the function. </td></tr>
<tr><td class="paramname">transform_type</td><td>The type of transformation. For <code>affine</code>, input data should be an affine matrix of size (batch, 6). For <code>warp</code>, input data should be an </td></tr>
<tr><td class="paramname">target_shape</td><td>Specifies the output shape (H, W). This is required if transformation type is <code>affine</code>. If transformation type is <code>warp</code>, this </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="ad6e1c5da8364f84e285d6139bbbc721f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::GridGenerator </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespacemxnet_1_1cpp.html#a98745f0114674ef8fa60b2a35a877a2c">GridGeneratorTransformType</a> </td>
<td class="paramname"><em>transform_type</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> </td>
<td class="paramname"><em>target_shape</em> = <code><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>(0,0)</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Generates 2D sampling grid for bilinear sampling. </p><dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>Input data to the function. </td></tr>
<tr><td class="paramname">transform_type</td><td>The type of transformation. For <code>affine</code>, input data should be an affine matrix of size (batch, 6). For <code>warp</code>, input data should be an </td></tr>
<tr><td class="paramname">target_shape</td><td>Specifies the output shape (H, W). This is required if transformation type is <code>affine</code>. If transformation type is <code>warp</code>, this </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a839623f90b9f4d3834b7b234bb3a187f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::hard_sigmoid </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>alpha</em> = <code>0.2</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>beta</em> = <code>0.5</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Computes hard sigmoid of x element-wise. </p><pre class="fragment">   .. math::
   y = max(0, min(1, alpha * x + beta))



   Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L115
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>The input array. </td></tr>
<tr><td class="paramname">alpha</td><td>Slope of hard sigmoid </td></tr>
<tr><td class="paramname">beta</td><td>Bias of hard sigmoid. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a733bbbf5bde5141809a8be8e5ba9f4c2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::hard_sigmoid </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>alpha</em> = <code>0.2</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>beta</em> = <code>0.5</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Computes hard sigmoid of x element-wise. </p><pre class="fragment">   .. math::
   y = max(0, min(1, alpha * x + beta))



   Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L115
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>The input array. </td></tr>
<tr><td class="paramname">alpha</td><td>Slope of hard sigmoid </td></tr>
<tr><td class="paramname">beta</td><td>Bias of hard sigmoid. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a14ef7f6f4e3e5952dedfbd42b02d2831"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::IdentityAttachKLSparseReg </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>sparseness_target</em> = <code>0.1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>penalty</em> = <code>0.001</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>momentum</em> = <code>0.9</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Apply a sparse regularization to the output a sigmoid activation function. </p><dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>Input data. </td></tr>
<tr><td class="paramname">sparseness_target</td><td>The sparseness target </td></tr>
<tr><td class="paramname">penalty</td><td>The tradeoff parameter for the sparseness penalty </td></tr>
<tr><td class="paramname">momentum</td><td>The momentum for running average </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a102418bba419088e913ab8cfa6e24d69"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::IdentityAttachKLSparseReg </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>sparseness_target</em> = <code>0.1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>penalty</em> = <code>0.001</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>momentum</em> = <code>0.9</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Apply a sparse regularization to the output a sigmoid activation function. </p><dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>Input data. </td></tr>
<tr><td class="paramname">sparseness_target</td><td>The sparseness target </td></tr>
<tr><td class="paramname">penalty</td><td>The tradeoff parameter for the sparseness penalty </td></tr>
<tr><td class="paramname">momentum</td><td>The momentum for running average </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a5541e08fbfa3d0b49e1f3e63b36c001b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::InstanceNorm </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>gamma</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>beta</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>eps</em> = <code>0.001</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Applies instance normalization to the n-dimensional input array. </p><pre class="fragment">   This operator takes an n-dimensional input array where (n&gt;2) and normalizes
   the input using the following formula:

   .. math::

   out = \frac{x - mean[data]}{ \sqrt{Var[data]} + \epsilon} * gamma + beta

   This layer is similar to batch normalization layer (`BatchNorm`)
   with two differences: first, the normalization is
   carried out per example (instance), not over a batch. Second, the
   same normalization is applied both at test and train time. This
   operation is also known as `contrast normalization`.

   If the input data is of shape [batch, channel, spacial_dim1, spacial_dim2, ...],
   `gamma` and `beta` parameters must be vectors of shape [channel].

   This implementation is based on paper:

   .. [1] Instance Normalization: The Missing Ingredient for Fast Stylization,
   D. Ulyanov, A. Vedaldi, V. Lempitsky, 2016 (arXiv:1607.08022v2).

   Examples::

   // Input of shape (2,1,2)
   x = [[[ 1.1,  2.2]],
   [[ 3.3,  4.4]]]

   // gamma parameter of length 1
   gamma = [1.5]

   // beta parameter of length 1
   beta = [0.5]

   // Instance normalization is calculated with the above formula
   InstanceNorm(x,gamma,beta) = [[[-0.997527  ,  1.99752665]],
   [[-0.99752653,  1.99752724]]]



   Defined in src/operator/instance_norm.cc:L95
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>An n-dimensional input array (n &gt; 2) of the form [batch, channel, </td></tr>
<tr><td class="paramname">gamma</td><td>A vector of length 'channel', which multiplies the normalized input. </td></tr>
<tr><td class="paramname">beta</td><td>A vector of length 'channel', which is added to the product of the </td></tr>
<tr><td class="paramname">eps</td><td>An <code>epsilon</code> parameter to prevent division by 0. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="ae3362668d61945e47ee8b9f46e529ae6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::InstanceNorm </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>gamma</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>beta</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>eps</em> = <code>0.001</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Applies instance normalization to the n-dimensional input array. </p><pre class="fragment">   This operator takes an n-dimensional input array where (n&gt;2) and normalizes
   the input using the following formula:

   .. math::

   out = \frac{x - mean[data]}{ \sqrt{Var[data]} + \epsilon} * gamma + beta

   This layer is similar to batch normalization layer (`BatchNorm`)
   with two differences: first, the normalization is
   carried out per example (instance), not over a batch. Second, the
   same normalization is applied both at test and train time. This
   operation is also known as `contrast normalization`.

   If the input data is of shape [batch, channel, spacial_dim1, spacial_dim2, ...],
   `gamma` and `beta` parameters must be vectors of shape [channel].

   This implementation is based on paper:

   .. [1] Instance Normalization: The Missing Ingredient for Fast Stylization,
   D. Ulyanov, A. Vedaldi, V. Lempitsky, 2016 (arXiv:1607.08022v2).

   Examples::

   // Input of shape (2,1,2)
   x = [[[ 1.1,  2.2]],
   [[ 3.3,  4.4]]]

   // gamma parameter of length 1
   gamma = [1.5]

   // beta parameter of length 1
   beta = [0.5]

   // Instance normalization is calculated with the above formula
   InstanceNorm(x,gamma,beta) = [[[-0.997527  ,  1.99752665]],
   [[-0.99752653,  1.99752724]]]



   Defined in src/operator/instance_norm.cc:L95
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>An n-dimensional input array (n &gt; 2) of the form [batch, channel, </td></tr>
<tr><td class="paramname">gamma</td><td>A vector of length 'channel', which multiplies the normalized input. </td></tr>
<tr><td class="paramname">beta</td><td>A vector of length 'channel', which is added to the product of the </td></tr>
<tr><td class="paramname">eps</td><td>An <code>epsilon</code> parameter to prevent division by 0. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a97005a6afb32b3706d7dbe12e8c7a139"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::khatri_rao </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const std::vector&lt; <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> &gt; &amp; </td>
<td class="paramname"><em>args</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Computes the Khatri-Rao product of the input matrices. </p><pre class="fragment">   Given a collection of :math:`n` input matrices,

   .. math::
   A_1 \in \mathbb{R}^{M_1 \times M}, \ldots, A_n \in \mathbb{R}^{M_n \times N},

   the (column-wise) Khatri-Rao product is defined as the matrix,

   .. math::
   X = A_1 \otimes \cdots \otimes A_n \in \mathbb{R}^{(M_1 \cdots M_n) \times N},

   where the :math:`k` th column is equal to the column-wise outer product
   :math:`{A_1}_k \otimes \cdots \otimes {A_n}_k` where :math:`{A_i}_k` is the kth
   column of the ith matrix.

   Example::

   &gt;&gt;&gt; A = mx.nd.array([[1, -1],
   &gt;&gt;&gt;                  [2, -3]])
   &gt;&gt;&gt; B = mx.nd.array([[1, 4],
   &gt;&gt;&gt;                  [2, 5],
   &gt;&gt;&gt;                  [3, 6]])
   &gt;&gt;&gt; C = mx.nd.khatri_rao(A, B)
   &gt;&gt;&gt; print(C.asnumpy())
   [[  1.  -4.]
   [  2.  -5.]
   [  3.  -6.]
   [  2. -12.]
   [  4. -15.]
   [  6. -18.]]



   Defined in src/operator/contrib/krprod.cc:L108
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">args</td><td>Positional input matrices </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a6ec5b3c7c995f8548c955a13459e91a9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::khatri_rao </td>
<td>(</td>
<td class="paramtype">const std::vector&lt; <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> &gt; &amp; </td>
<td class="paramname"><em>args</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Computes the Khatri-Rao product of the input matrices. </p><pre class="fragment">   Given a collection of :math:`n` input matrices,

   .. math::
   A_1 \in \mathbb{R}^{M_1 \times M}, \ldots, A_n \in \mathbb{R}^{M_n \times N},

   the (column-wise) Khatri-Rao product is defined as the matrix,

   .. math::
   X = A_1 \otimes \cdots \otimes A_n \in \mathbb{R}^{(M_1 \cdots M_n) \times N},

   where the :math:`k` th column is equal to the column-wise outer product
   :math:`{A_1}_k \otimes \cdots \otimes {A_n}_k` where :math:`{A_i}_k` is the kth
   column of the ith matrix.

   Example::

   &gt;&gt;&gt; A = mx.nd.array([[1, -1],
   &gt;&gt;&gt;                  [2, -3]])
   &gt;&gt;&gt; B = mx.nd.array([[1, 4],
   &gt;&gt;&gt;                  [2, 5],
   &gt;&gt;&gt;                  [3, 6]])
   &gt;&gt;&gt; C = mx.nd.khatri_rao(A, B)
   &gt;&gt;&gt; print(C.asnumpy())
   [[  1.  -4.]
   [  2.  -5.]
   [  3.  -6.]
   [  2. -12.]
   [  4. -15.]
   [  6. -18.]]



   Defined in src/operator/contrib/krprod.cc:L108
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">args</td><td>Positional input matrices </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a38d13c13c0be0010e704a30430dff2b0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::L2Normalization </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>eps</em> = <code>1e-10</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespacemxnet_1_1cpp.html#a92b87bed551457a3d444a28fd3c7c84f">L2NormalizationMode</a> </td>
<td class="paramname"><em>mode</em> = <code><a class="el" href="namespacemxnet_1_1cpp.html#a08bbd5633680ffa58dae3cab685e2ebfa63f56d9e95d7b447075aef94444c4c96">L2NormalizationMode::kInstance</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Normalize the input array using the L2 norm. </p><pre class="fragment">   For 1-D NDArray, it computes::

   out = data / sqrt(sum(data ** 2) + eps)

   For N-D NDArray, if the input array has shape (N, N, ..., N),

   with ``mode`` = ``instance``, it normalizes each instance in the
   array by its L2 norm.::

   for i in 0...N
   out[i,:,:,...,:] = data[i,:,:,...,:] / sqrt(sum(data[i,:,:,...,:] ** 2) + eps)

   with ``mode`` = ``channel``, it normalizes each channel in the array by its L2

   for i in 0...N
   out[:,i,:,...,:] = data[:,i,:,...,:] / sqrt(sum(data[:,i,:,...,:] ** 2) + eps)

   with ``mode`` = ``spatial``, it normalizes the cross channel norm for each
   in the array by its L2 norm.::

   for dim in 2...N
   for i in 0...N
   out[.....,i,...] = take(out, indices=i, axis=dim) / sqrt(sum(take(out,
   -dim-

   Example::

   x = [[[1,2],
   [3,4]],
   [[2,2],
   [5,6]]]

   L2Normalization(x, mode='instance')
   =[[[ 0.18257418  0.36514837]
   [ 0.54772252  0.73029673]]
   [[ 0.24077171  0.24077171]
   [ 0.60192931  0.72231513]]]

   L2Normalization(x, mode='channel')
   =[[[ 0.31622776  0.44721359]
   [ 0.94868326  0.89442718]]
   [[ 0.37139067  0.31622776]
   [ 0.92847669  0.94868326]]]

   L2Normalization(x, mode='spatial')
   =[[[ 0.44721359  0.89442718]
   [ 0.60000002  0.80000001]]
   [[ 0.70710677  0.70710677]
   [ 0.6401844   0.76822126]]]



   Defined in src/operator/l2_normalization.cc:L98
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>Input array to normalize. </td></tr>
<tr><td class="paramname">eps</td><td>A small constant for numerical stability. </td></tr>
<tr><td class="paramname">mode</td><td>Specify the dimension along which to compute L2 norm. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="aa4fa4bb8aef8f707869fdd41953ca2f7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::L2Normalization </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>eps</em> = <code>1e-10</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespacemxnet_1_1cpp.html#a92b87bed551457a3d444a28fd3c7c84f">L2NormalizationMode</a> </td>
<td class="paramname"><em>mode</em> = <code><a class="el" href="namespacemxnet_1_1cpp.html#a08bbd5633680ffa58dae3cab685e2ebfa63f56d9e95d7b447075aef94444c4c96">L2NormalizationMode::kInstance</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Normalize the input array using the L2 norm. </p><pre class="fragment">   For 1-D NDArray, it computes::

   out = data / sqrt(sum(data ** 2) + eps)

   For N-D NDArray, if the input array has shape (N, N, ..., N),

   with ``mode`` = ``instance``, it normalizes each instance in the
   array by its L2 norm.::

   for i in 0...N
   out[i,:,:,...,:] = data[i,:,:,...,:] / sqrt(sum(data[i,:,:,...,:] ** 2) + eps)

   with ``mode`` = ``channel``, it normalizes each channel in the array by its L2

   for i in 0...N
   out[:,i,:,...,:] = data[:,i,:,...,:] / sqrt(sum(data[:,i,:,...,:] ** 2) + eps)

   with ``mode`` = ``spatial``, it normalizes the cross channel norm for each
   in the array by its L2 norm.::

   for dim in 2...N
   for i in 0...N
   out[.....,i,...] = take(out, indices=i, axis=dim) / sqrt(sum(take(out,
   -dim-

   Example::

   x = [[[1,2],
   [3,4]],
   [[2,2],
   [5,6]]]

   L2Normalization(x, mode='instance')
   =[[[ 0.18257418  0.36514837]
   [ 0.54772252  0.73029673]]
   [[ 0.24077171  0.24077171]
   [ 0.60192931  0.72231513]]]

   L2Normalization(x, mode='channel')
   =[[[ 0.31622776  0.44721359]
   [ 0.94868326  0.89442718]]
   [[ 0.37139067  0.31622776]
   [ 0.92847669  0.94868326]]]

   L2Normalization(x, mode='spatial')
   =[[[ 0.44721359  0.89442718]
   [ 0.60000002  0.80000001]]
   [[ 0.70710677  0.70710677]
   [ 0.6401844   0.76822126]]]



   Defined in src/operator/l2_normalization.cc:L98
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>Input array to normalize. </td></tr>
<tr><td class="paramname">eps</td><td>A small constant for numerical stability. </td></tr>
<tr><td class="paramname">mode</td><td>Specify the dimension along which to compute L2 norm. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a837a8ec6d76f03fc7085b5e6588eb53c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::LayerNorm </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>gamma</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>beta</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>axis</em> = <code>-1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>eps</em> = <code>1e-05</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>output_mean_var</em> = <code>false</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Layer normalization. </p><pre class="fragment">   Normalizes the channels of the input tensor by mean and variance, and applies a
   well as offset ``beta``.

   Assume the input has more than one dimension and we normalize along axis 1.
   We first compute the mean and variance along this axis and then
   compute the normalized output, which has the same shape as input, as following:

   .. math::

   out = \frac{data - mean(data, axis)}{\sqrt{var(data, axis) + \epsilon}} * gamma

   Both ``gamma`` and ``beta`` are learnable parameters.

   Unlike BatchNorm and InstanceNorm,  the *mean* and *var* are computed along the

   Assume the input has size *k* on axis 1, then both ``gamma`` and ``beta``
   have shape *(k,)*. If ``output_mean_var`` is set to be true, then outputs both
   ``data_std``. Note that no gradient will be passed through these two outputs.

   The parameter ``axis`` specifies which axis of the input shape denotes
   the 'channel' (separately normalized groups).  The default is -1, which sets
   axis to be the last item in the input shape.



   Defined in src/operator/nn/layer_norm.cc:L94
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>Input data to layer normalization </td></tr>
<tr><td class="paramname">gamma</td><td>gamma array </td></tr>
<tr><td class="paramname">beta</td><td>beta array </td></tr>
<tr><td class="paramname">axis</td><td>The axis to perform layer normalization. Usually, this should be be axis </td></tr>
<tr><td class="paramname">eps</td><td>An <code>epsilon</code> parameter to prevent division by 0. </td></tr>
<tr><td class="paramname">output_mean_var</td><td>Output the mean and std calculated along the given axis. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a093e0eb27a7bb61634444974e9400f67"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::LayerNorm </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>gamma</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>beta</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>axis</em> = <code>-1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>eps</em> = <code>1e-05</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>output_mean_var</em> = <code>false</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Layer normalization. </p><pre class="fragment">   Normalizes the channels of the input tensor by mean and variance, and applies a
   well as offset ``beta``.

   Assume the input has more than one dimension and we normalize along axis 1.
   We first compute the mean and variance along this axis and then
   compute the normalized output, which has the same shape as input, as following:

   .. math::

   out = \frac{data - mean(data, axis)}{\sqrt{var(data, axis) + \epsilon}} * gamma

   Both ``gamma`` and ``beta`` are learnable parameters.

   Unlike BatchNorm and InstanceNorm,  the *mean* and *var* are computed along the

   Assume the input has size *k* on axis 1, then both ``gamma`` and ``beta``
   have shape *(k,)*. If ``output_mean_var`` is set to be true, then outputs both
   ``data_std``. Note that no gradient will be passed through these two outputs.

   The parameter ``axis`` specifies which axis of the input shape denotes
   the 'channel' (separately normalized groups).  The default is -1, which sets
   axis to be the last item in the input shape.



   Defined in src/operator/nn/layer_norm.cc:L94
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>Input data to layer normalization </td></tr>
<tr><td class="paramname">gamma</td><td>gamma array </td></tr>
<tr><td class="paramname">beta</td><td>beta array </td></tr>
<tr><td class="paramname">axis</td><td>The axis to perform layer normalization. Usually, this should be be axis </td></tr>
<tr><td class="paramname">eps</td><td>An <code>epsilon</code> parameter to prevent division by 0. </td></tr>
<tr><td class="paramname">output_mean_var</td><td>Output the mean and std calculated along the given axis. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="afd094b64ffc4a3a77b1d2d52d86834b5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::LeakyReLU </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>gamma</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespacemxnet_1_1cpp.html#aad64d459f3652d3ec3cf37c460aa8ee0">LeakyReLUActType</a> </td>
<td class="paramname"><em>act_type</em> = <code><a class="el" href="namespacemxnet_1_1cpp.html#aad64d459f3652d3ec3cf37c460aa8ee0a3620dd046c3b58ec17570ae64aa325eb">LeakyReLUActType::kLeaky</a></code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>slope</em> = <code>0.25</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>lower_bound</em> = <code>0.125</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>upper_bound</em> = <code>0.334</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Applies Leaky rectified linear unit activation element-wise to the input. </p><pre class="fragment">   Leaky ReLUs attempt to fix the "dying ReLU" problem by allowing a small `slope`
   when the input is negative and has a slope of one when input is positive.

   The following modified ReLU Activation functions are supported:

   - *elu*: Exponential Linear Unit. `y = x &gt; 0 ? x : slope * (exp(x)-1)`
   - *selu*: Scaled Exponential Linear Unit. `y = lambda * (x &gt; 0 ? x : alpha *
   *lambda = 1.0507009873554804934193349852946* and *alpha =
   - *leaky*: Leaky ReLU. `y = x &gt; 0 ? x : slope * x`
   - *prelu*: Parametric ReLU. This is same as *leaky* except that `slope` is
   - *rrelu*: Randomized ReLU. same as *leaky* but the `slope` is uniformly and
   *[lower_bound, upper_bound)* for training, while fixed to be
   *(lower_bound+upper_bound)/2* for inference.



   Defined in src/operator/leaky_relu.cc:L65
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>Input data to activation function. </td></tr>
<tr><td class="paramname">gamma</td><td>Slope parameter for PReLU. Only required when act_type is 'prelu'. It should be either a vector of size 1, or the same size as the second dimension </td></tr>
<tr><td class="paramname">act_type</td><td>Activation function to be applied. </td></tr>
<tr><td class="paramname">slope</td><td>Init slope for the activation. (For leaky and elu only) </td></tr>
<tr><td class="paramname">lower_bound</td><td>Lower bound of random slope. (For rrelu only) </td></tr>
<tr><td class="paramname">upper_bound</td><td>Upper bound of random slope. (For rrelu only) </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="acbf6201925b98b3b055eac9fa6cdc0c6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::LeakyReLU </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>gamma</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespacemxnet_1_1cpp.html#aad64d459f3652d3ec3cf37c460aa8ee0">LeakyReLUActType</a> </td>
<td class="paramname"><em>act_type</em> = <code><a class="el" href="namespacemxnet_1_1cpp.html#aad64d459f3652d3ec3cf37c460aa8ee0a3620dd046c3b58ec17570ae64aa325eb">LeakyReLUActType::kLeaky</a></code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>slope</em> = <code>0.25</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>lower_bound</em> = <code>0.125</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>upper_bound</em> = <code>0.334</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Applies Leaky rectified linear unit activation element-wise to the input. </p><pre class="fragment">   Leaky ReLUs attempt to fix the "dying ReLU" problem by allowing a small `slope`
   when the input is negative and has a slope of one when input is positive.

   The following modified ReLU Activation functions are supported:

   - *elu*: Exponential Linear Unit. `y = x &gt; 0 ? x : slope * (exp(x)-1)`
   - *selu*: Scaled Exponential Linear Unit. `y = lambda * (x &gt; 0 ? x : alpha *
   *lambda = 1.0507009873554804934193349852946* and *alpha =
   - *leaky*: Leaky ReLU. `y = x &gt; 0 ? x : slope * x`
   - *prelu*: Parametric ReLU. This is same as *leaky* except that `slope` is
   - *rrelu*: Randomized ReLU. same as *leaky* but the `slope` is uniformly and
   *[lower_bound, upper_bound)* for training, while fixed to be
   *(lower_bound+upper_bound)/2* for inference.



   Defined in src/operator/leaky_relu.cc:L65
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>Input data to activation function. </td></tr>
<tr><td class="paramname">gamma</td><td>Slope parameter for PReLU. Only required when act_type is 'prelu'. It should be either a vector of size 1, or the same size as the second dimension </td></tr>
<tr><td class="paramname">act_type</td><td>Activation function to be applied. </td></tr>
<tr><td class="paramname">slope</td><td>Init slope for the activation. (For leaky and elu only) </td></tr>
<tr><td class="paramname">lower_bound</td><td>Lower bound of random slope. (For rrelu only) </td></tr>
<tr><td class="paramname">upper_bound</td><td>Upper bound of random slope. (For rrelu only) </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a9cde2fb30690b60d2659a4e4e56ab910"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::LinearRegressionOutput </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>label</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>grad_scale</em> = <code>1</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Computes and optimizes for squared loss during backward propagation. Just outputs <code>data</code> during forward propagation.</p>
<p>If :math:<code>\hat{y}_i</code> is the predicted value of the i-th sample, and :math:<code>y_i</code> then the squared loss estimated over :math:<code>n</code> samples is defined as</p>
<p>:math:`{SquaredLoss}({Y}, {{Y}} ) = {1}{n}</p>
<p>.. note:: Use the LinearRegressionOutput as the final output layer of a net.</p>
<p>The storage type of <code>label</code> can be <code>default</code> or <code>csr</code></p>
<ul>
<li>LinearRegressionOutput(default, default) = default</li>
<li>LinearRegressionOutput(default, csr) = default</li>
</ul>
<p>By default, gradients of this loss function are scaled by factor <code>1/m</code>, where m The parameter <code>grad_scale</code> can be used to change this scale to <code>grad_scale/m</code>.</p>
<pre class="fragment">   Defined in src/operator/regression_output.cc:L92
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>Input data to the function. </td></tr>
<tr><td class="paramname">label</td><td>Input label to the function. </td></tr>
<tr><td class="paramname">grad_scale</td><td>Scale the gradient by a float factor </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="afcbbe84c18e89e4c03a994f2438ea821"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::LinearRegressionOutput </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>label</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>grad_scale</em> = <code>1</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Computes and optimizes for squared loss during backward propagation. Just outputs <code>data</code> during forward propagation.</p>
<p>If :math:<code>\hat{y}_i</code> is the predicted value of the i-th sample, and :math:<code>y_i</code> then the squared loss estimated over :math:<code>n</code> samples is defined as</p>
<p>:math:`{SquaredLoss}({Y}, {{Y}} ) = {1}{n}</p>
<p>.. note:: Use the LinearRegressionOutput as the final output layer of a net.</p>
<p>The storage type of <code>label</code> can be <code>default</code> or <code>csr</code></p>
<ul>
<li>LinearRegressionOutput(default, default) = default</li>
<li>LinearRegressionOutput(default, csr) = default</li>
</ul>
<p>By default, gradients of this loss function are scaled by factor <code>1/m</code>, where m The parameter <code>grad_scale</code> can be used to change this scale to <code>grad_scale/m</code>.</p>
<pre class="fragment">   Defined in src/operator/regression_output.cc:L92
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>Input data to the function. </td></tr>
<tr><td class="paramname">label</td><td>Input label to the function. </td></tr>
<tr><td class="paramname">grad_scale</td><td>Scale the gradient by a float factor </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a580a36e5a8e2a0626a10f7966f505444"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::log </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns element-wise Natural logarithmic value of the input. </p><pre class="fragment">   The natural logarithm is logarithm in base *e*, so that ``log(exp(x)) = x``

   The storage type of ``log`` output is always dense



   Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L941
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>The input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a0d787f18713d6f542ecda83ed6eb4a79"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::log </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns element-wise Natural logarithmic value of the input. </p><pre class="fragment">   The natural logarithm is logarithm in base *e*, so that ``log(exp(x)) = x``

   The storage type of ``log`` output is always dense



   Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L941
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>The input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a4d08dc59931f382ffd3115f13ca75276"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::log10 </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns element-wise Base-10 logarithmic value of the input. </p><pre class="fragment">   ``10**log10(x) = x``

   The storage type of ``log10`` output is always dense



   Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L953
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>The input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a5a5514cf2f1b37b5a7c1072bff83bf96"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::log10 </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns element-wise Base-10 logarithmic value of the input. </p><pre class="fragment">   ``10**log10(x) = x``

   The storage type of ``log10`` output is always dense



   Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L953
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>The input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="ab08eb3c129e947100a42bbba98aa110a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::log1p </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns element-wise <code>log(1 + x)</code> value of the input. </p><pre class="fragment">   This function is more accurate than ``log(1 + x)``  for small ``x`` so that
   :math:`1+x\approx 1`

   The storage type of ``log1p`` output depends upon the input storage type:

   - log1p(default) = default
   - log1p(row_sparse) = row_sparse
   - log1p(csr) = csr



   Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L990
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>The input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a8184ba619a38ccf1d143c06b606e80a2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::log1p </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns element-wise <code>log(1 + x)</code> value of the input. </p><pre class="fragment">   This function is more accurate than ``log(1 + x)``  for small ``x`` so that
   :math:`1+x\approx 1`

   The storage type of ``log1p`` output depends upon the input storage type:

   - log1p(default) = default
   - log1p(row_sparse) = row_sparse
   - log1p(csr) = csr



   Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L990
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>The input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a054a0670ab0a98dd68468aca47cb94c4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::log2 </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns element-wise Base-2 logarithmic value of the input. </p><pre class="fragment">   ``2**log2(x) = x``

   The storage type of ``log2`` output is always dense



   Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L965
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>The input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="ae103fdff44ce1c9654fac5f5c0fc09a3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::log2 </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns element-wise Base-2 logarithmic value of the input. </p><pre class="fragment">   ``2**log2(x) = x``

   The storage type of ``log2`` output is always dense



   Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L965
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>The input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a88c6135b2e3c7eacc2da0aeb52332bd4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::log_softmax </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>axis</em> = <code>-1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">dmlc::optional&lt; double &gt; </td>
<td class="paramname"><em>temperature</em> = <code>dmlc::optional&lt;double&gt;()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Computes the log softmax of the input. This is equivalent to computing softmax followed by log.</p>
<p>Examples::</p>
<p>&gt;&gt;&gt; x = mx.nd.array([1, 2, .1]) &gt;&gt;&gt; mx.nd.log_softmax(x).asnumpy() array([-1.41702998, -0.41702995, -2.31702995], dtype=float32)</p>
<p>&gt;&gt;&gt; x = mx.nd.array( [[1, 2, .1],[.1, 2, 1]] ) &gt;&gt;&gt; mx.nd.log_softmax(x, axis=0).asnumpy() array([[-0.34115392, -0.69314718, -1.24115396], [-1.24115396, -0.69314718, -0.34115392]], dtype=float32)</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>The input array. </td></tr>
<tr><td class="paramname">axis</td><td>The axis along which to compute softmax. </td></tr>
<tr><td class="paramname">temperature</td><td>Temperature parameter in softmax </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="ac2e7d47cefba9918b648d84313aecce4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::log_softmax </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>axis</em> = <code>-1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">dmlc::optional&lt; double &gt; </td>
<td class="paramname"><em>temperature</em> = <code>dmlc::optional&lt;double&gt;()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Computes the log softmax of the input. This is equivalent to computing softmax followed by log.</p>
<p>Examples::</p>
<p>&gt;&gt;&gt; x = mx.nd.array([1, 2, .1]) &gt;&gt;&gt; mx.nd.log_softmax(x).asnumpy() array([-1.41702998, -0.41702995, -2.31702995], dtype=float32)</p>
<p>&gt;&gt;&gt; x = mx.nd.array( [[1, 2, .1],[.1, 2, 1]] ) &gt;&gt;&gt; mx.nd.log_softmax(x, axis=0).asnumpy() array([[-0.34115392, -0.69314718, -1.24115396], [-1.24115396, -0.69314718, -0.34115392]], dtype=float32)</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>The input array. </td></tr>
<tr><td class="paramname">axis</td><td>The axis along which to compute softmax. </td></tr>
<tr><td class="paramname">temperature</td><td>Temperature parameter in softmax </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="af359ed0c12f1e1a811c1cd42a038e2c4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::logical_not </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns the result of logical NOT (!) function </p><pre class="fragment">   Example:
   logical_not([-2., 0., 1.]) = [0., 1., 0.]
</pre><dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>The input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="ae986d6433f47471ec06f7c2d45495639"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::logical_not </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns the result of logical NOT (!) function </p><pre class="fragment">   Example:
   logical_not([-2., 0., 1.]) = [0., 1., 0.]
</pre><dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>The input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a29dec6f8e234fee06c02c64ddba3de1b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::LogisticRegressionOutput </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>label</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>grad_scale</em> = <code>1</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Applies a logistic function to the input. </p><pre class="fragment">   The logistic function, also known as the sigmoid function, is computed as
   :math:`\frac{1}{1+exp(-\textbf{x})}`.

   Commonly, the sigmoid is used to squash the real-valued output of a linear model
   :math:`wTx+b` into the [0,1] range so that it can be interpreted as a
   It is suitable for binary classification or probability prediction tasks.

   .. note::
   Use the LogisticRegressionOutput as the final output layer of a net.

   The storage type of ``label`` can be ``default`` or ``csr``

   - LogisticRegressionOutput(default, default) = default
   - LogisticRegressionOutput(default, csr) = default

   The loss function used is the Binary Cross Entropy Loss:

   :math:`-{(y\log(p) + (1 - y)\log(1 - p))}`

   Where `y` is the ground truth probability of positive outcome for a given
   example, and `p` the probability predicted by the model. By default, gradients
   of this loss function are scaled by factor `1/m`, where m is the number of
   The parameter `grad_scale` can be used to change this scale to `grad_scale/m`.



   Defined in src/operator/regression_output.cc:L152
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>Input data to the function. </td></tr>
<tr><td class="paramname">label</td><td>Input label to the function. </td></tr>
<tr><td class="paramname">grad_scale</td><td>Scale the gradient by a float factor </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a3d6693f2e767412417f87ccf82582de0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::LogisticRegressionOutput </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>label</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>grad_scale</em> = <code>1</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Applies a logistic function to the input. </p><pre class="fragment">   The logistic function, also known as the sigmoid function, is computed as
   :math:`\frac{1}{1+exp(-\textbf{x})}`.

   Commonly, the sigmoid is used to squash the real-valued output of a linear model
   :math:`wTx+b` into the [0,1] range so that it can be interpreted as a
   It is suitable for binary classification or probability prediction tasks.

   .. note::
   Use the LogisticRegressionOutput as the final output layer of a net.

   The storage type of ``label`` can be ``default`` or ``csr``

   - LogisticRegressionOutput(default, default) = default
   - LogisticRegressionOutput(default, csr) = default

   The loss function used is the Binary Cross Entropy Loss:

   :math:`-{(y\log(p) + (1 - y)\log(1 - p))}`

   Where `y` is the ground truth probability of positive outcome for a given
   example, and `p` the probability predicted by the model. By default, gradients
   of this loss function are scaled by factor `1/m`, where m is the number of
   The parameter `grad_scale` can be used to change this scale to `grad_scale/m`.



   Defined in src/operator/regression_output.cc:L152
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>Input data to the function. </td></tr>
<tr><td class="paramname">label</td><td>Input label to the function. </td></tr>
<tr><td class="paramname">grad_scale</td><td>Scale the gradient by a float factor </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a1110128eb77f14f6cf35f002b5b0c288"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::LRN </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint32_t </td>
<td class="paramname"><em>nsize</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>alpha</em> = <code>0.0001</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>beta</em> = <code>0.75</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>knorm</em> = <code>2</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Applies local response normalization to the input. </p><pre class="fragment">   The local response normalization layer performs "lateral inhibition" by
   over local input regions.

   If :math:`a_{x,y}^{i}` is the activity of a neuron computed by applying kernel
   :math:`(x, y)` and then applying the ReLU nonlinearity, the response-normalized
   activity :math:`b_{x,y}^{i}` is given by the expression:

   .. math::
   b_{x,y}^{i} = \frac{a_{x,y}^{i}}{\Bigg({k + \frac{\alpha}{n} \sum_{j=max(0,

   where the sum runs over :math:`n` "adjacent" kernel maps at the same spatial
   number of kernels in the layer.



   Defined in src/operator/nn/lrn.cc:L178
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>Input data to LRN </td></tr>
<tr><td class="paramname">nsize</td><td>normalization window width in elements. </td></tr>
<tr><td class="paramname">alpha</td><td>The variance scaling parameter :math:<code>lpha</code> in the LRN expression. </td></tr>
<tr><td class="paramname">beta</td><td>The power parameter :math:<code>eta</code> in the LRN expression. </td></tr>
<tr><td class="paramname">knorm</td><td>The parameter :math:<code>k</code> in the LRN expression. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="afa46e4eb9198e8a5d2ffdffa10d77f3d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::LRN </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint32_t </td>
<td class="paramname"><em>nsize</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>alpha</em> = <code>0.0001</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>beta</em> = <code>0.75</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>knorm</em> = <code>2</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Applies local response normalization to the input. </p><pre class="fragment">   The local response normalization layer performs "lateral inhibition" by
   over local input regions.

   If :math:`a_{x,y}^{i}` is the activity of a neuron computed by applying kernel
   :math:`(x, y)` and then applying the ReLU nonlinearity, the response-normalized
   activity :math:`b_{x,y}^{i}` is given by the expression:

   .. math::
   b_{x,y}^{i} = \frac{a_{x,y}^{i}}{\Bigg({k + \frac{\alpha}{n} \sum_{j=max(0,

   where the sum runs over :math:`n` "adjacent" kernel maps at the same spatial
   number of kernels in the layer.



   Defined in src/operator/nn/lrn.cc:L178
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>Input data to LRN </td></tr>
<tr><td class="paramname">nsize</td><td>normalization window width in elements. </td></tr>
<tr><td class="paramname">alpha</td><td>The variance scaling parameter :math:<code>lpha</code> in the LRN expression. </td></tr>
<tr><td class="paramname">beta</td><td>The power parameter :math:<code>eta</code> in the LRN expression. </td></tr>
<tr><td class="paramname">knorm</td><td>The parameter :math:<code>k</code> in the LRN expression. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a343358c8da2a0fd8cf79e97dab50a94d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::MAERegressionOutput </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>label</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>grad_scale</em> = <code>1</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Computes mean absolute error of the input. </p><pre class="fragment">   MAE is a risk metric corresponding to the expected value of the absolute error.

   If :math:`\hat{y}_i` is the predicted value of the i-th sample, and :math:`y_i`
   then the mean absolute error (MAE) estimated over :math:`n` samples is defined

   :math:`\text{MAE}(\textbf{Y}, \hat{\textbf{Y}} ) = \frac{1}{n} \sum_{i=0}^{n-1}

   .. note::
   Use the MAERegressionOutput as the final output layer of a net.

   The storage type of ``label`` can be ``default`` or ``csr``

   - MAERegressionOutput(default, default) = default
   - MAERegressionOutput(default, csr) = default

   By default, gradients of this loss function are scaled by factor `1/m`, where m
   The parameter `grad_scale` can be used to change this scale to `grad_scale/m`.



   Defined in src/operator/regression_output.cc:L120
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>Input data to the function. </td></tr>
<tr><td class="paramname">label</td><td>Input label to the function. </td></tr>
<tr><td class="paramname">grad_scale</td><td>Scale the gradient by a float factor </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a7de42fe56f402ed2ed64c0324310e2e2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::MAERegressionOutput </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>label</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>grad_scale</em> = <code>1</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Computes mean absolute error of the input. </p><pre class="fragment">   MAE is a risk metric corresponding to the expected value of the absolute error.

   If :math:`\hat{y}_i` is the predicted value of the i-th sample, and :math:`y_i`
   then the mean absolute error (MAE) estimated over :math:`n` samples is defined

   :math:`\text{MAE}(\textbf{Y}, \hat{\textbf{Y}} ) = \frac{1}{n} \sum_{i=0}^{n-1}

   .. note::
   Use the MAERegressionOutput as the final output layer of a net.

   The storage type of ``label`` can be ``default`` or ``csr``

   - MAERegressionOutput(default, default) = default
   - MAERegressionOutput(default, csr) = default

   By default, gradients of this loss function are scaled by factor `1/m`, where m
   The parameter `grad_scale` can be used to change this scale to `grad_scale/m`.



   Defined in src/operator/regression_output.cc:L120
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>Input data to the function. </td></tr>
<tr><td class="paramname">label</td><td>Input label to the function. </td></tr>
<tr><td class="paramname">grad_scale</td><td>Scale the gradient by a float factor </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a87534525f3cf07a8efca32e5be5b4865"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::make_loss </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Make your own loss function in network construction. </p><pre class="fragment">   This operator accepts a customized loss function symbol as a terminal loss and
   the symbol should be an operator with no backward dependency.
   The output of this function is the gradient of loss with respect to the input

   For example, if you are a making a cross entropy loss function. Assume ``out``
   predicted output and ``label`` is the true label, then the cross entropy can be

   cross_entropy = label * log(out) + (1 - label) * log(1 - out)
   loss = make_loss(cross_entropy)

   We will need to use ``make_loss`` when we are creating our own loss function or
   combine multiple loss functions. Also we may want to stop some variables'
   from backpropagation. See more detail in ``BlockGrad`` or ``stop_gradient``.

   The storage type of ``make_loss`` output depends upon the input storage type:

   - make_loss(default) = default
   - make_loss(row_sparse) = row_sparse



   Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L298
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>The input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a16ab7f08889ce658c3e8260458cb1143"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::make_loss </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Make your own loss function in network construction. </p><pre class="fragment">   This operator accepts a customized loss function symbol as a terminal loss and
   the symbol should be an operator with no backward dependency.
   The output of this function is the gradient of loss with respect to the input

   For example, if you are a making a cross entropy loss function. Assume ``out``
   predicted output and ``label`` is the true label, then the cross entropy can be

   cross_entropy = label * log(out) + (1 - label) * log(1 - out)
   loss = make_loss(cross_entropy)

   We will need to use ``make_loss`` when we are creating our own loss function or
   combine multiple loss functions. Also we may want to stop some variables'
   from backpropagation. See more detail in ``BlockGrad`` or ``stop_gradient``.

   The storage type of ``make_loss`` output depends upon the input storage type:

   - make_loss(default) = default
   - make_loss(row_sparse) = row_sparse



   Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L298
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>The input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a2b71f8b455ec59d0d9101d320ba77321"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::MakeLoss </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>grad_scale</em> = <code>1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>valid_thresh</em> = <code>0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespacemxnet_1_1cpp.html#a0f8c7551de879673caa593f74e8ebca6">MakeLossNormalization</a> </td>
<td class="paramname"><em>normalization</em> = <code><a class="el" href="namespacemxnet_1_1cpp.html#ae708904c6ad7046fcecfc6c6b7e0ac73af2655c2dee87cb9b0646f678a630394b">MakeLossNormalization::kNull</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Make your own loss function in network construction. </p><pre class="fragment">   This operator accepts a customized loss function symbol as a terminal loss and
   the symbol should be an operator with no backward dependency.
   The output of this function is the gradient of loss with respect to the input

   For example, if you are a making a cross entropy loss function. Assume ``out``
   predicted output and ``label`` is the true label, then the cross entropy can be

   cross_entropy = label * log(out) + (1 - label) * log(1 - out)
   loss = MakeLoss(cross_entropy)

   We will need to use ``MakeLoss`` when we are creating our own loss function or
   combine multiple loss functions. Also we may want to stop some variables'
   from backpropagation. See more detail in ``BlockGrad`` or ``stop_gradient``.

   In addition, we can give a scale to the loss by setting ``grad_scale``,
   so that the gradient of the loss will be rescaled in the backpropagation.

   .. note:: This operator should be used as a Symbol instead of NDArray.



   Defined in src/operator/make_loss.cc:L71
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>Input array. </td></tr>
<tr><td class="paramname">grad_scale</td><td>Gradient scale as a supplement to unary and binary operators </td></tr>
<tr><td class="paramname">valid_thresh</td><td>clip each element in the array to 0 when it is less than </td></tr>
<tr><td class="paramname">normalization</td><td>If this is set to null, the output gradient will not be normalized. If this is set to batch, the output gradient will be divided by the batch size. If this is set to valid, the output gradient will be divided by the </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a8139976df058af27379fe0eb1f8e24f4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::MakeLoss </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>grad_scale</em> = <code>1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>valid_thresh</em> = <code>0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespacemxnet_1_1cpp.html#a0f8c7551de879673caa593f74e8ebca6">MakeLossNormalization</a> </td>
<td class="paramname"><em>normalization</em> = <code><a class="el" href="namespacemxnet_1_1cpp.html#ae708904c6ad7046fcecfc6c6b7e0ac73af2655c2dee87cb9b0646f678a630394b">MakeLossNormalization::kNull</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Make your own loss function in network construction. </p><pre class="fragment">   This operator accepts a customized loss function symbol as a terminal loss and
   the symbol should be an operator with no backward dependency.
   The output of this function is the gradient of loss with respect to the input

   For example, if you are a making a cross entropy loss function. Assume ``out``
   predicted output and ``label`` is the true label, then the cross entropy can be

   cross_entropy = label * log(out) + (1 - label) * log(1 - out)
   loss = MakeLoss(cross_entropy)

   We will need to use ``MakeLoss`` when we are creating our own loss function or
   combine multiple loss functions. Also we may want to stop some variables'
   from backpropagation. See more detail in ``BlockGrad`` or ``stop_gradient``.

   In addition, we can give a scale to the loss by setting ``grad_scale``,
   so that the gradient of the loss will be rescaled in the backpropagation.

   .. note:: This operator should be used as a Symbol instead of NDArray.



   Defined in src/operator/make_loss.cc:L71
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>Input array. </td></tr>
<tr><td class="paramname">grad_scale</td><td>Gradient scale as a supplement to unary and binary operators </td></tr>
<tr><td class="paramname">valid_thresh</td><td>clip each element in the array to 0 when it is less than </td></tr>
<tr><td class="paramname">normalization</td><td>If this is set to null, the output gradient will not be normalized. If this is set to batch, the output gradient will be divided by the batch size. If this is set to valid, the output gradient will be divided by the </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="aaa1d63d156390ab52fd96a9ad1e0c314"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::max </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">dmlc::optional&lt; <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> &gt; </td>
<td class="paramname"><em>axis</em> = <code>dmlc::optional&lt;<a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>&gt;()</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>keepdims</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>exclude</em> = <code>false</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Computes the max of array elements over given axes. </p><pre class="fragment">   Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L190
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>The input </td></tr>
<tr><td class="paramname">axis</td><td>The axis or axes along which to perform the reduction. <pre class="fragment">   The default, `axis=()`, will compute over all elements into a
   scalar array with shape `(1,)`.

   If `axis` is int, a reduction is performed on a particular axis.

   If `axis` is a tuple of ints, a reduction is performed on all the axes
   specified in the tuple.

   If `exclude` is true, reduction will be performed on the axes that are
   NOT in axis instead.

   Negative values means indexing from right to left.
</pre> </td></tr>
<tr><td class="paramname">keepdims</td><td>If this is set to <code>True</code>, the reduced axes are left in the result as </td></tr>
<tr><td class="paramname">exclude</td><td>Whether to perform reduction on axis that are NOT in axis instead. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a1d16c7416b5924dd35a23ade7d465b52"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::max </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">dmlc::optional&lt; <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> &gt; </td>
<td class="paramname"><em>axis</em> = <code>dmlc::optional&lt;<a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>&gt;()</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>keepdims</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>exclude</em> = <code>false</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Computes the max of array elements over given axes. </p><pre class="fragment">   Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L190
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>The input </td></tr>
<tr><td class="paramname">axis</td><td>The axis or axes along which to perform the reduction. <pre class="fragment">   The default, `axis=()`, will compute over all elements into a
   scalar array with shape `(1,)`.

   If `axis` is int, a reduction is performed on a particular axis.

   If `axis` is a tuple of ints, a reduction is performed on all the axes
   specified in the tuple.

   If `exclude` is true, reduction will be performed on the axes that are
   NOT in axis instead.

   Negative values means indexing from right to left.
</pre> </td></tr>
<tr><td class="paramname">keepdims</td><td>If this is set to <code>True</code>, the reduced axes are left in the result as </td></tr>
<tr><td class="paramname">exclude</td><td>Whether to perform reduction on axis that are NOT in axis instead. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a54884055c968a6fcb737b772c82c5519"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::mean </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">dmlc::optional&lt; <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> &gt; </td>
<td class="paramname"><em>axis</em> = <code>dmlc::optional&lt;<a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>&gt;()</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>keepdims</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>exclude</em> = <code>false</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Computes the mean of array elements over given axes. </p><pre class="fragment">   Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L131
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>The input </td></tr>
<tr><td class="paramname">axis</td><td>The axis or axes along which to perform the reduction. <pre class="fragment">   The default, `axis=()`, will compute over all elements into a
   scalar array with shape `(1,)`.

   If `axis` is int, a reduction is performed on a particular axis.

   If `axis` is a tuple of ints, a reduction is performed on all the axes
   specified in the tuple.

   If `exclude` is true, reduction will be performed on the axes that are
   NOT in axis instead.

   Negative values means indexing from right to left.
</pre> </td></tr>
<tr><td class="paramname">keepdims</td><td>If this is set to <code>True</code>, the reduced axes are left in the result as </td></tr>
<tr><td class="paramname">exclude</td><td>Whether to perform reduction on axis that are NOT in axis instead. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="afd2d122473461f1f64f29b478a6d2569"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::mean </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">dmlc::optional&lt; <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> &gt; </td>
<td class="paramname"><em>axis</em> = <code>dmlc::optional&lt;<a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>&gt;()</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>keepdims</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>exclude</em> = <code>false</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Computes the mean of array elements over given axes. </p><pre class="fragment">   Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L131
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>The input </td></tr>
<tr><td class="paramname">axis</td><td>The axis or axes along which to perform the reduction. <pre class="fragment">   The default, `axis=()`, will compute over all elements into a
   scalar array with shape `(1,)`.

   If `axis` is int, a reduction is performed on a particular axis.

   If `axis` is a tuple of ints, a reduction is performed on all the axes
   specified in the tuple.

   If `exclude` is true, reduction will be performed on the axes that are
   NOT in axis instead.

   Negative values means indexing from right to left.
</pre> </td></tr>
<tr><td class="paramname">keepdims</td><td>If this is set to <code>True</code>, the reduced axes are left in the result as </td></tr>
<tr><td class="paramname">exclude</td><td>Whether to perform reduction on axis that are NOT in axis instead. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="aa42fcdd6b63c85b812018cbadb4ac521"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::min </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">dmlc::optional&lt; <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> &gt; </td>
<td class="paramname"><em>axis</em> = <code>dmlc::optional&lt;<a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>&gt;()</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>keepdims</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>exclude</em> = <code>false</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Computes the min of array elements over given axes. </p><pre class="fragment">   Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L204
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>The input </td></tr>
<tr><td class="paramname">axis</td><td>The axis or axes along which to perform the reduction. <pre class="fragment">   The default, `axis=()`, will compute over all elements into a
   scalar array with shape `(1,)`.

   If `axis` is int, a reduction is performed on a particular axis.

   If `axis` is a tuple of ints, a reduction is performed on all the axes
   specified in the tuple.

   If `exclude` is true, reduction will be performed on the axes that are
   NOT in axis instead.

   Negative values means indexing from right to left.
</pre> </td></tr>
<tr><td class="paramname">keepdims</td><td>If this is set to <code>True</code>, the reduced axes are left in the result as </td></tr>
<tr><td class="paramname">exclude</td><td>Whether to perform reduction on axis that are NOT in axis instead. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a92583837ea8e7e5d54564655703d48a4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::min </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">dmlc::optional&lt; <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> &gt; </td>
<td class="paramname"><em>axis</em> = <code>dmlc::optional&lt;<a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>&gt;()</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>keepdims</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>exclude</em> = <code>false</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Computes the min of array elements over given axes. </p><pre class="fragment">   Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L204
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>The input </td></tr>
<tr><td class="paramname">axis</td><td>The axis or axes along which to perform the reduction. <pre class="fragment">   The default, `axis=()`, will compute over all elements into a
   scalar array with shape `(1,)`.

   If `axis` is int, a reduction is performed on a particular axis.

   If `axis` is a tuple of ints, a reduction is performed on all the axes
   specified in the tuple.

   If `exclude` is true, reduction will be performed on the axes that are
   NOT in axis instead.

   Negative values means indexing from right to left.
</pre> </td></tr>
<tr><td class="paramname">keepdims</td><td>If this is set to <code>True</code>, the reduced axes are left in the result as </td></tr>
<tr><td class="paramname">exclude</td><td>Whether to perform reduction on axis that are NOT in axis instead. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a2e5c614842a25263659a0e743f2982bf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::mp_sgd_mom_update </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>weight</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>grad</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>mom</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>weight32</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>lr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>momentum</em> = <code>0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>wd</em> = <code>0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>rescale_grad</em> = <code>1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>clip_gradient</em> = <code>-1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>lazy_update</em> = <code>true</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Updater function for multi-precision sgd optimizer </p><dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">weight</td><td>Weight </td></tr>
<tr><td class="paramname">grad</td><td>Gradient </td></tr>
<tr><td class="paramname">mom</td><td>Momentum </td></tr>
<tr><td class="paramname">weight32</td><td>Weight32 </td></tr>
<tr><td class="paramname">lr</td><td>Learning rate </td></tr>
<tr><td class="paramname">momentum</td><td>The decay rate of momentum estimates at each epoch. </td></tr>
<tr><td class="paramname">wd</td><td>Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of </td></tr>
<tr><td class="paramname">rescale_grad</td><td>Rescale gradient to grad = rescale_grad*grad. </td></tr>
<tr><td class="paramname">clip_gradient</td><td>Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, </td></tr>
<tr><td class="paramname">lazy_update</td><td>If true, lazy updates are applied if gradient's stype is row_sparse </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a53f827d8b1865bd5003138db6ee98218"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::mp_sgd_mom_update </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>weight</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>grad</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>mom</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>weight32</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>lr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>momentum</em> = <code>0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>wd</em> = <code>0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>rescale_grad</em> = <code>1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>clip_gradient</em> = <code>-1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>lazy_update</em> = <code>true</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Updater function for multi-precision sgd optimizer </p><dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">weight</td><td>Weight </td></tr>
<tr><td class="paramname">grad</td><td>Gradient </td></tr>
<tr><td class="paramname">mom</td><td>Momentum </td></tr>
<tr><td class="paramname">weight32</td><td>Weight32 </td></tr>
<tr><td class="paramname">lr</td><td>Learning rate </td></tr>
<tr><td class="paramname">momentum</td><td>The decay rate of momentum estimates at each epoch. </td></tr>
<tr><td class="paramname">wd</td><td>Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of </td></tr>
<tr><td class="paramname">rescale_grad</td><td>Rescale gradient to grad = rescale_grad*grad. </td></tr>
<tr><td class="paramname">clip_gradient</td><td>Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, </td></tr>
<tr><td class="paramname">lazy_update</td><td>If true, lazy updates are applied if gradient's stype is row_sparse </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="ab7eb6765323ad891149d3709a4933f27"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::mp_sgd_update </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>weight</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>grad</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>weight32</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>lr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>wd</em> = <code>0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>rescale_grad</em> = <code>1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>clip_gradient</em> = <code>-1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>lazy_update</em> = <code>true</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Updater function for multi-precision sgd optimizer </p><dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">weight</td><td>Weight </td></tr>
<tr><td class="paramname">grad</td><td>gradient </td></tr>
<tr><td class="paramname">weight32</td><td>Weight32 </td></tr>
<tr><td class="paramname">lr</td><td>Learning rate </td></tr>
<tr><td class="paramname">wd</td><td>Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of </td></tr>
<tr><td class="paramname">rescale_grad</td><td>Rescale gradient to grad = rescale_grad*grad. </td></tr>
<tr><td class="paramname">clip_gradient</td><td>Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, </td></tr>
<tr><td class="paramname">lazy_update</td><td>If true, lazy updates are applied if gradient's stype is row_sparse. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a9941ee833dfee8eeb7af773dec8243fe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::mp_sgd_update </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>weight</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>grad</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>weight32</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>lr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>wd</em> = <code>0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>rescale_grad</em> = <code>1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>clip_gradient</em> = <code>-1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>lazy_update</em> = <code>true</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Updater function for multi-precision sgd optimizer </p><dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">weight</td><td>Weight </td></tr>
<tr><td class="paramname">grad</td><td>gradient </td></tr>
<tr><td class="paramname">weight32</td><td>Weight32 </td></tr>
<tr><td class="paramname">lr</td><td>Learning rate </td></tr>
<tr><td class="paramname">wd</td><td>Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of </td></tr>
<tr><td class="paramname">rescale_grad</td><td>Rescale gradient to grad = rescale_grad*grad. </td></tr>
<tr><td class="paramname">clip_gradient</td><td>Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, </td></tr>
<tr><td class="paramname">lazy_update</td><td>If true, lazy updates are applied if gradient's stype is row_sparse. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="afb57e17a490b7a4e60e1e3543b165ec3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::nanprod </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">dmlc::optional&lt; <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> &gt; </td>
<td class="paramname"><em>axis</em> = <code>dmlc::optional&lt;<a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>&gt;()</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>keepdims</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>exclude</em> = <code>false</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Computes the product of array elements over given axes treating Not a Numbers</p>
<pre class="fragment">   Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L176
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>The input </td></tr>
<tr><td class="paramname">axis</td><td>The axis or axes along which to perform the reduction. <pre class="fragment">   The default, `axis=()`, will compute over all elements into a
   scalar array with shape `(1,)`.

   If `axis` is int, a reduction is performed on a particular axis.

   If `axis` is a tuple of ints, a reduction is performed on all the axes
   specified in the tuple.

   If `exclude` is true, reduction will be performed on the axes that are
   NOT in axis instead.

   Negative values means indexing from right to left.
</pre> </td></tr>
<tr><td class="paramname">keepdims</td><td>If this is set to <code>True</code>, the reduced axes are left in the result as </td></tr>
<tr><td class="paramname">exclude</td><td>Whether to perform reduction on axis that are NOT in axis instead. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="aa9cc44c642e6b8cbb5c175d4766c01f5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::nanprod </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">dmlc::optional&lt; <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> &gt; </td>
<td class="paramname"><em>axis</em> = <code>dmlc::optional&lt;<a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>&gt;()</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>keepdims</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>exclude</em> = <code>false</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Computes the product of array elements over given axes treating Not a Numbers</p>
<pre class="fragment">   Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L176
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>The input </td></tr>
<tr><td class="paramname">axis</td><td>The axis or axes along which to perform the reduction. <pre class="fragment">   The default, `axis=()`, will compute over all elements into a
   scalar array with shape `(1,)`.

   If `axis` is int, a reduction is performed on a particular axis.

   If `axis` is a tuple of ints, a reduction is performed on all the axes
   specified in the tuple.

   If `exclude` is true, reduction will be performed on the axes that are
   NOT in axis instead.

   Negative values means indexing from right to left.
</pre> </td></tr>
<tr><td class="paramname">keepdims</td><td>If this is set to <code>True</code>, the reduced axes are left in the result as </td></tr>
<tr><td class="paramname">exclude</td><td>Whether to perform reduction on axis that are NOT in axis instead. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a64e41923c4d0e2e201e0837c320e8c32"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::nansum </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">dmlc::optional&lt; <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> &gt; </td>
<td class="paramname"><em>axis</em> = <code>dmlc::optional&lt;<a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>&gt;()</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>keepdims</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>exclude</em> = <code>false</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Computes the sum of array elements over given axes treating Not a Numbers</p>
<pre class="fragment">   Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L161
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>The input </td></tr>
<tr><td class="paramname">axis</td><td>The axis or axes along which to perform the reduction. <pre class="fragment">   The default, `axis=()`, will compute over all elements into a
   scalar array with shape `(1,)`.

   If `axis` is int, a reduction is performed on a particular axis.

   If `axis` is a tuple of ints, a reduction is performed on all the axes
   specified in the tuple.

   If `exclude` is true, reduction will be performed on the axes that are
   NOT in axis instead.

   Negative values means indexing from right to left.
</pre> </td></tr>
<tr><td class="paramname">keepdims</td><td>If this is set to <code>True</code>, the reduced axes are left in the result as </td></tr>
<tr><td class="paramname">exclude</td><td>Whether to perform reduction on axis that are NOT in axis instead. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a5b86040bbbd97c0e325c50fb8bb6bfe1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::nansum </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">dmlc::optional&lt; <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> &gt; </td>
<td class="paramname"><em>axis</em> = <code>dmlc::optional&lt;<a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>&gt;()</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>keepdims</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>exclude</em> = <code>false</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Computes the sum of array elements over given axes treating Not a Numbers</p>
<pre class="fragment">   Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L161
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>The input </td></tr>
<tr><td class="paramname">axis</td><td>The axis or axes along which to perform the reduction. <pre class="fragment">   The default, `axis=()`, will compute over all elements into a
   scalar array with shape `(1,)`.

   If `axis` is int, a reduction is performed on a particular axis.

   If `axis` is a tuple of ints, a reduction is performed on all the axes
   specified in the tuple.

   If `exclude` is true, reduction will be performed on the axes that are
   NOT in axis instead.

   Negative values means indexing from right to left.
</pre> </td></tr>
<tr><td class="paramname">keepdims</td><td>If this is set to <code>True</code>, the reduced axes are left in the result as </td></tr>
<tr><td class="paramname">exclude</td><td>Whether to perform reduction on axis that are NOT in axis instead. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a7357e06979b835b0a9fa03a43a729c3e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::negative </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Numerical negative of the argument, element-wise. </p><pre class="fragment">   The storage type of ``negative`` output depends upon the input storage type:

   - negative(default) = default
   - negative(row_sparse) = row_sparse
   - negative(csr) = csr
</pre><dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>The input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a79d571267e32c41b46aefc11bae47884"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::negative </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Numerical negative of the argument, element-wise. </p><pre class="fragment">   The storage type of ``negative`` output depends upon the input storage type:

   - negative(default) = default
   - negative(row_sparse) = row_sparse
   - negative(csr) = csr
</pre><dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>The input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="af7eecf137de8b1f769b0ca0f189a148a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::norm </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>ord</em> = <code>2</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">dmlc::optional&lt; <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> &gt; </td>
<td class="paramname"><em>axis</em> = <code>dmlc::optional&lt;<a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>&gt;()</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>keepdims</em> = <code>false</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Computes the norm on an <a class="el" href="classmxnet_1_1cpp_1_1NDArray.html" title="NDArray interface. ">NDArray</a>. </p><pre class="fragment">   This operator computes the norm on an NDArray with the specified axis, depending
   on the value of the ord parameter. By default, it computes the L2 norm on the
   array. Currently only ord=2 supports sparse ndarrays.

   Examples::

   x = [[[1, 2],
   [3, 4]],
   [[2, 2],
   [5, 6]]]

   norm(x, ord=2, axis=1) = [[3.1622777 4.472136 ]
   [5.3851647 6.3245554]]

   norm(x, ord=1, axis=1) = [[4., 6.],
   [7., 8.]]

   rsp = x.cast_storage('row_sparse')

   norm(rsp) = [5.47722578]

   csr = x.cast_storage('csr')

   norm(csr) = [5.47722578]



   Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L345
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>The input </td></tr>
<tr><td class="paramname">ord</td><td>Order of the norm. Currently ord=1 and ord=2 is supported. </td></tr>
<tr><td class="paramname">axis</td><td>The axis or axes along which to perform the reduction. The default, <code>axis=()</code>, will compute over all elements into a scalar array with shape <code>(1,)</code>. If <code>axis</code> is int, a reduction is performed on a particular axis. If <code>axis</code> is a 2-tuple, it specifies the axes that hold 2-D matrices, and the matrix norms of these matrices are computed. </td></tr>
<tr><td class="paramname">keepdims</td><td>If this is set to <code>True</code>, the reduced axis is left in the result as </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a114145f016a9c2d5aa9be37a3c67fe1e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::norm </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>ord</em> = <code>2</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">dmlc::optional&lt; <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> &gt; </td>
<td class="paramname"><em>axis</em> = <code>dmlc::optional&lt;<a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>&gt;()</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>keepdims</em> = <code>false</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Computes the norm on an <a class="el" href="classmxnet_1_1cpp_1_1NDArray.html" title="NDArray interface. ">NDArray</a>. </p><pre class="fragment">   This operator computes the norm on an NDArray with the specified axis, depending
   on the value of the ord parameter. By default, it computes the L2 norm on the
   array. Currently only ord=2 supports sparse ndarrays.

   Examples::

   x = [[[1, 2],
   [3, 4]],
   [[2, 2],
   [5, 6]]]

   norm(x, ord=2, axis=1) = [[3.1622777 4.472136 ]
   [5.3851647 6.3245554]]

   norm(x, ord=1, axis=1) = [[4., 6.],
   [7., 8.]]

   rsp = x.cast_storage('row_sparse')

   norm(rsp) = [5.47722578]

   csr = x.cast_storage('csr')

   norm(csr) = [5.47722578]



   Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L345
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>The input </td></tr>
<tr><td class="paramname">ord</td><td>Order of the norm. Currently ord=1 and ord=2 is supported. </td></tr>
<tr><td class="paramname">axis</td><td>The axis or axes along which to perform the reduction. The default, <code>axis=()</code>, will compute over all elements into a scalar array with shape <code>(1,)</code>. If <code>axis</code> is int, a reduction is performed on a particular axis. If <code>axis</code> is a 2-tuple, it specifies the axes that hold 2-D matrices, and the matrix norms of these matrices are computed. </td></tr>
<tr><td class="paramname">keepdims</td><td>If this is set to <code>True</code>, the reduced axis is left in the result as </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a9e910ba1e5b10fdc19d0d807ef263c14"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::one_hot </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>indices</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>depth</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double </td>
<td class="paramname"><em>on_value</em> = <code>1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double </td>
<td class="paramname"><em>off_value</em> = <code>0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespacemxnet_1_1cpp.html#a38cfaf4948f45cc4e6e46fbef0f6b8c2">One_hotDtype</a> </td>
<td class="paramname"><em>dtype</em> = <code><a class="el" href="namespacemxnet_1_1cpp.html#a8e907a5fbbe4ec21628e500b34a5f35da9a78d6a569d086b524c3caf8c2522f96">One_hotDtype::kFloat32</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns a one-hot array. </p><pre class="fragment">   The locations represented by `indices` take value `on_value`, while all
   other locations take value `off_value`.

   `one_hot` operation with `indices` of shape ``(i0, i1)`` and `depth`  of ``d``
   in an output array of shape ``(i0, i1, d)`` with::

   output[i,j,:] = off_value
   output[i,j,indices[i,j]] = on_value

   Examples::

   one_hot([1,0,2,0], 3) = [[ 0.  1.  0.]
   [ 1.  0.  0.]
   [ 0.  0.  1.]
   [ 1.  0.  0.]]

   one_hot([1,0,2,0], 3, on_value=8, off_value=1,
   dtype='int32') = [[1 8 1]
   [8 1 1]
   [1 1 8]
   [8 1 1]]

   one_hot([[1,0],[1,0],[2,0]], 3) = [[[ 0.  1.  0.]
   [ 1.  0.  0.]]

   [[ 0.  1.  0.]
   [ 1.  0.  0.]]

   [[ 0.  0.  1.]
   [ 1.  0.  0.]]]


   Defined in src/operator/tensor/indexing_op.cc:L536
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">indices</td><td>array of locations where to set on_value </td></tr>
<tr><td class="paramname">depth</td><td>Depth of the one hot dimension. </td></tr>
<tr><td class="paramname">on_value</td><td>The value assigned to the locations represented by indices. </td></tr>
<tr><td class="paramname">off_value</td><td>The value assigned to the locations not represented by indices. </td></tr>
<tr><td class="paramname">dtype</td><td>DType of the output </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a35c04a9ebe97b9bf13a1f2928b464c6e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::one_hot </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>indices</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>depth</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double </td>
<td class="paramname"><em>on_value</em> = <code>1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double </td>
<td class="paramname"><em>off_value</em> = <code>0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespacemxnet_1_1cpp.html#a38cfaf4948f45cc4e6e46fbef0f6b8c2">One_hotDtype</a> </td>
<td class="paramname"><em>dtype</em> = <code><a class="el" href="namespacemxnet_1_1cpp.html#a8e907a5fbbe4ec21628e500b34a5f35da9a78d6a569d086b524c3caf8c2522f96">One_hotDtype::kFloat32</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns a one-hot array. </p><pre class="fragment">   The locations represented by `indices` take value `on_value`, while all
   other locations take value `off_value`.

   `one_hot` operation with `indices` of shape ``(i0, i1)`` and `depth`  of ``d``
   in an output array of shape ``(i0, i1, d)`` with::

   output[i,j,:] = off_value
   output[i,j,indices[i,j]] = on_value

   Examples::

   one_hot([1,0,2,0], 3) = [[ 0.  1.  0.]
   [ 1.  0.  0.]
   [ 0.  0.  1.]
   [ 1.  0.  0.]]

   one_hot([1,0,2,0], 3, on_value=8, off_value=1,
   dtype='int32') = [[1 8 1]
   [8 1 1]
   [1 1 8]
   [8 1 1]]

   one_hot([[1,0],[1,0],[2,0]], 3) = [[[ 0.  1.  0.]
   [ 1.  0.  0.]]

   [[ 0.  1.  0.]
   [ 1.  0.  0.]]

   [[ 0.  0.  1.]
   [ 1.  0.  0.]]]


   Defined in src/operator/tensor/indexing_op.cc:L536
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">indices</td><td>array of locations where to set on_value </td></tr>
<tr><td class="paramname">depth</td><td>Depth of the one hot dimension. </td></tr>
<tr><td class="paramname">on_value</td><td>The value assigned to the locations represented by indices. </td></tr>
<tr><td class="paramname">off_value</td><td>The value assigned to the locations not represented by indices. </td></tr>
<tr><td class="paramname">dtype</td><td>DType of the output </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a053cb533e3262bf393fd868a92e37f2f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::ones_like </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Return an array of ones with the same shape and type as the input array.</p>
<p>Examples::</p>
<p>x = [[ 0., 0., 0.], [ 0., 0., 0.]]</p>
<p>ones_like(x) = [[ 1., 1., 1.], [ 1., 1., 1.]]</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>The input </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a457ca5ac74ed9713761c55f9c2eace46"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::ones_like </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Return an array of ones with the same shape and type as the input array.</p>
<p>Examples::</p>
<p>x = [[ 0., 0., 0.], [ 0., 0., 0.]]</p>
<p>ones_like(x) = [[ 1., 1., 1.], [ 1., 1., 1.]]</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>The input </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a9dd3c680ffa337cc97981ada80645880"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::operator% </td>
<td>(</td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> &amp; </td>
<td class="paramname"><em>rhs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a class="anchor" id="ae76138e7d064b0f17638b365c27425f6"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::operator* </td>
<td>(</td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> &amp; </td>
<td class="paramname"><em>rhs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a class="anchor" id="af7ac3062c79e5700205043f94e7029ad"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::operator+ </td>
<td>(</td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> &amp; </td>
<td class="paramname"><em>rhs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a class="anchor" id="a4a500d425fad80171b91185fa781b937"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::operator- </td>
<td>(</td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> &amp; </td>
<td class="paramname"><em>rhs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a class="anchor" id="a6e10e5bdac4feca95f2a2cc4050ccb29"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::operator/ </td>
<td>(</td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> &amp; </td>
<td class="paramname"><em>rhs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a class="anchor" id="a70dfe73858728880adc2f777c0a55d68"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">std::ostream&amp; mxnet::cpp::operator&lt;&lt; </td>
<td>(</td>
<td class="paramtype">std::ostream &amp; </td>
<td class="paramname"><em>os</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> &amp; </td>
<td class="paramname"><em>shape</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>allow string printing of the shape </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">os</td><td>the output stream </td></tr>
<tr><td class="paramname">shape</td><td>the shape </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the ostream </dd></dl>
</div>
</div>
<a class="anchor" id="a56bcf615f032f8ca632e0ed3d56223a0"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">std::ostream&amp; mxnet::cpp::operator&lt;&lt; </td>
<td>(</td>
<td class="paramtype">std::ostream &amp; </td>
<td class="paramname"><em>out</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="classmxnet_1_1cpp_1_1NDArray.html">NDArray</a> &amp; </td>
<td class="paramname"><em>ndarray</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a class="anchor" id="aaab80b2ff315a4fa9c5c6782a6b372d8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">std::istream&amp; mxnet::cpp::operator&gt;&gt; </td>
<td>(</td>
<td class="paramtype">std::istream &amp; </td>
<td class="paramname"><em>is</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> &amp; </td>
<td class="paramname"><em>shape</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>read shape from the istream </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">is</td><td>the input stream </td></tr>
<tr><td class="paramname">shape</td><td>the shape </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the istream </dd></dl>
</div>
</div>
<a class="anchor" id="a55dd6c1f44abfaf30cf60fd099ef511c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::Pad </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespacemxnet_1_1cpp.html#ab261a86c931574327d82188c75f93d1a">PadMode</a> </td>
<td class="paramname"><em>mode</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> </td>
<td class="paramname"><em>pad_width</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double </td>
<td class="paramname"><em>constant_value</em> = <code>0</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Pads an input array with a constant or edge values of the array. </p><pre class="fragment">   .. note:: `Pad` is deprecated. Use `pad` instead.

   .. note:: Current implementation only supports 4D and 5D input arrays with
   only on axes 1, 2 and 3. Expects axes 4 and 5 in `pad_width` to be zero.

   This operation pads an input array with either a `constant_value` or edge values
   along each axis of the input array. The amount of padding is specified by

   `pad_width` is a tuple of integer padding widths for each axis of the format
   ``(before_1, after_1, ... , before_N, after_N)``. The `pad_width` should be of
   where ``N`` is the number of dimensions of the array.

   For dimension ``N`` of the input array, ``before_N`` and ``after_N`` indicates
   to add before and after the elements of the array along dimension ``N``.
   The widths of the higher two dimensions ``before_1``, ``after_1``, ``before_2``,
   ``after_2`` must be 0.

   Example::

   x = [[[[  1.   2.   3.]
   [  4.   5.   6.]]

   [[  7.   8.   9.]
   [ 10.  11.  12.]]]


   [[[ 11.  12.  13.]
   [ 14.  15.  16.]]

   [[ 17.  18.  19.]
   [ 20.  21.  22.]]]]

   pad(x,mode="edge", pad_width=(0,0,0,0,1,1,1,1)) =

   [[[[  1.   1.   2.   3.   3.]
   [  1.   1.   2.   3.   3.]
   [  4.   4.   5.   6.   6.]
   [  4.   4.   5.   6.   6.]]

   [[  7.   7.   8.   9.   9.]
   [  7.   7.   8.   9.   9.]
   [ 10.  10.  11.  12.  12.]
   [ 10.  10.  11.  12.  12.]]]


   [[[ 11.  11.  12.  13.  13.]
   [ 11.  11.  12.  13.  13.]
   [ 14.  14.  15.  16.  16.]
   [ 14.  14.  15.  16.  16.]]

   [[ 17.  17.  18.  19.  19.]
   [ 17.  17.  18.  19.  19.]
   [ 20.  20.  21.  22.  22.]
   [ 20.  20.  21.  22.  22.]]]]

   pad(x, mode="constant", constant_value=0, pad_width=(0,0,0,0,1,1,1,1)) =

   [[[[  0.   0.   0.   0.   0.]
   [  0.   1.   2.   3.   0.]
   [  0.   4.   5.   6.   0.]
   [  0.   0.   0.   0.   0.]]

   [[  0.   0.   0.   0.   0.]
   [  0.   7.   8.   9.   0.]
   [  0.  10.  11.  12.   0.]
   [  0.   0.   0.   0.   0.]]]


   [[[  0.   0.   0.   0.   0.]
   [  0.  11.  12.  13.   0.]
   [  0.  14.  15.  16.   0.]
   [  0.   0.   0.   0.   0.]]

   [[  0.   0.   0.   0.   0.]
   [  0.  17.  18.  19.   0.]
   [  0.  20.  21.  22.   0.]
   [  0.   0.   0.   0.   0.]]]]




   Defined in src/operator/pad.cc:L766
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>An n-dimensional input array. </td></tr>
<tr><td class="paramname">mode</td><td>Padding type to use. "constant" pads with <code>constant_value</code> "edge" pads using the edge values of the input array "reflect" pads by reflecting values </td></tr>
<tr><td class="paramname">pad_width</td><td>Widths of the padding regions applied to the edges of each axis. It is a tuple of integer padding widths for each axis of the format <code>(before_1, after_1, ... , before_N, after_N)</code>. It should be of length <code>2*N</code> where <code>N</code> is the number of dimensions of the array.This is equivalent to pad_width in </td></tr>
<tr><td class="paramname">constant_value</td><td>The value used for padding when <code>mode</code> is "constant". </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a7f6a1f50318d64d45a5556c969fdfe1d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::Pad </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespacemxnet_1_1cpp.html#ab261a86c931574327d82188c75f93d1a">PadMode</a> </td>
<td class="paramname"><em>mode</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> </td>
<td class="paramname"><em>pad_width</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double </td>
<td class="paramname"><em>constant_value</em> = <code>0</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Pads an input array with a constant or edge values of the array. </p><pre class="fragment">   .. note:: `Pad` is deprecated. Use `pad` instead.

   .. note:: Current implementation only supports 4D and 5D input arrays with
   only on axes 1, 2 and 3. Expects axes 4 and 5 in `pad_width` to be zero.

   This operation pads an input array with either a `constant_value` or edge values
   along each axis of the input array. The amount of padding is specified by

   `pad_width` is a tuple of integer padding widths for each axis of the format
   ``(before_1, after_1, ... , before_N, after_N)``. The `pad_width` should be of
   where ``N`` is the number of dimensions of the array.

   For dimension ``N`` of the input array, ``before_N`` and ``after_N`` indicates
   to add before and after the elements of the array along dimension ``N``.
   The widths of the higher two dimensions ``before_1``, ``after_1``, ``before_2``,
   ``after_2`` must be 0.

   Example::

   x = [[[[  1.   2.   3.]
   [  4.   5.   6.]]

   [[  7.   8.   9.]
   [ 10.  11.  12.]]]


   [[[ 11.  12.  13.]
   [ 14.  15.  16.]]

   [[ 17.  18.  19.]
   [ 20.  21.  22.]]]]

   pad(x,mode="edge", pad_width=(0,0,0,0,1,1,1,1)) =

   [[[[  1.   1.   2.   3.   3.]
   [  1.   1.   2.   3.   3.]
   [  4.   4.   5.   6.   6.]
   [  4.   4.   5.   6.   6.]]

   [[  7.   7.   8.   9.   9.]
   [  7.   7.   8.   9.   9.]
   [ 10.  10.  11.  12.  12.]
   [ 10.  10.  11.  12.  12.]]]


   [[[ 11.  11.  12.  13.  13.]
   [ 11.  11.  12.  13.  13.]
   [ 14.  14.  15.  16.  16.]
   [ 14.  14.  15.  16.  16.]]

   [[ 17.  17.  18.  19.  19.]
   [ 17.  17.  18.  19.  19.]
   [ 20.  20.  21.  22.  22.]
   [ 20.  20.  21.  22.  22.]]]]

   pad(x, mode="constant", constant_value=0, pad_width=(0,0,0,0,1,1,1,1)) =

   [[[[  0.   0.   0.   0.   0.]
   [  0.   1.   2.   3.   0.]
   [  0.   4.   5.   6.   0.]
   [  0.   0.   0.   0.   0.]]

   [[  0.   0.   0.   0.   0.]
   [  0.   7.   8.   9.   0.]
   [  0.  10.  11.  12.   0.]
   [  0.   0.   0.   0.   0.]]]


   [[[  0.   0.   0.   0.   0.]
   [  0.  11.  12.  13.   0.]
   [  0.  14.  15.  16.   0.]
   [  0.   0.   0.   0.   0.]]

   [[  0.   0.   0.   0.   0.]
   [  0.  17.  18.  19.   0.]
   [  0.  20.  21.  22.   0.]
   [  0.   0.   0.   0.   0.]]]]




   Defined in src/operator/pad.cc:L766
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>An n-dimensional input array. </td></tr>
<tr><td class="paramname">mode</td><td>Padding type to use. "constant" pads with <code>constant_value</code> "edge" pads using the edge values of the input array "reflect" pads by reflecting values </td></tr>
<tr><td class="paramname">pad_width</td><td>Widths of the padding regions applied to the edges of each axis. It is a tuple of integer padding widths for each axis of the format <code>(before_1, after_1, ... , before_N, after_N)</code>. It should be of length <code>2*N</code> where <code>N</code> is the number of dimensions of the array.This is equivalent to pad_width in </td></tr>
<tr><td class="paramname">constant_value</td><td>The value used for padding when <code>mode</code> is "constant". </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a0f5fae458553ff92bb0b5308263cf76e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::pick </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>index</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">dmlc::optional&lt; int &gt; </td>
<td class="paramname"><em>axis</em> = <code>dmlc::optional&lt;int&gt;(-1)</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>keepdims</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespacemxnet_1_1cpp.html#a30fd3a240ebc436ddb671d0c33d5bdc3">PickMode</a> </td>
<td class="paramname"><em>mode</em> = <code><a class="el" href="namespacemxnet_1_1cpp.html#a30fd3a240ebc436ddb671d0c33d5bdc3ae2867cadc2a39b014e89d241b72f3a75">PickMode::kClip</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Picks elements from an input array according to the input indices along the </p><pre class="fragment">   Given an input array of shape ``(d0, d1)`` and indices of shape ``(i0,)``, the
   an output array of shape ``(i0,)`` with::

   output[i] = input[i, indices[i]]

   By default, if any index mentioned is too large, it is replaced by the index
   the last element along an axis (the `clip` mode).

   This function supports n-dimensional input and (n-1)-dimensional indices arrays.

   Examples::

   x = [[ 1.,  2.],
   [ 3.,  4.],
   [ 5.,  6.]]

   // picks elements with specified indices along axis 0
   pick(x, y=[0,1], 0) = [ 1.,  4.]

   // picks elements with specified indices along axis 1
   pick(x, y=[0,1,0], 1) = [ 1.,  4.,  5.]

   y = [[ 1.],
   [ 0.],
   [ 2.]]

   // picks elements with specified indices along axis 1 using 'wrap' mode
   // to place indicies that would normally be out of bounds
   pick(x, y=[2,-1,-2], 1, mode='wrap') = [ 1.,  4.,  5.]

   y = [[ 1.],
   [ 0.],
   [ 2.]]

   // picks elements with specified indices along axis 1 and dims are maintained
   pick(x,y, 1, keepdims=True) = [[ 2.],
   [ 3.],
   [ 6.]]



   Defined in src/operator/tensor/broadcast_reduce_op_index.cc:L153
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>The input array </td></tr>
<tr><td class="paramname">index</td><td>The index array </td></tr>
<tr><td class="paramname">axis</td><td>int or None. The axis to picking the elements. Negative values means indexing from right to left. If is <code>None</code>, the elements in the index w.r.t the </td></tr>
<tr><td class="paramname">keepdims</td><td>If true, the axis where we pick the elements is left in the result as </td></tr>
<tr><td class="paramname">mode</td><td>Specify how out-of-bound indices behave. Default is "clip". "clip" means clip to the range. So, if all indices mentioned are too large, they are replaced by the index that addresses the last element along an axis. "wrap" </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a71433df39ed119974e03369b11974781"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::pick </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>index</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">dmlc::optional&lt; int &gt; </td>
<td class="paramname"><em>axis</em> = <code>dmlc::optional&lt;int&gt;(-1)</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>keepdims</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespacemxnet_1_1cpp.html#a30fd3a240ebc436ddb671d0c33d5bdc3">PickMode</a> </td>
<td class="paramname"><em>mode</em> = <code><a class="el" href="namespacemxnet_1_1cpp.html#a30fd3a240ebc436ddb671d0c33d5bdc3ae2867cadc2a39b014e89d241b72f3a75">PickMode::kClip</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Picks elements from an input array according to the input indices along the </p><pre class="fragment">   Given an input array of shape ``(d0, d1)`` and indices of shape ``(i0,)``, the
   an output array of shape ``(i0,)`` with::

   output[i] = input[i, indices[i]]

   By default, if any index mentioned is too large, it is replaced by the index
   the last element along an axis (the `clip` mode).

   This function supports n-dimensional input and (n-1)-dimensional indices arrays.

   Examples::

   x = [[ 1.,  2.],
   [ 3.,  4.],
   [ 5.,  6.]]

   // picks elements with specified indices along axis 0
   pick(x, y=[0,1], 0) = [ 1.,  4.]

   // picks elements with specified indices along axis 1
   pick(x, y=[0,1,0], 1) = [ 1.,  4.,  5.]

   y = [[ 1.],
   [ 0.],
   [ 2.]]

   // picks elements with specified indices along axis 1 using 'wrap' mode
   // to place indicies that would normally be out of bounds
   pick(x, y=[2,-1,-2], 1, mode='wrap') = [ 1.,  4.,  5.]

   y = [[ 1.],
   [ 0.],
   [ 2.]]

   // picks elements with specified indices along axis 1 and dims are maintained
   pick(x,y, 1, keepdims=True) = [[ 2.],
   [ 3.],
   [ 6.]]



   Defined in src/operator/tensor/broadcast_reduce_op_index.cc:L153
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>The input array </td></tr>
<tr><td class="paramname">index</td><td>The index array </td></tr>
<tr><td class="paramname">axis</td><td>int or None. The axis to picking the elements. Negative values means indexing from right to left. If is <code>None</code>, the elements in the index w.r.t the </td></tr>
<tr><td class="paramname">keepdims</td><td>If true, the axis where we pick the elements is left in the result as </td></tr>
<tr><td class="paramname">mode</td><td>Specify how out-of-bound indices behave. Default is "clip". "clip" means clip to the range. So, if all indices mentioned are too large, they are replaced by the index that addresses the last element along an axis. "wrap" </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a800c66c6506c33a9cd23d3f3d208bdcb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::Pooling </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> </td>
<td class="paramname"><em>kernel</em> = <code><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>()</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespacemxnet_1_1cpp.html#a44ef744b314acdba218a7405f56e00be">PoolingPoolType</a> </td>
<td class="paramname"><em>pool_type</em> = <code><a class="el" href="namespacemxnet_1_1cpp.html#a44ef744b314acdba218a7405f56e00beaa0b1ac8aae6b1cfbbe89085c642b3b4b">PoolingPoolType::kMax</a></code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>global_pool</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>cudnn_off</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespacemxnet_1_1cpp.html#abaf9ea614ede3210454943dd3130c5cd">PoolingPoolingConvention</a> </td>
<td class="paramname"><em>pooling_convention</em> = <code><a class="el" href="namespacemxnet_1_1cpp.html#abaf9ea614ede3210454943dd3130c5cda4d3576c37e6f03700bad4345238fffa0">PoolingPoolingConvention::kValid</a></code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> </td>
<td class="paramname"><em>stride</em> = <code><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>()</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> </td>
<td class="paramname"><em>pad</em> = <code><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>()</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">dmlc::optional&lt; int &gt; </td>
<td class="paramname"><em>p_value</em> = <code>dmlc::optional&lt;int&gt;()</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">dmlc::optional&lt; bool &gt; </td>
<td class="paramname"><em>count_include_pad</em> = <code>dmlc::optional&lt;bool&gt;()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Performs pooling on the input. </p><pre class="fragment">   The shapes for 1-D pooling are

   - **data**: *(batch_size, channel, width)*,
   - **out**: *(batch_size, num_filter, out_width)*.

   The shapes for 2-D pooling are

   - **data**: *(batch_size, channel, height, width)*
   - **out**: *(batch_size, num_filter, out_height, out_width)*, with::

   out_height = f(height, kernel[0], pad[0], stride[0])
   out_width = f(width, kernel[1], pad[1], stride[1])

   The definition of *f* depends on ``pooling_convention``, which has two options:

   - **valid** (default)::

   f(x, k, p, s) = floor((x+2*p-k)/s)+1

   - **full**, which is compatible with Caffe::

   f(x, k, p, s) = ceil((x+2*p-k)/s)+1

   But ``global_pool`` is set to be true, then do a global pooling, namely reset
   ``kernel=(height, width)``.

   Three pooling options are supported by ``pool_type``:

   - **avg**: average pooling
   - **max**: max pooling
   - **sum**: sum pooling
   - **lp**: Lp pooling

   For 3-D pooling, an additional *depth* dimension is added before
   *height*. Namely the input data will have shape *(batch_size, channel, depth,
   height, width)*.

   Notes on Lp pooling:

   Lp pooling was first introduced by this paper:
   L-1 pooling is simply sum pooling, while L-inf pooling is simply max pooling.
   We can see that Lp pooling stands between those two, in practice the most

   For each window ``X``, the mathematical expression for Lp pooling is:

   :math:`f(X) = \sqrt[p]{\sum_{x}^{X} x^p}`



   Defined in src/operator/nn/pooling.cc:L388
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>Input data to the pooling operator. </td></tr>
<tr><td class="paramname">kernel</td><td>Pooling kernel size: (y, x) or (d, y, x) </td></tr>
<tr><td class="paramname">pool_type</td><td>Pooling type to be applied. </td></tr>
<tr><td class="paramname">global_pool</td><td>Ignore kernel size, do global pooling based on current input </td></tr>
<tr><td class="paramname">cudnn_off</td><td>Turn off cudnn pooling and use MXNet pooling operator. </td></tr>
<tr><td class="paramname">pooling_convention</td><td>Pooling convention to be applied. </td></tr>
<tr><td class="paramname">stride</td><td>Stride: for pooling (y, x) or (d, y, x). Defaults to 1 for each </td></tr>
<tr><td class="paramname">pad</td><td>Pad for pooling: (y, x) or (d, y, x). Defaults to no padding. </td></tr>
<tr><td class="paramname">p_value</td><td>Value of p for Lp pooling, can be 1 or 2, required for Lp Pooling. </td></tr>
<tr><td class="paramname">count_include_pad</td><td>Only used for AvgPool, specify whether to count padding elements for averagecalculation. For example, with a 5*5 kernel on a 3*3 corner of a image,the sum of the 9 valid elements will be divided by 25 if this is set </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a4cbbb4de915456440868d7666b86ce62"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::Pooling </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> </td>
<td class="paramname"><em>kernel</em> = <code><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>()</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespacemxnet_1_1cpp.html#a44ef744b314acdba218a7405f56e00be">PoolingPoolType</a> </td>
<td class="paramname"><em>pool_type</em> = <code><a class="el" href="namespacemxnet_1_1cpp.html#a44ef744b314acdba218a7405f56e00beaa0b1ac8aae6b1cfbbe89085c642b3b4b">PoolingPoolType::kMax</a></code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>global_pool</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>cudnn_off</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespacemxnet_1_1cpp.html#abaf9ea614ede3210454943dd3130c5cd">PoolingPoolingConvention</a> </td>
<td class="paramname"><em>pooling_convention</em> = <code><a class="el" href="namespacemxnet_1_1cpp.html#abaf9ea614ede3210454943dd3130c5cda4d3576c37e6f03700bad4345238fffa0">PoolingPoolingConvention::kValid</a></code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> </td>
<td class="paramname"><em>stride</em> = <code><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>()</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> </td>
<td class="paramname"><em>pad</em> = <code><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>()</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">dmlc::optional&lt; int &gt; </td>
<td class="paramname"><em>p_value</em> = <code>dmlc::optional&lt;int&gt;()</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">dmlc::optional&lt; bool &gt; </td>
<td class="paramname"><em>count_include_pad</em> = <code>dmlc::optional&lt;bool&gt;()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Performs pooling on the input. </p><pre class="fragment">   The shapes for 1-D pooling are

   - **data**: *(batch_size, channel, width)*,
   - **out**: *(batch_size, num_filter, out_width)*.

   The shapes for 2-D pooling are

   - **data**: *(batch_size, channel, height, width)*
   - **out**: *(batch_size, num_filter, out_height, out_width)*, with::

   out_height = f(height, kernel[0], pad[0], stride[0])
   out_width = f(width, kernel[1], pad[1], stride[1])

   The definition of *f* depends on ``pooling_convention``, which has two options:

   - **valid** (default)::

   f(x, k, p, s) = floor((x+2*p-k)/s)+1

   - **full**, which is compatible with Caffe::

   f(x, k, p, s) = ceil((x+2*p-k)/s)+1

   But ``global_pool`` is set to be true, then do a global pooling, namely reset
   ``kernel=(height, width)``.

   Three pooling options are supported by ``pool_type``:

   - **avg**: average pooling
   - **max**: max pooling
   - **sum**: sum pooling
   - **lp**: Lp pooling

   For 3-D pooling, an additional *depth* dimension is added before
   *height*. Namely the input data will have shape *(batch_size, channel, depth,
   height, width)*.

   Notes on Lp pooling:

   Lp pooling was first introduced by this paper:
   L-1 pooling is simply sum pooling, while L-inf pooling is simply max pooling.
   We can see that Lp pooling stands between those two, in practice the most

   For each window ``X``, the mathematical expression for Lp pooling is:

   :math:`f(X) = \sqrt[p]{\sum_{x}^{X} x^p}`



   Defined in src/operator/nn/pooling.cc:L388
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>Input data to the pooling operator. </td></tr>
<tr><td class="paramname">kernel</td><td>Pooling kernel size: (y, x) or (d, y, x) </td></tr>
<tr><td class="paramname">pool_type</td><td>Pooling type to be applied. </td></tr>
<tr><td class="paramname">global_pool</td><td>Ignore kernel size, do global pooling based on current input </td></tr>
<tr><td class="paramname">cudnn_off</td><td>Turn off cudnn pooling and use MXNet pooling operator. </td></tr>
<tr><td class="paramname">pooling_convention</td><td>Pooling convention to be applied. </td></tr>
<tr><td class="paramname">stride</td><td>Stride: for pooling (y, x) or (d, y, x). Defaults to 1 for each </td></tr>
<tr><td class="paramname">pad</td><td>Pad for pooling: (y, x) or (d, y, x). Defaults to no padding. </td></tr>
<tr><td class="paramname">p_value</td><td>Value of p for Lp pooling, can be 1 or 2, required for Lp Pooling. </td></tr>
<tr><td class="paramname">count_include_pad</td><td>Only used for AvgPool, specify whether to count padding elements for averagecalculation. For example, with a 5*5 kernel on a 3*3 corner of a image,the sum of the 9 valid elements will be divided by 25 if this is set </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="ae29f3e882b99e31695e999819658c6aa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::Pooling_v1 </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> </td>
<td class="paramname"><em>kernel</em> = <code><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>()</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespacemxnet_1_1cpp.html#a7dc4e3b741dfffc9295e1f8fbcb51c2e">Pooling_v1PoolType</a> </td>
<td class="paramname"><em>pool_type</em> = <code><a class="el" href="namespacemxnet_1_1cpp.html#a44ef744b314acdba218a7405f56e00beaa0b1ac8aae6b1cfbbe89085c642b3b4b">Pooling_v1PoolType::kMax</a></code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>global_pool</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespacemxnet_1_1cpp.html#ac8e6f64dc9bca9d9388d34d5153cb094">Pooling_v1PoolingConvention</a> </td>
<td class="paramname"><em>pooling_convention</em> = <code><a class="el" href="namespacemxnet_1_1cpp.html#abaf9ea614ede3210454943dd3130c5cda4d3576c37e6f03700bad4345238fffa0">Pooling_v1PoolingConvention::kValid</a></code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> </td>
<td class="paramname"><em>stride</em> = <code><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>()</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> </td>
<td class="paramname"><em>pad</em> = <code><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>This operator is DEPRECATED. Perform pooling on the input.</p>
<p>The shapes for 2-D pooling is</p>
<ul>
<li><b>data</b>: *(batch_size, channel, height, width)*</li>
<li><b>out</b>: *(batch_size, num_filter, out_height, out_width)*, with::</li>
</ul>
<p>out_height = f(height, kernel[0], pad[0], stride[0]) out_width = f(width, kernel[1], pad[1], stride[1])</p>
<p>The definition of <em>f</em> depends on <code>pooling_convention</code>, which has two options:</p>
<ul>
<li><b>valid</b> (default)::</li>
</ul>
<p>f(x, k, p, s) = floor((x+2*p-k)/s)+1</p>
<ul>
<li><b>full</b>, which is compatible with Caffe::</li>
</ul>
<p>f(x, k, p, s) = ceil((x+2*p-k)/s)+1</p>
<p>But <code>global_pool</code> is set to be true, then do a global pooling, namely reset <code>kernel=(height, width)</code>.</p>
<p>Three pooling options are supported by <code>pool_type</code>:</p>
<ul>
<li><b>avg</b>: average pooling</li>
<li><b>max</b>: max pooling</li>
<li><b>sum</b>: sum pooling</li>
</ul>
<p>1-D pooling is special case of 2-D pooling with <em>weight=1</em> and <em>kernel[1]=1</em>.</p>
<p>For 3-D pooling, an additional <em>depth</em> dimension is added before <em>height</em>. Namely the input data will have shape *(batch_size, channel, depth, height, width)*.</p>
<pre class="fragment">   Defined in src/operator/pooling_v1.cc:L104
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>Input data to the pooling operator. </td></tr>
<tr><td class="paramname">kernel</td><td>pooling kernel size: (y, x) or (d, y, x) </td></tr>
<tr><td class="paramname">pool_type</td><td>Pooling type to be applied. </td></tr>
<tr><td class="paramname">global_pool</td><td>Ignore kernel size, do global pooling based on current input </td></tr>
<tr><td class="paramname">pooling_convention</td><td>Pooling convention to be applied. </td></tr>
<tr><td class="paramname">stride</td><td>stride: for pooling (y, x) or (d, y, x) </td></tr>
<tr><td class="paramname">pad</td><td>pad for pooling: (y, x) or (d, y, x) </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="acf4b40f6c651421d5af75362083290c5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::Pooling_v1 </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> </td>
<td class="paramname"><em>kernel</em> = <code><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>()</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespacemxnet_1_1cpp.html#a7dc4e3b741dfffc9295e1f8fbcb51c2e">Pooling_v1PoolType</a> </td>
<td class="paramname"><em>pool_type</em> = <code><a class="el" href="namespacemxnet_1_1cpp.html#a44ef744b314acdba218a7405f56e00beaa0b1ac8aae6b1cfbbe89085c642b3b4b">Pooling_v1PoolType::kMax</a></code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>global_pool</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespacemxnet_1_1cpp.html#ac8e6f64dc9bca9d9388d34d5153cb094">Pooling_v1PoolingConvention</a> </td>
<td class="paramname"><em>pooling_convention</em> = <code><a class="el" href="namespacemxnet_1_1cpp.html#abaf9ea614ede3210454943dd3130c5cda4d3576c37e6f03700bad4345238fffa0">Pooling_v1PoolingConvention::kValid</a></code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> </td>
<td class="paramname"><em>stride</em> = <code><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>()</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> </td>
<td class="paramname"><em>pad</em> = <code><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>This operator is DEPRECATED. Perform pooling on the input.</p>
<p>The shapes for 2-D pooling is</p>
<ul>
<li><b>data</b>: *(batch_size, channel, height, width)*</li>
<li><b>out</b>: *(batch_size, num_filter, out_height, out_width)*, with::</li>
</ul>
<p>out_height = f(height, kernel[0], pad[0], stride[0]) out_width = f(width, kernel[1], pad[1], stride[1])</p>
<p>The definition of <em>f</em> depends on <code>pooling_convention</code>, which has two options:</p>
<ul>
<li><b>valid</b> (default)::</li>
</ul>
<p>f(x, k, p, s) = floor((x+2*p-k)/s)+1</p>
<ul>
<li><b>full</b>, which is compatible with Caffe::</li>
</ul>
<p>f(x, k, p, s) = ceil((x+2*p-k)/s)+1</p>
<p>But <code>global_pool</code> is set to be true, then do a global pooling, namely reset <code>kernel=(height, width)</code>.</p>
<p>Three pooling options are supported by <code>pool_type</code>:</p>
<ul>
<li><b>avg</b>: average pooling</li>
<li><b>max</b>: max pooling</li>
<li><b>sum</b>: sum pooling</li>
</ul>
<p>1-D pooling is special case of 2-D pooling with <em>weight=1</em> and <em>kernel[1]=1</em>.</p>
<p>For 3-D pooling, an additional <em>depth</em> dimension is added before <em>height</em>. Namely the input data will have shape *(batch_size, channel, depth, height, width)*.</p>
<pre class="fragment">   Defined in src/operator/pooling_v1.cc:L104
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>Input data to the pooling operator. </td></tr>
<tr><td class="paramname">kernel</td><td>pooling kernel size: (y, x) or (d, y, x) </td></tr>
<tr><td class="paramname">pool_type</td><td>Pooling type to be applied. </td></tr>
<tr><td class="paramname">global_pool</td><td>Ignore kernel size, do global pooling based on current input </td></tr>
<tr><td class="paramname">pooling_convention</td><td>Pooling convention to be applied. </td></tr>
<tr><td class="paramname">stride</td><td>stride: for pooling (y, x) or (d, y, x) </td></tr>
<tr><td class="paramname">pad</td><td>pad for pooling: (y, x) or (d, y, x) </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="af84dd35dd17a1675a342c52708da9902"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::prod </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">dmlc::optional&lt; <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> &gt; </td>
<td class="paramname"><em>axis</em> = <code>dmlc::optional&lt;<a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>&gt;()</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>keepdims</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>exclude</em> = <code>false</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Computes the product of array elements over given axes. </p><pre class="fragment">   Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L146
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>The input </td></tr>
<tr><td class="paramname">axis</td><td>The axis or axes along which to perform the reduction. <pre class="fragment">   The default, `axis=()`, will compute over all elements into a
   scalar array with shape `(1,)`.

   If `axis` is int, a reduction is performed on a particular axis.

   If `axis` is a tuple of ints, a reduction is performed on all the axes
   specified in the tuple.

   If `exclude` is true, reduction will be performed on the axes that are
   NOT in axis instead.

   Negative values means indexing from right to left.
</pre> </td></tr>
<tr><td class="paramname">keepdims</td><td>If this is set to <code>True</code>, the reduced axes are left in the result as </td></tr>
<tr><td class="paramname">exclude</td><td>Whether to perform reduction on axis that are NOT in axis instead. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a561746f1a9bf11e5e3c488248cd73973"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::prod </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">dmlc::optional&lt; <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> &gt; </td>
<td class="paramname"><em>axis</em> = <code>dmlc::optional&lt;<a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>&gt;()</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>keepdims</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>exclude</em> = <code>false</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Computes the product of array elements over given axes. </p><pre class="fragment">   Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L146
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>The input </td></tr>
<tr><td class="paramname">axis</td><td>The axis or axes along which to perform the reduction. <pre class="fragment">   The default, `axis=()`, will compute over all elements into a
   scalar array with shape `(1,)`.

   If `axis` is int, a reduction is performed on a particular axis.

   If `axis` is a tuple of ints, a reduction is performed on all the axes
   specified in the tuple.

   If `exclude` is true, reduction will be performed on the axes that are
   NOT in axis instead.

   Negative values means indexing from right to left.
</pre> </td></tr>
<tr><td class="paramname">keepdims</td><td>If this is set to <code>True</code>, the reduced axes are left in the result as </td></tr>
<tr><td class="paramname">exclude</td><td>Whether to perform reduction on axis that are NOT in axis instead. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a413e3d0f2b11b02be475cab94cfb2fa1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::radians </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Converts each element of the input array from degrees to radians. </p><pre class="fragment">   .. math::
   radians([0, 90, 180, 270, 360]) = [0, \pi/2, \pi, 3\pi/2, 2\pi]

   The storage type of ``radians`` output depends upon the input storage type:

   - radians(default) = default
   - radians(row_sparse) = row_sparse
   - radians(csr) = csr



   Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L182
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>The input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a2d8acb8fde9c8865b0aa5b869ed2e16b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::radians </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Converts each element of the input array from degrees to radians. </p><pre class="fragment">   .. math::
   radians([0, 90, 180, 270, 360]) = [0, \pi/2, \pi, 3\pi/2, 2\pi]

   The storage type of ``radians`` output depends upon the input storage type:

   - radians(default) = default
   - radians(row_sparse) = row_sparse
   - radians(csr) = csr



   Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L182
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>The input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a972e0dadef2c71b91dc3685789d94ab4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::rcbrt </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns element-wise inverse cube-root value of the input. </p><pre class="fragment">   .. math::
   rcbrt(x) = 1/\sqrt[3]{x}

   Example::

   rcbrt([1,8,-125]) = [1.0, 0.5, -0.2]



   Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L906
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>The input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a758557e50929ad4a53c1d05f8e7b1afa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::rcbrt </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns element-wise inverse cube-root value of the input. </p><pre class="fragment">   .. math::
   rcbrt(x) = 1/\sqrt[3]{x}

   Example::

   rcbrt([1,8,-125]) = [1.0, 0.5, -0.2]



   Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L906
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>The input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="ab66c850dfcfb6313bac6e13c24107fde"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::reciprocal </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns the reciprocal of the argument, element-wise. </p><pre class="fragment">   Calculates 1/x.

   Example::

   reciprocal([-2, 1, 3, 1.6, 0.2]) = [-0.5, 1.0, 0.33333334, 0.625, 5.0]



   Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L646
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>The input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a370fe4b2e23600010dc3ad531b109769"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::reciprocal </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns the reciprocal of the argument, element-wise. </p><pre class="fragment">   Calculates 1/x.

   Example::

   reciprocal([-2, 1, 3, 1.6, 0.2]) = [-0.5, 1.0, 0.33333334, 0.625, 5.0]



   Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L646
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>The input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="af8a5a31dd642ff81cca32b096b1f4c9d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::relu </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Computes rectified linear. </p><pre class="fragment">   .. math::
   max(features, 0)

   The storage type of ``relu`` output depends upon the input storage type:

   - relu(default) = default
   - relu(row_sparse) = row_sparse
   - relu(csr) = csr



   Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L85
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>The input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a7b4c34e40a23912627b965bbc00131f0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::relu </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Computes rectified linear. </p><pre class="fragment">   .. math::
   max(features, 0)

   The storage type of ``relu`` output depends upon the input storage type:

   - relu(default) = default
   - relu(row_sparse) = row_sparse
   - relu(csr) = csr



   Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L85
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>The input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a4653aa86f2c35187bd9d4f152e1ab253"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::repeat </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>repeats</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">dmlc::optional&lt; int &gt; </td>
<td class="paramname"><em>axis</em> = <code>dmlc::optional&lt;int&gt;()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Repeats elements of an array. </p><pre class="fragment">   By default, ``repeat`` flattens the input array into 1-D and then repeats the
   elements::

   x = [[ 1, 2],
   [ 3, 4]]

   repeat(x, repeats=2) = [ 1.,  1.,  2.,  2.,  3.,  3.,  4.,  4.]

   The parameter ``axis`` specifies the axis along which to perform repeat::

   repeat(x, repeats=2, axis=1) = [[ 1.,  1.,  2.,  2.],
   [ 3.,  3.,  4.,  4.]]

   repeat(x, repeats=2, axis=0) = [[ 1.,  2.],
   [ 1.,  2.],
   [ 3.,  4.],
   [ 3.,  4.]]

   repeat(x, repeats=2, axis=-1) = [[ 1.,  1.,  2.,  2.],
   [ 3.,  3.,  4.,  4.]]



   Defined in src/operator/tensor/matrix_op.cc:L691
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>Input data array </td></tr>
<tr><td class="paramname">repeats</td><td>The number of repetitions for each element. </td></tr>
<tr><td class="paramname">axis</td><td>The axis along which to repeat values. The negative numbers are interpreted counting from the backward. By default, use the flattened input </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a9fc591da8cc66efbc5a9730c4595b8c2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::repeat </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>repeats</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">dmlc::optional&lt; int &gt; </td>
<td class="paramname"><em>axis</em> = <code>dmlc::optional&lt;int&gt;()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Repeats elements of an array. </p><pre class="fragment">   By default, ``repeat`` flattens the input array into 1-D and then repeats the
   elements::

   x = [[ 1, 2],
   [ 3, 4]]

   repeat(x, repeats=2) = [ 1.,  1.,  2.,  2.,  3.,  3.,  4.,  4.]

   The parameter ``axis`` specifies the axis along which to perform repeat::

   repeat(x, repeats=2, axis=1) = [[ 1.,  1.,  2.,  2.],
   [ 3.,  3.,  4.,  4.]]

   repeat(x, repeats=2, axis=0) = [[ 1.,  2.],
   [ 1.,  2.],
   [ 3.,  4.],
   [ 3.,  4.]]

   repeat(x, repeats=2, axis=-1) = [[ 1.,  1.,  2.,  2.],
   [ 3.,  3.,  4.,  4.]]



   Defined in src/operator/tensor/matrix_op.cc:L691
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>Input data array </td></tr>
<tr><td class="paramname">repeats</td><td>The number of repetitions for each element. </td></tr>
<tr><td class="paramname">axis</td><td>The axis along which to repeat values. The negative numbers are interpreted counting from the backward. By default, use the flattened input </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a7b26f5f8ccd20fe25f32d7fd18888c5b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::Reshape </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> </td>
<td class="paramname"><em>shape</em> = <code><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>()</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>reverse</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> </td>
<td class="paramname"><em>target_shape</em> = <code><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>()</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>keep_highest</em> = <code>false</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Reshapes the input array. </p><pre class="fragment">   .. note:: ``Reshape`` is deprecated, use ``reshape``

   Given an array and a shape, this function returns a copy of the array in the
   The shape is a tuple of integers such as (2,3,4). The size of the new shape

   Example::

   reshape([1,2,3,4], shape=(2,2)) = [[1,2], [3,4]]

   Some dimensions of the shape can take special values from the set {0, -1, -2,

   - ``0``  copy this dimension from the input to the output shape.

   Example::

   - input shape = (2,3,4), shape = (4,0,2), output shape = (4,3,2)
   - input shape = (2,3,4), shape = (2,0,0), output shape = (2,3,4)

   - ``-1`` infers the dimension of the output shape by using the remainder of the
   keeping the size of the new array same as that of the input array.
   At most one dimension of shape can be -1.

   Example::

   - input shape = (2,3,4), shape = (6,1,-1), output shape = (6,1,4)
   - input shape = (2,3,4), shape = (3,-1,8), output shape = (3,1,8)
   - input shape = (2,3,4), shape=(-1,), output shape = (24,)

   - ``-2`` copy all/remainder of the input dimensions to the output shape.

   Example::

   - input shape = (2,3,4), shape = (-2,), output shape = (2,3,4)
   - input shape = (2,3,4), shape = (2,-2), output shape = (2,3,4)
   - input shape = (2,3,4), shape = (-2,1,1), output shape = (2,3,4,1,1)

   - ``-3`` use the product of two consecutive dimensions of the input shape as

   Example::

   - input shape = (2,3,4), shape = (-3,4), output shape = (6,4)
   - input shape = (2,3,4,5), shape = (-3,-3), output shape = (6,20)
   - input shape = (2,3,4), shape = (0,-3), output shape = (2,12)
   - input shape = (2,3,4), shape = (-3,-2), output shape = (6,4)

   - ``-4`` split one dimension of the input into two dimensions passed subsequent

   Example::

   - input shape = (2,3,4), shape = (-4,1,2,-2), output shape =(1,2,3,4)
   - input shape = (2,3,4), shape = (2,-4,-1,3,-2), output shape = (2,1,3,4)

   If the argument `reverse` is set to 1, then the special values are inferred

   Example::

   - without reverse=1, for input shape = (10,5,4), shape = (-1,0), output shape
   - with reverse=1, output shape will be (50,4).



   Defined in src/operator/tensor/matrix_op.cc:L169
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>Input data to reshape. </td></tr>
<tr><td class="paramname">shape</td><td>The target shape </td></tr>
<tr><td class="paramname">reverse</td><td>If true then the special values are inferred from right to left </td></tr>
<tr><td class="paramname">target_shape</td><td>(Deprecated! Use <code>shape</code> instead.) Target new shape. <a class="el" href="classmxnet_1_1cpp_1_1One.html">One</a> and </td></tr>
<tr><td class="paramname">keep_highest</td><td>(Deprecated! Use <code>shape</code> instead.) Whether keep the highest dim unchanged.If set to true, then the first dim in target_shape is ignored,and </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a2d6a926184549a62111ec07592575471"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::Reshape </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> </td>
<td class="paramname"><em>shape</em> = <code><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>()</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>reverse</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> </td>
<td class="paramname"><em>target_shape</em> = <code><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>()</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>keep_highest</em> = <code>false</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Reshapes the input array. </p><pre class="fragment">   .. note:: ``Reshape`` is deprecated, use ``reshape``

   Given an array and a shape, this function returns a copy of the array in the
   The shape is a tuple of integers such as (2,3,4). The size of the new shape

   Example::

   reshape([1,2,3,4], shape=(2,2)) = [[1,2], [3,4]]

   Some dimensions of the shape can take special values from the set {0, -1, -2,

   - ``0``  copy this dimension from the input to the output shape.

   Example::

   - input shape = (2,3,4), shape = (4,0,2), output shape = (4,3,2)
   - input shape = (2,3,4), shape = (2,0,0), output shape = (2,3,4)

   - ``-1`` infers the dimension of the output shape by using the remainder of the
   keeping the size of the new array same as that of the input array.
   At most one dimension of shape can be -1.

   Example::

   - input shape = (2,3,4), shape = (6,1,-1), output shape = (6,1,4)
   - input shape = (2,3,4), shape = (3,-1,8), output shape = (3,1,8)
   - input shape = (2,3,4), shape=(-1,), output shape = (24,)

   - ``-2`` copy all/remainder of the input dimensions to the output shape.

   Example::

   - input shape = (2,3,4), shape = (-2,), output shape = (2,3,4)
   - input shape = (2,3,4), shape = (2,-2), output shape = (2,3,4)
   - input shape = (2,3,4), shape = (-2,1,1), output shape = (2,3,4,1,1)

   - ``-3`` use the product of two consecutive dimensions of the input shape as

   Example::

   - input shape = (2,3,4), shape = (-3,4), output shape = (6,4)
   - input shape = (2,3,4,5), shape = (-3,-3), output shape = (6,20)
   - input shape = (2,3,4), shape = (0,-3), output shape = (2,12)
   - input shape = (2,3,4), shape = (-3,-2), output shape = (6,4)

   - ``-4`` split one dimension of the input into two dimensions passed subsequent

   Example::

   - input shape = (2,3,4), shape = (-4,1,2,-2), output shape =(1,2,3,4)
   - input shape = (2,3,4), shape = (2,-4,-1,3,-2), output shape = (2,1,3,4)

   If the argument `reverse` is set to 1, then the special values are inferred

   Example::

   - without reverse=1, for input shape = (10,5,4), shape = (-1,0), output shape
   - with reverse=1, output shape will be (50,4).



   Defined in src/operator/tensor/matrix_op.cc:L169
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>Input data to reshape. </td></tr>
<tr><td class="paramname">shape</td><td>The target shape </td></tr>
<tr><td class="paramname">reverse</td><td>If true then the special values are inferred from right to left </td></tr>
<tr><td class="paramname">target_shape</td><td>(Deprecated! Use <code>shape</code> instead.) Target new shape. <a class="el" href="classmxnet_1_1cpp_1_1One.html">One</a> and </td></tr>
<tr><td class="paramname">keep_highest</td><td>(Deprecated! Use <code>shape</code> instead.) Whether keep the highest dim unchanged.If set to true, then the first dim in target_shape is ignored,and </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="af32748021b75072cf7a18fc19306ff8f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::reshape_like </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>rhs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Reshape some or all dimensions of <code>lhs</code> to have the same shape as some or all </p><pre class="fragment">   Returns a **view** of the `lhs` array with a new shape without altering any

   Example::

   x = [1, 2, 3, 4, 5, 6]
   y = [[0, -4], [3, 2], [2, 2]]
   reshape_like(x, y) = [[1, 2], [3, 4], [5, 6]]

   More precise control over how dimensions are inherited is achieved by
   slices over the `lhs` and `rhs` array dimensions. Only the sliced `lhs`
   are reshaped to the `rhs` sliced dimensions, with the non-sliced `lhs`

   Examples::

   - lhs shape = (30,7), rhs shape = (15,2,4), lhs_begin=0, lhs_end=1,
   - lhs shape = (3, 5), rhs shape = (1,15,4), lhs_begin=0, lhs_end=2,

   Negative indices are supported, and `None` can be used for either `lhs_end` or

   Example::

   - lhs shape = (30, 12), rhs shape = (4, 2, 2, 3), lhs_begin=-1, lhs_end=None,



   Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L453
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">lhs</td><td>First input. </td></tr>
<tr><td class="paramname">rhs</td><td>Second input. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a91e7e87913992cb4bd413c3ab6a3a2fa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::reshape_like </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>rhs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Reshape some or all dimensions of <code>lhs</code> to have the same shape as some or all </p><pre class="fragment">   Returns a **view** of the `lhs` array with a new shape without altering any

   Example::

   x = [1, 2, 3, 4, 5, 6]
   y = [[0, -4], [3, 2], [2, 2]]
   reshape_like(x, y) = [[1, 2], [3, 4], [5, 6]]

   More precise control over how dimensions are inherited is achieved by
   slices over the `lhs` and `rhs` array dimensions. Only the sliced `lhs`
   are reshaped to the `rhs` sliced dimensions, with the non-sliced `lhs`

   Examples::

   - lhs shape = (30,7), rhs shape = (15,2,4), lhs_begin=0, lhs_end=1,
   - lhs shape = (3, 5), rhs shape = (1,15,4), lhs_begin=0, lhs_end=2,

   Negative indices are supported, and `None` can be used for either `lhs_end` or

   Example::

   - lhs shape = (30, 12), rhs shape = (4, 2, 2, 3), lhs_begin=-1, lhs_end=None,



   Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L453
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">lhs</td><td>First input. </td></tr>
<tr><td class="paramname">rhs</td><td>Second input. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a76348d0263ce3ff577c3bf7333674160"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::reverse </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> </td>
<td class="paramname"><em>axis</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Reverses the order of elements along given axis while preserving array shape. </p><pre class="fragment">   Note: reverse and flip are equivalent. We use reverse in the following examples.

   Examples::

   x = [[ 0.,  1.,  2.,  3.,  4.],
   [ 5.,  6.,  7.,  8.,  9.]]

   reverse(x, axis=0) = [[ 5.,  6.,  7.,  8.,  9.],
   [ 0.,  1.,  2.,  3.,  4.]]

   reverse(x, axis=1) = [[ 4.,  3.,  2.,  1.,  0.],
   [ 9.,  8.,  7.,  6.,  5.]]


   Defined in src/operator/tensor/matrix_op.cc:L793
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>Input data array </td></tr>
<tr><td class="paramname">axis</td><td>The axis which to reverse elements. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="acede888b37e618502b093e8ebbcdd255"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::reverse </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> </td>
<td class="paramname"><em>axis</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Reverses the order of elements along given axis while preserving array shape. </p><pre class="fragment">   Note: reverse and flip are equivalent. We use reverse in the following examples.

   Examples::

   x = [[ 0.,  1.,  2.,  3.,  4.],
   [ 5.,  6.,  7.,  8.,  9.]]

   reverse(x, axis=0) = [[ 5.,  6.,  7.,  8.,  9.],
   [ 0.,  1.,  2.,  3.,  4.]]

   reverse(x, axis=1) = [[ 4.,  3.,  2.,  1.,  0.],
   [ 9.,  8.,  7.,  6.,  5.]]


   Defined in src/operator/tensor/matrix_op.cc:L793
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>Input data array </td></tr>
<tr><td class="paramname">axis</td><td>The axis which to reverse elements. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a46ec41d23cb8ec65c75cbca9ac3f1e04"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::rint </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns element-wise rounded value to the nearest integer of the input. </p><pre class="fragment">   .. note::
   - For input ``n.5`` ``rint`` returns ``n`` while ``round`` returns ``n+1``.
   - For input ``-n.5`` both ``rint`` and ``round`` returns ``-n-1``.

   Example::

   rint([-1.5, 1.5, -1.9, 1.9, 2.1]) = [-2.,  1., -2.,  2.,  2.]

   The storage type of ``rint`` output depends upon the input storage type:

   - rint(default) = default
   - rint(row_sparse) = row_sparse
   - rint(csr) = csr



   Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L727
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>The input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="ac3efddb7a6385fdb48afd9978f24225e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::rint </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns element-wise rounded value to the nearest integer of the input. </p><pre class="fragment">   .. note::
   - For input ``n.5`` ``rint`` returns ``n`` while ``round`` returns ``n+1``.
   - For input ``-n.5`` both ``rint`` and ``round`` returns ``-n-1``.

   Example::

   rint([-1.5, 1.5, -1.9, 1.9, 2.1]) = [-2.,  1., -2.,  2.,  2.]

   The storage type of ``rint`` output depends upon the input storage type:

   - rint(default) = default
   - rint(row_sparse) = row_sparse
   - rint(csr) = csr



   Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L727
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>The input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a7a41621e2256fb5d94ed5b5221a6db8f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::rmsprop_update </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>weight</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>grad</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>n</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>lr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>gamma1</em> = <code>0.95</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>epsilon</em> = <code>1e-08</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>wd</em> = <code>0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>rescale_grad</em> = <code>1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>clip_gradient</em> = <code>-1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>clip_weights</em> = <code>-1</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Update function for <code>RMSProp</code> optimizer. </p><pre class="fragment">   `RMSprop` is a variant of stochastic gradient descent where the gradients are
   divided by a cache which grows with the sum of squares of recent gradients?

   `RMSProp` is similar to `AdaGrad`, a popular variant of `SGD` which adaptively
   tunes the learning rate of each parameter. `AdaGrad` lowers the learning rate
   each parameter monotonically over the course of training.
   While this is analytically motivated for convex optimizations, it may not be
   for non-convex problems. `RMSProp` deals with this heuristically by allowing the
   learning rates to rebound as the denominator decays over time.

   Define the Root Mean Square (RMS) error criterion of the gradient as
   :math:`RMS[g]_t = \sqrt{E[g^2]_t + \epsilon}`, where :math:`g` represents
   gradient and :math:`E[g^2]_t` is the decaying average over past squared

   The :math:`E[g^2]_t` is given by:

   .. math::
   E[g^2]_t = \gamma * E[g^2]_{t-1} + (1-\gamma) * g_t^2

   The update step is

   .. math::
   \theta_{t+1} = \theta_t - \frac{\eta}{RMS[g]_t} g_t

   The RMSProp code follows the version in
   http://www.cs.toronto.edu/~tijmen/csc321/slides/lecture_slides_lec6.pdf
   Tieleman &amp; Hinton, 2012.

   Hinton suggests the momentum term :math:`\gamma` to be 0.9 and the learning rate
   :math:`\eta` to be 0.001.



   Defined in src/operator/optimizer_op.cc:L553
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">weight</td><td>Weight </td></tr>
<tr><td class="paramname">grad</td><td>Gradient </td></tr>
<tr><td class="paramname">n</td><td>n </td></tr>
<tr><td class="paramname">lr</td><td>Learning rate </td></tr>
<tr><td class="paramname">gamma1</td><td>The decay rate of momentum estimates. </td></tr>
<tr><td class="paramname">epsilon</td><td>A small constant for numerical stability. </td></tr>
<tr><td class="paramname">wd</td><td>Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of </td></tr>
<tr><td class="paramname">rescale_grad</td><td>Rescale gradient to grad = rescale_grad*grad. </td></tr>
<tr><td class="paramname">clip_gradient</td><td>Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, </td></tr>
<tr><td class="paramname">clip_weights</td><td>Clip weights to the range of [-clip_weights, clip_weights] If clip_weights &lt;= 0, weight clipping is turned off. weights = max(min(weights, </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a7f932eae14c6a0d1f2f76ee06990a0d0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::rmsprop_update </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>weight</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>grad</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>n</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>lr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>gamma1</em> = <code>0.95</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>epsilon</em> = <code>1e-08</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>wd</em> = <code>0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>rescale_grad</em> = <code>1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>clip_gradient</em> = <code>-1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>clip_weights</em> = <code>-1</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Update function for <code>RMSProp</code> optimizer. </p><pre class="fragment">   `RMSprop` is a variant of stochastic gradient descent where the gradients are
   divided by a cache which grows with the sum of squares of recent gradients?

   `RMSProp` is similar to `AdaGrad`, a popular variant of `SGD` which adaptively
   tunes the learning rate of each parameter. `AdaGrad` lowers the learning rate
   each parameter monotonically over the course of training.
   While this is analytically motivated for convex optimizations, it may not be
   for non-convex problems. `RMSProp` deals with this heuristically by allowing the
   learning rates to rebound as the denominator decays over time.

   Define the Root Mean Square (RMS) error criterion of the gradient as
   :math:`RMS[g]_t = \sqrt{E[g^2]_t + \epsilon}`, where :math:`g` represents
   gradient and :math:`E[g^2]_t` is the decaying average over past squared

   The :math:`E[g^2]_t` is given by:

   .. math::
   E[g^2]_t = \gamma * E[g^2]_{t-1} + (1-\gamma) * g_t^2

   The update step is

   .. math::
   \theta_{t+1} = \theta_t - \frac{\eta}{RMS[g]_t} g_t

   The RMSProp code follows the version in
   http://www.cs.toronto.edu/~tijmen/csc321/slides/lecture_slides_lec6.pdf
   Tieleman &amp; Hinton, 2012.

   Hinton suggests the momentum term :math:`\gamma` to be 0.9 and the learning rate
   :math:`\eta` to be 0.001.



   Defined in src/operator/optimizer_op.cc:L553
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">weight</td><td>Weight </td></tr>
<tr><td class="paramname">grad</td><td>Gradient </td></tr>
<tr><td class="paramname">n</td><td>n </td></tr>
<tr><td class="paramname">lr</td><td>Learning rate </td></tr>
<tr><td class="paramname">gamma1</td><td>The decay rate of momentum estimates. </td></tr>
<tr><td class="paramname">epsilon</td><td>A small constant for numerical stability. </td></tr>
<tr><td class="paramname">wd</td><td>Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of </td></tr>
<tr><td class="paramname">rescale_grad</td><td>Rescale gradient to grad = rescale_grad*grad. </td></tr>
<tr><td class="paramname">clip_gradient</td><td>Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, </td></tr>
<tr><td class="paramname">clip_weights</td><td>Clip weights to the range of [-clip_weights, clip_weights] If clip_weights &lt;= 0, weight clipping is turned off. weights = max(min(weights, </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="aef74bbe21576cee5e6d567b84e613a70"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::rmspropalex_update </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>weight</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>grad</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>n</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>g</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>delta</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>lr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>gamma1</em> = <code>0.95</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>gamma2</em> = <code>0.9</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>epsilon</em> = <code>1e-08</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>wd</em> = <code>0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>rescale_grad</em> = <code>1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>clip_gradient</em> = <code>-1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>clip_weights</em> = <code>-1</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Update function for RMSPropAlex optimizer. </p><pre class="fragment">   `RMSPropAlex` is non-centered version of `RMSProp`.

   Define :math:`E[g^2]_t` is the decaying average over past squared gradient and
   :math:`E[g]_t` is the decaying average over past gradient.

   .. math::
   E[g^2]_t = \gamma_1 * E[g^2]_{t-1} + (1 - \gamma_1) * g_t^2\\
   E[g]_t = \gamma_1 * E[g]_{t-1} + (1 - \gamma_1) * g_t\\
   \Delta_t = \gamma_2 * \Delta_{t-1} - \frac{\eta}{\sqrt{E[g^2]_t - E[g]_t^2 +

   The update step is

   .. math::
   \theta_{t+1} = \theta_t + \Delta_t

   The RMSPropAlex code follows the version in
   http://arxiv.org/pdf/1308.0850v5.pdf Eq(38) - Eq(45) by Alex Graves, 2013.

   Graves suggests the momentum term :math:`\gamma_1` to be 0.95, :math:`\gamma_2`
   to be 0.9 and the learning rate :math:`\eta` to be 0.0001.


   Defined in src/operator/optimizer_op.cc:L592
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">weight</td><td>Weight </td></tr>
<tr><td class="paramname">grad</td><td>Gradient </td></tr>
<tr><td class="paramname">n</td><td>n </td></tr>
<tr><td class="paramname">g</td><td>g </td></tr>
<tr><td class="paramname">delta</td><td>delta </td></tr>
<tr><td class="paramname">lr</td><td>Learning rate </td></tr>
<tr><td class="paramname">gamma1</td><td>Decay rate. </td></tr>
<tr><td class="paramname">gamma2</td><td>Decay rate. </td></tr>
<tr><td class="paramname">epsilon</td><td>A small constant for numerical stability. </td></tr>
<tr><td class="paramname">wd</td><td>Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of </td></tr>
<tr><td class="paramname">rescale_grad</td><td>Rescale gradient to grad = rescale_grad*grad. </td></tr>
<tr><td class="paramname">clip_gradient</td><td>Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, </td></tr>
<tr><td class="paramname">clip_weights</td><td>Clip weights to the range of [-clip_weights, clip_weights] If clip_weights &lt;= 0, weight clipping is turned off. weights = max(min(weights, </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a3c19fd898bed06f082d7086826b01c7c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::rmspropalex_update </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>weight</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>grad</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>n</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>g</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>delta</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>lr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>gamma1</em> = <code>0.95</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>gamma2</em> = <code>0.9</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>epsilon</em> = <code>1e-08</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>wd</em> = <code>0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>rescale_grad</em> = <code>1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>clip_gradient</em> = <code>-1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>clip_weights</em> = <code>-1</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Update function for RMSPropAlex optimizer. </p><pre class="fragment">   `RMSPropAlex` is non-centered version of `RMSProp`.

   Define :math:`E[g^2]_t` is the decaying average over past squared gradient and
   :math:`E[g]_t` is the decaying average over past gradient.

   .. math::
   E[g^2]_t = \gamma_1 * E[g^2]_{t-1} + (1 - \gamma_1) * g_t^2\\
   E[g]_t = \gamma_1 * E[g]_{t-1} + (1 - \gamma_1) * g_t\\
   \Delta_t = \gamma_2 * \Delta_{t-1} - \frac{\eta}{\sqrt{E[g^2]_t - E[g]_t^2 +

   The update step is

   .. math::
   \theta_{t+1} = \theta_t + \Delta_t

   The RMSPropAlex code follows the version in
   http://arxiv.org/pdf/1308.0850v5.pdf Eq(38) - Eq(45) by Alex Graves, 2013.

   Graves suggests the momentum term :math:`\gamma_1` to be 0.95, :math:`\gamma_2`
   to be 0.9 and the learning rate :math:`\eta` to be 0.0001.


   Defined in src/operator/optimizer_op.cc:L592
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">weight</td><td>Weight </td></tr>
<tr><td class="paramname">grad</td><td>Gradient </td></tr>
<tr><td class="paramname">n</td><td>n </td></tr>
<tr><td class="paramname">g</td><td>g </td></tr>
<tr><td class="paramname">delta</td><td>delta </td></tr>
<tr><td class="paramname">lr</td><td>Learning rate </td></tr>
<tr><td class="paramname">gamma1</td><td>Decay rate. </td></tr>
<tr><td class="paramname">gamma2</td><td>Decay rate. </td></tr>
<tr><td class="paramname">epsilon</td><td>A small constant for numerical stability. </td></tr>
<tr><td class="paramname">wd</td><td>Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of </td></tr>
<tr><td class="paramname">rescale_grad</td><td>Rescale gradient to grad = rescale_grad*grad. </td></tr>
<tr><td class="paramname">clip_gradient</td><td>Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, </td></tr>
<tr><td class="paramname">clip_weights</td><td>Clip weights to the range of [-clip_weights, clip_weights] If clip_weights &lt;= 0, weight clipping is turned off. weights = max(min(weights, </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a3124c45d4c48a007d773a35168733a37"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::RNN </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>parameters</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>state</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>state_cell</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint32_t </td>
<td class="paramname"><em>state_size</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint32_t </td>
<td class="paramname"><em>num_layers</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespacemxnet_1_1cpp.html#ae39119fed3c83726a0a2ea89b506661d">RNNMode</a> </td>
<td class="paramname"><em>mode</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>bidirectional</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>p</em> = <code>0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>state_outputs</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">dmlc::optional&lt; int &gt; </td>
<td class="paramname"><em>projection_size</em> = <code>dmlc::optional&lt;int&gt;()</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">dmlc::optional&lt; double &gt; </td>
<td class="paramname"><em>lstm_state_clip_min</em> = <code>dmlc::optional&lt;double&gt;()</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">dmlc::optional&lt; double &gt; </td>
<td class="paramname"><em>lstm_state_clip_max</em> = <code>dmlc::optional&lt;double&gt;()</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>lstm_state_clip_nan</em> = <code>false</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Applies recurrent layers to input data. Currently, vanilla RNN, LSTM and GRU are implemented, with both multi-layer and bidirectional support.</p>
<p><b>Vanilla RNN</b></p>
<p>Applies a single-gate recurrent layer to input X. Two kinds of activation ReLU and Tanh.</p>
<p>With ReLU activation function:</p>
<p>.. math:: h_t = relu(W_{ih} * x_t + b_{ih} + W_{hh} * h_{(t-1)} + b_{hh})</p>
<p>With Tanh activtion function:</p>
<p>.. math:: h_t = (W_{ih} * x_t + b_{ih} + W_{hh} * h_{(t-1)} + b_{hh})</p>
<p>Reference paper: Finding structure in time - Elman, 1988. <a href="https://crl.ucsd.edu/~elman/Papers/fsit.pdf">https://crl.ucsd.edu/~elman/Papers/fsit.pdf</a></p>
<p><b>LSTM</b></p>
<p>Long Short-Term Memory - Hochreiter, 1997.</p>
<p>.. math:: {array}{ll} i_t = {sigmoid}(W_{ii} x_t + b_{ii} + W_{hi} h_{(t-1)} + b_{hi}) \ f_t = {sigmoid}(W_{if} x_t + b_{if} + W_{hf} h_{(t-1)} + b_{hf}) \ g_t = (W_{ig} x_t + b_{ig} + W_{hc} h_{(t-1)} + b_{hg}) \ o_t = {sigmoid}(W_{io} x_t + b_{io} + W_{ho} h_{(t-1)} + b_{ho}) \ c_t = f_t * c_{(t-1)} + i_t * g_t \ h_t = o_t * (c_t) {array}</p>
<p><b>GRU</b></p>
<p>Gated Recurrent Unit - Cho et al. 2014. <a href="http://arxiv.org/abs/1406.1078">http://arxiv.org/abs/1406.1078</a></p>
<p>The definition of GRU here is slightly different from paper but compatible with</p>
<p>.. math:: {array}{ll} r_t = {sigmoid}(W_{ir} x_t + b_{ir} + W_{hr} h_{(t-1)} + b_{hr}) \ z_t = {sigmoid}(W_{iz} x_t + b_{iz} + W_{hz} h_{(t-1)} + b_{hz}) \ n_t = (W_{in} x_t + b_{in} + r_t * (W_{hn} h_{(t-1)}+ b_{hn})) \ h_t = (1 - z_t) * n_t + z_t * h_{(t-1)} \ {array} </p><dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>Input data to RNN </td></tr>
<tr><td class="paramname">parameters</td><td>Vector of all RNN trainable parameters concatenated </td></tr>
<tr><td class="paramname">state</td><td>initial hidden state of the RNN </td></tr>
<tr><td class="paramname">state_cell</td><td>initial cell state for LSTM networks (only for LSTM) </td></tr>
<tr><td class="paramname">state_size</td><td>size of the state for each layer </td></tr>
<tr><td class="paramname">num_layers</td><td>number of stacked layers </td></tr>
<tr><td class="paramname">mode</td><td>the type of RNN to compute </td></tr>
<tr><td class="paramname">bidirectional</td><td>whether to use bidirectional recurrent layers </td></tr>
<tr><td class="paramname">p</td><td>drop rate of the dropout on the outputs of each RNN layer, except the last </td></tr>
<tr><td class="paramname">state_outputs</td><td>Whether to have the states as symbol outputs. </td></tr>
<tr><td class="paramname">projection_size</td><td>size of project size </td></tr>
<tr><td class="paramname">lstm_state_clip_min</td><td>Minimum clip value of LSTM states. This option must be used </td></tr>
<tr><td class="paramname">lstm_state_clip_max</td><td>Maximum clip value of LSTM states. This option must be used </td></tr>
<tr><td class="paramname">lstm_state_clip_nan</td><td>Whether to stop NaN from propagating in state by clipping </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a3406b9c4299950f15689fd7e0b9f475e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::RNN </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>parameters</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>state</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>state_cell</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint32_t </td>
<td class="paramname"><em>state_size</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint32_t </td>
<td class="paramname"><em>num_layers</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespacemxnet_1_1cpp.html#ae39119fed3c83726a0a2ea89b506661d">RNNMode</a> </td>
<td class="paramname"><em>mode</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>bidirectional</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>p</em> = <code>0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>state_outputs</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">dmlc::optional&lt; int &gt; </td>
<td class="paramname"><em>projection_size</em> = <code>dmlc::optional&lt;int&gt;()</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">dmlc::optional&lt; double &gt; </td>
<td class="paramname"><em>lstm_state_clip_min</em> = <code>dmlc::optional&lt;double&gt;()</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">dmlc::optional&lt; double &gt; </td>
<td class="paramname"><em>lstm_state_clip_max</em> = <code>dmlc::optional&lt;double&gt;()</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>lstm_state_clip_nan</em> = <code>false</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Applies recurrent layers to input data. Currently, vanilla RNN, LSTM and GRU are implemented, with both multi-layer and bidirectional support.</p>
<p><b>Vanilla RNN</b></p>
<p>Applies a single-gate recurrent layer to input X. Two kinds of activation ReLU and Tanh.</p>
<p>With ReLU activation function:</p>
<p>.. math:: h_t = relu(W_{ih} * x_t + b_{ih} + W_{hh} * h_{(t-1)} + b_{hh})</p>
<p>With Tanh activtion function:</p>
<p>.. math:: h_t = (W_{ih} * x_t + b_{ih} + W_{hh} * h_{(t-1)} + b_{hh})</p>
<p>Reference paper: Finding structure in time - Elman, 1988. <a href="https://crl.ucsd.edu/~elman/Papers/fsit.pdf">https://crl.ucsd.edu/~elman/Papers/fsit.pdf</a></p>
<p><b>LSTM</b></p>
<p>Long Short-Term Memory - Hochreiter, 1997.</p>
<p>.. math:: {array}{ll} i_t = {sigmoid}(W_{ii} x_t + b_{ii} + W_{hi} h_{(t-1)} + b_{hi}) \ f_t = {sigmoid}(W_{if} x_t + b_{if} + W_{hf} h_{(t-1)} + b_{hf}) \ g_t = (W_{ig} x_t + b_{ig} + W_{hc} h_{(t-1)} + b_{hg}) \ o_t = {sigmoid}(W_{io} x_t + b_{io} + W_{ho} h_{(t-1)} + b_{ho}) \ c_t = f_t * c_{(t-1)} + i_t * g_t \ h_t = o_t * (c_t) {array}</p>
<p><b>GRU</b></p>
<p>Gated Recurrent Unit - Cho et al. 2014. <a href="http://arxiv.org/abs/1406.1078">http://arxiv.org/abs/1406.1078</a></p>
<p>The definition of GRU here is slightly different from paper but compatible with</p>
<p>.. math:: {array}{ll} r_t = {sigmoid}(W_{ir} x_t + b_{ir} + W_{hr} h_{(t-1)} + b_{hr}) \ z_t = {sigmoid}(W_{iz} x_t + b_{iz} + W_{hz} h_{(t-1)} + b_{hz}) \ n_t = (W_{in} x_t + b_{in} + r_t * (W_{hn} h_{(t-1)}+ b_{hn})) \ h_t = (1 - z_t) * n_t + z_t * h_{(t-1)} \ {array} </p><dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>Input data to RNN </td></tr>
<tr><td class="paramname">parameters</td><td>Vector of all RNN trainable parameters concatenated </td></tr>
<tr><td class="paramname">state</td><td>initial hidden state of the RNN </td></tr>
<tr><td class="paramname">state_cell</td><td>initial cell state for LSTM networks (only for LSTM) </td></tr>
<tr><td class="paramname">state_size</td><td>size of the state for each layer </td></tr>
<tr><td class="paramname">num_layers</td><td>number of stacked layers </td></tr>
<tr><td class="paramname">mode</td><td>the type of RNN to compute </td></tr>
<tr><td class="paramname">bidirectional</td><td>whether to use bidirectional recurrent layers </td></tr>
<tr><td class="paramname">p</td><td>drop rate of the dropout on the outputs of each RNN layer, except the last </td></tr>
<tr><td class="paramname">state_outputs</td><td>Whether to have the states as symbol outputs. </td></tr>
<tr><td class="paramname">projection_size</td><td>size of project size </td></tr>
<tr><td class="paramname">lstm_state_clip_min</td><td>Minimum clip value of LSTM states. This option must be used </td></tr>
<tr><td class="paramname">lstm_state_clip_max</td><td>Maximum clip value of LSTM states. This option must be used </td></tr>
<tr><td class="paramname">lstm_state_clip_nan</td><td>Whether to stop NaN from propagating in state by clipping </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a13294121c39bafaa2c9c233fd8f25fc2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::ROIPooling </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>rois</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> </td>
<td class="paramname"><em>pooled_size</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>spatial_scale</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Performs region of interest(ROI) pooling on the input array. </p><pre class="fragment">   ROI pooling is a variant of a max pooling layer, in which the output size is
   region of interest is a parameter. Its purpose is to perform max pooling on the
   of non-uniform sizes to obtain fixed-size feature maps. ROI pooling is a
   layer mostly used in training a `Fast R-CNN` network for object detection.

   This operator takes a 4D feature map as an input array and region proposals as
   then it pools over sub-regions of input and produces a fixed-sized output array
   regardless of the ROI size.

   To crop the feature map accordingly, you can resize the bounding box coordinates
   by changing the parameters `rois` and `spatial_scale`.

   The cropped feature maps are pooled by standard max pooling operation to a
   indicated by a `pooled_size` parameter. batch_size will change to the number of
   bounding boxes after `ROIPooling`.

   The size of each region of interest doesn't have to be perfectly divisible by
   the number of pooling sections(`pooled_size`).

   Example::

   x = [[[[  0.,   1.,   2.,   3.,   4.,   5.],
   [  6.,   7.,   8.,   9.,  10.,  11.],
   [ 12.,  13.,  14.,  15.,  16.,  17.],
   [ 18.,  19.,  20.,  21.,  22.,  23.],
   [ 24.,  25.,  26.,  27.,  28.,  29.],
   [ 30.,  31.,  32.,  33.,  34.,  35.],
   [ 36.,  37.,  38.,  39.,  40.,  41.],
   [ 42.,  43.,  44.,  45.,  46.,  47.]]]]

   // region of interest i.e. bounding box coordinates.
   y = [[0,0,0,4,4]]

   // returns array of shape (2,2) according to the given roi with max pooling.
   ROIPooling(x, y, (2,2), 1.0) = [[[[ 14.,  16.],
   [ 26.,  28.]]]]

   // region of interest is changed due to the change in `spacial_scale` parameter.
   ROIPooling(x, y, (2,2), 0.7) = [[[[  7.,   9.],
   [ 19.,  21.]]]]



   Defined in src/operator/roi_pooling.cc:L295
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>The input array to the pooling operator, a 4D Feature maps </td></tr>
<tr><td class="paramname">rois</td><td>Bounding box coordinates, a 2D array of [[batch_index, x1, y1, x2, y2]], where (x1, y1) and (x2, y2) are top left and bottom right corners of designated region of interest. <code>batch_index</code> indicates the index of corresponding image in </td></tr>
<tr><td class="paramname">pooled_size</td><td>ROI pooling output shape (h,w) </td></tr>
<tr><td class="paramname">spatial_scale</td><td>Ratio of input feature map height (or w) to raw image height (or </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="ac28bbe9ec60d45820a7404d409aa7f8f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::ROIPooling </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>rois</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> </td>
<td class="paramname"><em>pooled_size</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>spatial_scale</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Performs region of interest(ROI) pooling on the input array. </p><pre class="fragment">   ROI pooling is a variant of a max pooling layer, in which the output size is
   region of interest is a parameter. Its purpose is to perform max pooling on the
   of non-uniform sizes to obtain fixed-size feature maps. ROI pooling is a
   layer mostly used in training a `Fast R-CNN` network for object detection.

   This operator takes a 4D feature map as an input array and region proposals as
   then it pools over sub-regions of input and produces a fixed-sized output array
   regardless of the ROI size.

   To crop the feature map accordingly, you can resize the bounding box coordinates
   by changing the parameters `rois` and `spatial_scale`.

   The cropped feature maps are pooled by standard max pooling operation to a
   indicated by a `pooled_size` parameter. batch_size will change to the number of
   bounding boxes after `ROIPooling`.

   The size of each region of interest doesn't have to be perfectly divisible by
   the number of pooling sections(`pooled_size`).

   Example::

   x = [[[[  0.,   1.,   2.,   3.,   4.,   5.],
   [  6.,   7.,   8.,   9.,  10.,  11.],
   [ 12.,  13.,  14.,  15.,  16.,  17.],
   [ 18.,  19.,  20.,  21.,  22.,  23.],
   [ 24.,  25.,  26.,  27.,  28.,  29.],
   [ 30.,  31.,  32.,  33.,  34.,  35.],
   [ 36.,  37.,  38.,  39.,  40.,  41.],
   [ 42.,  43.,  44.,  45.,  46.,  47.]]]]

   // region of interest i.e. bounding box coordinates.
   y = [[0,0,0,4,4]]

   // returns array of shape (2,2) according to the given roi with max pooling.
   ROIPooling(x, y, (2,2), 1.0) = [[[[ 14.,  16.],
   [ 26.,  28.]]]]

   // region of interest is changed due to the change in `spacial_scale` parameter.
   ROIPooling(x, y, (2,2), 0.7) = [[[[  7.,   9.],
   [ 19.,  21.]]]]



   Defined in src/operator/roi_pooling.cc:L295
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>The input array to the pooling operator, a 4D Feature maps </td></tr>
<tr><td class="paramname">rois</td><td>Bounding box coordinates, a 2D array of [[batch_index, x1, y1, x2, y2]], where (x1, y1) and (x2, y2) are top left and bottom right corners of designated region of interest. <code>batch_index</code> indicates the index of corresponding image in </td></tr>
<tr><td class="paramname">pooled_size</td><td>ROI pooling output shape (h,w) </td></tr>
<tr><td class="paramname">spatial_scale</td><td>Ratio of input feature map height (or w) to raw image height (or </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a1f0d1f332bc2577a0349b780efda622d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::round </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns element-wise rounded value to the nearest integer of the input. </p><pre class="fragment">   Example::

   round([-1.5, 1.5, -1.9, 1.9, 2.1]) = [-2.,  2., -2.,  2.,  2.]

   The storage type of ``round`` output depends upon the input storage type:

   - round(default) = default
   - round(row_sparse) = row_sparse
   - round(csr) = csr



   Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L706
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>The input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a712b4d43ded153ed7b3291b2daa2145e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::round </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns element-wise rounded value to the nearest integer of the input. </p><pre class="fragment">   Example::

   round([-1.5, 1.5, -1.9, 1.9, 2.1]) = [-2.,  2., -2.,  2.,  2.]

   The storage type of ``round`` output depends upon the input storage type:

   - round(default) = default
   - round(row_sparse) = row_sparse
   - round(csr) = csr



   Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L706
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>The input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a83e44804082cf10a5bae940d5a09a3cf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::rsqrt </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns element-wise inverse square-root value of the input. </p><pre class="fragment">   .. math::
   rsqrt(x) = 1/\sqrt{x}

   Example::

   rsqrt([4,9,16]) = [0.5, 0.33333334, 0.25]

   The storage type of ``rsqrt`` output is always dense



   Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L866
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>The input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="ac6ffc5b821537fb9b7ab687cef75519c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::rsqrt </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns element-wise inverse square-root value of the input. </p><pre class="fragment">   .. math::
   rsqrt(x) = 1/\sqrt{x}

   Example::

   rsqrt([4,9,16]) = [0.5, 0.33333334, 0.25]

   The storage type of ``rsqrt`` output is always dense



   Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L866
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>The input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="ab7d9f3f1e538d870956ea70c2b1c95e8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::scatter_nd </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>indices</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> </td>
<td class="paramname"><em>shape</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Scatters data into a new tensor according to indices. </p><pre class="fragment">   Given `data` with shape `(Y_0, ..., Y_{K-1}, X_M, ..., X_{N-1})` and indices
   `(M, Y_0, ..., Y_{K-1})`, the output will have shape `(X_0, X_1, ..., X_{N-1})`,
   where `M &lt;= N`. If `M == N`, data shape should simply be `(Y_0, ..., Y_{K-1})`.

   The elements in output is defined as follows::

   output[indices[0, y_0, ..., y_{K-1}],
   ...,
   indices[M-1, y_0, ..., y_{K-1}],
   x_M, ..., x_{N-1}] = data[y_0, ..., y_{K-1}, x_M, ..., x_{N-1}]

   all other entries in output are 0.

   .. warning::

   If the indices have duplicates, the result will be non-deterministic and
   the gradient of `scatter_nd` will not be correct!!


   Examples::

   data = [2, 3, 0]
   indices = [[1, 1, 0], [0, 1, 0]]
   shape = (2, 2)
   scatter_nd(data, indices, shape) = [[0, 0], [2, 3]]

   data = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]
   indices = [[0, 1], [1, 1]]
   shape = (2, 2, 2, 2)
   scatter_nd(data, indices, shape) = [[[[0, 0],
   [0, 0]],

   [[1, 2],
   [3, 4]]],

   [[[0, 0],
   [0, 0]],

   [[5, 6],
   [7, 8]]]]
</pre><dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>data </td></tr>
<tr><td class="paramname">indices</td><td>indices </td></tr>
<tr><td class="paramname">shape</td><td><a class="el" href="structmxnet_1_1cpp_1_1Shape.html" title="dynamic shape class that can hold shape of arbirary dimension ">Shape</a> of output. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="ab9ec3a53eddee3f24f4608c1f0123ae5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::scatter_nd </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>indices</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> </td>
<td class="paramname"><em>shape</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Scatters data into a new tensor according to indices. </p><pre class="fragment">   Given `data` with shape `(Y_0, ..., Y_{K-1}, X_M, ..., X_{N-1})` and indices
   `(M, Y_0, ..., Y_{K-1})`, the output will have shape `(X_0, X_1, ..., X_{N-1})`,
   where `M &lt;= N`. If `M == N`, data shape should simply be `(Y_0, ..., Y_{K-1})`.

   The elements in output is defined as follows::

   output[indices[0, y_0, ..., y_{K-1}],
   ...,
   indices[M-1, y_0, ..., y_{K-1}],
   x_M, ..., x_{N-1}] = data[y_0, ..., y_{K-1}, x_M, ..., x_{N-1}]

   all other entries in output are 0.

   .. warning::

   If the indices have duplicates, the result will be non-deterministic and
   the gradient of `scatter_nd` will not be correct!!


   Examples::

   data = [2, 3, 0]
   indices = [[1, 1, 0], [0, 1, 0]]
   shape = (2, 2)
   scatter_nd(data, indices, shape) = [[0, 0], [2, 3]]

   data = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]
   indices = [[0, 1], [1, 1]]
   shape = (2, 2, 2, 2)
   scatter_nd(data, indices, shape) = [[[[0, 0],
   [0, 0]],

   [[1, 2],
   [3, 4]]],

   [[[0, 0],
   [0, 0]],

   [[5, 6],
   [7, 8]]]]
</pre><dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>data </td></tr>
<tr><td class="paramname">indices</td><td>indices </td></tr>
<tr><td class="paramname">shape</td><td><a class="el" href="structmxnet_1_1cpp_1_1Shape.html" title="dynamic shape class that can hold shape of arbirary dimension ">Shape</a> of output. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a4566fd03b43aee1681141cea8c9d87a0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::SequenceLast </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>sequence_length</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>use_sequence_length</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>axis</em> = <code>0</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Takes the last element of a sequence. </p><pre class="fragment">   This function takes an n-dimensional input array of the form
   [max_sequence_length, batch_size, other_feature_dims] and returns a
   of the form [batch_size, other_feature_dims].

   Parameter `sequence_length` is used to handle variable-length sequences.
   an input array of positive ints of dimension [batch_size]. To use this
   set `use_sequence_length` to `True`, otherwise each example in the batch is
   to have the max sequence length.

   .. note:: Alternatively, you can also use `take` operator.

   Example::

   x = [[[  1.,   2.,   3.],
   [  4.,   5.,   6.],
   [  7.,   8.,   9.]],

   [[ 10.,   11.,   12.],
   [ 13.,   14.,   15.],
   [ 16.,   17.,   18.]],

   [[  19.,   20.,   21.],
   [  22.,   23.,   24.],
   [  25.,   26.,   27.]]]

   // returns last sequence when sequence_length parameter is not used
   SequenceLast(x) = [[  19.,   20.,   21.],
   [  22.,   23.,   24.],
   [  25.,   26.,   27.]]

   // sequence_length is used
   SequenceLast(x, sequence_length=[1,1,1], use_sequence_length=True) =
   [[  1.,   2.,   3.],
   [  4.,   5.,   6.],
   [  7.,   8.,   9.]]

   // sequence_length is used
   SequenceLast(x, sequence_length=[1,2,3], use_sequence_length=True) =
   [[  1.,    2.,   3.],
   [  13.,  14.,  15.],
   [  25.,  26.,  27.]]



   Defined in src/operator/sequence_last.cc:L92
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>n-dimensional input array of the form [max_sequence_length, batch_size, </td></tr>
<tr><td class="paramname">sequence_length</td><td>vector of sequence lengths of the form [batch_size] </td></tr>
<tr><td class="paramname">use_sequence_length</td><td>If set to true, this layer takes in an extra input </td></tr>
<tr><td class="paramname">axis</td><td>The sequence axis. Only values of 0 and 1 are currently supported. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a35734beff2899c26ee62c9ce6c13b5ae"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::SequenceLast </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>sequence_length</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>use_sequence_length</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>axis</em> = <code>0</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Takes the last element of a sequence. </p><pre class="fragment">   This function takes an n-dimensional input array of the form
   [max_sequence_length, batch_size, other_feature_dims] and returns a
   of the form [batch_size, other_feature_dims].

   Parameter `sequence_length` is used to handle variable-length sequences.
   an input array of positive ints of dimension [batch_size]. To use this
   set `use_sequence_length` to `True`, otherwise each example in the batch is
   to have the max sequence length.

   .. note:: Alternatively, you can also use `take` operator.

   Example::

   x = [[[  1.,   2.,   3.],
   [  4.,   5.,   6.],
   [  7.,   8.,   9.]],

   [[ 10.,   11.,   12.],
   [ 13.,   14.,   15.],
   [ 16.,   17.,   18.]],

   [[  19.,   20.,   21.],
   [  22.,   23.,   24.],
   [  25.,   26.,   27.]]]

   // returns last sequence when sequence_length parameter is not used
   SequenceLast(x) = [[  19.,   20.,   21.],
   [  22.,   23.,   24.],
   [  25.,   26.,   27.]]

   // sequence_length is used
   SequenceLast(x, sequence_length=[1,1,1], use_sequence_length=True) =
   [[  1.,   2.,   3.],
   [  4.,   5.,   6.],
   [  7.,   8.,   9.]]

   // sequence_length is used
   SequenceLast(x, sequence_length=[1,2,3], use_sequence_length=True) =
   [[  1.,    2.,   3.],
   [  13.,  14.,  15.],
   [  25.,  26.,  27.]]



   Defined in src/operator/sequence_last.cc:L92
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>n-dimensional input array of the form [max_sequence_length, batch_size, </td></tr>
<tr><td class="paramname">sequence_length</td><td>vector of sequence lengths of the form [batch_size] </td></tr>
<tr><td class="paramname">use_sequence_length</td><td>If set to true, this layer takes in an extra input </td></tr>
<tr><td class="paramname">axis</td><td>The sequence axis. Only values of 0 and 1 are currently supported. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a90663714055325d9150b772a6ef0a1d6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::SequenceMask </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>sequence_length</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>use_sequence_length</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>value</em> = <code>0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>axis</em> = <code>0</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Sets all elements outside the sequence to a constant value. </p><pre class="fragment">   This function takes an n-dimensional input array of the form
   [max_sequence_length, batch_size, other_feature_dims] and returns an array of

   Parameter `sequence_length` is used to handle variable-length sequences.
   should be an input array of positive ints of dimension [batch_size].
   To use this parameter, set `use_sequence_length` to `True`,
   otherwise each example in the batch is assumed to have the max sequence length
   this operator works as the `identity` operator.

   Example::

   x = [[[  1.,   2.,   3.],
   [  4.,   5.,   6.]],

   [[  7.,   8.,   9.],
   [ 10.,  11.,  12.]],

   [[ 13.,  14.,   15.],
   [ 16.,  17.,   18.]]]

   // Batch 1
   B1 = [[  1.,   2.,   3.],
   [  7.,   8.,   9.],
   [ 13.,  14.,  15.]]

   // Batch 2
   B2 = [[  4.,   5.,   6.],
   [ 10.,  11.,  12.],
   [ 16.,  17.,  18.]]

   // works as identity operator when sequence_length parameter is not used
   SequenceMask(x) = [[[  1.,   2.,   3.],
   [  4.,   5.,   6.]],

   [[  7.,   8.,   9.],
   [ 10.,  11.,  12.]],

   [[ 13.,  14.,   15.],
   [ 16.,  17.,   18.]]]

   // sequence_length [1,1] means 1 of each batch will be kept
   // and other rows are masked with default mask value = 0
   SequenceMask(x, sequence_length=[1,1], use_sequence_length=True) =
   [[[  1.,   2.,   3.],
   [  4.,   5.,   6.]],

   [[  0.,   0.,   0.],
   [  0.,   0.,   0.]],

   [[  0.,   0.,   0.],
   [  0.,   0.,   0.]]]

   // sequence_length [2,3] means 2 of batch B1 and 3 of batch B2 will be kept
   // and other rows are masked with value = 1
   SequenceMask(x, sequence_length=[2,3], use_sequence_length=True, value=1) =
   [[[  1.,   2.,   3.],
   [  4.,   5.,   6.]],

   [[  7.,   8.,   9.],
   [  10.,  11.,  12.]],

   [[   1.,   1.,   1.],
   [  16.,  17.,  18.]]]



   Defined in src/operator/sequence_mask.cc:L114
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>n-dimensional input array of the form [max_sequence_length, batch_size, </td></tr>
<tr><td class="paramname">sequence_length</td><td>vector of sequence lengths of the form [batch_size] </td></tr>
<tr><td class="paramname">use_sequence_length</td><td>If set to true, this layer takes in an extra input </td></tr>
<tr><td class="paramname">value</td><td>The value to be used as a mask. </td></tr>
<tr><td class="paramname">axis</td><td>The sequence axis. Only values of 0 and 1 are currently supported. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a4853a8cd35759c1b5d1e481366df9bee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::SequenceMask </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>sequence_length</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>use_sequence_length</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>value</em> = <code>0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>axis</em> = <code>0</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Sets all elements outside the sequence to a constant value. </p><pre class="fragment">   This function takes an n-dimensional input array of the form
   [max_sequence_length, batch_size, other_feature_dims] and returns an array of

   Parameter `sequence_length` is used to handle variable-length sequences.
   should be an input array of positive ints of dimension [batch_size].
   To use this parameter, set `use_sequence_length` to `True`,
   otherwise each example in the batch is assumed to have the max sequence length
   this operator works as the `identity` operator.

   Example::

   x = [[[  1.,   2.,   3.],
   [  4.,   5.,   6.]],

   [[  7.,   8.,   9.],
   [ 10.,  11.,  12.]],

   [[ 13.,  14.,   15.],
   [ 16.,  17.,   18.]]]

   // Batch 1
   B1 = [[  1.,   2.,   3.],
   [  7.,   8.,   9.],
   [ 13.,  14.,  15.]]

   // Batch 2
   B2 = [[  4.,   5.,   6.],
   [ 10.,  11.,  12.],
   [ 16.,  17.,  18.]]

   // works as identity operator when sequence_length parameter is not used
   SequenceMask(x) = [[[  1.,   2.,   3.],
   [  4.,   5.,   6.]],

   [[  7.,   8.,   9.],
   [ 10.,  11.,  12.]],

   [[ 13.,  14.,   15.],
   [ 16.,  17.,   18.]]]

   // sequence_length [1,1] means 1 of each batch will be kept
   // and other rows are masked with default mask value = 0
   SequenceMask(x, sequence_length=[1,1], use_sequence_length=True) =
   [[[  1.,   2.,   3.],
   [  4.,   5.,   6.]],

   [[  0.,   0.,   0.],
   [  0.,   0.,   0.]],

   [[  0.,   0.,   0.],
   [  0.,   0.,   0.]]]

   // sequence_length [2,3] means 2 of batch B1 and 3 of batch B2 will be kept
   // and other rows are masked with value = 1
   SequenceMask(x, sequence_length=[2,3], use_sequence_length=True, value=1) =
   [[[  1.,   2.,   3.],
   [  4.,   5.,   6.]],

   [[  7.,   8.,   9.],
   [  10.,  11.,  12.]],

   [[   1.,   1.,   1.],
   [  16.,  17.,  18.]]]



   Defined in src/operator/sequence_mask.cc:L114
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>n-dimensional input array of the form [max_sequence_length, batch_size, </td></tr>
<tr><td class="paramname">sequence_length</td><td>vector of sequence lengths of the form [batch_size] </td></tr>
<tr><td class="paramname">use_sequence_length</td><td>If set to true, this layer takes in an extra input </td></tr>
<tr><td class="paramname">value</td><td>The value to be used as a mask. </td></tr>
<tr><td class="paramname">axis</td><td>The sequence axis. Only values of 0 and 1 are currently supported. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a64276cac6005f45bbbe1f2b4f00e2316"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::SequenceReverse </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>sequence_length</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>use_sequence_length</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>axis</em> = <code>0</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Reverses the elements of each sequence. </p><pre class="fragment">   This function takes an n-dimensional input array of the form
   and returns an array of the same shape.

   Parameter `sequence_length` is used to handle variable-length sequences.
   `sequence_length` should be an input array of positive ints of dimension
   To use this parameter, set `use_sequence_length` to `True`,
   otherwise each example in the batch is assumed to have the max sequence length.

   Example::

   x = [[[  1.,   2.,   3.],
   [  4.,   5.,   6.]],

   [[  7.,   8.,   9.],
   [ 10.,  11.,  12.]],

   [[ 13.,  14.,   15.],
   [ 16.,  17.,   18.]]]

   // Batch 1
   B1 = [[  1.,   2.,   3.],
   [  7.,   8.,   9.],
   [ 13.,  14.,  15.]]

   // Batch 2
   B2 = [[  4.,   5.,   6.],
   [ 10.,  11.,  12.],
   [ 16.,  17.,  18.]]

   // returns reverse sequence when sequence_length parameter is not used
   SequenceReverse(x) = [[[ 13.,  14.,   15.],
   [ 16.,  17.,   18.]],

   [[  7.,   8.,   9.],
   [ 10.,  11.,  12.]],

   [[  1.,   2.,   3.],
   [  4.,   5.,   6.]]]

   // sequence_length [2,2] means 2 rows of
   // both batch B1 and B2 will be reversed.
   SequenceReverse(x, sequence_length=[2,2], use_sequence_length=True) =
   [[[  7.,   8.,   9.],
   [ 10.,  11.,  12.]],

   [[  1.,   2.,   3.],
   [  4.,   5.,   6.]],

   [[ 13.,  14.,   15.],
   [ 16.,  17.,   18.]]]

   // sequence_length [2,3] means 2 of batch B2 and 3 of batch B3
   // will be reversed.
   SequenceReverse(x, sequence_length=[2,3], use_sequence_length=True) =
   [[[  7.,   8.,   9.],
   [ 16.,  17.,  18.]],

   [[  1.,   2.,   3.],
   [ 10.,  11.,  12.]],

   [[ 13.,  14,   15.],
   [  4.,   5.,   6.]]]



   Defined in src/operator/sequence_reverse.cc:L113
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>n-dimensional input array of the form [max_sequence_length, batch_size, </td></tr>
<tr><td class="paramname">sequence_length</td><td>vector of sequence lengths of the form [batch_size] </td></tr>
<tr><td class="paramname">use_sequence_length</td><td>If set to true, this layer takes in an extra input </td></tr>
<tr><td class="paramname">axis</td><td>The sequence axis. Only 0 is currently supported. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a042d45fccd1db23d69fc5e05c49df21f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::SequenceReverse </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>sequence_length</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>use_sequence_length</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>axis</em> = <code>0</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Reverses the elements of each sequence. </p><pre class="fragment">   This function takes an n-dimensional input array of the form
   and returns an array of the same shape.

   Parameter `sequence_length` is used to handle variable-length sequences.
   `sequence_length` should be an input array of positive ints of dimension
   To use this parameter, set `use_sequence_length` to `True`,
   otherwise each example in the batch is assumed to have the max sequence length.

   Example::

   x = [[[  1.,   2.,   3.],
   [  4.,   5.,   6.]],

   [[  7.,   8.,   9.],
   [ 10.,  11.,  12.]],

   [[ 13.,  14.,   15.],
   [ 16.,  17.,   18.]]]

   // Batch 1
   B1 = [[  1.,   2.,   3.],
   [  7.,   8.,   9.],
   [ 13.,  14.,  15.]]

   // Batch 2
   B2 = [[  4.,   5.,   6.],
   [ 10.,  11.,  12.],
   [ 16.,  17.,  18.]]

   // returns reverse sequence when sequence_length parameter is not used
   SequenceReverse(x) = [[[ 13.,  14.,   15.],
   [ 16.,  17.,   18.]],

   [[  7.,   8.,   9.],
   [ 10.,  11.,  12.]],

   [[  1.,   2.,   3.],
   [  4.,   5.,   6.]]]

   // sequence_length [2,2] means 2 rows of
   // both batch B1 and B2 will be reversed.
   SequenceReverse(x, sequence_length=[2,2], use_sequence_length=True) =
   [[[  7.,   8.,   9.],
   [ 10.,  11.,  12.]],

   [[  1.,   2.,   3.],
   [  4.,   5.,   6.]],

   [[ 13.,  14.,   15.],
   [ 16.,  17.,   18.]]]

   // sequence_length [2,3] means 2 of batch B2 and 3 of batch B3
   // will be reversed.
   SequenceReverse(x, sequence_length=[2,3], use_sequence_length=True) =
   [[[  7.,   8.,   9.],
   [ 16.,  17.,  18.]],

   [[  1.,   2.,   3.],
   [ 10.,  11.,  12.]],

   [[ 13.,  14,   15.],
   [  4.,   5.,   6.]]]



   Defined in src/operator/sequence_reverse.cc:L113
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>n-dimensional input array of the form [max_sequence_length, batch_size, </td></tr>
<tr><td class="paramname">sequence_length</td><td>vector of sequence lengths of the form [batch_size] </td></tr>
<tr><td class="paramname">use_sequence_length</td><td>If set to true, this layer takes in an extra input </td></tr>
<tr><td class="paramname">axis</td><td>The sequence axis. Only 0 is currently supported. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a26ad240c6e162aee5209319b26d774b5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::sgd_mom_update </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>weight</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>grad</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>mom</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>lr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>momentum</em> = <code>0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>wd</em> = <code>0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>rescale_grad</em> = <code>1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>clip_gradient</em> = <code>-1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>lazy_update</em> = <code>true</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Momentum update function for Stochastic Gradient Descent (SGD) optimizer. </p><pre class="fragment">   Momentum update has better convergence rates on neural networks. Mathematically
   like below:

   .. math::

   v_1 = \alpha * \nabla J(W_0)\\
   v_t = \gamma v_{t-1} - \alpha * \nabla J(W_{t-1})\\
   W_t = W_{t-1} + v_t

   It updates the weights using::

   v = momentum * v - learning_rate * gradient
   weight += v

   Where the parameter ``momentum`` is the decay rate of momentum estimates at

   However, if grad's storage type is ``row_sparse``, ``lazy_update`` is True and
   type is the same as momentum's storage type,
   only the row slices whose indices appear in grad.indices are updated (for both

   for row in gradient.indices:
   v[row] = momentum[row] * v[row] - learning_rate * gradient[row]
   weight[row] += v[row]



   Defined in src/operator/optimizer_op.cc:L372
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">weight</td><td>Weight </td></tr>
<tr><td class="paramname">grad</td><td>Gradient </td></tr>
<tr><td class="paramname">mom</td><td>Momentum </td></tr>
<tr><td class="paramname">lr</td><td>Learning rate </td></tr>
<tr><td class="paramname">momentum</td><td>The decay rate of momentum estimates at each epoch. </td></tr>
<tr><td class="paramname">wd</td><td>Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of </td></tr>
<tr><td class="paramname">rescale_grad</td><td>Rescale gradient to grad = rescale_grad*grad. </td></tr>
<tr><td class="paramname">clip_gradient</td><td>Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, </td></tr>
<tr><td class="paramname">lazy_update</td><td>If true, lazy updates are applied if gradient's stype is row_sparse </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="ab438e11e3f3ecfbc0a1a490bc6a96efa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::sgd_mom_update </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>weight</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>grad</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>mom</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>lr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>momentum</em> = <code>0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>wd</em> = <code>0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>rescale_grad</em> = <code>1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>clip_gradient</em> = <code>-1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>lazy_update</em> = <code>true</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Momentum update function for Stochastic Gradient Descent (SGD) optimizer. </p><pre class="fragment">   Momentum update has better convergence rates on neural networks. Mathematically
   like below:

   .. math::

   v_1 = \alpha * \nabla J(W_0)\\
   v_t = \gamma v_{t-1} - \alpha * \nabla J(W_{t-1})\\
   W_t = W_{t-1} + v_t

   It updates the weights using::

   v = momentum * v - learning_rate * gradient
   weight += v

   Where the parameter ``momentum`` is the decay rate of momentum estimates at

   However, if grad's storage type is ``row_sparse``, ``lazy_update`` is True and
   type is the same as momentum's storage type,
   only the row slices whose indices appear in grad.indices are updated (for both

   for row in gradient.indices:
   v[row] = momentum[row] * v[row] - learning_rate * gradient[row]
   weight[row] += v[row]



   Defined in src/operator/optimizer_op.cc:L372
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">weight</td><td>Weight </td></tr>
<tr><td class="paramname">grad</td><td>Gradient </td></tr>
<tr><td class="paramname">mom</td><td>Momentum </td></tr>
<tr><td class="paramname">lr</td><td>Learning rate </td></tr>
<tr><td class="paramname">momentum</td><td>The decay rate of momentum estimates at each epoch. </td></tr>
<tr><td class="paramname">wd</td><td>Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of </td></tr>
<tr><td class="paramname">rescale_grad</td><td>Rescale gradient to grad = rescale_grad*grad. </td></tr>
<tr><td class="paramname">clip_gradient</td><td>Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, </td></tr>
<tr><td class="paramname">lazy_update</td><td>If true, lazy updates are applied if gradient's stype is row_sparse </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a4b5be9332d99264e24de75c0025adf6e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::sgd_update </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>weight</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>grad</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>lr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>wd</em> = <code>0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>rescale_grad</em> = <code>1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>clip_gradient</em> = <code>-1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>lazy_update</em> = <code>true</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Update function for Stochastic Gradient Descent (SDG) optimizer. </p><pre class="fragment">   It updates the weights using::

   weight = weight - learning_rate * (gradient + wd * weight)

   However, if gradient is of ``row_sparse`` storage type and ``lazy_update`` is
   only the row slices whose indices appear in grad.indices are updated::

   for row in gradient.indices:
   weight[row] = weight[row] - learning_rate * (gradient[row] + wd * weight[row])



   Defined in src/operator/optimizer_op.cc:L331
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">weight</td><td>Weight </td></tr>
<tr><td class="paramname">grad</td><td>Gradient </td></tr>
<tr><td class="paramname">lr</td><td>Learning rate </td></tr>
<tr><td class="paramname">wd</td><td>Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of </td></tr>
<tr><td class="paramname">rescale_grad</td><td>Rescale gradient to grad = rescale_grad*grad. </td></tr>
<tr><td class="paramname">clip_gradient</td><td>Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, </td></tr>
<tr><td class="paramname">lazy_update</td><td>If true, lazy updates are applied if gradient's stype is row_sparse. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="afbcd2e7ea8aaa409748a99785ad7101e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::sgd_update </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>weight</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>grad</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>lr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>wd</em> = <code>0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>rescale_grad</em> = <code>1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>clip_gradient</em> = <code>-1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>lazy_update</em> = <code>true</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Update function for Stochastic Gradient Descent (SDG) optimizer. </p><pre class="fragment">   It updates the weights using::

   weight = weight - learning_rate * (gradient + wd * weight)

   However, if gradient is of ``row_sparse`` storage type and ``lazy_update`` is
   only the row slices whose indices appear in grad.indices are updated::

   for row in gradient.indices:
   weight[row] = weight[row] - learning_rate * (gradient[row] + wd * weight[row])



   Defined in src/operator/optimizer_op.cc:L331
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">weight</td><td>Weight </td></tr>
<tr><td class="paramname">grad</td><td>Gradient </td></tr>
<tr><td class="paramname">lr</td><td>Learning rate </td></tr>
<tr><td class="paramname">wd</td><td>Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of </td></tr>
<tr><td class="paramname">rescale_grad</td><td>Rescale gradient to grad = rescale_grad*grad. </td></tr>
<tr><td class="paramname">clip_gradient</td><td>Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, </td></tr>
<tr><td class="paramname">lazy_update</td><td>If true, lazy updates are applied if gradient's stype is row_sparse. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a758e473aa6a402a906790bd79054440a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::shape_array </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">dmlc::optional&lt; int &gt; </td>
<td class="paramname"><em>lhs_begin</em> = <code>dmlc::optional&lt;int&gt;()</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">dmlc::optional&lt; int &gt; </td>
<td class="paramname"><em>lhs_end</em> = <code>dmlc::optional&lt;int&gt;()</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">dmlc::optional&lt; int &gt; </td>
<td class="paramname"><em>rhs_begin</em> = <code>dmlc::optional&lt;int&gt;()</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">dmlc::optional&lt; int &gt; </td>
<td class="paramname"><em>rhs_end</em> = <code>dmlc::optional&lt;int&gt;()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns a 1D int64 array containing the shape of data. </p><pre class="fragment">   Example::

   shape_array([[1,2,3,4], [5,6,7,8]]) = [2,4]



   Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L504
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>Input Array. </td></tr>
<tr><td class="paramname">lhs_begin</td><td>Defaults to 0. The beginning index along which the lhs dimensions are </td></tr>
<tr><td class="paramname">lhs_end</td><td>Defaults to None. The ending index along which the lhs dimensions are </td></tr>
<tr><td class="paramname">rhs_begin</td><td>Defaults to 0. The beginning index along which the rhs dimensions are </td></tr>
<tr><td class="paramname">rhs_end</td><td>Defaults to None. The ending index along which the rhs dimensions are </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="ae34a439176afd8a619da3bab534ef83a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::shape_array </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">dmlc::optional&lt; int &gt; </td>
<td class="paramname"><em>lhs_begin</em> = <code>dmlc::optional&lt;int&gt;()</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">dmlc::optional&lt; int &gt; </td>
<td class="paramname"><em>lhs_end</em> = <code>dmlc::optional&lt;int&gt;()</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">dmlc::optional&lt; int &gt; </td>
<td class="paramname"><em>rhs_begin</em> = <code>dmlc::optional&lt;int&gt;()</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">dmlc::optional&lt; int &gt; </td>
<td class="paramname"><em>rhs_end</em> = <code>dmlc::optional&lt;int&gt;()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns a 1D int64 array containing the shape of data. </p><pre class="fragment">   Example::

   shape_array([[1,2,3,4], [5,6,7,8]]) = [2,4]



   Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L504
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>Input Array. </td></tr>
<tr><td class="paramname">lhs_begin</td><td>Defaults to 0. The beginning index along which the lhs dimensions are </td></tr>
<tr><td class="paramname">lhs_end</td><td>Defaults to None. The ending index along which the lhs dimensions are </td></tr>
<tr><td class="paramname">rhs_begin</td><td>Defaults to 0. The beginning index along which the rhs dimensions are </td></tr>
<tr><td class="paramname">rhs_end</td><td>Defaults to None. The ending index along which the rhs dimensions are </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a814727890ac1a094385eaba1ec51424c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::sigmoid </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Computes sigmoid of x element-wise. </p><pre class="fragment">   .. math::
   y = 1 / (1 + exp(-x))

   The storage type of ``sigmoid`` output is always dense



   Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L101
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>The input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a363a584748a70171a6af7caac561f771"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::sigmoid </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Computes sigmoid of x element-wise. </p><pre class="fragment">   .. math::
   y = 1 / (1 + exp(-x))

   The storage type of ``sigmoid`` output is always dense



   Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L101
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>The input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="ae1ea721e794c312bbb79429979219670"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::sign </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns element-wise sign of the input. </p><pre class="fragment">   Example::

   sign([-2, 0, 3]) = [-1, 0, 1]

   The storage type of ``sign`` output depends upon the input storage type:

   - sign(default) = default
   - sign(row_sparse) = row_sparse
   - sign(csr) = csr



   Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L687
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>The input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a04100daf8a349bc8427de9ad8fc34d59"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::sign </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns element-wise sign of the input. </p><pre class="fragment">   Example::

   sign([-2, 0, 3]) = [-1, 0, 1]

   The storage type of ``sign`` output depends upon the input storage type:

   - sign(default) = default
   - sign(row_sparse) = row_sparse
   - sign(csr) = csr



   Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L687
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>The input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="ac506a85a7f6e1903fb8ee802db0c65be"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::signsgd_update </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>weight</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>grad</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>lr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>wd</em> = <code>0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>rescale_grad</em> = <code>1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>clip_gradient</em> = <code>-1</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Update function for SignSGD optimizer. </p><pre class="fragment">   .. math::

   g_t = \nabla J(W_{t-1})\\
   W_t = W_{t-1} - \eta_t \text{sign}(g_t)

   It updates the weights using::

   weight = weight - learning_rate * sign(gradient)

   .. note::
   - sparse ndarray not supported for this optimizer yet.


   Defined in src/operator/optimizer_op.cc:L57
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">weight</td><td>Weight </td></tr>
<tr><td class="paramname">grad</td><td>Gradient </td></tr>
<tr><td class="paramname">lr</td><td>Learning rate </td></tr>
<tr><td class="paramname">wd</td><td>Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of </td></tr>
<tr><td class="paramname">rescale_grad</td><td>Rescale gradient to grad = rescale_grad*grad. </td></tr>
<tr><td class="paramname">clip_gradient</td><td>Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="ab37ca50a86731d14d5f337f4ec7a22b3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::signsgd_update </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>weight</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>grad</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>lr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>wd</em> = <code>0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>rescale_grad</em> = <code>1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>clip_gradient</em> = <code>-1</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Update function for SignSGD optimizer. </p><pre class="fragment">   .. math::

   g_t = \nabla J(W_{t-1})\\
   W_t = W_{t-1} - \eta_t \text{sign}(g_t)

   It updates the weights using::

   weight = weight - learning_rate * sign(gradient)

   .. note::
   - sparse ndarray not supported for this optimizer yet.


   Defined in src/operator/optimizer_op.cc:L57
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">weight</td><td>Weight </td></tr>
<tr><td class="paramname">grad</td><td>Gradient </td></tr>
<tr><td class="paramname">lr</td><td>Learning rate </td></tr>
<tr><td class="paramname">wd</td><td>Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of </td></tr>
<tr><td class="paramname">rescale_grad</td><td>Rescale gradient to grad = rescale_grad*grad. </td></tr>
<tr><td class="paramname">clip_gradient</td><td>Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a6120815ac0de2ae15c44b827b0edf9ce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::signum_update </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>weight</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>grad</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>mom</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>lr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>momentum</em> = <code>0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>wd</em> = <code>0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>rescale_grad</em> = <code>1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>clip_gradient</em> = <code>-1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>wd_lh</em> = <code>0</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>SIGN momentUM (Signum) optimizer. </p><pre class="fragment">   .. math::

   g_t = \nabla J(W_{t-1})\\
   m_t = \beta m_{t-1} + (1 - \beta) g_t\\
   W_t = W_{t-1} - \eta_t \text{sign}(m_t)

   It updates the weights using::
   state = momentum * state + (1-momentum) * gradient
   weight = weight - learning_rate * sign(state)

   Where the parameter ``momentum`` is the decay rate of momentum estimates at

   .. note::
   - sparse ndarray not supported for this optimizer yet.


   Defined in src/operator/optimizer_op.cc:L86
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">weight</td><td>Weight </td></tr>
<tr><td class="paramname">grad</td><td>Gradient </td></tr>
<tr><td class="paramname">mom</td><td>Momentum </td></tr>
<tr><td class="paramname">lr</td><td>Learning rate </td></tr>
<tr><td class="paramname">momentum</td><td>The decay rate of momentum estimates at each epoch. </td></tr>
<tr><td class="paramname">wd</td><td>Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of </td></tr>
<tr><td class="paramname">rescale_grad</td><td>Rescale gradient to grad = rescale_grad*grad. </td></tr>
<tr><td class="paramname">clip_gradient</td><td>Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, </td></tr>
<tr><td class="paramname">wd_lh</td><td>The amount of weight decay that does not go into gradient/momentum </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a2250806e349b6fab16dbb1e2892fe907"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::signum_update </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>weight</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>grad</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>mom</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>lr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>momentum</em> = <code>0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>wd</em> = <code>0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>rescale_grad</em> = <code>1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>clip_gradient</em> = <code>-1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>wd_lh</em> = <code>0</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>SIGN momentUM (Signum) optimizer. </p><pre class="fragment">   .. math::

   g_t = \nabla J(W_{t-1})\\
   m_t = \beta m_{t-1} + (1 - \beta) g_t\\
   W_t = W_{t-1} - \eta_t \text{sign}(m_t)

   It updates the weights using::
   state = momentum * state + (1-momentum) * gradient
   weight = weight - learning_rate * sign(state)

   Where the parameter ``momentum`` is the decay rate of momentum estimates at

   .. note::
   - sparse ndarray not supported for this optimizer yet.


   Defined in src/operator/optimizer_op.cc:L86
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">weight</td><td>Weight </td></tr>
<tr><td class="paramname">grad</td><td>Gradient </td></tr>
<tr><td class="paramname">mom</td><td>Momentum </td></tr>
<tr><td class="paramname">lr</td><td>Learning rate </td></tr>
<tr><td class="paramname">momentum</td><td>The decay rate of momentum estimates at each epoch. </td></tr>
<tr><td class="paramname">wd</td><td>Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of </td></tr>
<tr><td class="paramname">rescale_grad</td><td>Rescale gradient to grad = rescale_grad*grad. </td></tr>
<tr><td class="paramname">clip_gradient</td><td>Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, </td></tr>
<tr><td class="paramname">wd_lh</td><td>The amount of weight decay that does not go into gradient/momentum </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a86ed9f253317ed4bd414507e296274e2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::sin </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Computes the element-wise sine of the input array. </p><pre class="fragment">   The input should be in radians (:math:`2\pi` rad equals 360 degrees).

   .. math::
   sin([0, \pi/4, \pi/2]) = [0, 0.707, 1]

   The storage type of ``sin`` output depends upon the input storage type:

   - sin(default) = default
   - sin(row_sparse) = row_sparse
   - sin(csr) = csr



   Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L46
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>The input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="abfdb853df16f749a6cdf033f45c7b7fb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::sin </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Computes the element-wise sine of the input array. </p><pre class="fragment">   The input should be in radians (:math:`2\pi` rad equals 360 degrees).

   .. math::
   sin([0, \pi/4, \pi/2]) = [0, 0.707, 1]

   The storage type of ``sin`` output depends upon the input storage type:

   - sin(default) = default
   - sin(row_sparse) = row_sparse
   - sin(csr) = csr



   Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L46
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>The input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a74af4ade5fd6940e4001d46d14b55112"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::sinh </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns the hyperbolic sine of the input array, computed element-wise. </p><pre class="fragment">   .. math::
   sinh(x) = 0.5\times(exp(x) - exp(-x))

   The storage type of ``sinh`` output depends upon the input storage type:

   - sinh(default) = default
   - sinh(row_sparse) = row_sparse
   - sinh(csr) = csr



   Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L201
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>The input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="abe11f1abc4a9939760060286bf6d0764"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::sinh </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns the hyperbolic sine of the input array, computed element-wise. </p><pre class="fragment">   .. math::
   sinh(x) = 0.5\times(exp(x) - exp(-x))

   The storage type of ``sinh`` output depends upon the input storage type:

   - sinh(default) = default
   - sinh(row_sparse) = row_sparse
   - sinh(csr) = csr



   Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L201
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>The input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="ab36b34848f6d0dad9f6ba2523499e58f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::size_array </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns a 1D int64 array containing the size of data. </p><pre class="fragment">   Example::

   size_array([[1,2,3,4], [5,6,7,8]]) = [8]



   Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L556
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>Input Array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a5a52dd70cab3aae46299fe690a415f12"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::size_array </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns a 1D int64 array containing the size of data. </p><pre class="fragment">   Example::

   size_array([[1,2,3,4], [5,6,7,8]]) = [8]



   Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L556
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>Input Array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a558a6483730916ff934a4cc992915cd4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::slice </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> </td>
<td class="paramname"><em>begin</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> </td>
<td class="paramname"><em>end</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> </td>
<td class="paramname"><em>step</em> = <code><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Slices a region of the array. </p><pre class="fragment">   .. note:: ``crop`` is deprecated. Use ``slice`` instead.

   This function returns a sliced array between the indices given
   by `begin` and `end` with the corresponding `step`.

   For an input array of ``shape=(d_0, d_1, ..., d_n-1)``,
   slice operation with ``begin=(b_0, b_1...b_m-1)``,
   ``end=(e_0, e_1, ..., e_m-1)``, and ``step=(s_0, s_1, ..., s_m-1)``,
   where m &lt;= n, results in an array with the shape
   ``(|e_0-b_0|/|s_0|, ..., |e_m-1-b_m-1|/|s_m-1|, d_m, ..., d_n-1)``.

   The resulting array's *k*-th dimension contains elements
   from the *k*-th dimension of the input array starting
   from index ``b_k`` (inclusive) with step ``s_k``
   until reaching ``e_k`` (exclusive).

   If the *k*-th elements are `None` in the sequence of `begin`, `end`,
   and `step`, the following rule will be used to set default values.
   If `s_k` is `None`, set `s_k=1`. If `s_k &gt; 0`, set `b_k=0`, `e_k=d_k`;
   else, set `b_k=d_k-1`, `e_k=-1`.

   The storage type of ``slice`` output depends on storage types of inputs

   - slice(csr) = csr
   - otherwise, ``slice`` generates output with default storage

   .. note:: When input data storage type is csr, it only supports
   step=(), or step=(None,), or step=(1,) to generate a csr output.
   For other step parameter values, it falls back to slicing
   a dense tensor.

   Example::

   x = [[  1.,   2.,   3.,   4.],
   [  5.,   6.,   7.,   8.],
   [  9.,  10.,  11.,  12.]]

   slice(x, begin=(0,1), end=(2,4)) = [[ 2.,  3.,  4.],
   [ 6.,  7.,  8.]]
   slice(x, begin=(None, 0), end=(None, 3), step=(-1, 2)) = [[9., 11.],
   [5.,  7.],
   [1.,  3.]]


   Defined in src/operator/tensor/matrix_op.cc:L413
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>Source input </td></tr>
<tr><td class="paramname">begin</td><td>starting indices for the slice operation, supports negative indices. </td></tr>
<tr><td class="paramname">end</td><td>ending indices for the slice operation, supports negative indices. </td></tr>
<tr><td class="paramname">step</td><td>step for the slice operation, supports negative values. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="ad2fa3bd92fa801376d12ea5bc4e83521"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::slice </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> </td>
<td class="paramname"><em>begin</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> </td>
<td class="paramname"><em>end</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> </td>
<td class="paramname"><em>step</em> = <code><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Slices a region of the array. </p><pre class="fragment">   .. note:: ``crop`` is deprecated. Use ``slice`` instead.

   This function returns a sliced array between the indices given
   by `begin` and `end` with the corresponding `step`.

   For an input array of ``shape=(d_0, d_1, ..., d_n-1)``,
   slice operation with ``begin=(b_0, b_1...b_m-1)``,
   ``end=(e_0, e_1, ..., e_m-1)``, and ``step=(s_0, s_1, ..., s_m-1)``,
   where m &lt;= n, results in an array with the shape
   ``(|e_0-b_0|/|s_0|, ..., |e_m-1-b_m-1|/|s_m-1|, d_m, ..., d_n-1)``.

   The resulting array's *k*-th dimension contains elements
   from the *k*-th dimension of the input array starting
   from index ``b_k`` (inclusive) with step ``s_k``
   until reaching ``e_k`` (exclusive).

   If the *k*-th elements are `None` in the sequence of `begin`, `end`,
   and `step`, the following rule will be used to set default values.
   If `s_k` is `None`, set `s_k=1`. If `s_k &gt; 0`, set `b_k=0`, `e_k=d_k`;
   else, set `b_k=d_k-1`, `e_k=-1`.

   The storage type of ``slice`` output depends on storage types of inputs

   - slice(csr) = csr
   - otherwise, ``slice`` generates output with default storage

   .. note:: When input data storage type is csr, it only supports
   step=(), or step=(None,), or step=(1,) to generate a csr output.
   For other step parameter values, it falls back to slicing
   a dense tensor.

   Example::

   x = [[  1.,   2.,   3.,   4.],
   [  5.,   6.,   7.,   8.],
   [  9.,  10.,  11.,  12.]]

   slice(x, begin=(0,1), end=(2,4)) = [[ 2.,  3.,  4.],
   [ 6.,  7.,  8.]]
   slice(x, begin=(None, 0), end=(None, 3), step=(-1, 2)) = [[9., 11.],
   [5.,  7.],
   [1.,  3.]]


   Defined in src/operator/tensor/matrix_op.cc:L413
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>Source input </td></tr>
<tr><td class="paramname">begin</td><td>starting indices for the slice operation, supports negative indices. </td></tr>
<tr><td class="paramname">end</td><td>ending indices for the slice operation, supports negative indices. </td></tr>
<tr><td class="paramname">step</td><td>step for the slice operation, supports negative values. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a1fd30630137204361b04675f70b217bc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::slice_axis </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>axis</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>begin</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">dmlc::optional&lt; int &gt; </td>
<td class="paramname"><em>end</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Slices along a given axis. </p><pre class="fragment">   Returns an array slice along a given `axis` starting from the `begin` index
   to the `end` index.

   Examples::

   x = [[  1.,   2.,   3.,   4.],
   [  5.,   6.,   7.,   8.],
   [  9.,  10.,  11.,  12.]]

   slice_axis(x, axis=0, begin=1, end=3) = [[  5.,   6.,   7.,   8.],
   [  9.,  10.,  11.,  12.]]

   slice_axis(x, axis=1, begin=0, end=2) = [[  1.,   2.],
   [  5.,   6.],
   [  9.,  10.]]

   slice_axis(x, axis=1, begin=-3, end=-1) = [[  2.,   3.],
   [  6.,   7.],
   [ 10.,  11.]]


   Defined in src/operator/tensor/matrix_op.cc:L500
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>Source input </td></tr>
<tr><td class="paramname">axis</td><td>Axis along which to be sliced, supports negative indexes. </td></tr>
<tr><td class="paramname">begin</td><td>The beginning index along the axis to be sliced, supports negative </td></tr>
<tr><td class="paramname">end</td><td>The ending index along the axis to be sliced, supports negative indexes. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a000616c91bc1d6318553e27d58698b74"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::slice_axis </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>axis</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>begin</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">dmlc::optional&lt; int &gt; </td>
<td class="paramname"><em>end</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Slices along a given axis. </p><pre class="fragment">   Returns an array slice along a given `axis` starting from the `begin` index
   to the `end` index.

   Examples::

   x = [[  1.,   2.,   3.,   4.],
   [  5.,   6.,   7.,   8.],
   [  9.,  10.,  11.,  12.]]

   slice_axis(x, axis=0, begin=1, end=3) = [[  5.,   6.,   7.,   8.],
   [  9.,  10.,  11.,  12.]]

   slice_axis(x, axis=1, begin=0, end=2) = [[  1.,   2.],
   [  5.,   6.],
   [  9.,  10.]]

   slice_axis(x, axis=1, begin=-3, end=-1) = [[  2.,   3.],
   [  6.,   7.],
   [ 10.,  11.]]


   Defined in src/operator/tensor/matrix_op.cc:L500
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>Source input </td></tr>
<tr><td class="paramname">axis</td><td>Axis along which to be sliced, supports negative indexes. </td></tr>
<tr><td class="paramname">begin</td><td>The beginning index along the axis to be sliced, supports negative </td></tr>
<tr><td class="paramname">end</td><td>The ending index along the axis to be sliced, supports negative indexes. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a25256ed685760f4b284dd018f21096da"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::slice_like </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>shape_like</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> </td>
<td class="paramname"><em>axes</em> = <code><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Slices a region of the array like the shape of another array. </p><pre class="fragment">   This function is similar to ``slice``, however, the `begin` are always `0`s
   and `end` of specific axes are inferred from the second input `shape_like`.

   Given the second `shape_like` input of ``shape=(d_0, d_1, ..., d_n-1)``,
   a ``slice_like`` operator with default empty `axes`, it performs the
   following operation:

   `` out = slice(input, begin=(0, 0, ..., 0), end=(d_0, d_1, ..., d_n-1))``.

   When `axes` is not empty, it is used to speficy which axes are being sliced.

   Given a 4-d input data, ``slice_like`` operator with ``axes=(0, 2, -1)``
   will perform the following operation:

   `` out = slice(input, begin=(0, 0, 0, 0), end=(d_0, None, d_2, d_3))``.

   Note that it is allowed to have first and second input with different
   however, you have to make sure the `axes` are specified and not exceeding the
   dimension limits.

   For example, given `input_1` with ``shape=(2,3,4,5)`` and `input_2` with
   ``shape=(1,2,3)``, it is not allowed to use:

   `` out = slice_like(a, b)`` because ndim of `input_1` is 4, and ndim of
   is 3.

   The following is allowed in this situation:

   `` out = slice_like(a, b, axes=(0, 2))``

   Example::

   x = [[  1.,   2.,   3.,   4.],
   [  5.,   6.,   7.,   8.],
   [  9.,  10.,  11.,  12.]]

   y = [[  0.,   0.,   0.],
   [  0.,   0.,   0.]]

   slice_like(x, y) = [[ 1.,  2.,  3.]
   [ 5.,  6.,  7.]]
   slice_like(x, y, axes=(0, 1)) = [[ 1.,  2.,  3.]
   [ 5.,  6.,  7.]]
   slice_like(x, y, axes=(0)) = [[ 1.,  2.,  3.,  4.]
   [ 5.,  6.,  7.,  8.]]
   slice_like(x, y, axes=(-1)) = [[  1.,   2.,   3.]
   [  5.,   6.,   7.]
   [  9.,  10.,  11.]]


   Defined in src/operator/tensor/matrix_op.cc:L569
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>Source input </td></tr>
<tr><td class="paramname">shape_like</td><td><a class="el" href="structmxnet_1_1cpp_1_1Shape.html" title="dynamic shape class that can hold shape of arbirary dimension ">Shape</a> like input </td></tr>
<tr><td class="paramname">axes</td><td>List of axes on which input data will be sliced according to the corresponding size of the second input. By default will slice on all axes. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="ad9c0bcdbd71633a994588e6d5ac64149"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::slice_like </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>shape_like</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> </td>
<td class="paramname"><em>axes</em> = <code><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Slices a region of the array like the shape of another array. </p><pre class="fragment">   This function is similar to ``slice``, however, the `begin` are always `0`s
   and `end` of specific axes are inferred from the second input `shape_like`.

   Given the second `shape_like` input of ``shape=(d_0, d_1, ..., d_n-1)``,
   a ``slice_like`` operator with default empty `axes`, it performs the
   following operation:

   `` out = slice(input, begin=(0, 0, ..., 0), end=(d_0, d_1, ..., d_n-1))``.

   When `axes` is not empty, it is used to speficy which axes are being sliced.

   Given a 4-d input data, ``slice_like`` operator with ``axes=(0, 2, -1)``
   will perform the following operation:

   `` out = slice(input, begin=(0, 0, 0, 0), end=(d_0, None, d_2, d_3))``.

   Note that it is allowed to have first and second input with different
   however, you have to make sure the `axes` are specified and not exceeding the
   dimension limits.

   For example, given `input_1` with ``shape=(2,3,4,5)`` and `input_2` with
   ``shape=(1,2,3)``, it is not allowed to use:

   `` out = slice_like(a, b)`` because ndim of `input_1` is 4, and ndim of
   is 3.

   The following is allowed in this situation:

   `` out = slice_like(a, b, axes=(0, 2))``

   Example::

   x = [[  1.,   2.,   3.,   4.],
   [  5.,   6.,   7.,   8.],
   [  9.,  10.,  11.,  12.]]

   y = [[  0.,   0.,   0.],
   [  0.,   0.,   0.]]

   slice_like(x, y) = [[ 1.,  2.,  3.]
   [ 5.,  6.,  7.]]
   slice_like(x, y, axes=(0, 1)) = [[ 1.,  2.,  3.]
   [ 5.,  6.,  7.]]
   slice_like(x, y, axes=(0)) = [[ 1.,  2.,  3.,  4.]
   [ 5.,  6.,  7.,  8.]]
   slice_like(x, y, axes=(-1)) = [[  1.,   2.,   3.]
   [  5.,   6.,   7.]
   [  9.,  10.,  11.]]


   Defined in src/operator/tensor/matrix_op.cc:L569
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>Source input </td></tr>
<tr><td class="paramname">shape_like</td><td><a class="el" href="structmxnet_1_1cpp_1_1Shape.html" title="dynamic shape class that can hold shape of arbirary dimension ">Shape</a> like input </td></tr>
<tr><td class="paramname">axes</td><td>List of axes on which input data will be sliced according to the corresponding size of the second input. By default will slice on all axes. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a6a8afcdb74cfc8eb33a58e89d9534699"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::SliceChannel </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>num_outputs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>axis</em> = <code>1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>squeeze_axis</em> = <code>false</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Splits an array along a particular axis into multiple sub-arrays. </p><pre class="fragment">   .. note:: ``SliceChannel`` is deprecated. Use ``split`` instead.

   **Note** that `num_outputs` should evenly divide the length of the axis
   along which to split the array.

   Example::

   x  = [[[ 1.]
   [ 2.]]
   [[ 3.]
   [ 4.]]
   [[ 5.]
   [ 6.]]]
   x.shape = (3, 2, 1)

   y = split(x, axis=1, num_outputs=2) // a list of 2 arrays with shape (3, 1, 1)
   y = [[[ 1.]]
   [[ 3.]]
   [[ 5.]]]

   [[[ 2.]]
   [[ 4.]]
   [[ 6.]]]

   y[0].shape = (3, 1, 1)

   z = split(x, axis=0, num_outputs=3) // a list of 3 arrays with shape (1, 2, 1)
   z = [[[ 1.]
   [ 2.]]]

   [[[ 3.]
   [ 4.]]]

   [[[ 5.]
   [ 6.]]]

   z[0].shape = (1, 2, 1)

   `squeeze_axis=1` removes the axis with length 1 from the shapes of the output
   **Note** that setting `squeeze_axis` to ``1`` removes axis with length 1 only
   along the `axis` which it is split.
   Also `squeeze_axis` can be set to true only if ``input.shape[axis] ==

   Example::

   z = split(x, axis=0, num_outputs=3, squeeze_axis=1) // a list of 3 arrays with
   z = [[ 1.]
   [ 2.]]

   [[ 3.]
   [ 4.]]

   [[ 5.]
   [ 6.]]
   z[0].shape = (2 ,1 )



   Defined in src/operator/slice_channel.cc:L107
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>The input </td></tr>
<tr><td class="paramname">num_outputs</td><td>Number of splits. Note that this should evenly divide the length of </td></tr>
<tr><td class="paramname">axis</td><td>Axis along which to split. </td></tr>
<tr><td class="paramname">squeeze_axis</td><td>If true, Removes the axis with length 1 from the shapes of the output arrays. <b>Note</b> that setting <code>squeeze_axis</code> to <code>true</code> removes axis with length 1 only along the <code>axis</code> which it is split. Also <code>squeeze_axis</code> can </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a1649d07b09ce8eece2e28d4de0586691"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::SliceChannel </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>num_outputs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>axis</em> = <code>1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>squeeze_axis</em> = <code>false</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Splits an array along a particular axis into multiple sub-arrays. </p><pre class="fragment">   .. note:: ``SliceChannel`` is deprecated. Use ``split`` instead.

   **Note** that `num_outputs` should evenly divide the length of the axis
   along which to split the array.

   Example::

   x  = [[[ 1.]
   [ 2.]]
   [[ 3.]
   [ 4.]]
   [[ 5.]
   [ 6.]]]
   x.shape = (3, 2, 1)

   y = split(x, axis=1, num_outputs=2) // a list of 2 arrays with shape (3, 1, 1)
   y = [[[ 1.]]
   [[ 3.]]
   [[ 5.]]]

   [[[ 2.]]
   [[ 4.]]
   [[ 6.]]]

   y[0].shape = (3, 1, 1)

   z = split(x, axis=0, num_outputs=3) // a list of 3 arrays with shape (1, 2, 1)
   z = [[[ 1.]
   [ 2.]]]

   [[[ 3.]
   [ 4.]]]

   [[[ 5.]
   [ 6.]]]

   z[0].shape = (1, 2, 1)

   `squeeze_axis=1` removes the axis with length 1 from the shapes of the output
   **Note** that setting `squeeze_axis` to ``1`` removes axis with length 1 only
   along the `axis` which it is split.
   Also `squeeze_axis` can be set to true only if ``input.shape[axis] ==

   Example::

   z = split(x, axis=0, num_outputs=3, squeeze_axis=1) // a list of 3 arrays with
   z = [[ 1.]
   [ 2.]]

   [[ 3.]
   [ 4.]]

   [[ 5.]
   [ 6.]]
   z[0].shape = (2 ,1 )



   Defined in src/operator/slice_channel.cc:L107
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>The input </td></tr>
<tr><td class="paramname">num_outputs</td><td>Number of splits. Note that this should evenly divide the length of </td></tr>
<tr><td class="paramname">axis</td><td>Axis along which to split. </td></tr>
<tr><td class="paramname">squeeze_axis</td><td>If true, Removes the axis with length 1 from the shapes of the output arrays. <b>Note</b> that setting <code>squeeze_axis</code> to <code>true</code> removes axis with length 1 only along the <code>axis</code> which it is split. Also <code>squeeze_axis</code> can </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a3fe03556ba0c297e94e53b47bb4452bc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::smooth_l1 </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>scalar</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Calculate Smooth L1 Loss(lhs, scalar) by summing </p><pre class="fragment">   .. math::

   f(x) =
   \begin{cases}
   (\sigma x)^2/2,&amp; \text{if }x &lt; 1/\sigma^2\\
   |x|-0.5/\sigma^2,&amp; \text{otherwise}
   \end{cases}

   where :math:`x` is an element of the tensor *lhs* and :math:`\sigma` is the

   Example::

   smooth_l1([1, 2, 3, 4], scalar=1) = [0.5, 1.5, 2.5, 3.5]



   Defined in src/operator/tensor/elemwise_binary_scalar_op_extended.cc:L103
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>source input </td></tr>
<tr><td class="paramname">scalar</td><td>scalar input </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a29ce9a8a70e7853377a65aabc41483fb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::smooth_l1 </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>scalar</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Calculate Smooth L1 Loss(lhs, scalar) by summing </p><pre class="fragment">   .. math::

   f(x) =
   \begin{cases}
   (\sigma x)^2/2,&amp; \text{if }x &lt; 1/\sigma^2\\
   |x|-0.5/\sigma^2,&amp; \text{otherwise}
   \end{cases}

   where :math:`x` is an element of the tensor *lhs* and :math:`\sigma` is the

   Example::

   smooth_l1([1, 2, 3, 4], scalar=1) = [0.5, 1.5, 2.5, 3.5]



   Defined in src/operator/tensor/elemwise_binary_scalar_op_extended.cc:L103
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>source input </td></tr>
<tr><td class="paramname">scalar</td><td>scalar input </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a0b5a88497c964061b72953a700681895"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::softmax </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>axis</em> = <code>-1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">dmlc::optional&lt; double &gt; </td>
<td class="paramname"><em>temperature</em> = <code>dmlc::optional&lt;double&gt;()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Applies the softmax function. </p><pre class="fragment">   The resulting array contains elements in the range (0,1) and the elements along

   .. math::
   softmax(\mathbf{z/t})_j = \frac{e^{z_j/t}}{\sum_{k=1}^K e^{z_k/t}}

   for :math:`j = 1, ..., K`

   t is the temperature parameter in softmax function. By default, t equals 1.0

   Example::

   x = [[ 1.  1.  1.]
   [ 1.  1.  1.]]

   softmax(x,axis=0) = [[ 0.5  0.5  0.5]
   [ 0.5  0.5  0.5]]

   softmax(x,axis=1) = [[ 0.33333334,  0.33333334,  0.33333334],
   [ 0.33333334,  0.33333334,  0.33333334]]



   Defined in src/operator/nn/softmax.cc:L100
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>The input array. </td></tr>
<tr><td class="paramname">axis</td><td>The axis along which to compute softmax. </td></tr>
<tr><td class="paramname">temperature</td><td>Temperature parameter in softmax </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a5c43bc2921ee5db9ddd94f2418e79abc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::Softmax </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>grad_scale</em> = <code>1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>ignore_label</em> = <code>-1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>multi_output</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>use_ignore</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>preserve_shape</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespacemxnet_1_1cpp.html#abac2e8c934c7bd4416728b351fcbae5b">SoftmaxNormalization</a> </td>
<td class="paramname"><em>normalization</em> = <code><a class="el" href="namespacemxnet_1_1cpp.html#ae708904c6ad7046fcecfc6c6b7e0ac73af2655c2dee87cb9b0646f678a630394b">SoftmaxNormalization::kNull</a></code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>out_grad</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>smooth_alpha</em> = <code>0</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Please use <code>SoftmaxOutput</code>. </p><pre class="fragment">   .. note::

   This operator has been renamed to `SoftmaxOutput`, which
   computes the gradient of cross-entropy loss w.r.t softmax output.
   To just compute softmax output, use the `softmax` operator.



   Defined in src/operator/softmax_output.cc:L138
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>Input array. </td></tr>
<tr><td class="paramname">grad_scale</td><td>Scales the gradient by a float factor. </td></tr>
<tr><td class="paramname">ignore_label</td><td>The instances whose <code>labels</code> == <code>ignore_label</code> will be ignored </td></tr>
<tr><td class="paramname">multi_output</td><td>If set to <code>true</code>, the softmax function will be computed along axis <code>1</code>. This is applied when the shape of input array differs from the </td></tr>
<tr><td class="paramname">use_ignore</td><td>If set to <code>true</code>, the <code>ignore_label</code> value will not contribute to </td></tr>
<tr><td class="paramname">preserve_shape</td><td>If set to <code>true</code>, the softmax function will be computed along </td></tr>
<tr><td class="paramname">normalization</td><td>Normalizes the gradient. </td></tr>
<tr><td class="paramname">out_grad</td><td>Multiplies gradient with output gradient element-wise. </td></tr>
<tr><td class="paramname">smooth_alpha</td><td><a class="el" href="classmxnet_1_1cpp_1_1Constant.html">Constant</a> for computing a label smoothed version of cross-entropyfor the backwards pass. This constant gets subtracted from theone-hot encoding of the gold label and distributed uniformly toall other </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a28f560dc313748091ad850d7a8a7f915"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::softmax </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>axis</em> = <code>-1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">dmlc::optional&lt; double &gt; </td>
<td class="paramname"><em>temperature</em> = <code>dmlc::optional&lt;double&gt;()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Applies the softmax function. </p><pre class="fragment">   The resulting array contains elements in the range (0,1) and the elements along

   .. math::
   softmax(\mathbf{z/t})_j = \frac{e^{z_j/t}}{\sum_{k=1}^K e^{z_k/t}}

   for :math:`j = 1, ..., K`

   t is the temperature parameter in softmax function. By default, t equals 1.0

   Example::

   x = [[ 1.  1.  1.]
   [ 1.  1.  1.]]

   softmax(x,axis=0) = [[ 0.5  0.5  0.5]
   [ 0.5  0.5  0.5]]

   softmax(x,axis=1) = [[ 0.33333334,  0.33333334,  0.33333334],
   [ 0.33333334,  0.33333334,  0.33333334]]



   Defined in src/operator/nn/softmax.cc:L100
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>The input array. </td></tr>
<tr><td class="paramname">axis</td><td>The axis along which to compute softmax. </td></tr>
<tr><td class="paramname">temperature</td><td>Temperature parameter in softmax </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="aecb7320878e120e7164b6db540c184c4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::Softmax </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>grad_scale</em> = <code>1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>ignore_label</em> = <code>-1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>multi_output</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>use_ignore</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>preserve_shape</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespacemxnet_1_1cpp.html#abac2e8c934c7bd4416728b351fcbae5b">SoftmaxNormalization</a> </td>
<td class="paramname"><em>normalization</em> = <code><a class="el" href="namespacemxnet_1_1cpp.html#ae708904c6ad7046fcecfc6c6b7e0ac73af2655c2dee87cb9b0646f678a630394b">SoftmaxNormalization::kNull</a></code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>out_grad</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>smooth_alpha</em> = <code>0</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Please use <code>SoftmaxOutput</code>. </p><pre class="fragment">   .. note::

   This operator has been renamed to `SoftmaxOutput`, which
   computes the gradient of cross-entropy loss w.r.t softmax output.
   To just compute softmax output, use the `softmax` operator.



   Defined in src/operator/softmax_output.cc:L138
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>Input array. </td></tr>
<tr><td class="paramname">grad_scale</td><td>Scales the gradient by a float factor. </td></tr>
<tr><td class="paramname">ignore_label</td><td>The instances whose <code>labels</code> == <code>ignore_label</code> will be ignored </td></tr>
<tr><td class="paramname">multi_output</td><td>If set to <code>true</code>, the softmax function will be computed along axis <code>1</code>. This is applied when the shape of input array differs from the </td></tr>
<tr><td class="paramname">use_ignore</td><td>If set to <code>true</code>, the <code>ignore_label</code> value will not contribute to </td></tr>
<tr><td class="paramname">preserve_shape</td><td>If set to <code>true</code>, the softmax function will be computed along </td></tr>
<tr><td class="paramname">normalization</td><td>Normalizes the gradient. </td></tr>
<tr><td class="paramname">out_grad</td><td>Multiplies gradient with output gradient element-wise. </td></tr>
<tr><td class="paramname">smooth_alpha</td><td><a class="el" href="classmxnet_1_1cpp_1_1Constant.html">Constant</a> for computing a label smoothed version of cross-entropyfor the backwards pass. This constant gets subtracted from theone-hot encoding of the gold label and distributed uniformly toall other </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a9a45e59107b4d972d026627fa7f25e63"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::softmax_cross_entropy </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>label</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Calculate cross entropy of softmax output and one-hot label. </p><pre class="fragment">   - This operator computes the cross entropy in two steps:
   - Applies softmax function on the input array.
   - Computes and returns the cross entropy loss between the softmax output and

   - The softmax function and cross entropy loss is given by:

   - Softmax Function:

   .. math:: \text{softmax}(x)_i = \frac{exp(x_i)}{\sum_j exp(x_j)}

   - Cross Entropy Function:

   .. math:: \text{CE(label, output)} = - \sum_i \text{label}_i

   Example::

   x = [[1, 2, 3],
   [11, 7, 5]]

   label = [2, 0]

   softmax(x) = [[0.09003057, 0.24472848, 0.66524094],
   [0.97962922, 0.01794253, 0.00242826]]

   softmax_cross_entropy(data, label) = - log(0.66524084) - log(0.97962922) =



   Defined in src/operator/loss_binary_op.cc:L59
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>Input data </td></tr>
<tr><td class="paramname">label</td><td>Input label </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="abf57185c13c3163e7537759fc519ea33"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::softmax_cross_entropy </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>label</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Calculate cross entropy of softmax output and one-hot label. </p><pre class="fragment">   - This operator computes the cross entropy in two steps:
   - Applies softmax function on the input array.
   - Computes and returns the cross entropy loss between the softmax output and

   - The softmax function and cross entropy loss is given by:

   - Softmax Function:

   .. math:: \text{softmax}(x)_i = \frac{exp(x_i)}{\sum_j exp(x_j)}

   - Cross Entropy Function:

   .. math:: \text{CE(label, output)} = - \sum_i \text{label}_i

   Example::

   x = [[1, 2, 3],
   [11, 7, 5]]

   label = [2, 0]

   softmax(x) = [[0.09003057, 0.24472848, 0.66524094],
   [0.97962922, 0.01794253, 0.00242826]]

   softmax_cross_entropy(data, label) = - log(0.66524084) - log(0.97962922) =



   Defined in src/operator/loss_binary_op.cc:L59
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>Input data </td></tr>
<tr><td class="paramname">label</td><td>Input label </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a58de1c65842e8b5421c9960ed3a6f8e8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::SoftmaxActivation </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespacemxnet_1_1cpp.html#a08bbd5633680ffa58dae3cab685e2ebf">SoftmaxActivationMode</a> </td>
<td class="paramname"><em>mode</em> = <code><a class="el" href="namespacemxnet_1_1cpp.html#a08bbd5633680ffa58dae3cab685e2ebfa63f56d9e95d7b447075aef94444c4c96">SoftmaxActivationMode::kInstance</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Applies softmax activation to input. This is intended for internal layers. </p><pre class="fragment">   .. note::

   This operator has been deprecated, please use `softmax`.

   If `mode` = ``instance``, this operator will compute a softmax for each
   This is the default mode.

   If `mode` = ``channel``, this operator will compute a k-class softmax at each
   of each instance, where `k` = ``num_channel``. This mode can only be used when
   has at least 3 dimensions.
   This can be used for `fully convolutional network`, `image segmentation`, etc.

   Example::

   &gt;&gt;&gt; input_array = mx.nd.array([[3., 0.5, -0.5, 2., 7.],
   &gt;&gt;&gt;                            [2., -.4, 7.,   3., 0.2]])
   &gt;&gt;&gt; softmax_act = mx.nd.SoftmaxActivation(input_array)
   &gt;&gt;&gt; print softmax_act.asnumpy()
   [[  1.78322066e-02   1.46375655e-03   5.38485940e-04   6.56010211e-03
   [  6.56221947e-03   5.95310994e-04   9.73919690e-01   1.78379621e-02



   Defined in src/operator/nn/softmax_activation.cc:L59
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>The input array. </td></tr>
<tr><td class="paramname">mode</td><td>Specifies how to compute the softmax. If set to <code>instance</code>, it computes softmax for each instance. If set to <code>channel</code>, It computes cross channel </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a259eac5a8f0f3dbe37d2708e1c81abf4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::SoftmaxActivation </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespacemxnet_1_1cpp.html#a08bbd5633680ffa58dae3cab685e2ebf">SoftmaxActivationMode</a> </td>
<td class="paramname"><em>mode</em> = <code><a class="el" href="namespacemxnet_1_1cpp.html#a08bbd5633680ffa58dae3cab685e2ebfa63f56d9e95d7b447075aef94444c4c96">SoftmaxActivationMode::kInstance</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Applies softmax activation to input. This is intended for internal layers. </p><pre class="fragment">   .. note::

   This operator has been deprecated, please use `softmax`.

   If `mode` = ``instance``, this operator will compute a softmax for each
   This is the default mode.

   If `mode` = ``channel``, this operator will compute a k-class softmax at each
   of each instance, where `k` = ``num_channel``. This mode can only be used when
   has at least 3 dimensions.
   This can be used for `fully convolutional network`, `image segmentation`, etc.

   Example::

   &gt;&gt;&gt; input_array = mx.nd.array([[3., 0.5, -0.5, 2., 7.],
   &gt;&gt;&gt;                            [2., -.4, 7.,   3., 0.2]])
   &gt;&gt;&gt; softmax_act = mx.nd.SoftmaxActivation(input_array)
   &gt;&gt;&gt; print softmax_act.asnumpy()
   [[  1.78322066e-02   1.46375655e-03   5.38485940e-04   6.56010211e-03
   [  6.56221947e-03   5.95310994e-04   9.73919690e-01   1.78379621e-02



   Defined in src/operator/nn/softmax_activation.cc:L59
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>The input array. </td></tr>
<tr><td class="paramname">mode</td><td>Specifies how to compute the softmax. If set to <code>instance</code>, it computes softmax for each instance. If set to <code>channel</code>, It computes cross channel </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a91a94bf31170afd035f7cc85351eaf98"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::SoftmaxOutput </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>label</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>grad_scale</em> = <code>1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>ignore_label</em> = <code>-1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>multi_output</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>use_ignore</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>preserve_shape</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespacemxnet_1_1cpp.html#ae708904c6ad7046fcecfc6c6b7e0ac73">SoftmaxOutputNormalization</a> </td>
<td class="paramname"><em>normalization</em> = <code><a class="el" href="namespacemxnet_1_1cpp.html#ae708904c6ad7046fcecfc6c6b7e0ac73af2655c2dee87cb9b0646f678a630394b">SoftmaxOutputNormalization::kNull</a></code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>out_grad</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>smooth_alpha</em> = <code>0</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Computes the gradient of cross entropy loss with respect to softmax output. </p><pre class="fragment">   - This operator computes the gradient in two steps.
   The cross entropy loss does not actually need to be computed.

   - Applies softmax function on the input array.
   - Computes and returns the gradient of cross entropy loss w.r.t. the softmax

   - The softmax function, cross entropy loss and gradient is given by:

   - Softmax Function:

   .. math:: \text{softmax}(x)_i = \frac{exp(x_i)}{\sum_j exp(x_j)}

   - Cross Entropy Function:

   .. math:: \text{CE(label, output)} = - \sum_i \text{label}_i

   - The gradient of cross entropy loss w.r.t softmax output:

   .. math:: \text{gradient} = \text{output} - \text{label}

   - During forward propagation, the softmax function is computed for each

   For general *N*-D input arrays with shape :math:`(d_1, d_2, ..., d_n)`. The
   :math:`s=d_1 \cdot d_2 \cdot \cdot \cdot d_n`. We can use the parameters
   and `multi_output` to specify the way to compute softmax:

   - By default, `preserve_shape` is ``false``. This operator will reshape the
   into a 2-D array with shape :math:`(d_1, \frac{s}{d_1})` and then compute the
   each row in the reshaped array, and afterwards reshape it back to the original
   :math:`(d_1, d_2, ..., d_n)`.
   - If `preserve_shape` is ``true``, the softmax function will be computed along
   the last axis (`axis` = ``-1``).
   - If `multi_output` is ``true``, the softmax function will be computed along
   the second axis (`axis` = ``1``).

   - During backward propagation, the gradient of cross-entropy loss w.r.t softmax
   The provided label can be a one-hot label array or a probability label array.

   - If the parameter `use_ignore` is ``true``, `ignore_label` can specify input
   with a particular label to be ignored during backward propagation. **This has
   softmax `output` has same shape as `label`**.

   Example::

   data = [[1,2,3,4],[2,2,2,2],[3,3,3,3],[4,4,4,4]]
   label = [1,0,2,3]
   ignore_label = 1
   SoftmaxOutput(data=data, label = label,\
   multi_output=true, use_ignore=true,\
   ignore_label=ignore_label)
   ## forward softmax output
   [[ 0.0320586   0.08714432  0.23688284  0.64391428]
   [ 0.25        0.25        0.25        0.25      ]
   [ 0.25        0.25        0.25        0.25      ]
   [ 0.25        0.25        0.25        0.25      ]]
   ## backward gradient output
   [[ 0.    0.    0.    0.  ]
   [-0.75  0.25  0.25  0.25]
   [ 0.25  0.25 -0.75  0.25]
   [ 0.25  0.25  0.25 -0.75]]
   ## notice that the first row is all 0 because label[0] is 1, which is equal to

   - The parameter `grad_scale` can be used to rescale the gradient, which is
   give each loss function different weights.

   - This operator also supports various ways to normalize the gradient by
   The `normalization` is applied if softmax output has different shape than the
   The `normalization` mode can be set to the followings:

   - ``'null'``: do nothing.
   - ``'batch'``: divide the gradient by the batch size.
   - ``'valid'``: divide the gradient by the number of instances which are not



   Defined in src/operator/softmax_output.cc:L123
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>Input array. </td></tr>
<tr><td class="paramname">label</td><td>Ground truth label. </td></tr>
<tr><td class="paramname">grad_scale</td><td>Scales the gradient by a float factor. </td></tr>
<tr><td class="paramname">ignore_label</td><td>The instances whose <code>labels</code> == <code>ignore_label</code> will be ignored </td></tr>
<tr><td class="paramname">multi_output</td><td>If set to <code>true</code>, the softmax function will be computed along axis <code>1</code>. This is applied when the shape of input array differs from the </td></tr>
<tr><td class="paramname">use_ignore</td><td>If set to <code>true</code>, the <code>ignore_label</code> value will not contribute to </td></tr>
<tr><td class="paramname">preserve_shape</td><td>If set to <code>true</code>, the softmax function will be computed along </td></tr>
<tr><td class="paramname">normalization</td><td>Normalizes the gradient. </td></tr>
<tr><td class="paramname">out_grad</td><td>Multiplies gradient with output gradient element-wise. </td></tr>
<tr><td class="paramname">smooth_alpha</td><td><a class="el" href="classmxnet_1_1cpp_1_1Constant.html">Constant</a> for computing a label smoothed version of cross-entropyfor the backwards pass. This constant gets subtracted from theone-hot encoding of the gold label and distributed uniformly toall other </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a5ec4377c6f25f29b8321f21efec43bf8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::SoftmaxOutput </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>label</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>grad_scale</em> = <code>1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>ignore_label</em> = <code>-1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>multi_output</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>use_ignore</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>preserve_shape</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespacemxnet_1_1cpp.html#ae708904c6ad7046fcecfc6c6b7e0ac73">SoftmaxOutputNormalization</a> </td>
<td class="paramname"><em>normalization</em> = <code><a class="el" href="namespacemxnet_1_1cpp.html#ae708904c6ad7046fcecfc6c6b7e0ac73af2655c2dee87cb9b0646f678a630394b">SoftmaxOutputNormalization::kNull</a></code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>out_grad</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>smooth_alpha</em> = <code>0</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Computes the gradient of cross entropy loss with respect to softmax output. </p><pre class="fragment">   - This operator computes the gradient in two steps.
   The cross entropy loss does not actually need to be computed.

   - Applies softmax function on the input array.
   - Computes and returns the gradient of cross entropy loss w.r.t. the softmax

   - The softmax function, cross entropy loss and gradient is given by:

   - Softmax Function:

   .. math:: \text{softmax}(x)_i = \frac{exp(x_i)}{\sum_j exp(x_j)}

   - Cross Entropy Function:

   .. math:: \text{CE(label, output)} = - \sum_i \text{label}_i

   - The gradient of cross entropy loss w.r.t softmax output:

   .. math:: \text{gradient} = \text{output} - \text{label}

   - During forward propagation, the softmax function is computed for each

   For general *N*-D input arrays with shape :math:`(d_1, d_2, ..., d_n)`. The
   :math:`s=d_1 \cdot d_2 \cdot \cdot \cdot d_n`. We can use the parameters
   and `multi_output` to specify the way to compute softmax:

   - By default, `preserve_shape` is ``false``. This operator will reshape the
   into a 2-D array with shape :math:`(d_1, \frac{s}{d_1})` and then compute the
   each row in the reshaped array, and afterwards reshape it back to the original
   :math:`(d_1, d_2, ..., d_n)`.
   - If `preserve_shape` is ``true``, the softmax function will be computed along
   the last axis (`axis` = ``-1``).
   - If `multi_output` is ``true``, the softmax function will be computed along
   the second axis (`axis` = ``1``).

   - During backward propagation, the gradient of cross-entropy loss w.r.t softmax
   The provided label can be a one-hot label array or a probability label array.

   - If the parameter `use_ignore` is ``true``, `ignore_label` can specify input
   with a particular label to be ignored during backward propagation. **This has
   softmax `output` has same shape as `label`**.

   Example::

   data = [[1,2,3,4],[2,2,2,2],[3,3,3,3],[4,4,4,4]]
   label = [1,0,2,3]
   ignore_label = 1
   SoftmaxOutput(data=data, label = label,\
   multi_output=true, use_ignore=true,\
   ignore_label=ignore_label)
   ## forward softmax output
   [[ 0.0320586   0.08714432  0.23688284  0.64391428]
   [ 0.25        0.25        0.25        0.25      ]
   [ 0.25        0.25        0.25        0.25      ]
   [ 0.25        0.25        0.25        0.25      ]]
   ## backward gradient output
   [[ 0.    0.    0.    0.  ]
   [-0.75  0.25  0.25  0.25]
   [ 0.25  0.25 -0.75  0.25]
   [ 0.25  0.25  0.25 -0.75]]
   ## notice that the first row is all 0 because label[0] is 1, which is equal to

   - The parameter `grad_scale` can be used to rescale the gradient, which is
   give each loss function different weights.

   - This operator also supports various ways to normalize the gradient by
   The `normalization` is applied if softmax output has different shape than the
   The `normalization` mode can be set to the followings:

   - ``'null'``: do nothing.
   - ``'batch'``: divide the gradient by the batch size.
   - ``'valid'``: divide the gradient by the number of instances which are not



   Defined in src/operator/softmax_output.cc:L123
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>Input array. </td></tr>
<tr><td class="paramname">label</td><td>Ground truth label. </td></tr>
<tr><td class="paramname">grad_scale</td><td>Scales the gradient by a float factor. </td></tr>
<tr><td class="paramname">ignore_label</td><td>The instances whose <code>labels</code> == <code>ignore_label</code> will be ignored </td></tr>
<tr><td class="paramname">multi_output</td><td>If set to <code>true</code>, the softmax function will be computed along axis <code>1</code>. This is applied when the shape of input array differs from the </td></tr>
<tr><td class="paramname">use_ignore</td><td>If set to <code>true</code>, the <code>ignore_label</code> value will not contribute to </td></tr>
<tr><td class="paramname">preserve_shape</td><td>If set to <code>true</code>, the softmax function will be computed along </td></tr>
<tr><td class="paramname">normalization</td><td>Normalizes the gradient. </td></tr>
<tr><td class="paramname">out_grad</td><td>Multiplies gradient with output gradient element-wise. </td></tr>
<tr><td class="paramname">smooth_alpha</td><td><a class="el" href="classmxnet_1_1cpp_1_1Constant.html">Constant</a> for computing a label smoothed version of cross-entropyfor the backwards pass. This constant gets subtracted from theone-hot encoding of the gold label and distributed uniformly toall other </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a4cef537eb471a1f52e8c539553052bd2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::softsign </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Computes softsign of x element-wise. </p><pre class="fragment">   .. math::
   y = x / (1 + abs(x))

   The storage type of ``softsign`` output is always dense



   Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L145
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>The input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a985feb01bb14fb5ef55b356fe7466eda"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::softsign </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Computes softsign of x element-wise. </p><pre class="fragment">   .. math::
   y = x / (1 + abs(x))

   The storage type of ``softsign`` output is always dense



   Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L145
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>The input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a2c2db6021bb4a9fd444b4905bf639f6d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::sort </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">dmlc::optional&lt; int &gt; </td>
<td class="paramname"><em>axis</em> = <code>dmlc::optional&lt;int&gt;(-1)</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>is_ascend</em> = <code>true</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns a sorted copy of an input array along the given axis. </p><pre class="fragment">   Examples::

   x = [[ 1, 4],
   [ 3, 1]]

   // sorts along the last axis
   sort(x) = [[ 1.,  4.],
   [ 1.,  3.]]

   // flattens and then sorts
   sort(x) = [ 1.,  1.,  3.,  4.]

   // sorts along the first axis
   sort(x, axis=0) = [[ 1.,  1.],
   [ 3.,  4.]]

   // in a descend order
   sort(x, is_ascend=0) = [[ 4.,  1.],
   [ 3.,  1.]]



   Defined in src/operator/tensor/ordering_op.cc:L127
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>The input array </td></tr>
<tr><td class="paramname">axis</td><td>Axis along which to choose sort the input tensor. If not given, the </td></tr>
<tr><td class="paramname">is_ascend</td><td>Whether to sort in ascending or descending order. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="aeb4f996f23cdac3f5a3d2bf2eb507fb8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::sort </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">dmlc::optional&lt; int &gt; </td>
<td class="paramname"><em>axis</em> = <code>dmlc::optional&lt;int&gt;(-1)</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>is_ascend</em> = <code>true</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns a sorted copy of an input array along the given axis. </p><pre class="fragment">   Examples::

   x = [[ 1, 4],
   [ 3, 1]]

   // sorts along the last axis
   sort(x) = [[ 1.,  4.],
   [ 1.,  3.]]

   // flattens and then sorts
   sort(x) = [ 1.,  1.,  3.,  4.]

   // sorts along the first axis
   sort(x, axis=0) = [[ 1.,  1.],
   [ 3.,  4.]]

   // in a descend order
   sort(x, is_ascend=0) = [[ 4.,  1.],
   [ 3.,  1.]]



   Defined in src/operator/tensor/ordering_op.cc:L127
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>The input array </td></tr>
<tr><td class="paramname">axis</td><td>Axis along which to choose sort the input tensor. If not given, the </td></tr>
<tr><td class="paramname">is_ascend</td><td>Whether to sort in ascending or descending order. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="ab8bce3987c7b40b428cdb091068102a0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::space_to_depth </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>block_size</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Rearranges(permutes) blocks of spatial data into depth. Similar to ONNX SpaceToDepth operator: <a href="https://github.com/onnx/onnx/blob/master/docs/Operators.md#SpaceToDepth">https://github.com/onnx/onnx/blob/master/docs/Operators.md#SpaceToDepth</a></p>
<p>The output is a new tensor where the values from height and width dimension are moved to the depth dimension. The reverse of this operation is</p>
<p>.. math::</p>
<p>{gather*} x  = reshape(x, [N, C, H / block_size, block_size, W / block_size, x   = transpose(x , [0, 3, 5, 1, 2, 4]) \ y = reshape(x  , [N, C * (block_size ^ 2), H / block_size, W / {gather*}</p>
<p>where :math:<code>x</code> is an input tensor with default layout as :math:<code>[N, C, H, W]</code>: and :math:<code>y</code> is the output tensor of layout :math:`[N, C * (block_size ^ 2),</p>
<p>Example::</p>
<p>x = [[[[0, 6, 1, 7, 2, 8], [12, 18, 13, 19, 14, 20], [3, 9, 4, 10, 5, 11], [15, 21, 16, 22, 17, 23]]]]</p>
<pre class="fragment">   space_to_depth(x, 2) = [[[[0, 1, 2],
   [3, 4, 5]],
   [[6, 7, 8],
   [9, 10, 11]],
   [[12, 13, 14],
   [15, 16, 17]],
   [[18, 19, 20],
   [21, 22, 23]]]]


   Defined in src/operator/tensor/matrix_op.cc:L999
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>Input ndarray </td></tr>
<tr><td class="paramname">block_size</td><td>Blocks of [block_size. block_size] are moved </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a4616a04f60e88f94591dfb2332f65544"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::space_to_depth </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>block_size</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Rearranges(permutes) blocks of spatial data into depth. Similar to ONNX SpaceToDepth operator: <a href="https://github.com/onnx/onnx/blob/master/docs/Operators.md#SpaceToDepth">https://github.com/onnx/onnx/blob/master/docs/Operators.md#SpaceToDepth</a></p>
<p>The output is a new tensor where the values from height and width dimension are moved to the depth dimension. The reverse of this operation is</p>
<p>.. math::</p>
<p>{gather*} x  = reshape(x, [N, C, H / block_size, block_size, W / block_size, x   = transpose(x , [0, 3, 5, 1, 2, 4]) \ y = reshape(x  , [N, C * (block_size ^ 2), H / block_size, W / {gather*}</p>
<p>where :math:<code>x</code> is an input tensor with default layout as :math:<code>[N, C, H, W]</code>: and :math:<code>y</code> is the output tensor of layout :math:`[N, C * (block_size ^ 2),</p>
<p>Example::</p>
<p>x = [[[[0, 6, 1, 7, 2, 8], [12, 18, 13, 19, 14, 20], [3, 9, 4, 10, 5, 11], [15, 21, 16, 22, 17, 23]]]]</p>
<pre class="fragment">   space_to_depth(x, 2) = [[[[0, 1, 2],
   [3, 4, 5]],
   [[6, 7, 8],
   [9, 10, 11]],
   [[12, 13, 14],
   [15, 16, 17]],
   [[18, 19, 20],
   [21, 22, 23]]]]


   Defined in src/operator/tensor/matrix_op.cc:L999
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>Input ndarray </td></tr>
<tr><td class="paramname">block_size</td><td>Blocks of [block_size. block_size] are moved </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a33597bd1c2770b9cba161f7ad2171879"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::SpatialTransformer </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>loc</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespacemxnet_1_1cpp.html#a0ff49861ba295abeac5d545bfa16b0aa">SpatialTransformerTransformType</a> </td>
<td class="paramname"><em>transform_type</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespacemxnet_1_1cpp.html#a20ce4a2b1581ec74fc957d816d1e19ce">SpatialTransformerSamplerType</a> </td>
<td class="paramname"><em>sampler_type</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> </td>
<td class="paramname"><em>target_shape</em> = <code><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>(0,0)</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Applies a spatial transformer to input feature map. </p><dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>Input data to the SpatialTransformerOp. </td></tr>
<tr><td class="paramname">loc</td><td>localisation net, the output dim should be 6 when transform_type is affine. </td></tr>
<tr><td class="paramname">transform_type</td><td>transformation type </td></tr>
<tr><td class="paramname">sampler_type</td><td>sampling type </td></tr>
<tr><td class="paramname">target_shape</td><td>output shape(h, w) of spatial transformer: (y, x) </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a5e34e5f58fe70a5b2260ee11acda3b26"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::SpatialTransformer </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>loc</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespacemxnet_1_1cpp.html#a0ff49861ba295abeac5d545bfa16b0aa">SpatialTransformerTransformType</a> </td>
<td class="paramname"><em>transform_type</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespacemxnet_1_1cpp.html#a20ce4a2b1581ec74fc957d816d1e19ce">SpatialTransformerSamplerType</a> </td>
<td class="paramname"><em>sampler_type</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> </td>
<td class="paramname"><em>target_shape</em> = <code><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>(0,0)</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Applies a spatial transformer to input feature map. </p><dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>Input data to the SpatialTransformerOp. </td></tr>
<tr><td class="paramname">loc</td><td>localisation net, the output dim should be 6 when transform_type is affine. </td></tr>
<tr><td class="paramname">transform_type</td><td>transformation type </td></tr>
<tr><td class="paramname">sampler_type</td><td>sampling type </td></tr>
<tr><td class="paramname">target_shape</td><td>output shape(h, w) of spatial transformer: (y, x) </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a64eb6f5b502c17ee27062b042a062c15"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::sqrt </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns element-wise square-root value of the input. </p><pre class="fragment">   .. math::
   \textrm{sqrt}(x) = \sqrt{x}

   Example::

   sqrt([4, 9, 16]) = [2, 3, 4]

   The storage type of ``sqrt`` output depends upon the input storage type:

   - sqrt(default) = default
   - sqrt(row_sparse) = row_sparse
   - sqrt(csr) = csr



   Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L846
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>The input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="af4b5f03a9d0fa1011cd5b315cd9d8bb4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::sqrt </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns element-wise square-root value of the input. </p><pre class="fragment">   .. math::
   \textrm{sqrt}(x) = \sqrt{x}

   Example::

   sqrt([4, 9, 16]) = [2, 3, 4]

   The storage type of ``sqrt`` output depends upon the input storage type:

   - sqrt(default) = default
   - sqrt(row_sparse) = row_sparse
   - sqrt(csr) = csr



   Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L846
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>The input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a3b37dc5985254f4eda64f9fc74a24de3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::square </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns element-wise squared value of the input. </p><pre class="fragment">   .. math::
   square(x) = x^2

   Example::

   square([2, 3, 4]) = [4, 9, 16]

   The storage type of ``square`` output depends upon the input storage type:

   - square(default) = default
   - square(row_sparse) = row_sparse
   - square(csr) = csr



   Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L823
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>The input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="af59dc76acf7ba30af0ad766ea088113e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::square </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns element-wise squared value of the input. </p><pre class="fragment">   .. math::
   square(x) = x^2

   Example::

   square([2, 3, 4]) = [4, 9, 16]

   The storage type of ``square`` output depends upon the input storage type:

   - square(default) = default
   - square(row_sparse) = row_sparse
   - square(csr) = csr



   Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L823
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>The input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a191d9896dfcd9cf280007acfeb54ac69"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::squeeze </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const std::vector&lt; <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> &gt; &amp; </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">dmlc::optional&lt; <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> &gt; </td>
<td class="paramname"><em>axis</em> = <code>dmlc::optional&lt;<a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>&gt;()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Remove single-dimensional entries from the shape of an array. Same behavior of defining the output tensor shape as numpy.squeeze for the most See the following note for exception.</p>
<p>Examples::</p>
<p>data = [[[0], [1], [2]]] squeeze(data) = [0, 1, 2] squeeze(data, axis=0) = [[0], [1], [2]] squeeze(data, axis=2) = [[0, 1, 2]] squeeze(data, axis=(0, 2)) = [0, 1, 2]</p>
<p>.. Note:: The output of this operator will keep at least one dimension not removed. For squeeze([[[4]]]) = [4], while in numpy.squeeze, the output will become a scalar.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>data to squeeze </td></tr>
<tr><td class="paramname">axis</td><td>Selects a subset of the single-dimensional entries in the shape. If an </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="aad07b802cc93e4013de3721651c9132d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::squeeze </td>
<td>(</td>
<td class="paramtype">const std::vector&lt; <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> &gt; &amp; </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">dmlc::optional&lt; <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> &gt; </td>
<td class="paramname"><em>axis</em> = <code>dmlc::optional&lt;<a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>&gt;()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Remove single-dimensional entries from the shape of an array. Same behavior of defining the output tensor shape as numpy.squeeze for the most See the following note for exception.</p>
<p>Examples::</p>
<p>data = [[[0], [1], [2]]] squeeze(data) = [0, 1, 2] squeeze(data, axis=0) = [[0], [1], [2]] squeeze(data, axis=2) = [[0, 1, 2]] squeeze(data, axis=(0, 2)) = [0, 1, 2]</p>
<p>.. Note:: The output of this operator will keep at least one dimension not removed. For squeeze([[[4]]]) = [4], while in numpy.squeeze, the output will become a scalar.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>data to squeeze </td></tr>
<tr><td class="paramname">axis</td><td>Selects a subset of the single-dimensional entries in the shape. If an </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a282577d4c4952b15afb4a84891f9f5ed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::stack </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const std::vector&lt; <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> &gt; &amp; </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>num_args</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>axis</em> = <code>0</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Join a sequence of arrays along a new axis. </p><pre class="fragment">   The axis parameter specifies the index of the new axis in the dimensions of the
   result. For example, if axis=0 it will be the first dimension and if axis=-1 it
   will be the last dimension.

   Examples::

   x = [1, 2]
   y = [3, 4]

   stack(x, y) = [[1, 2],
   [3, 4]]
   stack(x, y, axis=1) = [[1, 3],
   [2, 4]]
</pre><dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>List of arrays to stack </td></tr>
<tr><td class="paramname">num_args</td><td>Number of inputs to be stacked. </td></tr>
<tr><td class="paramname">axis</td><td>The axis in the result array along which the input arrays are stacked. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="af42af48d0b7dcde4e027c84e4dcb1206"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::stack </td>
<td>(</td>
<td class="paramtype">const std::vector&lt; <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> &gt; &amp; </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>num_args</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>axis</em> = <code>0</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Join a sequence of arrays along a new axis. </p><pre class="fragment">   The axis parameter specifies the index of the new axis in the dimensions of the
   result. For example, if axis=0 it will be the first dimension and if axis=-1 it
   will be the last dimension.

   Examples::

   x = [1, 2]
   y = [3, 4]

   stack(x, y) = [[1, 2],
   [3, 4]]
   stack(x, y, axis=1) = [[1, 3],
   [2, 4]]
</pre><dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>List of arrays to stack </td></tr>
<tr><td class="paramname">num_args</td><td>Number of inputs to be stacked. </td></tr>
<tr><td class="paramname">axis</td><td>The axis in the result array along which the input arrays are stacked. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="acb4fccaa546283e233c15b46f6465443"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::sum </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">dmlc::optional&lt; <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> &gt; </td>
<td class="paramname"><em>axis</em> = <code>dmlc::optional&lt;<a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>&gt;()</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>keepdims</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>exclude</em> = <code>false</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Computes the sum of array elements over given axes. </p><pre class="fragment">   .. Note::

   `sum` and `sum_axis` are equivalent.
   For ndarray of csr storage type summation along axis 0 and axis 1 is supported.
   Setting keepdims or exclude to True will cause a fallback to dense operator.

   Example::

   data = [[[1, 2], [2, 3], [1, 3]],
   [[1, 4], [4, 3], [5, 2]],
   [[7, 1], [7, 2], [7, 3]]]

   sum(data, axis=1)
   [[  4.   8.]
   [ 10.   9.]
   [ 21.   6.]]

   sum(data, axis=[1,2])
   [ 12.  19.  27.]

   data = [[1, 2, 0],
   [3, 0, 1],
   [4, 1, 0]]

   csr = cast_storage(data, 'csr')

   sum(csr, axis=0)
   [ 8.  3.  1.]

   sum(csr, axis=1)
   [ 3.  4.  5.]



   Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L115
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>The input </td></tr>
<tr><td class="paramname">axis</td><td>The axis or axes along which to perform the reduction. <pre class="fragment">   The default, `axis=()`, will compute over all elements into a
   scalar array with shape `(1,)`.

   If `axis` is int, a reduction is performed on a particular axis.

   If `axis` is a tuple of ints, a reduction is performed on all the axes
   specified in the tuple.

   If `exclude` is true, reduction will be performed on the axes that are
   NOT in axis instead.

   Negative values means indexing from right to left.
</pre> </td></tr>
<tr><td class="paramname">keepdims</td><td>If this is set to <code>True</code>, the reduced axes are left in the result as </td></tr>
<tr><td class="paramname">exclude</td><td>Whether to perform reduction on axis that are NOT in axis instead. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="ac84c546676d48eae71fe9997e232a148"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::sum </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">dmlc::optional&lt; <a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> &gt; </td>
<td class="paramname"><em>axis</em> = <code>dmlc::optional&lt;<a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>&gt;()</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>keepdims</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>exclude</em> = <code>false</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Computes the sum of array elements over given axes. </p><pre class="fragment">   .. Note::

   `sum` and `sum_axis` are equivalent.
   For ndarray of csr storage type summation along axis 0 and axis 1 is supported.
   Setting keepdims or exclude to True will cause a fallback to dense operator.

   Example::

   data = [[[1, 2], [2, 3], [1, 3]],
   [[1, 4], [4, 3], [5, 2]],
   [[7, 1], [7, 2], [7, 3]]]

   sum(data, axis=1)
   [[  4.   8.]
   [ 10.   9.]
   [ 21.   6.]]

   sum(data, axis=[1,2])
   [ 12.  19.  27.]

   data = [[1, 2, 0],
   [3, 0, 1],
   [4, 1, 0]]

   csr = cast_storage(data, 'csr')

   sum(csr, axis=0)
   [ 8.  3.  1.]

   sum(csr, axis=1)
   [ 3.  4.  5.]



   Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L115
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>The input </td></tr>
<tr><td class="paramname">axis</td><td>The axis or axes along which to perform the reduction. <pre class="fragment">   The default, `axis=()`, will compute over all elements into a
   scalar array with shape `(1,)`.

   If `axis` is int, a reduction is performed on a particular axis.

   If `axis` is a tuple of ints, a reduction is performed on all the axes
   specified in the tuple.

   If `exclude` is true, reduction will be performed on the axes that are
   NOT in axis instead.

   Negative values means indexing from right to left.
</pre> </td></tr>
<tr><td class="paramname">keepdims</td><td>If this is set to <code>True</code>, the reduced axes are left in the result as </td></tr>
<tr><td class="paramname">exclude</td><td>Whether to perform reduction on axis that are NOT in axis instead. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a9bb4aa662eea7cdf0e29eeb966a22ba4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::SVMOutput </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>label</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>margin</em> = <code>1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>regularization_coefficient</em> = <code>1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>use_linear</em> = <code>false</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Computes support vector machine based transformation of the input. </p><pre class="fragment">   This tutorial demonstrates using SVM as output layer for classification instead
   https://github.com/dmlc/mxnet/tree/master/example/svm_mnist.
</pre><dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>Input data for SVM transformation. </td></tr>
<tr><td class="paramname">label</td><td>Class label for the input data. </td></tr>
<tr><td class="paramname">margin</td><td>The loss function penalizes outputs that lie outside this margin. </td></tr>
<tr><td class="paramname">regularization_coefficient</td><td>Regularization parameter for the SVM. This balances </td></tr>
<tr><td class="paramname">use_linear</td><td>Whether to use L1-SVM objective. L2-SVM objective is used by default. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a6851ce98be905130b0807873e1c51f17"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::SVMOutput </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>label</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>margin</em> = <code>1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="c__api_8h.html#a4e709067707d9f90c534bd65494ae668">mx_float</a> </td>
<td class="paramname"><em>regularization_coefficient</em> = <code>1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>use_linear</em> = <code>false</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Computes support vector machine based transformation of the input. </p><pre class="fragment">   This tutorial demonstrates using SVM as output layer for classification instead
   https://github.com/dmlc/mxnet/tree/master/example/svm_mnist.
</pre><dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>Input data for SVM transformation. </td></tr>
<tr><td class="paramname">label</td><td>Class label for the input data. </td></tr>
<tr><td class="paramname">margin</td><td>The loss function penalizes outputs that lie outside this margin. </td></tr>
<tr><td class="paramname">regularization_coefficient</td><td>Regularization parameter for the SVM. This balances </td></tr>
<tr><td class="paramname">use_linear</td><td>Whether to use L1-SVM objective. L2-SVM objective is used by default. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="afcb2337221cd6de68df05fb28683e398"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::SwapAxis </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint32_t </td>
<td class="paramname"><em>dim1</em> = <code>0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint32_t </td>
<td class="paramname"><em>dim2</em> = <code>0</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Interchanges two axes of an array. </p><pre class="fragment">   Examples::

   x = [[1, 2, 3]])
   swapaxes(x, 0, 1) = [[ 1],
   [ 2],
   [ 3]]

   x = [[[ 0, 1],
   [ 2, 3]],
   [[ 4, 5],
   [ 6, 7]]]  // (2,2,2) array

   swapaxes(x, 0, 2) = [[[ 0, 4],
   [ 2, 6]],
   [[ 1, 5],
   [ 3, 7]]]


   Defined in src/operator/swapaxis.cc:L70
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>Input array. </td></tr>
<tr><td class="paramname">dim1</td><td>the first axis to be swapped. </td></tr>
<tr><td class="paramname">dim2</td><td>the second axis to be swapped. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="abb2365de281fa565de27fc0e8ae6211e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::SwapAxis </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint32_t </td>
<td class="paramname"><em>dim1</em> = <code>0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint32_t </td>
<td class="paramname"><em>dim2</em> = <code>0</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Interchanges two axes of an array. </p><pre class="fragment">   Examples::

   x = [[1, 2, 3]])
   swapaxes(x, 0, 1) = [[ 1],
   [ 2],
   [ 3]]

   x = [[[ 0, 1],
   [ 2, 3]],
   [[ 4, 5],
   [ 6, 7]]]  // (2,2,2) array

   swapaxes(x, 0, 2) = [[[ 0, 4],
   [ 2, 6]],
   [[ 1, 5],
   [ 3, 7]]]


   Defined in src/operator/swapaxis.cc:L70
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>Input array. </td></tr>
<tr><td class="paramname">dim1</td><td>the first axis to be swapped. </td></tr>
<tr><td class="paramname">dim2</td><td>the second axis to be swapped. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="aa1a8cb38168a5258ec78a8e0956261c0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::take </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>a</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>indices</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>axis</em> = <code>0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespacemxnet_1_1cpp.html#ab8b82422d329aa4497e6891590633325">TakeMode</a> </td>
<td class="paramname"><em>mode</em> = <code><a class="el" href="namespacemxnet_1_1cpp.html#a30fd3a240ebc436ddb671d0c33d5bdc3ae2867cadc2a39b014e89d241b72f3a75">TakeMode::kClip</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Takes elements from an input array along the given axis. </p><pre class="fragment">   This function slices the input array along a particular axis with the provided

   Given data tensor of rank r &gt;= 1, and indices tensor of rank q, gather entries
   dimension of data (by default outer-most one as axis=0) indexed by indices, and
   in an output tensor of rank q + (r - 1).

   Examples::
   x = [4.  5.  6.]

   // Trivial case, take the second element along the first axis.

   take(x, [1]) = [ 5. ]

   // The other trivial case, axis=-1, take the third element along the first axis

   take(x, [3], axis=-1, mode='clip') = [ 6. ]

   x = [[ 1.,  2.],
   [ 3.,  4.],
   [ 5.,  6.]]

   // In this case we will get rows 0 and 1, then 1 and 2. Along axis 0

   take(x, [[0,1],[1,2]]) = [[[ 1.,  2.],
   [ 3.,  4.]],

   [[ 3.,  4.],
   [ 5.,  6.]]]

   // In this case we will get rows 0 and 1, then 1 and 2 (calculated by wrapping
   // Along axis 1

   take(x, [[0, 3], [-1, -2]], axis=1, mode='wrap') = [[[ 1.,  2.],
   [ 3.,  4.]],

   [[ 3.,  4.],
   [ 5.,  6.]]]



   Defined in src/operator/tensor/indexing_op.cc:L434
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">a</td><td>The input array. </td></tr>
<tr><td class="paramname">indices</td><td>The indices of the values to be extracted. </td></tr>
<tr><td class="paramname">axis</td><td>The axis of input array to be taken.For input tensor of rank r, it could </td></tr>
<tr><td class="paramname">mode</td><td>Specify how out-of-bound indices bahave. Default is "clip". "clip" means clip to the range. So, if all indices mentioned are too large, they are replaced by the index that addresses the last element along an axis. "wrap" </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a4e3b22b06d6a4942606eabcb732c0385"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::take </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>a</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>indices</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>axis</em> = <code>0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespacemxnet_1_1cpp.html#ab8b82422d329aa4497e6891590633325">TakeMode</a> </td>
<td class="paramname"><em>mode</em> = <code><a class="el" href="namespacemxnet_1_1cpp.html#a30fd3a240ebc436ddb671d0c33d5bdc3ae2867cadc2a39b014e89d241b72f3a75">TakeMode::kClip</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Takes elements from an input array along the given axis. </p><pre class="fragment">   This function slices the input array along a particular axis with the provided

   Given data tensor of rank r &gt;= 1, and indices tensor of rank q, gather entries
   dimension of data (by default outer-most one as axis=0) indexed by indices, and
   in an output tensor of rank q + (r - 1).

   Examples::
   x = [4.  5.  6.]

   // Trivial case, take the second element along the first axis.

   take(x, [1]) = [ 5. ]

   // The other trivial case, axis=-1, take the third element along the first axis

   take(x, [3], axis=-1, mode='clip') = [ 6. ]

   x = [[ 1.,  2.],
   [ 3.,  4.],
   [ 5.,  6.]]

   // In this case we will get rows 0 and 1, then 1 and 2. Along axis 0

   take(x, [[0,1],[1,2]]) = [[[ 1.,  2.],
   [ 3.,  4.]],

   [[ 3.,  4.],
   [ 5.,  6.]]]

   // In this case we will get rows 0 and 1, then 1 and 2 (calculated by wrapping
   // Along axis 1

   take(x, [[0, 3], [-1, -2]], axis=1, mode='wrap') = [[[ 1.,  2.],
   [ 3.,  4.]],

   [[ 3.,  4.],
   [ 5.,  6.]]]



   Defined in src/operator/tensor/indexing_op.cc:L434
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">a</td><td>The input array. </td></tr>
<tr><td class="paramname">indices</td><td>The indices of the values to be extracted. </td></tr>
<tr><td class="paramname">axis</td><td>The axis of input array to be taken.For input tensor of rank r, it could </td></tr>
<tr><td class="paramname">mode</td><td>Specify how out-of-bound indices bahave. Default is "clip". "clip" means clip to the range. So, if all indices mentioned are too large, they are replaced by the index that addresses the last element along an axis. "wrap" </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a9a60483ca0304c89eed9c3cdc4bc9f9e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::tan </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Computes the element-wise tangent of the input array. </p><pre class="fragment">   The input should be in radians (:math:`2\pi` rad equals 360 degrees).

   .. math::
   tan([0, \pi/4, \pi/2]) = [0, 1, -inf]

   The storage type of ``tan`` output depends upon the input storage type:

   - tan(default) = default
   - tan(row_sparse) = row_sparse
   - tan(csr) = csr



   Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L83
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>The input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a058cbde68708560604f8d8ab299a41fb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::tan </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Computes the element-wise tangent of the input array. </p><pre class="fragment">   The input should be in radians (:math:`2\pi` rad equals 360 degrees).

   .. math::
   tan([0, \pi/4, \pi/2]) = [0, 1, -inf]

   The storage type of ``tan`` output depends upon the input storage type:

   - tan(default) = default
   - tan(row_sparse) = row_sparse
   - tan(csr) = csr



   Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L83
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>The input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a06e84f93bdc83cac7bb8d74cdb1bf941"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::tanh </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns the hyperbolic tangent of the input array, computed element-wise. </p><pre class="fragment">   .. math::
   tanh(x) = sinh(x) / cosh(x)

   The storage type of ``tanh`` output depends upon the input storage type:

   - tanh(default) = default
   - tanh(row_sparse) = row_sparse
   - tanh(csr) = csr



   Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L234
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>The input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a6fc758629ea0443dd943f0c5f03e3fb3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::tanh </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns the hyperbolic tangent of the input array, computed element-wise. </p><pre class="fragment">   .. math::
   tanh(x) = sinh(x) / cosh(x)

   The storage type of ``tanh`` output depends upon the input storage type:

   - tanh(default) = default
   - tanh(row_sparse) = row_sparse
   - tanh(csr) = csr



   Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L234
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>The input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="af04fa0ca4da5bce545b8294d4f1a4174"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::tile </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> </td>
<td class="paramname"><em>reps</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Repeats the whole array multiple times. </p><pre class="fragment">   If ``reps`` has length *d*, and input array has dimension of *n*. There are
   three cases:

   - **n=d**. Repeat *i*-th dimension of the input by ``reps[i]`` times::

   x = [[1, 2],
   [3, 4]]

   tile(x, reps=(2,3)) = [[ 1.,  2.,  1.,  2.,  1.,  2.],
   [ 3.,  4.,  3.,  4.,  3.,  4.],
   [ 1.,  2.,  1.,  2.,  1.,  2.],
   [ 3.,  4.,  3.,  4.,  3.,  4.]]

   - **n&gt;d**. ``reps`` is promoted to length *n* by pre-pending 1's to it. Thus for
   an input shape ``(2,3)``, ``repos=(2,)`` is treated as ``(1,2)``::


   tile(x, reps=(2,)) = [[ 1.,  2.,  1.,  2.],
   [ 3.,  4.,  3.,  4.]]

   - **n&lt;d**. The input is promoted to be d-dimensional by prepending new axes. So
   shape ``(2,2)`` array is promoted to ``(1,2,2)`` for 3-D replication::

   tile(x, reps=(2,2,3)) = [[[ 1.,  2.,  1.,  2.,  1.,  2.],
   [ 3.,  4.,  3.,  4.,  3.,  4.],
   [ 1.,  2.,  1.,  2.,  1.,  2.],
   [ 3.,  4.,  3.,  4.,  3.,  4.]],

   [[ 1.,  2.,  1.,  2.,  1.,  2.],
   [ 3.,  4.,  3.,  4.,  3.,  4.],
   [ 1.,  2.,  1.,  2.,  1.,  2.],
   [ 3.,  4.,  3.,  4.,  3.,  4.]]]


   Defined in src/operator/tensor/matrix_op.cc:L752
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>Input data array </td></tr>
<tr><td class="paramname">reps</td><td>The number of times for repeating the tensor a. Each dim size of reps must be a positive integer. If reps has length d, the result will have dimension of max(d, a.ndim); If a.ndim &lt; d, a is promoted to be d-dimensional by prepending </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="aef94ad2c501f07193638bcf581a9fcb5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::tile </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> </td>
<td class="paramname"><em>reps</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Repeats the whole array multiple times. </p><pre class="fragment">   If ``reps`` has length *d*, and input array has dimension of *n*. There are
   three cases:

   - **n=d**. Repeat *i*-th dimension of the input by ``reps[i]`` times::

   x = [[1, 2],
   [3, 4]]

   tile(x, reps=(2,3)) = [[ 1.,  2.,  1.,  2.,  1.,  2.],
   [ 3.,  4.,  3.,  4.,  3.,  4.],
   [ 1.,  2.,  1.,  2.,  1.,  2.],
   [ 3.,  4.,  3.,  4.,  3.,  4.]]

   - **n&gt;d**. ``reps`` is promoted to length *n* by pre-pending 1's to it. Thus for
   an input shape ``(2,3)``, ``repos=(2,)`` is treated as ``(1,2)``::


   tile(x, reps=(2,)) = [[ 1.,  2.,  1.,  2.],
   [ 3.,  4.,  3.,  4.]]

   - **n&lt;d**. The input is promoted to be d-dimensional by prepending new axes. So
   shape ``(2,2)`` array is promoted to ``(1,2,2)`` for 3-D replication::

   tile(x, reps=(2,2,3)) = [[[ 1.,  2.,  1.,  2.,  1.,  2.],
   [ 3.,  4.,  3.,  4.,  3.,  4.],
   [ 1.,  2.,  1.,  2.,  1.,  2.],
   [ 3.,  4.,  3.,  4.,  3.,  4.]],

   [[ 1.,  2.,  1.,  2.,  1.,  2.],
   [ 3.,  4.,  3.,  4.,  3.,  4.],
   [ 1.,  2.,  1.,  2.,  1.,  2.],
   [ 3.,  4.,  3.,  4.,  3.,  4.]]]


   Defined in src/operator/tensor/matrix_op.cc:L752
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>Input data array </td></tr>
<tr><td class="paramname">reps</td><td>The number of times for repeating the tensor a. Each dim size of reps must be a positive integer. If reps has length d, the result will have dimension of max(d, a.ndim); If a.ndim &lt; d, a is promoted to be d-dimensional by prepending </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a9316e5d42a968b40458cb89d2481727c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::topk </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">dmlc::optional&lt; int &gt; </td>
<td class="paramname"><em>axis</em> = <code>dmlc::optional&lt;int&gt;(-1)</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>k</em> = <code>1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespacemxnet_1_1cpp.html#a3d86bd343a0a3b4d7f1205cadaf24855">TopkRetTyp</a> </td>
<td class="paramname"><em>ret_typ</em> = <code><a class="el" href="namespacemxnet_1_1cpp.html#a3d86bd343a0a3b4d7f1205cadaf24855ac514f90edc83d38e3527476bbfb8e5e8">TopkRetTyp::kIndices</a></code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>is_ascend</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespacemxnet_1_1cpp.html#a992f67b993b07623d888ddcf01f9ddc3">TopkDtype</a> </td>
<td class="paramname"><em>dtype</em> = <code><a class="el" href="namespacemxnet_1_1cpp.html#a8e907a5fbbe4ec21628e500b34a5f35da9a78d6a569d086b524c3caf8c2522f96">TopkDtype::kFloat32</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns the top <em>k</em> elements in an input array along the given axis. The returned elements will be sorted.</p>
<p>Examples::</p>
<p>x = [[ 0.3, 0.2, 0.4], [ 0.1, 0.3, 0.2]]</p>
<p>// returns an index of the largest element on last axis topk(x) = [[ 2.], [ 1.]]</p>
<p>// returns the value of top-2 largest elements on last axis topk(x, ret_typ='value', k=2) = [[ 0.4, 0.3], [ 0.3, 0.2]]</p>
<p>// returns the value of top-2 smallest elements on last axis topk(x, ret_typ='value', k=2, is_ascend=1) = [[ 0.2 , 0.3], [ 0.1 , 0.2]]</p>
<p>// returns the value of top-2 largest elements on axis 0 topk(x, axis=0, ret_typ='value', k=2) = [[ 0.3, 0.3, 0.4], [ 0.1, 0.2, 0.2]]</p>
<p>// flattens and then returns list of both values and indices topk(x, ret_typ='both', k=2) = [[[ 0.4, 0.3], [ 0.3, 0.2]] , [[ 2., 0.], [</p>
<pre class="fragment">   Defined in src/operator/tensor/ordering_op.cc:L64
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>The input array </td></tr>
<tr><td class="paramname">axis</td><td>Axis along which to choose the top k indices. If not given, the flattened </td></tr>
<tr><td class="paramname">k</td><td>Number of top elements to select, should be always smaller than or equal to </td></tr>
<tr><td class="paramname">ret_typ</td><td>The return type. "value" means to return the top k values, "indices" means to return the indices of the top k values, "mask" means to return a mask array containing 0 and 1. 1 means the top k values. "both" means to return a list of both values and </td></tr>
<tr><td class="paramname">is_ascend</td><td>Whether to choose k largest or k smallest elements. Top K largest </td></tr>
<tr><td class="paramname">dtype</td><td>DType of the output indices when ret_typ is "indices" or "both". An error </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a2cb1728a95b30486ece5317bdd12dbe0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::topk </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">dmlc::optional&lt; int &gt; </td>
<td class="paramname"><em>axis</em> = <code>dmlc::optional&lt;int&gt;(-1)</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>k</em> = <code>1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespacemxnet_1_1cpp.html#a3d86bd343a0a3b4d7f1205cadaf24855">TopkRetTyp</a> </td>
<td class="paramname"><em>ret_typ</em> = <code><a class="el" href="namespacemxnet_1_1cpp.html#a3d86bd343a0a3b4d7f1205cadaf24855ac514f90edc83d38e3527476bbfb8e5e8">TopkRetTyp::kIndices</a></code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>is_ascend</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespacemxnet_1_1cpp.html#a992f67b993b07623d888ddcf01f9ddc3">TopkDtype</a> </td>
<td class="paramname"><em>dtype</em> = <code><a class="el" href="namespacemxnet_1_1cpp.html#a8e907a5fbbe4ec21628e500b34a5f35da9a78d6a569d086b524c3caf8c2522f96">TopkDtype::kFloat32</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns the top <em>k</em> elements in an input array along the given axis. The returned elements will be sorted.</p>
<p>Examples::</p>
<p>x = [[ 0.3, 0.2, 0.4], [ 0.1, 0.3, 0.2]]</p>
<p>// returns an index of the largest element on last axis topk(x) = [[ 2.], [ 1.]]</p>
<p>// returns the value of top-2 largest elements on last axis topk(x, ret_typ='value', k=2) = [[ 0.4, 0.3], [ 0.3, 0.2]]</p>
<p>// returns the value of top-2 smallest elements on last axis topk(x, ret_typ='value', k=2, is_ascend=1) = [[ 0.2 , 0.3], [ 0.1 , 0.2]]</p>
<p>// returns the value of top-2 largest elements on axis 0 topk(x, axis=0, ret_typ='value', k=2) = [[ 0.3, 0.3, 0.4], [ 0.1, 0.2, 0.2]]</p>
<p>// flattens and then returns list of both values and indices topk(x, ret_typ='both', k=2) = [[[ 0.4, 0.3], [ 0.3, 0.2]] , [[ 2., 0.], [</p>
<pre class="fragment">   Defined in src/operator/tensor/ordering_op.cc:L64
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>The input array </td></tr>
<tr><td class="paramname">axis</td><td>Axis along which to choose the top k indices. If not given, the flattened </td></tr>
<tr><td class="paramname">k</td><td>Number of top elements to select, should be always smaller than or equal to </td></tr>
<tr><td class="paramname">ret_typ</td><td>The return type. "value" means to return the top k values, "indices" means to return the indices of the top k values, "mask" means to return a mask array containing 0 and 1. 1 means the top k values. "both" means to return a list of both values and </td></tr>
<tr><td class="paramname">is_ascend</td><td>Whether to choose k largest or k smallest elements. Top K largest </td></tr>
<tr><td class="paramname">dtype</td><td>DType of the output indices when ret_typ is "indices" or "both". An error </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a159e3b3996fcfbc2881330aa6373a7db"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::transpose </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> </td>
<td class="paramname"><em>axes</em> = <code><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Permutes the dimensions of an array. </p><pre class="fragment">   Examples::

   x = [[ 1, 2],
   [ 3, 4]]

   transpose(x) = [[ 1.,  3.],
   [ 2.,  4.]]

   x = [[[ 1.,  2.],
   [ 3.,  4.]],

   [[ 5.,  6.],
   [ 7.,  8.]]]

   transpose(x) = [[[ 1.,  5.],
   [ 3.,  7.]],

   [[ 2.,  6.],
   [ 4.,  8.]]]

   transpose(x, axes=(1,0,2)) = [[[ 1.,  2.],
   [ 5.,  6.]],

   [[ 3.,  4.],
   [ 7.,  8.]]]


   Defined in src/operator/tensor/matrix_op.cc:L311
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>Source input </td></tr>
<tr><td class="paramname">axes</td><td>Target axis order. By default the axes will be inverted. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a7e5b6a53565d55a8b8e1c98f95b4547b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::transpose </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a> </td>
<td class="paramname"><em>axes</em> = <code><a class="el" href="structmxnet_1_1cpp_1_1Shape.html">Shape</a>()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Permutes the dimensions of an array. </p><pre class="fragment">   Examples::

   x = [[ 1, 2],
   [ 3, 4]]

   transpose(x) = [[ 1.,  3.],
   [ 2.,  4.]]

   x = [[[ 1.,  2.],
   [ 3.,  4.]],

   [[ 5.,  6.],
   [ 7.,  8.]]]

   transpose(x) = [[[ 1.,  5.],
   [ 3.,  7.]],

   [[ 2.,  6.],
   [ 4.,  8.]]]

   transpose(x, axes=(1,0,2)) = [[[ 1.,  2.],
   [ 5.,  6.]],

   [[ 3.,  4.],
   [ 7.,  8.]]]


   Defined in src/operator/tensor/matrix_op.cc:L311
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>Source input </td></tr>
<tr><td class="paramname">axes</td><td>Target axis order. By default the axes will be inverted. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a308aaabadc48791c4924c8a71cba8ca4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::trunc </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Return the element-wise truncated value of the input. </p><pre class="fragment">   The truncated value of the scalar x is the nearest integer i which is closer to
   zero than x is. In short, the fractional part of the signed number x is

   Example::

   trunc([-2.1, -1.9, 1.5, 1.9, 2.1]) = [-2., -1.,  1.,  1.,  2.]

   The storage type of ``trunc`` output depends upon the input storage type:

   - trunc(default) = default
   - trunc(row_sparse) = row_sparse
   - trunc(csr) = csr



   Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L785
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>The input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a757f20c97f47b0f6f720df6686d97cf9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::trunc </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Return the element-wise truncated value of the input. </p><pre class="fragment">   The truncated value of the scalar x is the nearest integer i which is closer to
   zero than x is. In short, the fractional part of the signed number x is

   Example::

   trunc([-2.1, -1.9, 1.5, 1.9, 2.1]) = [-2., -1.,  1.,  1.,  2.]

   The storage type of ``trunc`` output depends upon the input storage type:

   - trunc(default) = default
   - trunc(row_sparse) = row_sparse
   - trunc(csr) = csr



   Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L785
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>The input array. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="ac02c4b9e4c60499b3931d120ef51eca3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::UpSampling </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const std::vector&lt; <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> &gt; &amp; </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint32_t </td>
<td class="paramname"><em>scale</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespacemxnet_1_1cpp.html#a9c9a4644f19e7ed3c729165de2e963ab">UpSamplingSampleType</a> </td>
<td class="paramname"><em>sample_type</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>num_args</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint32_t </td>
<td class="paramname"><em>num_filter</em> = <code>0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespacemxnet_1_1cpp.html#afce90445dba4ab6be903251cb0c960ef">UpSamplingMultiInputMode</a> </td>
<td class="paramname"><em>multi_input_mode</em> = <code><a class="el" href="namespacemxnet_1_1cpp.html#afce90445dba4ab6be903251cb0c960efa07f24210ce07b41cf8370dd8e9a3eb70">UpSamplingMultiInputMode::kConcat</a></code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint64_t </td>
<td class="paramname"><em>workspace</em> = <code>512</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Performs nearest neighbor/bilinear up sampling to inputs. </p><dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>Array of tensors to upsample </td></tr>
<tr><td class="paramname">scale</td><td>Up sampling scale </td></tr>
<tr><td class="paramname">sample_type</td><td>upsampling method </td></tr>
<tr><td class="paramname">num_args</td><td>Number of inputs to be upsampled. For nearest neighbor upsampling, this can be 1-N; the size of output will be(scale*h_0,scale*w_0) and all other inputs will be upsampled to thesame size. For bilinear upsampling this must be </td></tr>
<tr><td class="paramname">num_filter</td><td>Input filter. Only used by bilinear sample_type. </td></tr>
<tr><td class="paramname">multi_input_mode</td><td>How to handle multiple input. concat means concatenate upsampled images along the channel dimension. sum means add all images </td></tr>
<tr><td class="paramname">workspace</td><td>Tmp workspace for deconvolution (MB) </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a34b5385f8b52334cfedaa5a7f4ce68c9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::UpSampling </td>
<td>(</td>
<td class="paramtype">const std::vector&lt; <a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> &gt; &amp; </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint32_t </td>
<td class="paramname"><em>scale</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespacemxnet_1_1cpp.html#a9c9a4644f19e7ed3c729165de2e963ab">UpSamplingSampleType</a> </td>
<td class="paramname"><em>sample_type</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>num_args</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint32_t </td>
<td class="paramname"><em>num_filter</em> = <code>0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespacemxnet_1_1cpp.html#afce90445dba4ab6be903251cb0c960ef">UpSamplingMultiInputMode</a> </td>
<td class="paramname"><em>multi_input_mode</em> = <code><a class="el" href="namespacemxnet_1_1cpp.html#afce90445dba4ab6be903251cb0c960efa07f24210ce07b41cf8370dd8e9a3eb70">UpSamplingMultiInputMode::kConcat</a></code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint64_t </td>
<td class="paramname"><em>workspace</em> = <code>512</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Performs nearest neighbor/bilinear up sampling to inputs. </p><dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>Array of tensors to upsample </td></tr>
<tr><td class="paramname">scale</td><td>Up sampling scale </td></tr>
<tr><td class="paramname">sample_type</td><td>upsampling method </td></tr>
<tr><td class="paramname">num_args</td><td>Number of inputs to be upsampled. For nearest neighbor upsampling, this can be 1-N; the size of output will be(scale*h_0,scale*w_0) and all other inputs will be upsampled to thesame size. For bilinear upsampling this must be </td></tr>
<tr><td class="paramname">num_filter</td><td>Input filter. Only used by bilinear sample_type. </td></tr>
<tr><td class="paramname">multi_input_mode</td><td>How to handle multiple input. concat means concatenate upsampled images along the channel dimension. sum means add all images </td></tr>
<tr><td class="paramname">workspace</td><td>Tmp workspace for deconvolution (MB) </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a5b247c5c4425fb127b5b99634efd11fd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::where </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>condition</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>x</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>y</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Return the elements, either from x or y, depending on the condition. </p><pre class="fragment">   Given three ndarrays, condition, x, and y, return an ndarray with the elements
   depending on the elements from condition are true or false. x and y must have
   If condition has the same shape as x, each element in the output array is from
   corresponding element in the condition is true, and from y if false.

   If condition does not have the same shape as x, it must be a 1D array whose
   the same as x's first dimension size. Each row of the output array is from x's
   if the corresponding element from condition is true, and from y's row if false.

   Note that all non-zero values are interpreted as ``True`` in condition.

   Examples::

   x = [[1, 2], [3, 4]]
   y = [[5, 6], [7, 8]]
   cond = [[0, 1], [-1, 0]]

   where(cond, x, y) = [[5, 2], [3, 8]]

   csr_cond = cast_storage(cond, 'csr')

   where(csr_cond, x, y) = [[5, 2], [3, 8]]



   Defined in src/operator/tensor/control_flow_op.cc:L57
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">condition</td><td>condition array </td></tr>
<tr><td class="paramname">x</td><td></td></tr>
<tr><td class="paramname">y</td><td></td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a2345fcd1e2232a7b4f3b21416f71b151"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::where </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>condition</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>x</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>y</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Return the elements, either from x or y, depending on the condition. </p><pre class="fragment">   Given three ndarrays, condition, x, and y, return an ndarray with the elements
   depending on the elements from condition are true or false. x and y must have
   If condition has the same shape as x, each element in the output array is from
   corresponding element in the condition is true, and from y if false.

   If condition does not have the same shape as x, it must be a 1D array whose
   the same as x's first dimension size. Each row of the output array is from x's
   if the corresponding element from condition is true, and from y's row if false.

   Note that all non-zero values are interpreted as ``True`` in condition.

   Examples::

   x = [[1, 2], [3, 4]]
   y = [[5, 6], [7, 8]]
   cond = [[0, 1], [-1, 0]]

   where(cond, x, y) = [[5, 2], [3, 8]]

   csr_cond = cast_storage(cond, 'csr')

   where(csr_cond, x, y) = [[5, 2], [3, 8]]



   Defined in src/operator/tensor/control_flow_op.cc:L57
</pre> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">condition</td><td>condition array </td></tr>
<tr><td class="paramname">x</td><td></td></tr>
<tr><td class="paramname">y</td><td></td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a71d184875ccdfcd9046a0520c5c29899"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::zeros_like </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>symbol_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Return an array of zeros with the same shape, type and storage type as the input array.</p>
<p>The storage type of <code>zeros_like</code> output depends on the storage type of the</p>
<ul>
<li>zeros_like(row_sparse) = row_sparse</li>
<li>zeros_like(csr) = csr</li>
<li>zeros_like(default) = default</li>
</ul>
<p>Examples::</p>
<p>x = [[ 1., 1., 1.], [ 1., 1., 1.]]</p>
<p>zeros_like(x) = [[ 0., 0., 0.], [ 0., 0., 0.]]</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">symbol_name</td><td>name of the resulting symbol </td></tr>
<tr><td class="paramname">data</td><td>The input </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
<a class="anchor" id="a3cccee07dd82261d6325ceb08fbf3fe3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> mxnet::cpp::zeros_like </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classmxnet_1_1cpp_1_1Symbol.html">Symbol</a> </td>
<td class="paramname"><em>data</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Return an array of zeros with the same shape, type and storage type as the input array.</p>
<p>The storage type of <code>zeros_like</code> output depends on the storage type of the</p>
<ul>
<li>zeros_like(row_sparse) = row_sparse</li>
<li>zeros_like(csr) = csr</li>
<li>zeros_like(default) = default</li>
</ul>
<p>Examples::</p>
<p>x = [[ 1., 1., 1.], [ 1., 1., 1.]]</p>
<p>zeros_like(x) = [[ 0., 0., 0.], [ 0., 0., 0.]]</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>The input </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new symbol </dd></dl>
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Sep 19 2019 12:47:36 for mxnet by  <a href="http://www.doxygen.org/index.html">
<img alt="doxygen" class="footer" src="doxygen.png"/>
</a> 1.8.11
</small></address>
</body>
</html>
