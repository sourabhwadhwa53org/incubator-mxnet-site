<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta content="text/xhtml;charset=utf-8" http-equiv="Content-Type"/>
<meta content="IE=9" http-equiv="X-UA-Compatible"/>
<meta content="Doxygen 1.8.11" name="generator"/>
<title>mxnet: mxnet Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script src="jquery.js" type="text/javascript"></script>
<script src="dynsections.js" type="text/javascript"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script src="search/searchdata.js" type="text/javascript"></script>
<script src="search/search.js" type="text/javascript"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellpadding="0" cellspacing="0">
<tbody>
<tr style="height: 56px;">
<td id="projectalign" style="padding-left: 0.5em;">
<div id="projectname">mxnet
   </div>
</td>
</tr>
</tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<div class="tabs" id="navrow1">
<ul class="tablist">
<li><a href="index.html"><span>Main Page</span></a></li>
<li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
<li><a href="annotated.html"><span>Classes</span></a></li>
<li><a href="files.html"><span>Files</span></a></li>
<li>
<div class="MSearchBoxInactive" id="MSearchBox">
<span class="left">
<img alt="" id="MSearchSelect" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()" src="search/mag_sel.png"/>
<input accesskey="S" id="MSearchField" onblur="searchBox.OnSearchFieldFocus(false)" onfocus="searchBox.OnSearchFieldFocus(true)" onkeyup="searchBox.OnSearchFieldChange(event)" type="text" value="Search"/>
</span><span class="right">
<a href="javascript:searchBox.CloseResultsWindow()" id="MSearchClose"><img alt="" border="0" id="MSearchCloseImg" src="search/close.png"/></a>
</span>
</div>
</li>
</ul>
</div>
<div class="tabs2" id="navrow2">
<ul class="tablist">
<li><a href="namespaces.html"><span>Namespace List</span></a></li>
<li><a href="namespacemembers.html"><span>Namespace Members</span></a></li>
</ul>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onkeydown="return searchBox.OnSearchSelectKey(event)" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe frameborder="0" id="MSearchResults" name="MSearchResults" src="javascript:void(0)">
</iframe>
</div>
</div><!-- top -->
<div class="header">
<div class="summary">
<a href="#namespaces">Namespaces</a> |
<a href="#nested-classes">Classes</a> |
<a href="#typedef-members">Typedefs</a> |
<a href="#enum-members">Enumerations</a> |
<a href="#func-members">Functions</a> |
<a href="#var-members">Variables</a> </div>
<div class="headertitle">
<div class="title">mxnet Namespace Reference</div> </div>
</div><!--header-->
<div class="contents">
<p>namespace of mxnet  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacemxnet_1_1common"><td align="right" class="memItemLeft" valign="top">  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1common.html">common</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:namespacemxnet_1_1cpp"><td align="right" class="memItemLeft" valign="top">  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html">cpp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:namespacemxnet_1_1csr"><td align="right" class="memItemLeft" valign="top">  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1csr.html">csr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:namespacemxnet_1_1engine"><td align="right" class="memItemLeft" valign="top">  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1engine.html">engine</a></td></tr>
<tr class="memdesc:namespacemxnet_1_1engine"><td class="mdescLeft"> </td><td class="mdescRight">namespace of engine internal types. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:namespacemxnet_1_1op"><td align="right" class="memItemLeft" valign="top">  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1op.html">op</a></td></tr>
<tr class="memdesc:namespacemxnet_1_1op"><td class="mdescLeft"> </td><td class="mdescRight">namespace of arguments <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:namespacemxnet_1_1rowsparse"><td align="right" class="memItemLeft" valign="top">  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1rowsparse.html">rowsparse</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structmxnet_1_1CachedOpParam.html">CachedOpParam</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">CachedOp Parameters.  <a href="structmxnet_1_1CachedOpParam.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structmxnet_1_1Context.html">Context</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight"><a class="el" href="structmxnet_1_1Context.html" title="Context information about the execution environment. ">Context</a> information about the execution environment.  <a href="structmxnet_1_1Context.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structmxnet_1_1DataBatch.html">DataBatch</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight"><a class="el" href="structmxnet_1_1DataBatch.html" title="DataBatch of NDArray, returned by Iterator. ">DataBatch</a> of <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>, returned by Iterator.  <a href="structmxnet_1_1DataBatch.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structmxnet_1_1DataInst.html">DataInst</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">a single data instance  <a href="structmxnet_1_1DataInst.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structmxnet_1_1DataIteratorReg.html">DataIteratorReg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">Registry entry for DataIterator factory functions.  <a href="structmxnet_1_1DataIteratorReg.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1Engine.html">Engine</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">Dependency engine that schedules operations.  <a href="classmxnet_1_1Engine.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1Executor.html">Executor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight"><a class="el" href="classmxnet_1_1Executor.html" title="Executor of a computation graph. Executor can be created by Binding a symbol. ">Executor</a> of a computation graph. <a class="el" href="classmxnet_1_1Executor.html" title="Executor of a computation graph. Executor can be created by Binding a symbol. ">Executor</a> can be created by Binding a symbol.  <a href="classmxnet_1_1Executor.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1IIterator.html">IIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">iterator type  <a href="classmxnet_1_1IIterator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1Imperative.html">Imperative</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">runtime functions for <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> <a href="classmxnet_1_1Imperative.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1KVStore.html">KVStore</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">distributed key-value store  <a href="classmxnet_1_1KVStore.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">ndarray interface  <a href="classmxnet_1_1NDArray.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structmxnet_1_1NDArrayFunctionReg.html">NDArrayFunctionReg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">Registry entry for NDArrayFunction.  <a href="structmxnet_1_1NDArrayFunctionReg.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structmxnet_1_1OpContext.html">OpContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">All the possible information needed by <a class="el" href="classmxnet_1_1Operator.html#a3dbe23d985df86da51eeb868439872dd" title="perform a forward operation of Operator, save the output to TBlob. ">Operator.Forward</a> and Backward This is the superset of <a class="el" href="structmxnet_1_1RunContext.html" title="execution time context. The information needed in runtime for actual execution. ">RunContext</a>. We use this data structure to bookkeep everything needed by Forward and Backward.  <a href="structmxnet_1_1OpContext.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1Operator.html">Operator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight"><a class="el" href="classmxnet_1_1Operator.html" title="Operator interface. Operator defines basic operation unit of optimized computation graph in mxnet...">Operator</a> interface. <a class="el" href="classmxnet_1_1Operator.html" title="Operator interface. Operator defines basic operation unit of optimized computation graph in mxnet...">Operator</a> defines basic operation unit of optimized computation graph in mxnet. This interface relies on pre-allocated memory in <a class="el" href="classmxnet_1_1TBlob.html" title="tensor blob class that can be used to hold tensor of any dimension, any device and any data type...">TBlob</a>, the caller need to set the memory region in <a class="el" href="classmxnet_1_1TBlob.html" title="tensor blob class that can be used to hold tensor of any dimension, any device and any data type...">TBlob</a> correctly before calling Forward and Backward.  <a href="classmxnet_1_1Operator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1OperatorProperty.html">OperatorProperty</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight"><a class="el" href="classmxnet_1_1OperatorProperty.html" title="OperatorProperty is a object that stores all information about Operator. It also contains method to g...">OperatorProperty</a> is a object that stores all information about <a class="el" href="classmxnet_1_1Operator.html" title="Operator interface. Operator defines basic operation unit of optimized computation graph in mxnet...">Operator</a>. It also contains method to generate context(device) specific operators.  <a href="classmxnet_1_1OperatorProperty.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structmxnet_1_1OperatorPropertyReg.html">OperatorPropertyReg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">Registry entry for <a class="el" href="classmxnet_1_1OperatorProperty.html" title="OperatorProperty is a object that stores all information about Operator. It also contains method to g...">OperatorProperty</a> factory functions.  <a href="structmxnet_1_1OperatorPropertyReg.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1OpStatePtr.html">OpStatePtr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight"><a class="el" href="classmxnet_1_1Operator.html" title="Operator interface. Operator defines basic operation unit of optimized computation graph in mxnet...">Operator</a> state. This is a pointer type, its content is mutable even if <a class="el" href="classmxnet_1_1OpStatePtr.html" title="Operator state. This is a pointer type, its content is mutable even if OpStatePtr is const...">OpStatePtr</a> is const.  <a href="classmxnet_1_1OpStatePtr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structmxnet_1_1Resource.html">Resource</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">Resources used by mxnet operations. A resource is something special other than <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>, but will still participate.  <a href="structmxnet_1_1Resource.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1ResourceManager.html">ResourceManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">Global resource manager.  <a href="classmxnet_1_1ResourceManager.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structmxnet_1_1ResourceRequest.html">ResourceRequest</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">The resources that can be requested by <a class="el" href="classmxnet_1_1Operator.html" title="Operator interface. Operator defines basic operation unit of optimized computation graph in mxnet...">Operator</a>.  <a href="structmxnet_1_1ResourceRequest.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structmxnet_1_1RunContext.html">RunContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">execution time context. The information needed in runtime for actual execution.  <a href="structmxnet_1_1RunContext.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1Storage.html">Storage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight"><a class="el" href="classmxnet_1_1Storage.html" title="Storage manager across multiple devices. ">Storage</a> manager across multiple devices.  <a href="classmxnet_1_1Storage.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1TBlob.html">TBlob</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">tensor blob class that can be used to hold tensor of any dimension, any device and any data type, This is a weak type that can be used to transfer data through interface <a class="el" href="classmxnet_1_1TBlob.html" title="tensor blob class that can be used to hold tensor of any dimension, any device and any data type...">TBlob</a> itself do not involve any arithmentic operations, but it can be converted to tensor of fixed dimension for further operations  <a href="classmxnet_1_1TBlob.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a850af9d76d9d4beaeb5234c1434973e3"><td align="right" class="memItemLeft" valign="top">typedef mshadow::cpu </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#a850af9d76d9d4beaeb5234c1434973e3">cpu</a></td></tr>
<tr class="memdesc:a850af9d76d9d4beaeb5234c1434973e3"><td class="mdescLeft"> </td><td class="mdescRight">mxnet cpu  <a href="#a850af9d76d9d4beaeb5234c1434973e3">More...</a><br/></td></tr>
<tr class="separator:a850af9d76d9d4beaeb5234c1434973e3"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a31ef33571a4f6ba8847eeee1f4907141"><td align="right" class="memItemLeft" valign="top">typedef mshadow::gpu </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#a31ef33571a4f6ba8847eeee1f4907141">gpu</a></td></tr>
<tr class="memdesc:a31ef33571a4f6ba8847eeee1f4907141"><td class="mdescLeft"> </td><td class="mdescRight">mxnet gpu  <a href="#a31ef33571a4f6ba8847eeee1f4907141">More...</a><br/></td></tr>
<tr class="separator:a31ef33571a4f6ba8847eeee1f4907141"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:abadedc1b42ee3e5b8852e63783b982ef"><td align="right" class="memItemLeft" valign="top">typedef mshadow::index_t </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#abadedc1b42ee3e5b8852e63783b982ef">index_t</a></td></tr>
<tr class="memdesc:abadedc1b42ee3e5b8852e63783b982ef"><td class="mdescLeft"> </td><td class="mdescRight">index type usually use unsigned  <a href="#abadedc1b42ee3e5b8852e63783b982ef">More...</a><br/></td></tr>
<tr class="separator:abadedc1b42ee3e5b8852e63783b982ef"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4421326e33f2a848cb2fa3e70ab24ff4"><td align="right" class="memItemLeft" valign="top">typedef mshadow::default_real_t </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a></td></tr>
<tr class="memdesc:a4421326e33f2a848cb2fa3e70ab24ff4"><td class="mdescLeft"> </td><td class="mdescRight">data type that will be used to store ndarray  <a href="#a4421326e33f2a848cb2fa3e70ab24ff4">More...</a><br/></td></tr>
<tr class="separator:a4421326e33f2a848cb2fa3e70ab24ff4"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6e14bb5f6ffc81892feca8d1da658687"><td align="right" class="memItemLeft" valign="top">using </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#a6e14bb5f6ffc81892feca8d1da658687">TShape</a> = nnvm::TShape</td></tr>
<tr class="memdesc:a6e14bb5f6ffc81892feca8d1da658687"><td class="mdescLeft"> </td><td class="mdescRight">Shape data structure used to record shape information.  <a href="#a6e14bb5f6ffc81892feca8d1da658687">More...</a><br/></td></tr>
<tr class="separator:a6e14bb5f6ffc81892feca8d1da658687"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac2fb286fd7ddfbc7af1456f6c7a7ee52"><td align="right" class="memItemLeft" valign="top">using </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#ac2fb286fd7ddfbc7af1456f6c7a7ee52">Op</a> = nnvm::Op</td></tr>
<tr class="memdesc:ac2fb286fd7ddfbc7af1456f6c7a7ee52"><td class="mdescLeft"> </td><td class="mdescRight">operator structure from NNVM  <a href="#ac2fb286fd7ddfbc7af1456f6c7a7ee52">More...</a><br/></td></tr>
<tr class="separator:ac2fb286fd7ddfbc7af1456f6c7a7ee52"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6606bef15f41cccade14c9400e8447cf"><td align="right" class="memItemLeft" valign="top">using </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#a6606bef15f41cccade14c9400e8447cf">StorageTypeVector</a> = std::vector&lt; int &gt;</td></tr>
<tr class="memdesc:a6606bef15f41cccade14c9400e8447cf"><td class="mdescLeft"> </td><td class="mdescRight">The result holder of storage type of each NodeEntry in the graph.  <a href="#a6606bef15f41cccade14c9400e8447cf">More...</a><br/></td></tr>
<tr class="separator:a6606bef15f41cccade14c9400e8447cf"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1183dd8b779392f7ddafe1b010a6a2fe"><td align="right" class="memItemLeft" valign="top">using </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#a1183dd8b779392f7ddafe1b010a6a2fe">DispatchModeVector</a> = std::vector&lt; <a class="el" href="namespacemxnet.html#aad5fec2b4bceabbf4b884460cc2e0a2b">DispatchMode</a> &gt;</td></tr>
<tr class="memdesc:a1183dd8b779392f7ddafe1b010a6a2fe"><td class="mdescLeft"> </td><td class="mdescRight">The result holder of dispatch mode of each Node in the graph.  <a href="#a1183dd8b779392f7ddafe1b010a6a2fe">More...</a><br/></td></tr>
<tr class="separator:a1183dd8b779392f7ddafe1b010a6a2fe"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab54083e73557ebb63c021653da688810"><td align="right" class="memItemLeft" valign="top">using </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#ab54083e73557ebb63c021653da688810">CachedOpPtr</a> = std::shared_ptr&lt; <a class="el" href="classmxnet_1_1Imperative_1_1CachedOp.html">Imperative::CachedOp</a> &gt;</td></tr>
<tr class="separator:ab54083e73557ebb63c021653da688810"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6dca73c81706d54b0ddb0ef967d1e132"><td align="right" class="memItemLeft" valign="top">typedef std::function&lt; <a class="el" href="classmxnet_1_1IIterator.html">IIterator</a>&lt; <a class="el" href="structmxnet_1_1DataBatch.html">DataBatch</a> &gt; *()&gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#a6dca73c81706d54b0ddb0ef967d1e132">DataIteratorFactory</a></td></tr>
<tr class="memdesc:a6dca73c81706d54b0ddb0ef967d1e132"><td class="mdescLeft"> </td><td class="mdescRight">typedef the factory function of data iterator  <a href="#a6dca73c81706d54b0ddb0ef967d1e132">More...</a><br/></td></tr>
<tr class="separator:a6dca73c81706d54b0ddb0ef967d1e132"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab0d55b0edf98cf8f3caeb050662ae9ec"><td align="right" class="memItemLeft" valign="top">typedef std::function&lt; void(<a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> **used_vars, <a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a> *scalars, <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> **mutate_vars, int num_params, char **param_keys, char **param_vals)&gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#ab0d55b0edf98cf8f3caeb050662ae9ec">NDArrayAPIFunction</a></td></tr>
<tr class="memdesc:ab0d55b0edf98cf8f3caeb050662ae9ec"><td class="mdescLeft"> </td><td class="mdescRight">definition of <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> function  <a href="#ab0d55b0edf98cf8f3caeb050662ae9ec">More...</a><br/></td></tr>
<tr class="separator:ab0d55b0edf98cf8f3caeb050662ae9ec"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:acb83431b596f805fabcc4ba400c62e85"><td align="right" class="memItemLeft" valign="top">using </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#acb83431b596f805fabcc4ba400c62e85">FCreateOpState</a> = std::function&lt; <a class="el" href="classmxnet_1_1OpStatePtr.html">OpStatePtr</a>(const NodeAttrs &amp;attrs, <a class="el" href="structmxnet_1_1Context.html">Context</a> ctx, const std::vector&lt; <a class="el" href="namespacemxnet.html#a6e14bb5f6ffc81892feca8d1da658687">TShape</a> &gt; &amp;in_shape, const std::vector&lt; int &gt; &amp;in_type)&gt;</td></tr>
<tr class="memdesc:acb83431b596f805fabcc4ba400c62e85"><td class="mdescLeft"> </td><td class="mdescRight">Create a Layer style, forward/backward operator. This is easy to write code that contains state. <a class="el" href="classmxnet_1_1OpStatePtr.html" title="Operator state. This is a pointer type, its content is mutable even if OpStatePtr is const...">OpStatePtr</a> is a pointer type, it's content is mutable even if <a class="el" href="classmxnet_1_1OpStatePtr.html" title="Operator state. This is a pointer type, its content is mutable even if OpStatePtr is const...">OpStatePtr</a> is constant.  <a href="#acb83431b596f805fabcc4ba400c62e85">More...</a><br/></td></tr>
<tr class="separator:acb83431b596f805fabcc4ba400c62e85"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a666f1055e5401ecec0278e8ba5790732"><td align="right" class="memItemLeft" valign="top">using </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#a666f1055e5401ecec0278e8ba5790732">FExecType</a> = std::function&lt; <a class="el" href="namespacemxnet.html#ad7801fb2dd68294d4c7a9e289bc071ad">ExecType</a>(const NodeAttrs &amp;attrs)&gt;</td></tr>
<tr class="memdesc:a666f1055e5401ecec0278e8ba5790732"><td class="mdescLeft"> </td><td class="mdescRight">Execution mode of this operator.  <a href="#a666f1055e5401ecec0278e8ba5790732">More...</a><br/></td></tr>
<tr class="separator:a666f1055e5401ecec0278e8ba5790732"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9097a269dd76d833c014149ff3eaab9b"><td align="right" class="memItemLeft" valign="top">using </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#a9097a269dd76d833c014149ff3eaab9b">FStatefulCompute</a> = std::function&lt; void(const <a class="el" href="classmxnet_1_1OpStatePtr.html">OpStatePtr</a> &amp;state, const <a class="el" href="structmxnet_1_1OpContext.html">OpContext</a> &amp;ctx, const std::vector&lt; <a class="el" href="classmxnet_1_1TBlob.html">TBlob</a> &gt; &amp;inputs, const std::vector&lt; <a class="el" href="namespacemxnet.html#a7cd7094ef222e9ae1f520c3b6a214398">OpReqType</a> &gt; &amp;req, const std::vector&lt; <a class="el" href="classmxnet_1_1TBlob.html">TBlob</a> &gt; &amp;outputs)&gt;</td></tr>
<tr class="memdesc:a9097a269dd76d833c014149ff3eaab9b"><td class="mdescLeft"> </td><td class="mdescRight">Resiger a compute function for stateful operator. <a class="el" href="classmxnet_1_1OpStatePtr.html" title="Operator state. This is a pointer type, its content is mutable even if OpStatePtr is const...">OpStatePtr</a> is a pointer type, it's content is mutable even if <a class="el" href="classmxnet_1_1OpStatePtr.html" title="Operator state. This is a pointer type, its content is mutable even if OpStatePtr is const...">OpStatePtr</a> is constant.  <a href="#a9097a269dd76d833c014149ff3eaab9b">More...</a><br/></td></tr>
<tr class="separator:a9097a269dd76d833c014149ff3eaab9b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab12f1853179b1456152a563edff844a9"><td align="right" class="memItemLeft" valign="top">using </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#ab12f1853179b1456152a563edff844a9">FStatefulComputeEx</a> = std::function&lt; void(const <a class="el" href="classmxnet_1_1OpStatePtr.html">OpStatePtr</a> &amp;state, const <a class="el" href="structmxnet_1_1OpContext.html">OpContext</a> &amp;ctx, const std::vector&lt; <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &gt; &amp;inputs, const std::vector&lt; <a class="el" href="namespacemxnet.html#a7cd7094ef222e9ae1f520c3b6a214398">OpReqType</a> &gt; &amp;req, const std::vector&lt; <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &gt; &amp;outputs)&gt;</td></tr>
<tr class="memdesc:ab12f1853179b1456152a563edff844a9"><td class="mdescLeft"> </td><td class="mdescRight">Resiger a compute function for stateful operator using <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> interface. <a class="el" href="classmxnet_1_1OpStatePtr.html" title="Operator state. This is a pointer type, its content is mutable even if OpStatePtr is const...">OpStatePtr</a> is a pointer type, it's content is mutable even if <a class="el" href="classmxnet_1_1OpStatePtr.html" title="Operator state. This is a pointer type, its content is mutable even if OpStatePtr is const...">OpStatePtr</a> is constant.  <a href="#ab12f1853179b1456152a563edff844a9">More...</a><br/></td></tr>
<tr class="separator:ab12f1853179b1456152a563edff844a9"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:afaa687cbca9e992614be285711c1d72d"><td align="right" class="memItemLeft" valign="top">using </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#afaa687cbca9e992614be285711c1d72d">FResourceRequest</a> = std::function&lt; std::vector&lt; <a class="el" href="structmxnet_1_1ResourceRequest.html">ResourceRequest</a> &gt;(const NodeAttrs &amp;n)&gt;</td></tr>
<tr class="memdesc:afaa687cbca9e992614be285711c1d72d"><td class="mdescLeft"> </td><td class="mdescRight">The resource request from the operator.  <a href="#afaa687cbca9e992614be285711c1d72d">More...</a><br/></td></tr>
<tr class="separator:afaa687cbca9e992614be285711c1d72d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a0906e49a921265634672f555451075ed"><td align="right" class="memItemLeft" valign="top">using </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#a0906e49a921265634672f555451075ed">FNDArrayFunction</a> = std::function&lt; void(const nnvm::NodeAttrs &amp;attrs, const std::vector&lt; <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &gt; &amp;inputs, std::vector&lt; <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &gt; *outputs)&gt;</td></tr>
<tr class="memdesc:a0906e49a921265634672f555451075ed"><td class="mdescLeft"> </td><td class="mdescRight">Register an operator called as a <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> function.  <a href="#a0906e49a921265634672f555451075ed">More...</a><br/></td></tr>
<tr class="separator:a0906e49a921265634672f555451075ed"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad77e2048b7e8db91a12e05b477aac13e"><td align="right" class="memItemLeft" valign="top">using </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#ad77e2048b7e8db91a12e05b477aac13e">FCompute</a> = std::function&lt; void(const nnvm::NodeAttrs &amp;attrs, const <a class="el" href="structmxnet_1_1OpContext.html">OpContext</a> &amp;ctx, const std::vector&lt; <a class="el" href="classmxnet_1_1TBlob.html">TBlob</a> &gt; &amp;inputs, const std::vector&lt; <a class="el" href="namespacemxnet.html#a7cd7094ef222e9ae1f520c3b6a214398">OpReqType</a> &gt; &amp;req, const std::vector&lt; <a class="el" href="classmxnet_1_1TBlob.html">TBlob</a> &gt; &amp;outputs)&gt;</td></tr>
<tr class="memdesc:ad77e2048b7e8db91a12e05b477aac13e"><td class="mdescLeft"> </td><td class="mdescRight">Resiger a compute function for simple stateless forward only operator.  <a href="#ad77e2048b7e8db91a12e05b477aac13e">More...</a><br/></td></tr>
<tr class="separator:ad77e2048b7e8db91a12e05b477aac13e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a294d2660c065f8d229c27e65f0461e10"><td align="right" class="memItemLeft" valign="top">using </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#a294d2660c065f8d229c27e65f0461e10">FComputeEx</a> = std::function&lt; void(const nnvm::NodeAttrs &amp;attrs, const <a class="el" href="structmxnet_1_1OpContext.html">OpContext</a> &amp;ctx, const std::vector&lt; <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &gt; &amp;inputs, const std::vector&lt; <a class="el" href="namespacemxnet.html#a7cd7094ef222e9ae1f520c3b6a214398">OpReqType</a> &gt; &amp;req, const std::vector&lt; <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &gt; &amp;outputs)&gt;</td></tr>
<tr class="memdesc:a294d2660c065f8d229c27e65f0461e10"><td class="mdescLeft"> </td><td class="mdescRight">Resiger an <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> compute function for simple stateless forward only operator.  <a href="#a294d2660c065f8d229c27e65f0461e10">More...</a><br/></td></tr>
<tr class="separator:a294d2660c065f8d229c27e65f0461e10"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a0a1395f21139ba975a6268539df6a15d"><td align="right" class="memItemLeft" valign="top">using </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#a0a1395f21139ba975a6268539df6a15d">FInferStorageType</a> = std::function&lt; bool(const NodeAttrs &amp;attrs, const int dev_mask, <a class="el" href="namespacemxnet.html#aad5fec2b4bceabbf4b884460cc2e0a2b">DispatchMode</a> *dispatch_mode, std::vector&lt; int &gt; *in_attrs, std::vector&lt; int &gt; *out_attrs)&gt;</td></tr>
<tr class="memdesc:a0a1395f21139ba975a6268539df6a15d"><td class="mdescLeft"> </td><td class="mdescRight">Resiger a storage and dispatch mode inference function based on storage types of the inputs and outputs, and the dev_mask for the operator.  <a href="#a0a1395f21139ba975a6268539df6a15d">More...</a><br/></td></tr>
<tr class="separator:a0a1395f21139ba975a6268539df6a15d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac4a55ce92442f122a1a0e6ae8d134f10"><td align="right" class="memItemLeft" valign="top">using </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#ac4a55ce92442f122a1a0e6ae8d134f10">FQuantizedOp</a> = std::function&lt; nnvm::NodePtr(const NodeAttrs &amp;attrs)&gt;</td></tr>
<tr class="memdesc:ac4a55ce92442f122a1a0e6ae8d134f10"><td class="mdescLeft"> </td><td class="mdescRight">Register a quantized node creation function based on the attrs of the node.  <a href="#ac4a55ce92442f122a1a0e6ae8d134f10">More...</a><br/></td></tr>
<tr class="separator:ac4a55ce92442f122a1a0e6ae8d134f10"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7f7c271f6d03ee358eb9e66486e41045"><td align="right" class="memItemLeft" valign="top">using </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#a7f7c271f6d03ee358eb9e66486e41045">FNeedRequantize</a> = std::function&lt; bool(const NodeAttrs &amp;attrs)&gt;</td></tr>
<tr class="memdesc:a7f7c271f6d03ee358eb9e66486e41045"><td class="mdescLeft"> </td><td class="mdescRight">Register a function to determine if the output of a quantized operator needs to be requantized. This is usually used for the operators taking int8 data types while accumulating in int32, e.g. quantized_conv.  <a href="#a7f7c271f6d03ee358eb9e66486e41045">More...</a><br/></td></tr>
<tr class="separator:a7f7c271f6d03ee358eb9e66486e41045"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6f5428fbf261a94eaac079ec24413815"><td align="right" class="memItemLeft" valign="top">typedef std::function&lt; <a class="el" href="classmxnet_1_1OperatorProperty.html">OperatorProperty</a> *()&gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#a6f5428fbf261a94eaac079ec24413815">OperatorPropertyFactory</a></td></tr>
<tr class="memdesc:a6f5428fbf261a94eaac079ec24413815"><td class="mdescLeft"> </td><td class="mdescRight">typedef the factory function of operator property  <a href="#a6f5428fbf261a94eaac079ec24413815">More...</a><br/></td></tr>
<tr class="separator:a6f5428fbf261a94eaac079ec24413815"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a998b74220fab2b012cf8a179650e1b3b"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#a998b74220fab2b012cf8a179650e1b3b">FnProperty</a> { <br/>
  <a class="el" href="namespacemxnet.html#a998b74220fab2b012cf8a179650e1b3ba07fa7a19aa722c635a15e94cb7f50416">FnProperty::kNormal</a>, 
<a class="el" href="namespacemxnet.html#a998b74220fab2b012cf8a179650e1b3ba739f2f416f05f4728c217f09e93958d1">FnProperty::kCopyFromGPU</a>, 
<a class="el" href="namespacemxnet.html#a998b74220fab2b012cf8a179650e1b3ba6cd75f41e0ec8d61b0a2f0e20ef6d1e8">FnProperty::kCopyToGPU</a>, 
<a class="el" href="namespacemxnet.html#a998b74220fab2b012cf8a179650e1b3bac41ceb98eeb9b2e208e3e242a7357142">FnProperty::kCPUPrioritized</a>, 
<br/>
  <a class="el" href="namespacemxnet.html#a998b74220fab2b012cf8a179650e1b3ba9f2b960005d2a3a5f35ac32809d84db7">FnProperty::kAsync</a>, 
<a class="el" href="namespacemxnet.html#a998b74220fab2b012cf8a179650e1b3bac41fda8552e9d327ad3b06b1bafa663a">FnProperty::kDeleteVar</a>
<br/>
 }<tr class="memdesc:a998b74220fab2b012cf8a179650e1b3b"><td class="mdescLeft"> </td><td class="mdescRight">Function property, used to hint what action is pushed to engine.  <a href="namespacemxnet.html#a998b74220fab2b012cf8a179650e1b3b">More...</a><br/></td></tr>
</td></tr>
<tr class="separator:a998b74220fab2b012cf8a179650e1b3b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a536b732faa980e1de446c552460ff76a"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#a536b732faa980e1de446c552460ff76a">NDArrayStorageType</a> { <a class="el" href="namespacemxnet.html#a536b732faa980e1de446c552460ff76aadf6c6faf0de1e55119c679180c99e584">kUndefinedStorage</a> = -1, 
<a class="el" href="namespacemxnet.html#a536b732faa980e1de446c552460ff76aabf6395d98a9668e8066a0c0da5570608">kDefaultStorage</a>, 
<a class="el" href="namespacemxnet.html#a536b732faa980e1de446c552460ff76aac095f52c31076adc7207f4a4f17d7aa3">kRowSparseStorage</a>, 
<a class="el" href="namespacemxnet.html#a536b732faa980e1de446c552460ff76aa777c7ad3afa566f2e841f12c81aab254">kCSRStorage</a>
 }</td></tr>
<tr class="separator:a536b732faa980e1de446c552460ff76a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ace60510752753f459193f95cab0e9e1a"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#ace60510752753f459193f95cab0e9e1a">NDArrayFormatErr</a> { <br/>
  <a class="el" href="namespacemxnet.html#ace60510752753f459193f95cab0e9e1aa322b8b178929b43f1b4b16c8cb9003ef">kNormalErr</a>, 
<a class="el" href="namespacemxnet.html#ace60510752753f459193f95cab0e9e1aaf64429479d4a48998e6cd122a3117628">kCSRShapeErr</a>, 
<a class="el" href="namespacemxnet.html#ace60510752753f459193f95cab0e9e1aa11ce5dbb8ad355e9ee5a678f2f51a5bb">kCSRIndPtrErr</a>, 
<a class="el" href="namespacemxnet.html#ace60510752753f459193f95cab0e9e1aaf3ee084ba1d9a6203922ff7c9ddb12e3">kCSRIdxErr</a>, 
<br/>
  <a class="el" href="namespacemxnet.html#ace60510752753f459193f95cab0e9e1aa200492eeec6fa431683ef0d943bfbc2d">kRSPShapeErr</a>, 
<a class="el" href="namespacemxnet.html#ace60510752753f459193f95cab0e9e1aa7636cc230df4abe46f3210846faac799">kRSPIdxErr</a>
<br/>
 }</td></tr>
<tr class="separator:ace60510752753f459193f95cab0e9e1a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a89a5f0f5cfd9e1e94604a7b42dda818a"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#a89a5f0f5cfd9e1e94604a7b42dda818a">NDArrayFunctionTypeMask</a> { <a class="el" href="namespacemxnet.html#a89a5f0f5cfd9e1e94604a7b42dda818aabbc1ba0bb3f8647dcfd8bad69efdbb51">kNDArrayArgBeforeScalar</a> = 1, 
<a class="el" href="namespacemxnet.html#a89a5f0f5cfd9e1e94604a7b42dda818aaef9818c8aae9d0046b3d9033a62fcfbb">kScalarArgBeforeNDArray</a> = 1 &lt;&lt; 1, 
<a class="el" href="namespacemxnet.html#a89a5f0f5cfd9e1e94604a7b42dda818aa334598420a4246d5412ddc346b2b57bd">kAcceptEmptyMutateTarget</a> = 1 &lt;&lt; 2
 }<tr class="memdesc:a89a5f0f5cfd9e1e94604a7b42dda818a"><td class="mdescLeft"> </td><td class="mdescRight">mask information on how functions can be exposed  <a href="namespacemxnet.html#a89a5f0f5cfd9e1e94604a7b42dda818a">More...</a><br/></td></tr>
</td></tr>
<tr class="separator:a89a5f0f5cfd9e1e94604a7b42dda818a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7cd7094ef222e9ae1f520c3b6a214398"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#a7cd7094ef222e9ae1f520c3b6a214398">OpReqType</a> { <a class="el" href="namespacemxnet.html#a7cd7094ef222e9ae1f520c3b6a214398a001b85096e07108e174fe4c406368a26">kNullOp</a>, 
<a class="el" href="namespacemxnet.html#a7cd7094ef222e9ae1f520c3b6a214398a03b4c19f34d3add7deecd7ef6c54b42a">kWriteTo</a>, 
<a class="el" href="namespacemxnet.html#a7cd7094ef222e9ae1f520c3b6a214398a640322face587ca12684378d0f053d51">kWriteInplace</a>, 
<a class="el" href="namespacemxnet.html#a7cd7094ef222e9ae1f520c3b6a214398a1b850737dba4d2c42a2687d14c10f383">kAddTo</a>
 }<tr class="memdesc:a7cd7094ef222e9ae1f520c3b6a214398"><td class="mdescLeft"> </td><td class="mdescRight">operation request type to Forward and Backward  <a href="namespacemxnet.html#a7cd7094ef222e9ae1f520c3b6a214398">More...</a><br/></td></tr>
</td></tr>
<tr class="separator:a7cd7094ef222e9ae1f520c3b6a214398"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad7801fb2dd68294d4c7a9e289bc071ad"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#ad7801fb2dd68294d4c7a9e289bc071ad">ExecType</a> { <a class="el" href="namespacemxnet.html#ad7801fb2dd68294d4c7a9e289bc071adae3bade32f12a5139b27ef40b3689b77c">ExecType::kSync</a>, 
<a class="el" href="namespacemxnet.html#ad7801fb2dd68294d4c7a9e289bc071ada9f2b960005d2a3a5f35ac32809d84db7">ExecType::kAsync</a>, 
<a class="el" href="namespacemxnet.html#ad7801fb2dd68294d4c7a9e289bc071ada3864860a073c64d74d3fc8e765fa6cad">ExecType::kCrossDeviceCopy</a>
 }<tr class="memdesc:ad7801fb2dd68294d4c7a9e289bc071ad"><td class="mdescLeft"> </td><td class="mdescRight">the execution type of the operator  <a href="namespacemxnet.html#ad7801fb2dd68294d4c7a9e289bc071ad">More...</a><br/></td></tr>
</td></tr>
<tr class="separator:ad7801fb2dd68294d4c7a9e289bc071ad"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aad5fec2b4bceabbf4b884460cc2e0a2b"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#aad5fec2b4bceabbf4b884460cc2e0a2b">DispatchMode</a> { <br/>
  <a class="el" href="namespacemxnet.html#aad5fec2b4bceabbf4b884460cc2e0a2ba7934d40c7c17315d892e8d5d745b1c66">DispatchMode::kUndefined</a> = -1, 
<a class="el" href="namespacemxnet.html#aad5fec2b4bceabbf4b884460cc2e0a2ba2157864769b54d1d0f8f9be63393e7d6">DispatchMode::kFCompute</a>, 
<a class="el" href="namespacemxnet.html#aad5fec2b4bceabbf4b884460cc2e0a2ba57f93219462690bc438372ecd92fedd5">DispatchMode::kFComputeEx</a>, 
<a class="el" href="namespacemxnet.html#aad5fec2b4bceabbf4b884460cc2e0a2ba18bf63b4c196f79c9bca4ad8637e8fef">DispatchMode::kFComputeFallback</a>, 
<br/>
  <a class="el" href="namespacemxnet.html#aad5fec2b4bceabbf4b884460cc2e0a2bafb751f6ee1af15e773242f2accd2dbff">DispatchMode::kVariable</a>
<br/>
 }<tr class="memdesc:aad5fec2b4bceabbf4b884460cc2e0a2b"><td class="mdescLeft"> </td><td class="mdescRight">the dispatch mode of the operator  <a href="namespacemxnet.html#aad5fec2b4bceabbf4b884460cc2e0a2b">More...</a><br/></td></tr>
</td></tr>
<tr class="separator:aad5fec2b4bceabbf4b884460cc2e0a2b"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae4143fe21881cbf0174bba638e8e0330"><td align="right" class="memItemLeft" valign="top">size_t </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#ae4143fe21881cbf0174bba638e8e0330">num_aux_data</a> (<a class="el" href="namespacemxnet.html#a536b732faa980e1de446c552460ff76a">NDArrayStorageType</a> stype)</td></tr>
<tr class="separator:ae4143fe21881cbf0174bba638e8e0330"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae7b0809624683afc59b6d7f7784d8bfb"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#ae7b0809624683afc59b6d7f7784d8bfb">CopyFromTo</a> (const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;from, const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> *to, int priority=0)</td></tr>
<tr class="memdesc:ae7b0809624683afc59b6d7f7784d8bfb"><td class="mdescLeft"> </td><td class="mdescRight">issue an copy operation from one <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> to another the two ndarray can sit on different devices this operation will be scheduled by the engine  <a href="#ae7b0809624683afc59b6d7f7784d8bfb">More...</a><br/></td></tr>
<tr class="separator:ae7b0809624683afc59b6d7f7784d8bfb"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa005a02aac4f297b6fab561e907e89e3"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#aa005a02aac4f297b6fab561e907e89e3">CopyFromTo</a> (const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;from, const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;to, int priority=0)</td></tr>
<tr class="memdesc:aa005a02aac4f297b6fab561e907e89e3"><td class="mdescLeft"> </td><td class="mdescRight">issue an copy operation from one <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> to another the two ndarray can sit on different devices this operation will be scheduled by the engine  <a href="#aa005a02aac4f297b6fab561e907e89e3">More...</a><br/></td></tr>
<tr class="separator:aa005a02aac4f297b6fab561e907e89e3"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a15dfd6f3fa03dc2cf39dbab1225e1a51"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#a15dfd6f3fa03dc2cf39dbab1225e1a51">ElementwiseSum</a> (const std::vector&lt; <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &gt; &amp;source, <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> *out, int priority=0)</td></tr>
<tr class="memdesc:a15dfd6f3fa03dc2cf39dbab1225e1a51"><td class="mdescLeft"> </td><td class="mdescRight">Perform elementwise sum over each data from source, store result into out.  <a href="#a15dfd6f3fa03dc2cf39dbab1225e1a51">More...</a><br/></td></tr>
<tr class="separator:a15dfd6f3fa03dc2cf39dbab1225e1a51"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4dafe3aae43025fd21bc44b98c18ed1e"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#a4dafe3aae43025fd21bc44b98c18ed1e">operator+</a> (const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;lhs, const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;rhs)</td></tr>
<tr class="memdesc:a4dafe3aae43025fd21bc44b98c18ed1e"><td class="mdescLeft"> </td><td class="mdescRight">elementwise add  <a href="#a4dafe3aae43025fd21bc44b98c18ed1e">More...</a><br/></td></tr>
<tr class="separator:a4dafe3aae43025fd21bc44b98c18ed1e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a30bfda0e3e1b347e3057097cafc628be"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#a30bfda0e3e1b347e3057097cafc628be">operator+</a> (const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;lhs, const <a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a> &amp;rhs)</td></tr>
<tr class="memdesc:a30bfda0e3e1b347e3057097cafc628be"><td class="mdescLeft"> </td><td class="mdescRight">elementwise add  <a href="#a30bfda0e3e1b347e3057097cafc628be">More...</a><br/></td></tr>
<tr class="separator:a30bfda0e3e1b347e3057097cafc628be"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae3356844b657c9ae1b84d3ddd56bccf6"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#ae3356844b657c9ae1b84d3ddd56bccf6">operator-</a> (const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;lhs, const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;rhs)</td></tr>
<tr class="memdesc:ae3356844b657c9ae1b84d3ddd56bccf6"><td class="mdescLeft"> </td><td class="mdescRight">elementwise subtraction  <a href="#ae3356844b657c9ae1b84d3ddd56bccf6">More...</a><br/></td></tr>
<tr class="separator:ae3356844b657c9ae1b84d3ddd56bccf6"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a0c8542953df5093060985db5518a339b"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#a0c8542953df5093060985db5518a339b">operator-</a> (const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;lhs, const <a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a> &amp;rhs)</td></tr>
<tr class="memdesc:a0c8542953df5093060985db5518a339b"><td class="mdescLeft"> </td><td class="mdescRight">elementwise subtraction  <a href="#a0c8542953df5093060985db5518a339b">More...</a><br/></td></tr>
<tr class="separator:a0c8542953df5093060985db5518a339b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af26b09fbcda865d34ec4fdad482d266a"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#af26b09fbcda865d34ec4fdad482d266a">operator*</a> (const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;lhs, const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;rhs)</td></tr>
<tr class="memdesc:af26b09fbcda865d34ec4fdad482d266a"><td class="mdescLeft"> </td><td class="mdescRight">elementwise multiplication  <a href="#af26b09fbcda865d34ec4fdad482d266a">More...</a><br/></td></tr>
<tr class="separator:af26b09fbcda865d34ec4fdad482d266a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a66510f6a344ee38bb89cb552e974b838"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#a66510f6a344ee38bb89cb552e974b838">operator*</a> (const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;lhs, const <a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a> &amp;rhs)</td></tr>
<tr class="memdesc:a66510f6a344ee38bb89cb552e974b838"><td class="mdescLeft"> </td><td class="mdescRight">elementwise multiplication  <a href="#a66510f6a344ee38bb89cb552e974b838">More...</a><br/></td></tr>
<tr class="separator:a66510f6a344ee38bb89cb552e974b838"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a502e3e00dc61cedb9c6eef711f1176ac"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#a502e3e00dc61cedb9c6eef711f1176ac">operator/</a> (const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;lhs, const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;rhs)</td></tr>
<tr class="memdesc:a502e3e00dc61cedb9c6eef711f1176ac"><td class="mdescLeft"> </td><td class="mdescRight">elementwise division  <a href="#a502e3e00dc61cedb9c6eef711f1176ac">More...</a><br/></td></tr>
<tr class="separator:a502e3e00dc61cedb9c6eef711f1176ac"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a3455659b714488e8e53e4e4580a43ec7"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#a3455659b714488e8e53e4e4580a43ec7">operator/</a> (const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;lhs, const <a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a> &amp;rhs)</td></tr>
<tr class="memdesc:a3455659b714488e8e53e4e4580a43ec7"><td class="mdescLeft"> </td><td class="mdescRight">elementwise division  <a href="#a3455659b714488e8e53e4e4580a43ec7">More...</a><br/></td></tr>
<tr class="separator:a3455659b714488e8e53e4e4580a43ec7"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5bf83454c8f41259eb9d471f59feda2b"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#a5bf83454c8f41259eb9d471f59feda2b">RandomSeed</a> (uint32_t seed)</td></tr>
<tr class="memdesc:a5bf83454c8f41259eb9d471f59feda2b"><td class="mdescLeft"> </td><td class="mdescRight">Seed all random number generator in mxnet.  <a href="#a5bf83454c8f41259eb9d471f59feda2b">More...</a><br/></td></tr>
<tr class="separator:a5bf83454c8f41259eb9d471f59feda2b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab6d578be9be3a2a0d3e21246834d3e71"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#ab6d578be9be3a2a0d3e21246834d3e71">RandomSeed</a> (<a class="el" href="structmxnet_1_1Context.html">Context</a> ctx, uint32_t seed)</td></tr>
<tr class="memdesc:ab6d578be9be3a2a0d3e21246834d3e71"><td class="mdescLeft"> </td><td class="mdescRight">Seed the random number generator of the device.  <a href="#ab6d578be9be3a2a0d3e21246834d3e71">More...</a><br/></td></tr>
<tr class="separator:ab6d578be9be3a2a0d3e21246834d3e71"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2846f4556c9ca9bd0f567504ce60f274"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#a2846f4556c9ca9bd0f567504ce60f274">SampleUniform</a> (<a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a> begin, <a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a> end, <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> *out)</td></tr>
<tr class="memdesc:a2846f4556c9ca9bd0f567504ce60f274"><td class="mdescLeft"> </td><td class="mdescRight">Sample uniform distribution for each elements of out.  <a href="#a2846f4556c9ca9bd0f567504ce60f274">More...</a><br/></td></tr>
<tr class="separator:a2846f4556c9ca9bd0f567504ce60f274"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5a28062f52ca576a126599e7ad487077"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#a5a28062f52ca576a126599e7ad487077">SampleGaussian</a> (<a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a> mu, <a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a> sigma, <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> *out)</td></tr>
<tr class="memdesc:a5a28062f52ca576a126599e7ad487077"><td class="mdescLeft"> </td><td class="mdescRight">Sample gaussian distribution for each elements of out.  <a href="#a5a28062f52ca576a126599e7ad487077">More...</a><br/></td></tr>
<tr class="separator:a5a28062f52ca576a126599e7ad487077"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a050beaa505f11e0b844deb91efe0cac2"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#a050beaa505f11e0b844deb91efe0cac2">SampleGamma</a> (<a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a> alpha, <a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a> beta, <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> *out)</td></tr>
<tr class="memdesc:a050beaa505f11e0b844deb91efe0cac2"><td class="mdescLeft"> </td><td class="mdescRight">Sample gamma distribution for each elements of out.  <a href="#a050beaa505f11e0b844deb91efe0cac2">More...</a><br/></td></tr>
<tr class="separator:a050beaa505f11e0b844deb91efe0cac2"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a51f9b094369a349c05463de2be9f0a31"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#a51f9b094369a349c05463de2be9f0a31">SampleExponential</a> (<a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a> lambda, <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> *out)</td></tr>
<tr class="memdesc:a51f9b094369a349c05463de2be9f0a31"><td class="mdescLeft"> </td><td class="mdescRight">Sample exponential distribution for each elements of out.  <a href="#a51f9b094369a349c05463de2be9f0a31">More...</a><br/></td></tr>
<tr class="separator:a51f9b094369a349c05463de2be9f0a31"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aed55e8197182b7c66126902b2a43739a"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#aed55e8197182b7c66126902b2a43739a">SamplePoisson</a> (<a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a> lambda, <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> *out)</td></tr>
<tr class="memdesc:aed55e8197182b7c66126902b2a43739a"><td class="mdescLeft"> </td><td class="mdescRight">Sample Poisson distribution for each elements of out.  <a href="#aed55e8197182b7c66126902b2a43739a">More...</a><br/></td></tr>
<tr class="separator:aed55e8197182b7c66126902b2a43739a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae82f70918b2d946f7ad66a158b1733dc"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#ae82f70918b2d946f7ad66a158b1733dc">SampleNegBinomial</a> (int32_t k, <a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a> p, <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> *out)</td></tr>
<tr class="memdesc:ae82f70918b2d946f7ad66a158b1733dc"><td class="mdescLeft"> </td><td class="mdescRight">Sample negative binomial distribution for each elements of out.  <a href="#ae82f70918b2d946f7ad66a158b1733dc">More...</a><br/></td></tr>
<tr class="separator:ae82f70918b2d946f7ad66a158b1733dc"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad8e0dad88ce27133fd24811763b7afdb"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#ad8e0dad88ce27133fd24811763b7afdb">SampleGenNegBinomial</a> (<a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a> mu, <a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a> alpha, <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> *out)</td></tr>
<tr class="memdesc:ad8e0dad88ce27133fd24811763b7afdb"><td class="mdescLeft"> </td><td class="mdescRight">Sample generalized negative binomial distribution for each elements of out.  <a href="#ad8e0dad88ce27133fd24811763b7afdb">More...</a><br/></td></tr>
<tr class="separator:ad8e0dad88ce27133fd24811763b7afdb"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a512ee02aece77cb0bf39b6e2ded77686"><td align="right" class="memItemLeft" valign="top">constexpr const int </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#a512ee02aece77cb0bf39b6e2ded77686">kCPU</a> = kDLCPU</td></tr>
<tr class="separator:a512ee02aece77cb0bf39b6e2ded77686"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a43ebce8ff01c0bee0dddb4417ea1239d"><td align="right" class="memItemLeft" valign="top">constexpr const int </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#a43ebce8ff01c0bee0dddb4417ea1239d">kGPU</a> = kDLGPU</td></tr>
<tr class="separator:a43ebce8ff01c0bee0dddb4417ea1239d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab96d1eea6c8d006db2b33bbdf9d90bd2"><td align="right" class="memItemLeft" valign="top">constexpr const int </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#ab96d1eea6c8d006db2b33bbdf9d90bd2">kTVMNDArrayTypeCode</a> = 19</td></tr>
<tr class="separator:ab96d1eea6c8d006db2b33bbdf9d90bd2"><td class="memSeparator" colspan="2"> </td></tr>
</table>
<a id="details" name="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>namespace of mxnet </p>
<p>Macros/inlines to assist CLion to parse Cuda files (*.cu, *.cuh)</p>
<p>When compiling a <b>device</b> function, check that the architecture is &gt;= Kepler (3.0) Note that <b>CUDA_ARCH</b> is not defined outside of a <b>device</b> function</p>
<p>Copyright (c) 2015 by Contributors </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ab54083e73557ebb63c021653da688810"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">using <a class="el" href="namespacemxnet.html#ab54083e73557ebb63c021653da688810">mxnet::CachedOpPtr</a> = typedef std::shared_ptr&lt;<a class="el" href="classmxnet_1_1Imperative_1_1CachedOp.html">Imperative::CachedOp</a>&gt;</td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a class="anchor" id="a850af9d76d9d4beaeb5234c1434973e3"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">typedef mshadow::cpu <a class="el" href="namespacemxnet.html#a850af9d76d9d4beaeb5234c1434973e3">mxnet::cpu</a></td>
</tr>
</table>
</div><div class="memdoc">
<p>mxnet cpu </p>
</div>
</div>
<a class="anchor" id="a6dca73c81706d54b0ddb0ef967d1e132"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">typedef std::function&lt;<a class="el" href="classmxnet_1_1IIterator.html">IIterator</a>&lt;<a class="el" href="structmxnet_1_1DataBatch.html">DataBatch</a>&gt; *()&gt; <a class="el" href="namespacemxnet.html#a6dca73c81706d54b0ddb0ef967d1e132">mxnet::DataIteratorFactory</a></td>
</tr>
</table>
</div><div class="memdoc">
<p>typedef the factory function of data iterator </p>
</div>
</div>
<a class="anchor" id="a1183dd8b779392f7ddafe1b010a6a2fe"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">using <a class="el" href="namespacemxnet.html#a1183dd8b779392f7ddafe1b010a6a2fe">mxnet::DispatchModeVector</a> = typedef std::vector&lt;<a class="el" href="namespacemxnet.html#aad5fec2b4bceabbf4b884460cc2e0a2b">DispatchMode</a>&gt;</td>
</tr>
</table>
</div><div class="memdoc">
<p>The result holder of dispatch mode of each Node in the graph. </p>
<ul>
<li>*+ * <dl class="section note"><dt>Note</dt><dd>Stored under graph.attrs["dispatch_mode"], provided by Pass "InferStorageType"</dd></dl>
</li>
<li>*</li>
<li>*<div class="fragment"><div class="line">+ *  Graph g = ApplyPass(src_graph, <span class="stringliteral">"InferStorageType"</span>);</div><div class="line">+ *  <span class="keyword">const</span> <a class="code" href="namespacemxnet.html#a1183dd8b779392f7ddafe1b010a6a2fe">DispatchModeVector</a>&amp; dispatch_modes = g.GetAttr&lt;<a class="code" href="namespacemxnet.html#a1183dd8b779392f7ddafe1b010a6a2fe">DispatchModeVector</a>&gt;(<span class="stringliteral">"dispatch_mode"</span>);</div><div class="line">+ *  <span class="comment">// get dispatch mode by entry node id</span></div><div class="line">+ *  <span class="keywordtype">int</span> node_type = dispatch_modes[nid];</div><div class="line">+ * </div></div><!-- fragment --></li>
<li>*</li>
<li>* <dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacemxnet.html#a0a1395f21139ba975a6268539df6a15d" title="Resiger a storage and dispatch mode inference function based on storage types of the inputs and outpu...">FInferStorageType</a></dd></dl>
</li>
<li></li>
</ul>
</div>
</div>
<a class="anchor" id="ad77e2048b7e8db91a12e05b477aac13e"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">using <a class="el" href="namespacemxnet.html#ad77e2048b7e8db91a12e05b477aac13e">mxnet::FCompute</a> = typedef std::function&lt;void (const nnvm::NodeAttrs&amp; attrs, const <a class="el" href="structmxnet_1_1OpContext.html">OpContext</a>&amp; ctx, const std::vector&lt;<a class="el" href="classmxnet_1_1TBlob.html">TBlob</a>&gt;&amp; inputs, const std::vector&lt;<a class="el" href="namespacemxnet.html#a7cd7094ef222e9ae1f520c3b6a214398">OpReqType</a>&gt;&amp; req, const std::vector&lt;<a class="el" href="classmxnet_1_1TBlob.html">TBlob</a>&gt;&amp; outputs)&gt;</td>
</tr>
</table>
</div><div class="memdoc">
<p>Resiger a compute function for simple stateless forward only operator. </p>
<dl class="section note"><dt>Note</dt><dd>Register under "FCompute&lt;cpu&gt;" and "FCompute&lt;gpu&gt;" </dd></dl>
</div>
</div>
<a class="anchor" id="a294d2660c065f8d229c27e65f0461e10"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">using <a class="el" href="namespacemxnet.html#a294d2660c065f8d229c27e65f0461e10">mxnet::FComputeEx</a> = typedef std::function&lt;void (const nnvm::NodeAttrs&amp; attrs, const <a class="el" href="structmxnet_1_1OpContext.html">OpContext</a>&amp; ctx, const std::vector&lt;<a class="el" href="classmxnet_1_1NDArray.html">NDArray</a>&gt;&amp; inputs, const std::vector&lt;<a class="el" href="namespacemxnet.html#a7cd7094ef222e9ae1f520c3b6a214398">OpReqType</a>&gt;&amp; req, const std::vector&lt;<a class="el" href="classmxnet_1_1NDArray.html">NDArray</a>&gt;&amp; outputs)&gt;</td>
</tr>
</table>
</div><div class="memdoc">
<p>Resiger an <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> compute function for simple stateless forward only operator. </p>
<dl class="section note"><dt>Note</dt><dd>Register under "FComputeEx&lt;xpu&gt;" and "FComputeEx&lt;xpu&gt;" Dispatched only when inferred dispatch_mode is FDispatchComputeEx </dd></dl>
</div>
</div>
<a class="anchor" id="acb83431b596f805fabcc4ba400c62e85"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">using <a class="el" href="namespacemxnet.html#acb83431b596f805fabcc4ba400c62e85">mxnet::FCreateOpState</a> = typedef std::function&lt;<a class="el" href="classmxnet_1_1OpStatePtr.html">OpStatePtr</a> (const NodeAttrs&amp; attrs, <a class="el" href="structmxnet_1_1Context.html">Context</a> ctx, const std::vector&lt;<a class="el" href="namespacemxnet.html#a6e14bb5f6ffc81892feca8d1da658687">TShape</a>&gt;&amp; in_shape, const std::vector&lt;int&gt;&amp; in_type)&gt;</td>
</tr>
</table>
</div><div class="memdoc">
<p>Create a Layer style, forward/backward operator. This is easy to write code that contains state. <a class="el" href="classmxnet_1_1OpStatePtr.html" title="Operator state. This is a pointer type, its content is mutable even if OpStatePtr is const...">OpStatePtr</a> is a pointer type, it's content is mutable even if <a class="el" href="classmxnet_1_1OpStatePtr.html" title="Operator state. This is a pointer type, its content is mutable even if OpStatePtr is const...">OpStatePtr</a> is constant. </p>
<p>This is not the only way to register an op execution function. More simpler or specialized operator form can be registered</p>
<dl class="section note"><dt>Note</dt><dd>Register under "FCreateLayerOp" </dd></dl>
</div>
</div>
<a class="anchor" id="a666f1055e5401ecec0278e8ba5790732"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">using <a class="el" href="namespacemxnet.html#a666f1055e5401ecec0278e8ba5790732">mxnet::FExecType</a> = typedef std::function&lt;<a class="el" href="namespacemxnet.html#ad7801fb2dd68294d4c7a9e289bc071ad">ExecType</a> (const NodeAttrs&amp; attrs)&gt;</td>
</tr>
</table>
</div><div class="memdoc">
<p>Execution mode of this operator. </p>
</div>
</div>
<a class="anchor" id="a0a1395f21139ba975a6268539df6a15d"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">using <a class="el" href="namespacemxnet.html#a0a1395f21139ba975a6268539df6a15d">mxnet::FInferStorageType</a> = typedef std::function&lt;bool (const NodeAttrs&amp; attrs, const int dev_mask, <a class="el" href="namespacemxnet.html#aad5fec2b4bceabbf4b884460cc2e0a2b">DispatchMode</a>* dispatch_mode, std::vector&lt;int&gt;* in_attrs, std::vector&lt;int&gt;* out_attrs)&gt;</td>
</tr>
</table>
</div><div class="memdoc">
<p>Resiger a storage and dispatch mode inference function based on storage types of the inputs and outputs, and the dev_mask for the operator. </p>
<dl class="section note"><dt>Note</dt><dd>Register under "FInferStorageType" </dd></dl>
</div>
</div>
<a class="anchor" id="a0906e49a921265634672f555451075ed"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">using <a class="el" href="namespacemxnet.html#a0906e49a921265634672f555451075ed">mxnet::FNDArrayFunction</a> = typedef std::function&lt;void (const nnvm::NodeAttrs&amp; attrs, const std::vector&lt;<a class="el" href="classmxnet_1_1NDArray.html">NDArray</a>&gt;&amp; inputs, std::vector&lt;<a class="el" href="classmxnet_1_1NDArray.html">NDArray</a>&gt;* outputs)&gt;</td>
</tr>
</table>
</div><div class="memdoc">
<p>Register an operator called as a <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> function. </p>
<dl class="section note"><dt>Note</dt><dd>Register under "FNDArrayFunction" </dd></dl>
</div>
</div>
<a class="anchor" id="a7f7c271f6d03ee358eb9e66486e41045"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">using <a class="el" href="namespacemxnet.html#a7f7c271f6d03ee358eb9e66486e41045">mxnet::FNeedRequantize</a> = typedef std::function&lt;bool (const NodeAttrs&amp; attrs)&gt;</td>
</tr>
</table>
</div><div class="memdoc">
<p>Register a function to determine if the output of a quantized operator needs to be requantized. This is usually used for the operators taking int8 data types while accumulating in int32, e.g. quantized_conv. </p>
<dl class="section note"><dt>Note</dt><dd>Register under "FNeedRequantize" for non-quantized operators </dd></dl>
</div>
</div>
<a class="anchor" id="ac4a55ce92442f122a1a0e6ae8d134f10"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">using <a class="el" href="namespacemxnet.html#ac4a55ce92442f122a1a0e6ae8d134f10">mxnet::FQuantizedOp</a> = typedef std::function&lt;nnvm::NodePtr (const NodeAttrs&amp; attrs)&gt;</td>
</tr>
</table>
</div><div class="memdoc">
<p>Register a quantized node creation function based on the attrs of the node. </p>
<dl class="section note"><dt>Note</dt><dd>Register under "FQuantizedOp" for non-quantized operators </dd></dl>
</div>
</div>
<a class="anchor" id="afaa687cbca9e992614be285711c1d72d"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">using <a class="el" href="namespacemxnet.html#afaa687cbca9e992614be285711c1d72d">mxnet::FResourceRequest</a> = typedef std::function&lt; std::vector&lt;<a class="el" href="structmxnet_1_1ResourceRequest.html">ResourceRequest</a>&gt; (const NodeAttrs&amp; n)&gt;</td>
</tr>
</table>
</div><div class="memdoc">
<p>The resource request from the operator. </p>
<dl class="section note"><dt>Note</dt><dd>Register under "FResourceRequest" </dd></dl>
</div>
</div>
<a class="anchor" id="a9097a269dd76d833c014149ff3eaab9b"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">using <a class="el" href="namespacemxnet.html#a9097a269dd76d833c014149ff3eaab9b">mxnet::FStatefulCompute</a> = typedef std::function&lt;void (const <a class="el" href="classmxnet_1_1OpStatePtr.html">OpStatePtr</a>&amp; state, const <a class="el" href="structmxnet_1_1OpContext.html">OpContext</a>&amp; ctx, const std::vector&lt;<a class="el" href="classmxnet_1_1TBlob.html">TBlob</a>&gt;&amp; inputs, const std::vector&lt;<a class="el" href="namespacemxnet.html#a7cd7094ef222e9ae1f520c3b6a214398">OpReqType</a>&gt;&amp; req, const std::vector&lt;<a class="el" href="classmxnet_1_1TBlob.html">TBlob</a>&gt;&amp; outputs)&gt;</td>
</tr>
</table>
</div><div class="memdoc">
<p>Resiger a compute function for stateful operator. <a class="el" href="classmxnet_1_1OpStatePtr.html" title="Operator state. This is a pointer type, its content is mutable even if OpStatePtr is const...">OpStatePtr</a> is a pointer type, it's content is mutable even if <a class="el" href="classmxnet_1_1OpStatePtr.html" title="Operator state. This is a pointer type, its content is mutable even if OpStatePtr is const...">OpStatePtr</a> is constant. </p>
<dl class="section note"><dt>Note</dt><dd>Register under "FStatefulCompute&lt;cpu&gt;" and "FStatefulCompute&lt;gpu&gt;" </dd></dl>
</div>
</div>
<a class="anchor" id="ab12f1853179b1456152a563edff844a9"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">using <a class="el" href="namespacemxnet.html#ab12f1853179b1456152a563edff844a9">mxnet::FStatefulComputeEx</a> = typedef std::function&lt;void (const <a class="el" href="classmxnet_1_1OpStatePtr.html">OpStatePtr</a>&amp; state, const <a class="el" href="structmxnet_1_1OpContext.html">OpContext</a>&amp; ctx, const std::vector&lt;<a class="el" href="classmxnet_1_1NDArray.html">NDArray</a>&gt;&amp; inputs, const std::vector&lt;<a class="el" href="namespacemxnet.html#a7cd7094ef222e9ae1f520c3b6a214398">OpReqType</a>&gt;&amp; req, const std::vector&lt;<a class="el" href="classmxnet_1_1NDArray.html">NDArray</a>&gt;&amp; outputs)&gt;</td>
</tr>
</table>
</div><div class="memdoc">
<p>Resiger a compute function for stateful operator using <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> interface. <a class="el" href="classmxnet_1_1OpStatePtr.html" title="Operator state. This is a pointer type, its content is mutable even if OpStatePtr is const...">OpStatePtr</a> is a pointer type, it's content is mutable even if <a class="el" href="classmxnet_1_1OpStatePtr.html" title="Operator state. This is a pointer type, its content is mutable even if OpStatePtr is const...">OpStatePtr</a> is constant. </p>
<dl class="section note"><dt>Note</dt><dd>Register under "FStatefulComputeEx&lt;cpu&gt;" and "FStatefulComputeEx&lt;gpu&gt;" </dd></dl>
</div>
</div>
<a class="anchor" id="a31ef33571a4f6ba8847eeee1f4907141"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">typedef mshadow::gpu <a class="el" href="namespacemxnet.html#a31ef33571a4f6ba8847eeee1f4907141">mxnet::gpu</a></td>
</tr>
</table>
</div><div class="memdoc">
<p>mxnet gpu </p>
</div>
</div>
<a class="anchor" id="abadedc1b42ee3e5b8852e63783b982ef"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">typedef mshadow::index_t <a class="el" href="namespacemxnet.html#abadedc1b42ee3e5b8852e63783b982ef">mxnet::index_t</a></td>
</tr>
</table>
</div><div class="memdoc">
<p>index type usually use unsigned </p>
</div>
</div>
<a class="anchor" id="ab0d55b0edf98cf8f3caeb050662ae9ec"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">typedef std::function&lt;void (<a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> **used_vars, <a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a> *scalars, <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> **mutate_vars, int num_params, char **param_keys, char **param_vals)&gt; <a class="el" href="namespacemxnet.html#ab0d55b0edf98cf8f3caeb050662ae9ec">mxnet::NDArrayAPIFunction</a></td>
</tr>
</table>
</div><div class="memdoc">
<p>definition of <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> function </p>
</div>
</div>
<a class="anchor" id="ac2fb286fd7ddfbc7af1456f6c7a7ee52"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">using <a class="el" href="namespacemxnet.html#ac2fb286fd7ddfbc7af1456f6c7a7ee52">mxnet::Op</a> = typedef nnvm::Op</td>
</tr>
</table>
</div><div class="memdoc">
<p>operator structure from NNVM </p>
</div>
</div>
<a class="anchor" id="a6f5428fbf261a94eaac079ec24413815"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">typedef std::function&lt;<a class="el" href="classmxnet_1_1OperatorProperty.html">OperatorProperty</a> *()&gt; <a class="el" href="namespacemxnet.html#a6f5428fbf261a94eaac079ec24413815">mxnet::OperatorPropertyFactory</a></td>
</tr>
</table>
</div><div class="memdoc">
<p>typedef the factory function of operator property </p>
</div>
</div>
<a class="anchor" id="a4421326e33f2a848cb2fa3e70ab24ff4"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">typedef mshadow::default_real_t <a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">mxnet::real_t</a></td>
</tr>
</table>
</div><div class="memdoc">
<p>data type that will be used to store ndarray </p>
</div>
</div>
<a class="anchor" id="a6606bef15f41cccade14c9400e8447cf"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">using <a class="el" href="namespacemxnet.html#a6606bef15f41cccade14c9400e8447cf">mxnet::StorageTypeVector</a> = typedef std::vector&lt;int&gt;</td>
</tr>
</table>
</div><div class="memdoc">
<p>The result holder of storage type of each NodeEntry in the graph. </p>
<dl class="section note"><dt>Note</dt><dd>Stored under graph.attrs["storage_type"], provided by Pass "InferStorageType"</dd></dl>
<div class="fragment"><div class="line">Graph g = ApplyPass(src_graph, <span class="stringliteral">"InferStorageType"</span>);</div><div class="line"><span class="keyword">const</span> StorageVector&amp; stypes = g.GetAttr&lt;<a class="code" href="namespacemxnet.html#a6606bef15f41cccade14c9400e8447cf">StorageTypeVector</a>&gt;(<span class="stringliteral">"storage_type"</span>);</div><div class="line"><span class="comment">// get storage type by entry id</span></div><div class="line"><span class="keywordtype">int</span> entry_type = stypes[g.indexed_graph().entry_id(my_entry)];</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacemxnet.html#a0a1395f21139ba975a6268539df6a15d" title="Resiger a storage and dispatch mode inference function based on storage types of the inputs and outpu...">FInferStorageType</a> </dd></dl>
</div>
</div>
<a class="anchor" id="a6e14bb5f6ffc81892feca8d1da658687"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">using <a class="el" href="namespacemxnet.html#a6e14bb5f6ffc81892feca8d1da658687">mxnet::TShape</a> = typedef nnvm::TShape</td>
</tr>
</table>
</div><div class="memdoc">
<p>Shape data structure used to record shape information. </p>
</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="aad5fec2b4bceabbf4b884460cc2e0a2b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="namespacemxnet.html#aad5fec2b4bceabbf4b884460cc2e0a2b">mxnet::DispatchMode</a></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>the dispatch mode of the operator </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="aad5fec2b4bceabbf4b884460cc2e0a2ba7934d40c7c17315d892e8d5d745b1c66"></a>kUndefined </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aad5fec2b4bceabbf4b884460cc2e0a2ba2157864769b54d1d0f8f9be63393e7d6"></a>kFCompute </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aad5fec2b4bceabbf4b884460cc2e0a2ba57f93219462690bc438372ecd92fedd5"></a>kFComputeEx </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aad5fec2b4bceabbf4b884460cc2e0a2ba18bf63b4c196f79c9bca4ad8637e8fef"></a>kFComputeFallback </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aad5fec2b4bceabbf4b884460cc2e0a2bafb751f6ee1af15e773242f2accd2dbff"></a>kVariable </td><td class="fielddoc">
</td></tr>
</table>
</div>
</div>
<a class="anchor" id="ad7801fb2dd68294d4c7a9e289bc071ad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="namespacemxnet.html#ad7801fb2dd68294d4c7a9e289bc071ad">mxnet::ExecType</a></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>the execution type of the operator </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ad7801fb2dd68294d4c7a9e289bc071adae3bade32f12a5139b27ef40b3689b77c"></a>kSync </td><td class="fielddoc">
<p>Forward/Backward are synchronize calls. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad7801fb2dd68294d4c7a9e289bc071ada9f2b960005d2a3a5f35ac32809d84db7"></a>kAsync </td><td class="fielddoc">
<p>Forward/Backward are asynchronize, will call <a class="el" href="structmxnet_1_1OpContext.html#a40ce0e3d4ac21412cfafafc5b1fd32ef" title="the callback when operation completes, used by asynchronize ops ">OpContext.async_on_complete</a> when operation finishes. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad7801fb2dd68294d4c7a9e289bc071ada3864860a073c64d74d3fc8e765fa6cad"></a>kCrossDeviceCopy </td><td class="fielddoc">
<p>Cross device copy operation, this is a special operator That indicates copy across devices, the input and output can sit on different device. In current implementation, copy operator is specially handled by executor. This flag is used for special case treatment and future extension of different copy ops. </p>
</td></tr>
</table>
</div>
</div>
<a class="anchor" id="a998b74220fab2b012cf8a179650e1b3b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="namespacemxnet.html#a998b74220fab2b012cf8a179650e1b3b">mxnet::FnProperty</a></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Function property, used to hint what action is pushed to engine. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a998b74220fab2b012cf8a179650e1b3ba07fa7a19aa722c635a15e94cb7f50416"></a>kNormal </td><td class="fielddoc">
<p>Normal operation. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a998b74220fab2b012cf8a179650e1b3ba739f2f416f05f4728c217f09e93958d1"></a>kCopyFromGPU </td><td class="fielddoc">
<p>Copy operation from GPU to other devices. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a998b74220fab2b012cf8a179650e1b3ba6cd75f41e0ec8d61b0a2f0e20ef6d1e8"></a>kCopyToGPU </td><td class="fielddoc">
<p>Copy operation from CPU to other devices. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a998b74220fab2b012cf8a179650e1b3bac41ceb98eeb9b2e208e3e242a7357142"></a>kCPUPrioritized </td><td class="fielddoc">
<p>Prioritized sync operation on CPU. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a998b74220fab2b012cf8a179650e1b3ba9f2b960005d2a3a5f35ac32809d84db7"></a>kAsync </td><td class="fielddoc">
<p>Asynchronous function call. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a998b74220fab2b012cf8a179650e1b3bac41fda8552e9d327ad3b06b1bafa663a"></a>kDeleteVar </td><td class="fielddoc">
<p>Delete variable call. </p>
</td></tr>
</table>
</div>
</div>
<a class="anchor" id="ace60510752753f459193f95cab0e9e1a"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="namespacemxnet.html#ace60510752753f459193f95cab0e9e1a">mxnet::NDArrayFormatErr</a></td>
</tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ace60510752753f459193f95cab0e9e1aa322b8b178929b43f1b4b16c8cb9003ef"></a>kNormalErr </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ace60510752753f459193f95cab0e9e1aaf64429479d4a48998e6cd122a3117628"></a>kCSRShapeErr </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ace60510752753f459193f95cab0e9e1aa11ce5dbb8ad355e9ee5a678f2f51a5bb"></a>kCSRIndPtrErr </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ace60510752753f459193f95cab0e9e1aaf3ee084ba1d9a6203922ff7c9ddb12e3"></a>kCSRIdxErr </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ace60510752753f459193f95cab0e9e1aa200492eeec6fa431683ef0d943bfbc2d"></a>kRSPShapeErr </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ace60510752753f459193f95cab0e9e1aa7636cc230df4abe46f3210846faac799"></a>kRSPIdxErr </td><td class="fielddoc">
</td></tr>
</table>
</div>
</div>
<a class="anchor" id="a89a5f0f5cfd9e1e94604a7b42dda818a"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="namespacemxnet.html#a89a5f0f5cfd9e1e94604a7b42dda818a">mxnet::NDArrayFunctionTypeMask</a></td>
</tr>
</table>
</div><div class="memdoc">
<p>mask information on how functions can be exposed </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a89a5f0f5cfd9e1e94604a7b42dda818aabbc1ba0bb3f8647dcfd8bad69efdbb51"></a>kNDArrayArgBeforeScalar </td><td class="fielddoc">
<p>all the use_vars should go before scalar </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a89a5f0f5cfd9e1e94604a7b42dda818aaef9818c8aae9d0046b3d9033a62fcfbb"></a>kScalarArgBeforeNDArray </td><td class="fielddoc">
<p>all the scalar should go before use_vars </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a89a5f0f5cfd9e1e94604a7b42dda818aa334598420a4246d5412ddc346b2b57bd"></a>kAcceptEmptyMutateTarget </td><td class="fielddoc">
<p>whether this function allows the handles in the target to be empty <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> that are not yet initialized, and will initialize them when the function is invoked. </p>
<p>most function should support this, except copy between different devices, which requires the <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> to be pre-initialized with context </p>
</td></tr>
</table>
</div>
</div>
<a class="anchor" id="a536b732faa980e1de446c552460ff76a"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="namespacemxnet.html#a536b732faa980e1de446c552460ff76a">mxnet::NDArrayStorageType</a></td>
</tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a536b732faa980e1de446c552460ff76aadf6c6faf0de1e55119c679180c99e584"></a>kUndefinedStorage </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a536b732faa980e1de446c552460ff76aabf6395d98a9668e8066a0c0da5570608"></a>kDefaultStorage </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a536b732faa980e1de446c552460ff76aac095f52c31076adc7207f4a4f17d7aa3"></a>kRowSparseStorage </td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a536b732faa980e1de446c552460ff76aa777c7ad3afa566f2e841f12c81aab254"></a>kCSRStorage </td><td class="fielddoc">
</td></tr>
</table>
</div>
</div>
<a class="anchor" id="a7cd7094ef222e9ae1f520c3b6a214398"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="namespacemxnet.html#a7cd7094ef222e9ae1f520c3b6a214398">mxnet::OpReqType</a></td>
</tr>
</table>
</div><div class="memdoc">
<p>operation request type to Forward and Backward </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a7cd7094ef222e9ae1f520c3b6a214398a001b85096e07108e174fe4c406368a26"></a>kNullOp </td><td class="fielddoc">
<p>no operation, do not write anything </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7cd7094ef222e9ae1f520c3b6a214398a03b4c19f34d3add7deecd7ef6c54b42a"></a>kWriteTo </td><td class="fielddoc">
<p>write gradient to provided space </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7cd7094ef222e9ae1f520c3b6a214398a640322face587ca12684378d0f053d51"></a>kWriteInplace </td><td class="fielddoc">
<p>perform an inplace write, This option only happen when Target shares memory with one of input arguments. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7cd7094ef222e9ae1f520c3b6a214398a1b850737dba4d2c42a2687d14c10f383"></a>kAddTo </td><td class="fielddoc">
<p>add to the provided space </p>
</td></tr>
</table>
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ae7b0809624683afc59b6d7f7784d8bfb"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void mxnet::CopyFromTo </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp; </td>
<td class="paramname"><em>from</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> * </td>
<td class="paramname"><em>to</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>priority</em> = <code>0</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>issue an copy operation from one <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> to another the two ndarray can sit on different devices this operation will be scheduled by the engine </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">from</td><td>the ndarray we want to copy data from </td></tr>
<tr><td class="paramname">to</td><td>the target ndarray </td></tr>
<tr><td class="paramname">priority</td><td>Priority of the action. </td></tr>
</table>
</dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The function name explicitly marks the order of from and to due to different possible convention carried by copy function. </dd></dl>
</div>
</div>
<a class="anchor" id="aa005a02aac4f297b6fab561e907e89e3"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void mxnet::CopyFromTo </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp; </td>
<td class="paramname"><em>from</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp; </td>
<td class="paramname"><em>to</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>priority</em> = <code>0</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>issue an copy operation from one <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> to another the two ndarray can sit on different devices this operation will be scheduled by the engine </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">from</td><td>the ndarray we want to copy data from </td></tr>
<tr><td class="paramname">to</td><td>the target ndarray </td></tr>
<tr><td class="paramname">priority</td><td>Priority of the action. </td></tr>
</table>
</dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The function name explicitly marks the order of from and to due to different possible convention carried by copy function. </dd></dl>
</div>
</div>
<a class="anchor" id="a15dfd6f3fa03dc2cf39dbab1225e1a51"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void mxnet::ElementwiseSum </td>
<td>(</td>
<td class="paramtype">const std::vector&lt; <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &gt; &amp; </td>
<td class="paramname"><em>source</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> * </td>
<td class="paramname"><em>out</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>priority</em> = <code>0</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Perform elementwise sum over each data from source, store result into out. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">source</td><td>the ndarray we want to sum </td></tr>
<tr><td class="paramname">out</td><td>the target ndarray </td></tr>
<tr><td class="paramname">priority</td><td>Priority of the action. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="ae4143fe21881cbf0174bba638e8e0330"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">size_t mxnet::num_aux_data </td>
<td>(</td>
<td class="paramtype"><a class="el" href="namespacemxnet.html#a536b732faa980e1de446c552460ff76a">NDArrayStorageType</a> </td>
<td class="paramname"><em>stype</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the number of aux data used for given storage type </dd></dl>
</div>
</div>
<a class="anchor" id="af26b09fbcda865d34ec4fdad482d266a"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> mxnet::operator* </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp; </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp; </td>
<td class="paramname"><em>rhs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>elementwise multiplication </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">lhs</td><td>left operand </td></tr>
<tr><td class="paramname">rhs</td><td>right operand </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new result ndarray </dd></dl>
</div>
</div>
<a class="anchor" id="a66510f6a344ee38bb89cb552e974b838"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> mxnet::operator* </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp; </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a> &amp; </td>
<td class="paramname"><em>rhs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>elementwise multiplication </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">lhs</td><td>left operand </td></tr>
<tr><td class="paramname">rhs</td><td>right operand </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new result ndarray </dd></dl>
</div>
</div>
<a class="anchor" id="a4dafe3aae43025fd21bc44b98c18ed1e"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> mxnet::operator+ </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp; </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp; </td>
<td class="paramname"><em>rhs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>elementwise add </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">lhs</td><td>left operand </td></tr>
<tr><td class="paramname">rhs</td><td>right operand </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new result ndarray </dd></dl>
</div>
</div>
<a class="anchor" id="a30bfda0e3e1b347e3057097cafc628be"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> mxnet::operator+ </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp; </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a> &amp; </td>
<td class="paramname"><em>rhs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>elementwise add </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">lhs</td><td>left operand </td></tr>
<tr><td class="paramname">rhs</td><td>right operand </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new result ndarray </dd></dl>
</div>
</div>
<a class="anchor" id="ae3356844b657c9ae1b84d3ddd56bccf6"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> mxnet::operator- </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp; </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp; </td>
<td class="paramname"><em>rhs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>elementwise subtraction </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">lhs</td><td>left operand </td></tr>
<tr><td class="paramname">rhs</td><td>right operand </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new result ndarray </dd></dl>
</div>
</div>
<a class="anchor" id="a0c8542953df5093060985db5518a339b"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> mxnet::operator- </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp; </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a> &amp; </td>
<td class="paramname"><em>rhs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>elementwise subtraction </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">lhs</td><td>left operand </td></tr>
<tr><td class="paramname">rhs</td><td>right operand </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new result ndarray </dd></dl>
</div>
</div>
<a class="anchor" id="a502e3e00dc61cedb9c6eef711f1176ac"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> mxnet::operator/ </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp; </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp; </td>
<td class="paramname"><em>rhs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>elementwise division </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">lhs</td><td>left operand </td></tr>
<tr><td class="paramname">rhs</td><td>right operand </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new result ndarray </dd></dl>
</div>
</div>
<a class="anchor" id="a3455659b714488e8e53e4e4580a43ec7"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> mxnet::operator/ </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp; </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a> &amp; </td>
<td class="paramname"><em>rhs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>elementwise division </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">lhs</td><td>left operand </td></tr>
<tr><td class="paramname">rhs</td><td>right operand </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new result ndarray </dd></dl>
</div>
</div>
<a class="anchor" id="a5bf83454c8f41259eb9d471f59feda2b"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void mxnet::RandomSeed </td>
<td>(</td>
<td class="paramtype">uint32_t </td>
<td class="paramname"><em>seed</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Seed all random number generator in mxnet. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">seed</td><td>the seed to set to global random number generators. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="ab6d578be9be3a2a0d3e21246834d3e71"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void mxnet::RandomSeed </td>
<td>(</td>
<td class="paramtype"><a class="el" href="structmxnet_1_1Context.html">Context</a> </td>
<td class="paramname"><em>ctx</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint32_t </td>
<td class="paramname"><em>seed</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Seed the random number generator of the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">seed</td><td>the seed to set to global random number generators. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="a51f9b094369a349c05463de2be9f0a31"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void mxnet::SampleExponential </td>
<td>(</td>
<td class="paramtype"><a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a> </td>
<td class="paramname"><em>lambda</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> * </td>
<td class="paramname"><em>out</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Sample exponential distribution for each elements of out. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">lambda</td><td>parameter (rate) of the exponential distribution </td></tr>
<tr><td class="paramname">out</td><td>output <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="a050beaa505f11e0b844deb91efe0cac2"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void mxnet::SampleGamma </td>
<td>(</td>
<td class="paramtype"><a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a> </td>
<td class="paramname"><em>alpha</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a> </td>
<td class="paramname"><em>beta</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> * </td>
<td class="paramname"><em>out</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Sample gamma distribution for each elements of out. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">alpha</td><td>parameter (shape) of the gamma distribution </td></tr>
<tr><td class="paramname">beta</td><td>parameter (scale) of the gamma distribution </td></tr>
<tr><td class="paramname">out</td><td>output <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="a5a28062f52ca576a126599e7ad487077"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void mxnet::SampleGaussian </td>
<td>(</td>
<td class="paramtype"><a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a> </td>
<td class="paramname"><em>mu</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a> </td>
<td class="paramname"><em>sigma</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> * </td>
<td class="paramname"><em>out</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Sample gaussian distribution for each elements of out. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">mu</td><td>mean of gaussian distribution. </td></tr>
<tr><td class="paramname">sigma</td><td>standard deviation of gaussian distribution. </td></tr>
<tr><td class="paramname">out</td><td>output <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="ad8e0dad88ce27133fd24811763b7afdb"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void mxnet::SampleGenNegBinomial </td>
<td>(</td>
<td class="paramtype"><a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a> </td>
<td class="paramname"><em>mu</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a> </td>
<td class="paramname"><em>alpha</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> * </td>
<td class="paramname"><em>out</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Sample generalized negative binomial distribution for each elements of out. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">mu</td><td>parameter (mean) of the distribution </td></tr>
<tr><td class="paramname">alpha</td><td>parameter (over dispersion) of the distribution </td></tr>
<tr><td class="paramname">out</td><td>output <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="ae82f70918b2d946f7ad66a158b1733dc"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void mxnet::SampleNegBinomial </td>
<td>(</td>
<td class="paramtype">int32_t </td>
<td class="paramname"><em>k</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a> </td>
<td class="paramname"><em>p</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> * </td>
<td class="paramname"><em>out</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Sample negative binomial distribution for each elements of out. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">k</td><td>failure limit </td></tr>
<tr><td class="paramname">p</td><td>success probability </td></tr>
<tr><td class="paramname">out</td><td>output <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="aed55e8197182b7c66126902b2a43739a"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void mxnet::SamplePoisson </td>
<td>(</td>
<td class="paramtype"><a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a> </td>
<td class="paramname"><em>lambda</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> * </td>
<td class="paramname"><em>out</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Sample Poisson distribution for each elements of out. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">lambda</td><td>parameter (rate) of the Poisson distribution </td></tr>
<tr><td class="paramname">out</td><td>output <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="a2846f4556c9ca9bd0f567504ce60f274"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void mxnet::SampleUniform </td>
<td>(</td>
<td class="paramtype"><a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a> </td>
<td class="paramname"><em>begin</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a> </td>
<td class="paramname"><em>end</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> * </td>
<td class="paramname"><em>out</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Sample uniform distribution for each elements of out. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">begin</td><td>lower bound of distribution. </td></tr>
<tr><td class="paramname">end</td><td>upper bound of distribution. </td></tr>
<tr><td class="paramname">out</td><td>output <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a512ee02aece77cb0bf39b6e2ded77686"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">constexpr const int mxnet::kCPU = kDLCPU</td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a class="anchor" id="a43ebce8ff01c0bee0dddb4417ea1239d"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">constexpr const int mxnet::kGPU = kDLGPU</td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a class="anchor" id="ab96d1eea6c8d006db2b33bbdf9d90bd2"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">constexpr const int mxnet::kTVMNDArrayTypeCode = 19</td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Sep 19 2019 12:53:03 for mxnet by  <a href="http://www.doxygen.org/index.html">
<img alt="doxygen" class="footer" src="doxygen.png"/>
</a> 1.8.11
</small></address>
</body>
</html>
