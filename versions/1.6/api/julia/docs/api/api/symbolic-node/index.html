



<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      <meta http-equiv="x-ua-compatible" content="ie=edge">
      
      
      
      
        <meta name="lang:clipboard.copy" content="Copy to clipboard">
      
        <meta name="lang:clipboard.copied" content="Copied to clipboard">
      
        <meta name="lang:search.language" content="en">
      
        <meta name="lang:search.pipeline.stopwords" content="True">
      
        <meta name="lang:search.pipeline.trimmer" content="True">
      
        <meta name="lang:search.result.none" content="No matching documents">
      
        <meta name="lang:search.result.one" content="1 matching document">
      
        <meta name="lang:search.result.other" content="# matching documents">
      
        <meta name="lang:search.tokenizer" content="[\s\-]+">
      
      <link rel="shortcut icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.0.4, mkdocs-material-4.6.0">
    
    
      
        <title>Symbolic API - MXNet.jl</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/application.1b62728e.css">
      
      
    
    
      <script src="../../assets/javascripts/modernizr.268332fc.js"></script>
    
    
      
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}</style>
      
    
    <link rel="stylesheet" href="../../assets/fonts/material-icons.css">
    
    
      <link rel="stylesheet" href="../../assets/Documenter.css">
    
    
      
    
    
  </head>
  
    <body dir="ltr">
  
    <svg class="md-svg">
      <defs>
        
        
          <svg xmlns="http://www.w3.org/2000/svg" width="416" height="448" viewBox="0 0 416 448" id="__github"><path fill="currentColor" d="M160 304q0 10-3.125 20.5t-10.75 19T128 352t-18.125-8.5-10.75-19T96 304t3.125-20.5 10.75-19T128 256t18.125 8.5 10.75 19T160 304zm160 0q0 10-3.125 20.5t-10.75 19T288 352t-18.125-8.5-10.75-19T256 304t3.125-20.5 10.75-19T288 256t18.125 8.5 10.75 19T320 304zm40 0q0-30-17.25-51T296 232q-10.25 0-48.75 5.25Q229.5 240 208 240t-39.25-2.75Q130.75 232 120 232q-29.5 0-46.75 21T56 304q0 22 8 38.375t20.25 25.75 30.5 15 35 7.375 37.25 1.75h42q20.5 0 37.25-1.75t35-7.375 30.5-15 20.25-25.75T360 304zm56-44q0 51.75-15.25 82.75-9.5 19.25-26.375 33.25t-35.25 21.5-42.5 11.875-42.875 5.5T212 416q-19.5 0-35.5-.75t-36.875-3.125-38.125-7.5-34.25-12.875T37 371.5t-21.5-28.75Q0 312 0 260q0-59.25 34-99-6.75-20.5-6.75-42.5 0-29 12.75-54.5 27 0 47.5 9.875t47.25 30.875Q171.5 96 212 96q37 0 70 8 26.25-20.5 46.75-30.25T376 64q12.75 25.5 12.75 54.5 0 21.75-6.75 42 34 40 34 99.5z"/></svg>
        
      </defs>
    </svg>
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
    
      <a href="#symbolic-api" tabindex="1" class="md-skip">
        Skip to content
      </a>
    
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href="../.." title="MXNet.jl" class="md-header-nav__button md-logo">
          
            <i class="md-icon"></i>
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          
            <span class="md-header-nav__topic">
              MXNet.jl
            </span>
            <span class="md-header-nav__topic">
              
                Symbolic API
              
            </span>
          
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        
          <label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
          
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="__search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        &#xE5CD;
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            Type to start searching
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
        
      </div>
      
        <div class="md-flex__cell md-flex__cell--shrink">
          <div class="md-header-nav__source">
            


  

<a href="https://github.com/apache/incubator-mxnet/tree/master/julia#mxnet/" title="Go to repository" class="md-source" data-md-source="github">
  
    <div class="md-source__icon">
      <svg viewBox="0 0 24 24" width="24" height="24">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    GitHub
  </div>
</a>
          </div>
        </div>
      
    </div>
  </nav>
</header>
    
    <div class="md-container">
      
        
      
      
      <main class="md-main" role="main">
        <div class="md-main__inner md-grid" data-md-component="container">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="__drawer">
    <a href="../.." title="MXNet.jl" class="md-nav__button md-logo">
      
        <i class="md-icon"></i>
      
    </a>
    MXNet.jl
  </label>
  
    <div class="md-nav__source">
      


  

<a href="https://github.com/apache/incubator-mxnet/tree/master/julia#mxnet/" title="Go to repository" class="md-source" data-md-source="github">
  
    <div class="md-source__icon">
      <svg viewBox="0 0 24 24" width="24" height="24">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    GitHub
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item">
    <a href="../.." title="Home" class="md-nav__link">
      Home
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-2" type="checkbox" id="nav-2">
    
    <label class="md-nav__link" for="nav-2">
      Tutorial
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-2">
        Tutorial
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../tutorial/mnist/" title="Digit Recognition on MNIST" class="md-nav__link">
      Digit Recognition on MNIST
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../tutorial/char-lstm/" title="Generating Random Sentence with LSTM RNN" class="md-nav__link">
      Generating Random Sentence with LSTM RNN
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-3" type="checkbox" id="nav-3">
    
    <label class="md-nav__link" for="nav-3">
      User Guide
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-3">
        User Guide
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../user-guide/install/" title="Installation Guide" class="md-nav__link">
      Installation Guide
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../user-guide/overview/" title="Overview" class="md-nav__link">
      Overview
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../user-guide/faq/" title="FAQ" class="md-nav__link">
      FAQ
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      

  


  <li class="md-nav__item md-nav__item--active md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-4" type="checkbox" id="nav-4" checked>
    
    <label class="md-nav__link" for="nav-4">
      API Documentation
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-4">
        API Documentation
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../context/" title="Context" class="md-nav__link">
      Context
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../model/" title="Models" class="md-nav__link">
      Models
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../initializer/" title="Initializers" class="md-nav__link">
      Initializers
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../optimizer/" title="Optimizers" class="md-nav__link">
      Optimizers
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../callback/" title="Callbacks in training" class="md-nav__link">
      Callbacks in training
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../metric/" title="Evaluation Metrics" class="md-nav__link">
      Evaluation Metrics
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../io/" title="Data Providers" class="md-nav__link">
      Data Providers
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../ndarray/" title="NDArray API" class="md-nav__link">
      NDArray API
    </a>
  </li>

        
          
          
          

  


  <li class="md-nav__item md-nav__item--active">
    
    <input class="md-toggle md-nav__toggle" data-md-toggle="toc" type="checkbox" id="__toc">
    
      
    
    
      <label class="md-nav__link md-nav__link--active" for="__toc">
        Symbolic API
      </label>
    
    <a href="./" title="Symbolic API" class="md-nav__link md-nav__link--active">
      Symbolic API
    </a>
    
      
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">Table of contents</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#forward-softmax-output" class="md-nav__link">
    forward softmax output
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#backward-gradient-output" class="md-nav__link">
    backward gradient output
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#notice-that-the-first-row-is-all-0-because-label0-is-1-which-is-equal-to-ignore_label" class="md-nav__link">
    notice that the first row is all 0 because label[0] is 1, which is equal to ignore_label.
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#forward-softmax-output_1" class="md-nav__link">
    forward softmax output
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#backward-gradient-output_1" class="md-nav__link">
    backward gradient output
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#notice-that-the-first-row-is-all-0-because-label0-is-1-which-is-equal-to-ignore_label_1" class="md-nav__link">
    notice that the first row is all 0 because label[0] is 1, which is equal to ignore_label.
  </a>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
    
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../nn-factory/" title="Neural Networks Factory" class="md-nav__link">
      Neural Networks Factory
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../executor/" title="Executor" class="md-nav__link">
      Executor
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../kvstore/" title="Key-Value Store" class="md-nav__link">
      Key-Value Store
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../visualize/" title="Network Visualization" class="md-nav__link">
      Network Visualization
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">Table of contents</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#forward-softmax-output" class="md-nav__link">
    forward softmax output
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#backward-gradient-output" class="md-nav__link">
    backward gradient output
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#notice-that-the-first-row-is-all-0-because-label0-is-1-which-is-equal-to-ignore_label" class="md-nav__link">
    notice that the first row is all 0 because label[0] is 1, which is equal to ignore_label.
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#forward-softmax-output_1" class="md-nav__link">
    forward softmax output
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#backward-gradient-output_1" class="md-nav__link">
    backward gradient output
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#notice-that-the-first-row-is-all-0-because-label0-is-1-which-is-equal-to-ignore_label_1" class="md-nav__link">
    notice that the first row is all 0 because label[0] is 1, which is equal to ignore_label.
  </a>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                  <a href="https://github.com/apache/incubator-mxnet/tree/master/edit/master/docs/api/symbolic-node.md" title="Edit this page" class="md-icon md-content__icon">&#xE3C9;</a>
                
                
                <!–- Licensed to the Apache Software Foundation (ASF) under one –> <!–- or more contributor license agreements.  See the NOTICE file –> <!–- distributed with this work for additional information –> <!–- regarding copyright ownership.  The ASF licenses this file –> <!–- to you under the Apache License, Version 2.0 (the –> <!–- "License"); you may not use this file except in compliance –> <!–- with the License.  You may obtain a copy of the License at –>

<!–-   http://www.apache.org/licenses/LICENSE-2.0 –>

<!–- Unless required by applicable law or agreed to in writing, –> <!–- software distributed under the License is distributed on an –> <!–- "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY –> <!–- KIND, either express or implied.  See the License for the –> <!–- specific language governing permissions and limitations –> <!–- under the License. –>

<p><a id='Symbolic-API-1'></a></p>
<h1 id="symbolic-api">Symbolic API</h1>
<p><a id='Base.reshape-Union{Tuple{N}, Tuple{SymbolicNode,Tuple{Vararg{Integer,N}}}} where N' href='#Base.reshape-Union{Tuple{N}, Tuple{SymbolicNode,Tuple{Vararg{Integer,N}}}} where N'>#</a>
<strong><code>Base.reshape</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">reshape(sym::SymbolicNode, dim; reverse=false, name)
reshape(sym::SymbolicNode, dim...; reverse=false, name)
</code></pre>

<p>Reshape SymbolicNode operator</p>
<p>Some dimensions of the shape can take special values from the set {0, -1, -2, -3, -4}. The significance of each is explained below:</p>
<ul>
<li>
<p><code>0</code>  copy this dimension from the input to the output shape.</p>
<p>Example:</p>
<ul>
<li>input shape = (2,3,4), shape = (4,0,2), output shape = (4,3,2)</li>
<li>input shape = (2,3,4), shape = (2,0,0), output shape = (2,3,4)</li>
<li><code>-1</code> infers the dimension of the output shape by using the remainder of the input dimensions keeping the size of the new array same as that of the input array. At most one dimension of shape can be -1.</li>
</ul>
<p>Example:</p>
<ul>
<li>input shape = (2,3,4), shape = (6,1,-1), output shape = (6,1,4)</li>
<li>input shape = (2,3,4), shape = (3,-1,8), output shape = (3,1,8)</li>
<li>input shape = (2,3,4), shape=(-1,), output shape = (24,)</li>
<li><code>-2</code> copy all/remainder of the input dimensions to the output shape.</li>
</ul>
<p>Example:</p>
<ul>
<li>input shape = (2,3,4), shape = (-2,), output shape = (2,3,4)</li>
<li>input shape = (2,3,4), shape = (2,-2), output shape = (2,3,4)</li>
<li>input shape = (2,3,4), shape = (-2,1,1), output shape = (2,3,4,1,1)</li>
<li><code>-3</code> use the product of two consecutive dimensions of the input shape as the output dimension.</li>
</ul>
<p>Example:</p>
<ul>
<li>input shape = (2,3,4), shape = (-3,4), output shape = (6,4)</li>
<li>input shape = (2,3,4,5), shape = (-3,-3), output shape = (6,20)</li>
<li>input shape = (2,3,4), shape = (0,-3), output shape = (2,12)</li>
<li>input shape = (2,3,4), shape = (-3,-2), output shape = (6,4)</li>
<li><code>-4</code> split one dimension of the input into two dimensions passed subsequent to -4 in shape (can contain -1).</li>
</ul>
<p>Example:</p>
<ul>
<li>input shape = (2,3,4), shape = (-4,1,2,-2), output shape = (1,2,3,4)</li>
<li>input shape = (2,3,4), shape = (2,-4,-1,3,-2), output shape = (2,1,3,4)</li>
</ul>
</li>
</ul>
<p>If the argument <code>reverse</code> is set to <code>1</code>, then the special values are inferred from right to left.</p>
<p>Example:</p>
<ul>
<li>with <code>reverse=false</code>, for input shape = (10,5,4), shape = (-1,0), output shape would be (40,5)</li>
<li>with <code>reverse=true</code>, output shape will be (50,4).</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/array.jl#L22-L83' class='documenter-source'>source</a><br></p>
<p><a id='Base.Broadcast.broadcast_axes-Tuple{Vararg{SymbolicNode,N} where N}' href='#Base.Broadcast.broadcast_axes-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>Base.Broadcast.broadcast_axes</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">broadcast_axes(data, axis, size)
</code></pre>

<p>broadcast<em>axes is an alias of broadcast</em>axis.</p>
<p>Broadcasts the input array over particular axes.</p>
<p>Broadcasting is allowed on axes with size 1, such as from <code>(2,1,3,1)</code> to <code>(2,8,3,9)</code>. Elements will be duplicated on the broadcasted axes.</p>
<p><code>broadcast_axes</code> is an alias to the function <code>broadcast_axis</code>.</p>
<p>Example::</p>
<p>// given x of shape (1,2,1)    x = [[[ 1.],          [ 2.]]]</p>
<p>// broadcast x on on axis 2    broadcast<em>axis(x, axis=2, size=3) = [[[ 1.,  1.,  1.],                                          [ 2.,  2.,  2.]]]    // broadcast x on on axes 0 and 2    broadcast</em>axis(x, axis=(0,2), size=(2,3)) = [[[ 1.,  1.,  1.],                                                  [ 2.,  2.,  2.]],                                                 [[ 1.,  1.,  1.],                                                  [ 2.,  2.,  2.]]]</p>
<p>Defined in src/operator/tensor/broadcast<em>reduce</em>op_value.cc:L93</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input</li>
<li><code>axis::Shape(tuple), optional, default=[]</code>: The axes to perform the broadcasting.</li>
<li><code>size::Shape(tuple), optional, default=[]</code>: Target sizes of the broadcasting axes.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L376' class='documenter-source'>source</a><br></p>
<p><a id='Base.cos-Tuple{Vararg{SymbolicNode,N} where N}' href='#Base.cos-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>Base.cos</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">cos(data)
</code></pre>

<p>Computes the element-wise cosine of the input array.</p>
<p>The input should be in radians (:math:<code>2\pi</code> rad equals 360 degrees).</p>
<p>.. math::    cos([0, \pi/4, \pi/2]) = [1, 0.707, 0]</p>
<p>The storage type of $cos$ output is always dense</p>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_trig.cc:L90</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L358' class='documenter-source'>source</a><br></p>
<p><a id='Base.cosh-Tuple{Vararg{SymbolicNode,N} where N}' href='#Base.cosh-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>Base.cosh</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">cosh(data)
</code></pre>

<p>Returns the hyperbolic cosine  of the input array, computed element-wise.</p>
<p>.. math::    cosh(x) = 0.5\times(exp(x) + exp(-x))</p>
<p>The storage type of $cosh$ output is always dense</p>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_trig.cc:L409</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L356' class='documenter-source'>source</a><br></p>
<p><a id='Base.prod-Tuple{Vararg{SymbolicNode,N} where N}' href='#Base.prod-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>Base.prod</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">prod(data, axis, keepdims, exclude)
</code></pre>

<p>Computes the product of array elements over given axes.</p>
<p>Defined in src/operator/tensor/./broadcast<em>reduce</em>op.h:L31</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input</li>
<li>
<p><code>axis::Shape or None, optional, default=None</code>: The axis or axes along which to perform the reduction.</p>
<p><code>``
The default,</code>axis=()<code>, will compute over all elements into a
scalar array with shape</code>(1,)`.</p>
<p>If <code>axis</code> is int, a reduction is performed on a particular axis.</p>
<p>If <code>axis</code> is a tuple of ints, a reduction is performed on all the axes
specified in the tuple.</p>
<p>If <code>exclude</code> is true, reduction will be performed on the axes that are
NOT in axis instead.</p>
<p>Negative values means indexing from right to left.
<code>``
  *</code>keepdims::boolean, optional, default=0<code>: If this is set to</code>True<code>, the reduced axes are left in the result as dimension with size one.
  *</code>exclude::boolean, optional, default=0<code>: Whether to perform reduction on axis that are NOT in axis instead.
  *</code>name::Symbol<code>: The name of the</code>SymbolicNode<code>. (e.g.</code>:my_symbol<code>), optional.
  *</code>attrs::Dict{Symbol,String}<code>: The attributes associated with this</code>SymbolicNode`.</p>
</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L368' class='documenter-source'>source</a><br></p>
<p><a id='Base.sin-Tuple{Vararg{SymbolicNode,N} where N}' href='#Base.sin-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>Base.sin</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">sin(data)
</code></pre>

<p>Computes the element-wise sine of the input array.</p>
<p>The input should be in radians (:math:<code>2\pi</code> rad equals 360 degrees).</p>
<p>.. math::    sin([0, \pi/4, \pi/2]) = [0, 0.707, 1]</p>
<p>The storage type of $sin$ output depends upon the input storage type:</p>
<ul>
<li>sin(default) = default</li>
<li>sin(row<em>sparse) = row</em>sparse</li>
<li>sin(csr) = csr</li>
</ul>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_trig.cc:L47</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L362' class='documenter-source'>source</a><br></p>
<p><a id='Base.sinh-Tuple{Vararg{SymbolicNode,N} where N}' href='#Base.sinh-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>Base.sinh</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">sinh(data)
</code></pre>

<p>Returns the hyperbolic sine of the input array, computed element-wise.</p>
<p>.. math::    sinh(x) = 0.5\times(exp(x) - exp(-x))</p>
<p>The storage type of $sinh$ output depends upon the input storage type:</p>
<ul>
<li>sinh(default) = default</li>
<li>sinh(row<em>sparse) = row</em>sparse</li>
<li>sinh(csr) = csr</li>
</ul>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_trig.cc:L371</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L360' class='documenter-source'>source</a><br></p>
<p><a id='Base.sum-Tuple{Vararg{SymbolicNode,N} where N}' href='#Base.sum-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>Base.sum</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">sum(data, axis, keepdims, exclude)
</code></pre>

<p>Computes the sum of array elements over given axes.</p>
<p>.. Note::</p>
<p><code>sum</code> and <code>sum_axis</code> are equivalent.   For ndarray of csr storage type summation along axis 0 and axis 1 is supported.   Setting keepdims or exclude to True will cause a fallback to dense operator.</p>
<p>Example::</p>
<p>data = [[[1, 2], [2, 3], [1, 3]],           [[1, 4], [4, 3], [5, 2]],           [[7, 1], [7, 2], [7, 3]]]</p>
<p>sum(data, axis=1)   [[  4.   8.]    [ 10.   9.]    [ 21.   6.]]</p>
<p>sum(data, axis=[1,2])   [ 12.  19.  27.]</p>
<p>data = [[1, 2, 0],           [3, 0, 1],           [4, 1, 0]]</p>
<p>csr = cast_storage(data, 'csr')</p>
<p>sum(csr, axis=0)   [ 8.  3.  1.]</p>
<p>sum(csr, axis=1)   [ 3.  4.  5.]</p>
<p>Defined in src/operator/tensor/broadcast<em>reduce</em>sum_value.cc:L67</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input</li>
<li>
<p><code>axis::Shape or None, optional, default=None</code>: The axis or axes along which to perform the reduction.</p>
<p><code>``
The default,</code>axis=()<code>, will compute over all elements into a
scalar array with shape</code>(1,)`.</p>
<p>If <code>axis</code> is int, a reduction is performed on a particular axis.</p>
<p>If <code>axis</code> is a tuple of ints, a reduction is performed on all the axes
specified in the tuple.</p>
<p>If <code>exclude</code> is true, reduction will be performed on the axes that are
NOT in axis instead.</p>
<p>Negative values means indexing from right to left.
<code>``
  *</code>keepdims::boolean, optional, default=0<code>: If this is set to</code>True<code>, the reduced axes are left in the result as dimension with size one.
  *</code>exclude::boolean, optional, default=0<code>: Whether to perform reduction on axis that are NOT in axis instead.
  *</code>name::Symbol<code>: The name of the</code>SymbolicNode<code>. (e.g.</code>:my_symbol<code>), optional.
  *</code>attrs::Dict{Symbol,String}<code>: The attributes associated with this</code>SymbolicNode`.</p>
</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L402' class='documenter-source'>source</a><br></p>
<p><a id='Base.tan-Tuple{Vararg{SymbolicNode,N} where N}' href='#Base.tan-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>Base.tan</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">tan(data)
</code></pre>

<p>Computes the element-wise tangent of the input array.</p>
<p>The input should be in radians (:math:<code>2\pi</code> rad equals 360 degrees).</p>
<p>.. math::    tan([0, \pi/4, \pi/2]) = [0, 1, -inf]</p>
<p>The storage type of $tan$ output depends upon the input storage type:</p>
<ul>
<li>tan(default) = default</li>
<li>tan(row<em>sparse) = row</em>sparse</li>
<li>tan(csr) = csr</li>
</ul>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_trig.cc:L140</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L362' class='documenter-source'>source</a><br></p>
<p><a id='Base.tanh-Tuple{Vararg{SymbolicNode,N} where N}' href='#Base.tanh-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>Base.tanh</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">tanh(data)
</code></pre>

<p>Returns the hyperbolic tangent of the input array, computed element-wise.</p>
<p>.. math::    tanh(x) = sinh(x) / cosh(x)</p>
<p>The storage type of $tanh$ output depends upon the input storage type:</p>
<ul>
<li>tanh(default) = default</li>
<li>tanh(row<em>sparse) = row</em>sparse</li>
<li>tanh(csr) = csr</li>
</ul>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_trig.cc:L451</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L360' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.arccos-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.arccos-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.arccos</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">arccos(data)
</code></pre>

<p>Returns element-wise inverse cosine of the input array.</p>
<p>The input should be in range <code>[-1, 1]</code>. The output is in the closed interval :math:<code>[0, \pi]</code></p>
<p>.. math::    arccos([-1, -.707, 0, .707, 1]) = [\pi, 3\pi/4, \pi/2, \pi/4, 0]</p>
<p>The storage type of $arccos$ output is always dense</p>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_trig.cc:L233</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L359' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.arccosh-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.arccosh-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.arccosh</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">arccosh(data)
</code></pre>

<p>Returns the element-wise inverse hyperbolic cosine of the input array, 
computed element-wise.</p>
<p>The storage type of $arccosh$ output is always dense</p>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_trig.cc:L535</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L354' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.arcsin-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.arcsin-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.arcsin</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">arcsin(data)
</code></pre>

<p>Returns element-wise inverse sine of the input array.</p>
<p>The input should be in the range <code>[-1, 1]</code>. The output is in the closed interval of [:math:<code>-\pi/2</code>, :math:<code>\pi/2</code>].</p>
<p>.. math::    arcsin([-1, -.707, 0, .707, 1]) = [-\pi/2, -\pi/4, 0, \pi/4, \pi/2]</p>
<p>The storage type of $arcsin$ output depends upon the input storage type:</p>
<ul>
<li>arcsin(default) = default</li>
<li>arcsin(row<em>sparse) = row</em>sparse</li>
<li>arcsin(csr) = csr</li>
</ul>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_trig.cc:L187</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L363' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.arcsinh-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.arcsinh-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.arcsinh</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">arcsinh(data)
</code></pre>

<p>Returns the element-wise inverse hyperbolic sine of the input array, 
computed element-wise.</p>
<p>The storage type of $arcsinh$ output depends upon the input storage type:</p>
<ul>
<li>arcsinh(default) = default</li>
<li>arcsinh(row<em>sparse) = row</em>sparse</li>
<li>arcsinh(csr) = csr</li>
</ul>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_trig.cc:L494</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L358' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.arctan-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.arctan-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.arctan</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">arctan(data)
</code></pre>

<p>Returns element-wise inverse tangent of the input array.</p>
<p>The output is in the closed interval :math:<code>[-\pi/2, \pi/2]</code></p>
<p>.. math::    arctan([-1, 0, 1]) = [-\pi/4, 0, \pi/4]</p>
<p>The storage type of $arctan$ output depends upon the input storage type:</p>
<ul>
<li>arctan(default) = default</li>
<li>arctan(row<em>sparse) = row</em>sparse</li>
<li>arctan(csr) = csr</li>
</ul>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_trig.cc:L282</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L362' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.arctanh-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.arctanh-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.arctanh</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">arctanh(data)
</code></pre>

<p>Returns the element-wise inverse hyperbolic tangent of the input array, 
computed element-wise.</p>
<p>The storage type of $arctanh$ output depends upon the input storage type:</p>
<ul>
<li>arctanh(default) = default</li>
<li>arctanh(row<em>sparse) = row</em>sparse</li>
<li>arctanh(csr) = csr</li>
</ul>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_trig.cc:L579</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L358' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.broadcast_axis-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.broadcast_axis-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.broadcast_axis</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">broadcast_axis(data, axis, size)
</code></pre>

<p>Broadcasts the input array over particular axes.</p>
<p>Broadcasting is allowed on axes with size 1, such as from <code>(2,1,3,1)</code> to <code>(2,8,3,9)</code>. Elements will be duplicated on the broadcasted axes.</p>
<p><code>broadcast_axes</code> is an alias to the function <code>broadcast_axis</code>.</p>
<p>Example::</p>
<p>// given x of shape (1,2,1)    x = [[[ 1.],          [ 2.]]]</p>
<p>// broadcast x on on axis 2    broadcast<em>axis(x, axis=2, size=3) = [[[ 1.,  1.,  1.],                                          [ 2.,  2.,  2.]]]    // broadcast x on on axes 0 and 2    broadcast</em>axis(x, axis=(0,2), size=(2,3)) = [[[ 1.,  1.,  1.],                                                  [ 2.,  2.,  2.]],                                                 [[ 1.,  1.,  1.],                                                  [ 2.,  2.,  2.]]]</p>
<p>Defined in src/operator/tensor/broadcast<em>reduce</em>op_value.cc:L93</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input</li>
<li><code>axis::Shape(tuple), optional, default=[]</code>: The axes to perform the broadcasting.</li>
<li><code>size::Shape(tuple), optional, default=[]</code>: Target sizes of the broadcasting axes.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L374' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.broadcast_to-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.broadcast_to-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.broadcast_to</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">broadcast_to(data, shape)
</code></pre>

<p>Broadcasts the input array to a new shape.</p>
<p>Broadcasting is a mechanism that allows NDArrays to perform arithmetic operations with arrays of different shapes efficiently without creating multiple copies of arrays. Also see, <code>Broadcasting &lt;https://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&gt;</code>_ for more explanation.</p>
<p>Broadcasting is allowed on axes with size 1, such as from <code>(2,1,3,1)</code> to <code>(2,8,3,9)</code>. Elements will be duplicated on the broadcasted axes.</p>
<p>For example::</p>
<p>broadcast_to([[1,2,3]], shape=(2,3)) = [[ 1.,  2.,  3.],                                            [ 1.,  2.,  3.]])</p>
<p>The dimension which you do not want to change can also be kept as <code>0</code> which means copy the original value. So with <code>shape=(2,0)</code>, we will obtain the same result as in the above example.</p>
<p>Defined in src/operator/tensor/broadcast<em>reduce</em>op_value.cc:L117</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input</li>
<li><code>shape::Shape(tuple), optional, default=[]</code>: The shape of the desired array. We can set the dim to zero if it's same as the original. E.g <code>A = broadcast_to(B, shape=(10, 0, 0))</code> has the same meaning as <code>A = broadcast_axis(B, axis=0, size=10)</code>.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L368' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.clip-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.clip-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.clip</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">clip(data, a_min, a_max)
</code></pre>

<p>Clips (limits) the values in an array. Given an interval, values outside the interval are clipped to the interval edges. Clipping $x$ between <code>a_min</code> and <code>a_max</code> would be:: .. math::    clip(x, a<em>min, a</em>max) = \max(\min(x, a<em>max), a</em>min)) Example::     x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]     clip(x,1,8) = [ 1.,  1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  8.] The storage type of $clip$ output depends on storage types of inputs and the a<em>min, a</em>max 
parameter values:</p>
<ul>
<li>clip(default) = default</li>
<li>clip(row<em>sparse, a</em>min &lt;= 0, a<em>max &gt;= 0) = row</em>sparse</li>
<li>clip(csr, a<em>min &lt;= 0, a</em>max &gt;= 0) = csr</li>
<li>clip(row<em>sparse, a</em>min &lt; 0, a_max &lt; 0) = default</li>
<li>clip(row<em>sparse, a</em>min &gt; 0, a_max &gt; 0) = default</li>
<li>clip(csr, a<em>min &lt; 0, a</em>max &lt; 0) = csr</li>
<li>clip(csr, a<em>min &gt; 0, a</em>max &gt; 0) = csr</li>
</ul>
<p>Defined in src/operator/tensor/matrix_op.cc:L677</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input array.</li>
<li><code>a_min::float, required</code>: Minimum value</li>
<li><code>a_max::float, required</code>: Maximum value</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L370' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.expand_dims-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.expand_dims-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.expand_dims</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">expand_dims(data, axis)
</code></pre>

<p>Inserts a new axis of size 1 into the array shape For example, given $x$ with shape $(2,3,4)$, then $expand_dims(x, axis=1)$ will return a new array with shape $(2,1,3,4)$.</p>
<p>Defined in src/operator/tensor/matrix_op.cc:L395</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Source input</li>
<li><code>axis::int, required</code>: Position where new axis is to be inserted. Suppose that the input <code>NDArray</code>'s dimension is <code>ndim</code>, the range of the inserted axis is <code>[-ndim, ndim]</code></li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L354' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.log_softmax-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.log_softmax-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.log_softmax</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">log_softmax(data, axis, temperature, dtype, use_length)
</code></pre>

<p>Computes the log softmax of the input. This is equivalent to computing softmax followed by log.</p>
<p>Examples::</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = mx.nd.array([1, 2, .1]) mx.nd.log_softmax(x).asnumpy()</p>
</blockquote>
</blockquote>
</blockquote>
<p>array([-1.41702998, -0.41702995, -2.31702995], dtype=float32)</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = mx.nd.array( [[1, 2, .1],[.1, 2, 1]] ) mx.nd.log_softmax(x, axis=0).asnumpy()</p>
</blockquote>
</blockquote>
</blockquote>
<p>array([[-0.34115392, -0.69314718, -1.24115396],          [-1.24115396, -0.69314718, -0.34115392]], dtype=float32)</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>axis::int, optional, default='-1'</code>: The axis along which to compute softmax.</li>
<li><code>temperature::double or None, optional, default=None</code>: Temperature parameter in softmax</li>
<li><code>dtype::{None, 'float16', 'float32', 'float64'},optional, default='None'</code>: DType of the output in case this can't be inferred. Defaults to the same as input's dtype if not defined (dtype=None).</li>
<li><code>use_length::boolean or None, optional, default=0</code>: Whether to use the length input as a mask over the data input.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L370' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.relu-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.relu-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.relu</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">relu(data)
</code></pre>

<p>Computes rectified linear activation.</p>
<p>.. math::    max(features, 0)</p>
<p>The storage type of $relu$ output depends upon the input storage type:</p>
<ul>
<li>relu(default) = default</li>
<li>relu(row<em>sparse) = row</em>sparse</li>
<li>relu(csr) = csr</li>
</ul>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_basic.cc:L85</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L360' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.sigmoid-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.sigmoid-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.sigmoid</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">sigmoid(data)
</code></pre>

<p>Computes sigmoid of x element-wise.</p>
<p>.. math::    y = 1 / (1 + exp(-x))</p>
<p>The storage type of $sigmoid$ output is always dense</p>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_basic.cc:L119</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L356' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.softmax-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.softmax-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.softmax</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">softmax(data, length, axis, temperature, dtype, use_length)
</code></pre>

<p>Applies the softmax function.</p>
<p>The resulting array contains elements in the range (0,1) and the elements along the given axis sum up to 1.</p>
<p>.. math::    softmax(\mathbf{z/t})<em>j = \frac{e^{z</em>j/t}}{\sum<em>{k=1}^K e^{z</em>k/t}}</p>
<p>for :math:<code>j = 1, ..., K</code></p>
<p>t is the temperature parameter in softmax function. By default, t equals 1.0</p>
<p>Example::</p>
<p>x = [[ 1.  1.  1.]        [ 1.  1.  1.]]</p>
<p>softmax(x,axis=0) = [[ 0.5  0.5  0.5]                        [ 0.5  0.5  0.5]]</p>
<p>softmax(x,axis=1) = [[ 0.33333334,  0.33333334,  0.33333334],                        [ 0.33333334,  0.33333334,  0.33333334]]</p>
<p>Defined in src/operator/nn/softmax.cc:L134</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>length::NDArray-or-SymbolicNode</code>: The length array.</li>
<li><code>axis::int, optional, default='-1'</code>: The axis along which to compute softmax.</li>
<li><code>temperature::double or None, optional, default=None</code>: Temperature parameter in softmax</li>
<li><code>dtype::{None, 'float16', 'float32', 'float64'},optional, default='None'</code>: DType of the output in case this can't be inferred. Defaults to the same as input's dtype if not defined (dtype=None).</li>
<li><code>use_length::boolean or None, optional, default=0</code>: Whether to use the length input as a mask over the data input.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L381' class='documenter-source'>source</a><br></p>
<p><a id='Statistics.mean-Tuple{Vararg{SymbolicNode,N} where N}' href='#Statistics.mean-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>Statistics.mean</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">mean(data, axis, keepdims, exclude)
</code></pre>

<p>Computes the mean of array elements over given axes.</p>
<p>Defined in src/operator/tensor/./broadcast<em>reduce</em>op.h:L84</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input</li>
<li>
<p><code>axis::Shape or None, optional, default=None</code>: The axis or axes along which to perform the reduction.</p>
<p><code>``
The default,</code>axis=()<code>, will compute over all elements into a
scalar array with shape</code>(1,)`.</p>
<p>If <code>axis</code> is int, a reduction is performed on a particular axis.</p>
<p>If <code>axis</code> is a tuple of ints, a reduction is performed on all the axes
specified in the tuple.</p>
<p>If <code>exclude</code> is true, reduction will be performed on the axes that are
NOT in axis instead.</p>
<p>Negative values means indexing from right to left.
<code>``
  *</code>keepdims::boolean, optional, default=0<code>: If this is set to</code>True<code>, the reduced axes are left in the result as dimension with size one.
  *</code>exclude::boolean, optional, default=0<code>: Whether to perform reduction on axis that are NOT in axis instead.
  *</code>name::Symbol<code>: The name of the</code>SymbolicNode<code>. (e.g.</code>:my_symbol<code>), optional.
  *</code>attrs::Dict{Symbol,String}<code>: The attributes associated with this</code>SymbolicNode`.</p>
</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L368' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.SymbolicNode' href='#MXNet.mx.SymbolicNode'>#</a>
<strong><code>MXNet.mx.SymbolicNode</code></strong> &mdash; <em>Type</em>.</p>
<pre><code class="julia">SymbolicNode
</code></pre>

<p>SymbolicNode is the basic building block of the symbolic graph in MXNet.jl. It's a callable object and supports following calls:</p>
<pre><code>(s::SymbolicNode)(args::SymbolicNode...)
(s::SymbolicNode)(; kwargs...)
</code></pre>

<p>Make a new node by composing <code>s</code> with <code>args</code>. Or the arguments can be specified using keyword arguments.</p>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/type.jl#L18-L29' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.Variable-Tuple{Union{AbstractString, Symbol}}' href='#MXNet.mx.Variable-Tuple{Union{AbstractString, Symbol}}'>#</a>
<strong><code>MXNet.mx.Variable</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">Variable(name::Union{Symbol,AbstractString}; attrs)
</code></pre>

<p>Create a symbolic variable with the given name. This is typically used as a placeholder. For example, the data node, acting as the starting point of a network architecture.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>attrs::Dict{Symbol,&lt;:AbstractString}</code>: The attributes associated with this <code>Variable</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/type.jl#L70-L79' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.@var-Tuple{Symbol}' href='#MXNet.mx.@var-Tuple{Symbol}'>#</a>
<strong><code>MXNet.mx.@var</code></strong> &mdash; <em>Macro</em>.</p>
<pre><code class="julia">@var &lt;symbols&gt;...
</code></pre>

<p>A handy macro for creating <code>mx.Variable</code>.</p>
<pre><code class="julia">julia&gt; x = @mx.var x
MXNet.mx.SymbolicNode x

julia&gt; x, y, z = @mx.var x y z
(MXNet.mx.SymbolicNode x, MXNet.mx.SymbolicNode y, MXNet.mx.SymbolicNode z)
</code></pre>

<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/type.jl#L91-L103' class='documenter-source'>source</a><br></p>
<p><a id='Base.:*-Tuple{SymbolicNode,Real}' href='#Base.:*-Tuple{SymbolicNode,Real}'>#</a>
<strong><code>Base.:*</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">.*(x, y)
</code></pre>

<p>Elementwise multiplication of <code>SymbolicNode</code>.</p>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/arithmetic.jl#L63-L67' class='documenter-source'>source</a><br></p>
<p><a id='Base.:+-Tuple{SymbolicNode,Vararg{Union{Real, SymbolicNode},N} where N}' href='#Base.:+-Tuple{SymbolicNode,Vararg{Union{Real, SymbolicNode},N} where N}'>#</a>
<strong><code>Base.:+</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">+(args...)
.+(args...)
</code></pre>

<p>Elementwise summation of <code>SymbolicNode</code>.</p>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/arithmetic.jl#L20-L25' class='documenter-source'>source</a><br></p>
<p><a id='Base.:--Tuple{SymbolicNode,SymbolicNode}' href='#Base.:--Tuple{SymbolicNode,SymbolicNode}'>#</a>
<strong><code>Base.:-</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">-(x, y)
.-(x, y)
</code></pre>

<p>Elementwise substraction of <code>SymbolicNode</code>. Operating with <code>Real</code> is available.</p>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/arithmetic.jl#L45-L51' class='documenter-source'>source</a><br></p>
<p><a id='Base.:/-Tuple{SymbolicNode,Real}' href='#Base.:/-Tuple{SymbolicNode,Real}'>#</a>
<strong><code>Base.:/</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">./(x, y)
</code></pre>

<ul>
<li>Elementwise dividing a <code>SymbolicNode</code> by a scalar or another <code>SymbolicNode</code></li>
</ul>
<p>of the same shape.</p>
<ul>
<li>Elementwise divide a scalar by an <code>SymbolicNode</code>.</li>
<li>Matrix division (solving linear systems) is not implemented yet.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/arithmetic.jl#L88-L97' class='documenter-source'>source</a><br></p>
<p><a id='Base.:^' href='#Base.:^'>#</a>
<strong><code>Base.:^</code></strong> &mdash; <em>Function</em>.</p>
<pre><code class="julia">.^(x, y)
</code></pre>

<p>Elementwise power of <code>SymbolicNode</code> and <code>NDArray</code>. Operating with <code>Real</code> is available.</p>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/arithmetic.jl#L107-L112' class='documenter-source'>source</a><br></p>
<p><a id='Base.getindex-Tuple{SymbolicNode,Union{AbstractString, Symbol}}' href='#Base.getindex-Tuple{SymbolicNode,Union{AbstractString, Symbol}}'>#</a>
<strong><code>Base.getindex</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">getindex(self :: SymbolicNode, idx :: Union{Int, Base.Symbol, AbstractString})
</code></pre>

<p>Get a node representing the specified output of this node. The index could be a symbol or string indicating the name of the output, or a 1-based integer indicating the index, as in the list of <a href="./#MXNet.mx.list_outputs-Tuple{SymbolicNode}"><code>list_outputs</code></a>.</p>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/array.jl#L102-L108' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.grad-Tuple{SymbolicNode,Array{Symbol,1}}' href='#MXNet.mx.grad-Tuple{SymbolicNode,Array{Symbol,1}}'>#</a>
<strong><code>MXNet.mx.grad</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">grad(s::SymbolicNode, wrt::Vector{Symbol})
</code></pre>

<p>Get the autodiff gradient of the current <code>SymbolicNode</code>. This function can only be used if the current symbol is a loss function.</p>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>s::SymbolicNode</code>: current node.</li>
<li><code>wrt::Vector{Symbol}</code>: the names of the arguments to the gradient.</li>
</ul>
<p>Returns a gradient symbol of the corresponding gradient.</p>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/autodiff.jl#L18-L29' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.infer_shape-Tuple{SymbolicNode}' href='#MXNet.mx.infer_shape-Tuple{SymbolicNode}'>#</a>
<strong><code>MXNet.mx.infer_shape</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">infer_shape(self :: SymbolicNode, args...)
infer_shape(self :: SymbolicNode; kwargs...)
</code></pre>

<p>Do shape inference according to the input shapes. The input shapes could be provided as a list of shapes, which should specify the shapes of inputs in the same order as the arguments returned by <a href="./#MXNet.mx.list_arguments-Tuple{SymbolicNode}"><code>list_arguments</code></a>. Alternatively, the shape information could be specified via keyword arguments.</p>
<p>Returns a 3-tuple containing shapes of all the arguments, shapes of all the outputs and shapes of all the auxiliary variables. If shape inference failed due to incomplete or incompatible inputs, the return value will be <code>(nothing, nothing, nothing)</code>.</p>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/autodiff.jl#L82-L94' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.infer_type-Tuple{SymbolicNode}' href='#MXNet.mx.infer_type-Tuple{SymbolicNode}'>#</a>
<strong><code>MXNet.mx.infer_type</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">infer_type(self :: SymbolicNode; kwargs...)
infer_type(self :: SymbolicNode, args...)
</code></pre>

<p>Do type inference according to the input types. The input types could be provided as a list of types, which should specify the types of inputs in the same order as the arguments returned by <a href="./#MXNet.mx.list_arguments-Tuple{SymbolicNode}"><code>list_arguments</code></a>. Alternatively, the type information could be specified via keyword arguments.</p>
<p>Returns a 3-tuple containing types of all the arguments, types of all the outputs and types of all the auxiliary variables. If type inference failed due to incomplete or incompatible inputs, the return value will be <code>(nothing, nothing, nothing)</code>.</p>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/autodiff.jl#L150-L162' class='documenter-source'>source</a><br></p>
<p><a id='Base.Iterators.Flatten-Tuple{Vararg{SymbolicNode,N} where N}' href='#Base.Iterators.Flatten-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>Base.Iterators.Flatten</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">Flatten(data)
</code></pre>

<p>Flattens the input array into a 2-D array by collapsing the higher dimensions. .. note:: <code>Flatten</code> is deprecated. Use <code>flatten</code> instead. For an input array with shape $(d1, d2, ..., dk)$, <code>flatten</code> operation reshapes the input array into an output array of shape $(d1, d2<em>...</em>dk)$. Note that the behavior of this function is different from numpy.ndarray.flatten, which behaves similar to mxnet.ndarray.reshape((-1,)). Example::     x = [[         [1,2,3],         [4,5,6],         [7,8,9]     ],     [    [1,2,3],         [4,5,6],         [7,8,9]     ]],     flatten(x) = [[ 1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9.],        [ 1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9.]]</p>
<p>Defined in src/operator/tensor/matrix_op.cc:L250</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L367' class='documenter-source'>source</a><br></p>
<p><a id='Base.Math.cbrt-Tuple{Vararg{SymbolicNode,N} where N}' href='#Base.Math.cbrt-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>Base.Math.cbrt</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">cbrt(data)
</code></pre>

<p>Returns element-wise cube-root value of the input.</p>
<p>.. math::    cbrt(x) = \sqrt[3]{x}</p>
<p>Example::</p>
<p>cbrt([1, 8, -125]) = [1, 2, -5]</p>
<p>The storage type of $cbrt$ output depends upon the input storage type:</p>
<ul>
<li>cbrt(default) = default</li>
<li>cbrt(row<em>sparse) = row</em>sparse</li>
<li>cbrt(csr) = csr</li>
</ul>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_pow.cc:L270</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L364' class='documenter-source'>source</a><br></p>
<p><a id='Base._div-Tuple{Vararg{SymbolicNode,N} where N}' href='#Base._div-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>Base._div</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_div(lhs, rhs)
</code></pre>

<p><em>div is an alias of elemwise</em>div.</p>
<p>Divides arguments element-wise.</p>
<p>The storage type of $elemwise_div$ output is always dense</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L355' class='documenter-source'>source</a><br></p>
<p><a id='Base._linspace-Tuple{Vararg{SymbolicNode,N} where N}' href='#Base._linspace-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>Base._linspace</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_linspace(start, stop, step, repeat, infer_range, ctx, dtype)
</code></pre>

<p>Return evenly spaced numbers over a specified interval. Similar to Numpy</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>start::double, required</code>: Start of interval. The interval includes this value. The default start value is 0.</li>
<li><code>stop::double or None, optional, default=None</code>: End of interval. The interval does not include this value, except in some cases where step is not an integer and floating point round-off affects the length of out.</li>
<li><code>step::double, optional, default=1</code>: Spacing between values.</li>
<li><code>repeat::int, optional, default='1'</code>: The repeating time of all elements. E.g repeat=3, the element a will be repeated three times –&gt; a, a, a.</li>
<li><code>infer_range::boolean, optional, default=0</code>: When set to True, infer the stop position from the start, step, repeat, and output tensor size.</li>
<li><code>ctx::string, optional, default=''</code>: Context of output, in format <a href="n">cpu|gpu|cpu_pinned</a>.Only used for imperative calls.</li>
<li><code>dtype::{'bfloat16', 'float16', 'float32', 'float64', 'int32', 'int64', 'int8', 'uint8'},optional, default='float32'</code>: Target data type.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L359' class='documenter-source'>source</a><br></p>
<p><a id='Base._maximum-Tuple{Vararg{SymbolicNode,N} where N}' href='#Base._maximum-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>Base._maximum</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_maximum(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='Base._minimum-Tuple{Vararg{SymbolicNode,N} where N}' href='#Base._minimum-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>Base._minimum</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_minimum(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='Base._sub-Tuple{Vararg{SymbolicNode,N} where N}' href='#Base._sub-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>Base._sub</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_sub(lhs, rhs)
</code></pre>

<p><em>sub is an alias of elemwise</em>sub.</p>
<p>Subtracts arguments element-wise.</p>
<p>The storage type of $elemwise_sub$ output depends on storage types of inputs</p>
<ul>
<li>elemwise<em>sub(row</em>sparse, row<em>sparse) = row</em>sparse</li>
<li>elemwise_sub(csr, csr) = csr</li>
<li>elemwise_sub(default, csr) = default</li>
<li>elemwise_sub(csr, default) = default</li>
<li>elemwise_sub(default, rsp) = default</li>
<li>elemwise_sub(rsp, default) = default</li>
<li>otherwise, $elemwise_sub$ generates output with default storage</li>
</ul>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L363' class='documenter-source'>source</a><br></p>
<p><a id='Base.abs-Tuple{Vararg{SymbolicNode,N} where N}' href='#Base.abs-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>Base.abs</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">abs(data)
</code></pre>

<p>Returns element-wise absolute value of the input.</p>
<p>Example::</p>
<p>abs([-2, 0, 3]) = [2, 0, 3]</p>
<p>The storage type of $abs$ output depends upon the input storage type:</p>
<ul>
<li>abs(default) = default</li>
<li>abs(row<em>sparse) = row</em>sparse</li>
<li>abs(csr) = csr</li>
</ul>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_basic.cc:L720</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L361' class='documenter-source'>source</a><br></p>
<p><a id='Base.argmax-Tuple{Vararg{SymbolicNode,N} where N}' href='#Base.argmax-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>Base.argmax</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">argmax(data, axis, keepdims)
</code></pre>

<p>Returns indices of the maximum values along an axis.</p>
<p>In the case of multiple occurrences of maximum values, the indices corresponding to the first occurrence are returned.</p>
<p>Examples::</p>
<p>x = [[ 0.,  1.,  2.],        [ 3.,  4.,  5.]]</p>
<p>// argmax along axis 0   argmax(x, axis=0) = [ 1.,  1.,  1.]</p>
<p>// argmax along axis 1   argmax(x, axis=1) = [ 2.,  2.]</p>
<p>// argmax along axis 1 keeping same dims as an input array   argmax(x, axis=1, keepdims=True) = [[ 2.],                                       [ 2.]]</p>
<p>Defined in src/operator/tensor/broadcast<em>reduce</em>op_index.cc:L52</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input</li>
<li><code>axis::int or None, optional, default='None'</code>: The axis along which to perform the reduction. Negative values means indexing from right to left. $Requires axis to be set as int, because global reduction is not supported yet.$</li>
<li><code>keepdims::boolean, optional, default=0</code>: If this is set to <code>True</code>, the reduced axis is left in the result as dimension with size one.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L373' class='documenter-source'>source</a><br></p>
<p><a id='Base.argmin-Tuple{Vararg{SymbolicNode,N} where N}' href='#Base.argmin-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>Base.argmin</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">argmin(data, axis, keepdims)
</code></pre>

<p>Returns indices of the minimum values along an axis.</p>
<p>In the case of multiple occurrences of minimum values, the indices corresponding to the first occurrence are returned.</p>
<p>Examples::</p>
<p>x = [[ 0.,  1.,  2.],        [ 3.,  4.,  5.]]</p>
<p>// argmin along axis 0   argmin(x, axis=0) = [ 0.,  0.,  0.]</p>
<p>// argmin along axis 1   argmin(x, axis=1) = [ 0.,  0.]</p>
<p>// argmin along axis 1 keeping same dims as an input array   argmin(x, axis=1, keepdims=True) = [[ 0.],                                       [ 0.]]</p>
<p>Defined in src/operator/tensor/broadcast<em>reduce</em>op_index.cc:L77</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input</li>
<li><code>axis::int or None, optional, default='None'</code>: The axis along which to perform the reduction. Negative values means indexing from right to left. $Requires axis to be set as int, because global reduction is not supported yet.$</li>
<li><code>keepdims::boolean, optional, default=0</code>: If this is set to <code>True</code>, the reduced axis is left in the result as dimension with size one.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L373' class='documenter-source'>source</a><br></p>
<p><a id='Base.ceil-Tuple{Vararg{SymbolicNode,N} where N}' href='#Base.ceil-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>Base.ceil</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">ceil(data)
</code></pre>

<p>Returns element-wise ceiling of the input.</p>
<p>The ceil of the scalar x is the smallest integer i, such that i &gt;= x.</p>
<p>Example::</p>
<p>ceil([-2.1, -1.9, 1.5, 1.9, 2.1]) = [-2., -1.,  2.,  2.,  3.]</p>
<p>The storage type of $ceil$ output depends upon the input storage type:</p>
<ul>
<li>ceil(default) = default</li>
<li>ceil(row<em>sparse) = row</em>sparse</li>
<li>ceil(csr) = csr</li>
</ul>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_basic.cc:L817</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L363' class='documenter-source'>source</a><br></p>
<p><a id='Base.cumsum-Tuple{Vararg{SymbolicNode,N} where N}' href='#Base.cumsum-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>Base.cumsum</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">cumsum(a, axis, dtype)
</code></pre>

<p>cumsum is an alias of <em>npi</em>cumsum.</p>
<p>Return the cumulative sum of the elements along a given axis.</p>
<p>Defined in src/operator/numpy/np_cumsum.cc:L70</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>a::NDArray-or-SymbolicNode</code>: Input ndarray</li>
<li><code>axis::int or None, optional, default='None'</code>: Axis along which the cumulative sum is computed. The default (None) is to compute the cumsum over the flattened array.</li>
<li><code>dtype::{None, 'float16', 'float32', 'float64', 'int32', 'int64', 'int8'},optional, default='None'</code>: Type of the returned array and of the accumulator in which the elements are summed. If dtype is not specified, it defaults to the dtype of a, unless a has an integer dtype with a precision less than that of the default platform integer. In that case, the default platform integer is used.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L355' class='documenter-source'>source</a><br></p>
<p><a id='Base.exp-Tuple{Vararg{SymbolicNode,N} where N}' href='#Base.exp-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>Base.exp</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">exp(data)
</code></pre>

<p>Returns element-wise exponential value of the input.</p>
<p>.. math::    exp(x) = e^x \approx 2.718^x</p>
<p>Example::</p>
<p>exp([0, 1, 2]) = [1., 2.71828175, 7.38905621]</p>
<p>The storage type of $exp$ output is always dense</p>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_logexp.cc:L64</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L360' class='documenter-source'>source</a><br></p>
<p><a id='Base.expm1-Tuple{Vararg{SymbolicNode,N} where N}' href='#Base.expm1-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>Base.expm1</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">expm1(data)
</code></pre>

<p>Returns $exp(x) - 1$ computed element-wise on the input.</p>
<p>This function provides greater precision than $exp(x) - 1$ for small values of $x$.</p>
<p>The storage type of $expm1$ output depends upon the input storage type:</p>
<ul>
<li>expm1(default) = default</li>
<li>expm1(row<em>sparse) = row</em>sparse</li>
<li>expm1(csr) = csr</li>
</ul>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_logexp.cc:L244</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L359' class='documenter-source'>source</a><br></p>
<p><a id='Base.floor-Tuple{Vararg{SymbolicNode,N} where N}' href='#Base.floor-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>Base.floor</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">floor(data)
</code></pre>

<p>Returns element-wise floor of the input.</p>
<p>The floor of the scalar x is the largest integer i, such that i &lt;= x.</p>
<p>Example::</p>
<p>floor([-2.1, -1.9, 1.5, 1.9, 2.1]) = [-3., -2.,  1.,  1.,  2.]</p>
<p>The storage type of $floor$ output depends upon the input storage type:</p>
<ul>
<li>floor(default) = default</li>
<li>floor(row<em>sparse) = row</em>sparse</li>
<li>floor(csr) = csr</li>
</ul>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_basic.cc:L836</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L363' class='documenter-source'>source</a><br></p>
<p><a id='Base.identity-Tuple{Vararg{SymbolicNode,N} where N}' href='#Base.identity-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>Base.identity</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">identity(data)
</code></pre>

<p>identity is an alias of _copy.</p>
<p>Returns a copy of the input.</p>
<p>From:src/operator/tensor/elemwise<em>unary</em>op_basic.cc:244</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='Base.log-Tuple{Vararg{SymbolicNode,N} where N}' href='#Base.log-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>Base.log</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">log(data)
</code></pre>

<p>Returns element-wise Natural logarithmic value of the input.</p>
<p>The natural logarithm is logarithm in base <em>e</em>, so that $log(exp(x)) = x$</p>
<p>The storage type of $log$ output is always dense</p>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_logexp.cc:L77</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L355' class='documenter-source'>source</a><br></p>
<p><a id='Base.log10-Tuple{Vararg{SymbolicNode,N} where N}' href='#Base.log10-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>Base.log10</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">log10(data)
</code></pre>

<p>Returns element-wise Base-10 logarithmic value of the input.</p>
<p>$10**log10(x) = x$</p>
<p>The storage type of $log10$ output is always dense</p>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_logexp.cc:L94</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L355' class='documenter-source'>source</a><br></p>
<p><a id='Base.log1p-Tuple{Vararg{SymbolicNode,N} where N}' href='#Base.log1p-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>Base.log1p</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">log1p(data)
</code></pre>

<p>Returns element-wise $log(1 + x)$ value of the input.</p>
<p>This function is more accurate than $log(1 + x)$  for small $x$ so that :math:<code>1+x\approx 1</code></p>
<p>The storage type of $log1p$ output depends upon the input storage type:</p>
<ul>
<li>log1p(default) = default</li>
<li>log1p(row<em>sparse) = row</em>sparse</li>
<li>log1p(csr) = csr</li>
</ul>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_logexp.cc:L199</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L360' class='documenter-source'>source</a><br></p>
<p><a id='Base.log2-Tuple{Vararg{SymbolicNode,N} where N}' href='#Base.log2-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>Base.log2</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">log2(data)
</code></pre>

<p>Returns element-wise Base-2 logarithmic value of the input.</p>
<p>$2**log2(x) = x$</p>
<p>The storage type of $log2$ output is always dense</p>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_logexp.cc:L106</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L355' class='documenter-source'>source</a><br></p>
<p><a id='Base.max-Tuple{Vararg{SymbolicNode,N} where N}' href='#Base.max-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>Base.max</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">max(data, axis, keepdims, exclude)
</code></pre>

<p>Computes the max of array elements over given axes.</p>
<p>Defined in src/operator/tensor/./broadcast<em>reduce</em>op.h:L32</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input</li>
<li>
<p><code>axis::Shape or None, optional, default=None</code>: The axis or axes along which to perform the reduction.</p>
<p><code>``
The default,</code>axis=()<code>, will compute over all elements into a
scalar array with shape</code>(1,)`.</p>
<p>If <code>axis</code> is int, a reduction is performed on a particular axis.</p>
<p>If <code>axis</code> is a tuple of ints, a reduction is performed on all the axes
specified in the tuple.</p>
<p>If <code>exclude</code> is true, reduction will be performed on the axes that are
NOT in axis instead.</p>
<p>Negative values means indexing from right to left.
<code>``
  *</code>keepdims::boolean, optional, default=0<code>: If this is set to</code>True<code>, the reduced axes are left in the result as dimension with size one.
  *</code>exclude::boolean, optional, default=0<code>: Whether to perform reduction on axis that are NOT in axis instead.
  *</code>name::Symbol<code>: The name of the</code>SymbolicNode<code>. (e.g.</code>:my_symbol<code>), optional.
  *</code>attrs::Dict{Symbol,String}<code>: The attributes associated with this</code>SymbolicNode`.</p>
</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L368' class='documenter-source'>source</a><br></p>
<p><a id='Base.min-Tuple{Vararg{SymbolicNode,N} where N}' href='#Base.min-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>Base.min</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">min(data, axis, keepdims, exclude)
</code></pre>

<p>Computes the min of array elements over given axes.</p>
<p>Defined in src/operator/tensor/./broadcast<em>reduce</em>op.h:L47</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input</li>
<li>
<p><code>axis::Shape or None, optional, default=None</code>: The axis or axes along which to perform the reduction.</p>
<p><code>``
The default,</code>axis=()<code>, will compute over all elements into a
scalar array with shape</code>(1,)`.</p>
<p>If <code>axis</code> is int, a reduction is performed on a particular axis.</p>
<p>If <code>axis</code> is a tuple of ints, a reduction is performed on all the axes
specified in the tuple.</p>
<p>If <code>exclude</code> is true, reduction will be performed on the axes that are
NOT in axis instead.</p>
<p>Negative values means indexing from right to left.
<code>``
  *</code>keepdims::boolean, optional, default=0<code>: If this is set to</code>True<code>, the reduced axes are left in the result as dimension with size one.
  *</code>exclude::boolean, optional, default=0<code>: Whether to perform reduction on axis that are NOT in axis instead.
  *</code>name::Symbol<code>: The name of the</code>SymbolicNode<code>. (e.g.</code>:my_symbol<code>), optional.
  *</code>attrs::Dict{Symbol,String}<code>: The attributes associated with this</code>SymbolicNode`.</p>
</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L368' class='documenter-source'>source</a><br></p>
<p><a id='Base.repeat-Tuple{Vararg{SymbolicNode,N} where N}' href='#Base.repeat-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>Base.repeat</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">repeat(data, repeats, axis)
</code></pre>

<p>Repeats elements of an array. By default, $repeat$ flattens the input array into 1-D and then repeats the elements::   x = [[ 1, 2],        [ 3, 4]]   repeat(x, repeats=2) = [ 1.,  1.,  2.,  2.,  3.,  3.,  4.,  4.] The parameter $axis$ specifies the axis along which to perform repeat::   repeat(x, repeats=2, axis=1) = [[ 1.,  1.,  2.,  2.],                                   [ 3.,  3.,  4.,  4.]]   repeat(x, repeats=2, axis=0) = [[ 1.,  2.],                                   [ 1.,  2.],                                   [ 3.,  4.],                                   [ 3.,  4.]]   repeat(x, repeats=2, axis=-1) = [[ 1.,  1.,  2.,  2.],                                    [ 3.,  3.,  4.,  4.]]</p>
<p>Defined in src/operator/tensor/matrix_op.cc:L744</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data array</li>
<li><code>repeats::int, required</code>: The number of repetitions for each element.</li>
<li><code>axis::int or None, optional, default='None'</code>: The axis along which to repeat values. The negative numbers are interpreted counting from the backward. By default, use the flattened input array, and return a flat output array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L368' class='documenter-source'>source</a><br></p>
<p><a id='Base.reverse-Tuple{Vararg{SymbolicNode,N} where N}' href='#Base.reverse-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>Base.reverse</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">reverse(data, axis)
</code></pre>

<p>Reverses the order of elements along given axis while preserving array shape. Note: reverse and flip are equivalent. We use reverse in the following examples. Examples::   x = [[ 0.,  1.,  2.,  3.,  4.],        [ 5.,  6.,  7.,  8.,  9.]]   reverse(x, axis=0) = [[ 5.,  6.,  7.,  8.,  9.],                         [ 0.,  1.,  2.,  3.,  4.]]   reverse(x, axis=1) = [[ 4.,  3.,  2.,  1.,  0.],                         [ 9.,  8.,  7.,  6.,  5.]]</p>
<p>Defined in src/operator/tensor/matrix_op.cc:L832</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data array</li>
<li><code>axis::Shape(tuple), required</code>: The axis which to reverse elements.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L360' class='documenter-source'>source</a><br></p>
<p><a id='Base.round-Tuple{Vararg{SymbolicNode,N} where N}' href='#Base.round-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>Base.round</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">round(data)
</code></pre>

<p>Returns element-wise rounded value to the nearest integer of the input.</p>
<p>Example::</p>
<p>round([-1.5, 1.5, -1.9, 1.9, 2.1]) = [-2.,  2., -2.,  2.,  2.]</p>
<p>The storage type of $round$ output depends upon the input storage type:</p>
<ul>
<li>round(default) = default</li>
<li>round(row<em>sparse) = row</em>sparse</li>
<li>round(csr) = csr</li>
</ul>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_basic.cc:L777</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L361' class='documenter-source'>source</a><br></p>
<p><a id='Base.sign-Tuple{Vararg{SymbolicNode,N} where N}' href='#Base.sign-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>Base.sign</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">sign(data)
</code></pre>

<p>Returns element-wise sign of the input.</p>
<p>Example::</p>
<p>sign([-2, 0, 3]) = [-1, 0, 1]</p>
<p>The storage type of $sign$ output depends upon the input storage type:</p>
<ul>
<li>sign(default) = default</li>
<li>sign(row<em>sparse) = row</em>sparse</li>
<li>sign(csr) = csr</li>
</ul>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_basic.cc:L758</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L361' class='documenter-source'>source</a><br></p>
<p><a id='Base.sort-Tuple{Vararg{SymbolicNode,N} where N}' href='#Base.sort-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>Base.sort</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">sort(data, axis, is_ascend)
</code></pre>

<p>Returns a sorted copy of an input array along the given axis.</p>
<p>Examples::</p>
<p>x = [[ 1, 4],        [ 3, 1]]</p>
<p>// sorts along the last axis   sort(x) = [[ 1.,  4.],              [ 1.,  3.]]</p>
<p>// flattens and then sorts   sort(x, axis=None) = [ 1.,  1.,  3.,  4.]</p>
<p>// sorts along the first axis   sort(x, axis=0) = [[ 1.,  1.],                      [ 3.,  4.]]</p>
<p>// in a descend order   sort(x, is_ascend=0) = [[ 4.,  1.],                           [ 3.,  1.]]</p>
<p>Defined in src/operator/tensor/ordering_op.cc:L133</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array</li>
<li><code>axis::int or None, optional, default='-1'</code>: Axis along which to choose sort the input tensor. If not given, the flattened array is used. Default is -1.</li>
<li><code>is_ascend::boolean, optional, default=1</code>: Whether to sort in ascending or descending order.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L375' class='documenter-source'>source</a><br></p>
<p><a id='Base.split-Tuple{Vararg{SymbolicNode,N} where N}' href='#Base.split-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>Base.split</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">split(data, num_outputs, axis, squeeze_axis)
</code></pre>

<p>split is an alias of SliceChannel.</p>
<p>Splits an array along a particular axis into multiple sub-arrays.</p>
<p>.. note:: $SliceChannel$ is deprecated. Use $split$ instead.</p>
<p><strong>Note</strong> that <code>num_outputs</code> should evenly divide the length of the axis along which to split the array.</p>
<p>Example::</p>
<p>x  = [[[ 1.]           [ 2.]]          [[ 3.]           [ 4.]]          [[ 5.]           [ 6.]]]    x.shape = (3, 2, 1)</p>
<p>y = split(x, axis=1, num_outputs=2) // a list of 2 arrays with shape (3, 1, 1)    y = [[[ 1.]]         [[ 3.]]         [[ 5.]]]</p>
<pre><code>   [[[ 2.]]
    [[ 4.]]
    [[ 6.]]]
</code></pre>

<p>y[0].shape = (3, 1, 1)</p>
<p>z = split(x, axis=0, num_outputs=3) // a list of 3 arrays with shape (1, 2, 1)    z = [[[ 1.]          [ 2.]]]</p>
<pre><code>   [[[ 3.]
     [ 4.]]]

   [[[ 5.]
     [ 6.]]]
</code></pre>

<p>z[0].shape = (1, 2, 1)</p>
<p><code>squeeze_axis=1</code> removes the axis with length 1 from the shapes of the output arrays. <strong>Note</strong> that setting <code>squeeze_axis</code> to $1$ removes axis with length 1 only along the <code>axis</code> which it is split. Also <code>squeeze_axis</code> can be set to true only if $input.shape[axis] == num_outputs$.</p>
<p>Example::</p>
<p>z = split(x, axis=0, num<em>outputs=3, squeeze</em>axis=1) // a list of 3 arrays with shape (2, 1)    z = [[ 1.]         [ 2.]]</p>
<pre><code>   [[ 3.]
    [ 4.]]

   [[ 5.]
    [ 6.]]
</code></pre>

<p>z[0].shape = (2 ,1 )</p>
<p>Defined in src/operator/slice_channel.cc:L107</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input</li>
<li><code>num_outputs::int, required</code>: Number of splits. Note that this should evenly divide the length of the <code>axis</code>.</li>
<li><code>axis::int, optional, default='1'</code>: Axis along which to split.</li>
<li><code>squeeze_axis::boolean, optional, default=0</code>: If true, Removes the axis with length 1 from the shapes of the output arrays. <strong>Note</strong> that setting <code>squeeze_axis</code> to $true$ removes axis with length 1 only along the <code>axis</code> which it is split. Also <code>squeeze_axis</code> can be set to $true$ only if $input.shape[axis] == num_outputs$.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L415' class='documenter-source'>source</a><br></p>
<p><a id='Base.sqrt-Tuple{Vararg{SymbolicNode,N} where N}' href='#Base.sqrt-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>Base.sqrt</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">sqrt(data)
</code></pre>

<p>Returns element-wise square-root value of the input.</p>
<p>.. math::    \textrm{sqrt}(x) = \sqrt{x}</p>
<p>Example::</p>
<p>sqrt([4, 9, 16]) = [2, 3, 4]</p>
<p>The storage type of $sqrt$ output depends upon the input storage type:</p>
<ul>
<li>sqrt(default) = default</li>
<li>sqrt(row<em>sparse) = row</em>sparse</li>
<li>sqrt(csr) = csr</li>
</ul>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_pow.cc:L170</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L364' class='documenter-source'>source</a><br></p>
<p><a id='Base.transpose-Tuple{Vararg{SymbolicNode,N} where N}' href='#Base.transpose-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>Base.transpose</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">transpose(data, axes)
</code></pre>

<p>Permutes the dimensions of an array. Examples::   x = [[ 1, 2],        [ 3, 4]]   transpose(x) = [[ 1.,  3.],                   [ 2.,  4.]]   x = [[[ 1.,  2.],         [ 3.,  4.]],        [[ 5.,  6.],         [ 7.,  8.]]]   transpose(x) = [[[ 1.,  5.],                    [ 3.,  7.]],                   [[ 2.,  6.],                    [ 4.,  8.]]]   transpose(x, axes=(1,0,2)) = [[[ 1.,  2.],                                  [ 5.,  6.]],                                 [[ 3.,  4.],                                  [ 7.,  8.]]]</p>
<p>Defined in src/operator/tensor/matrix_op.cc:L328</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Source input</li>
<li><code>axes::Shape(tuple), optional, default=[]</code>: Target axis order. By default the axes will be inverted.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L369' class='documenter-source'>source</a><br></p>
<p><a id='Base.trunc-Tuple{Vararg{SymbolicNode,N} where N}' href='#Base.trunc-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>Base.trunc</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">trunc(data)
</code></pre>

<p>Return the element-wise truncated value of the input.</p>
<p>The truncated value of the scalar x is the nearest integer i which is closer to zero than x is. In short, the fractional part of the signed number x is discarded.</p>
<p>Example::</p>
<p>trunc([-2.1, -1.9, 1.5, 1.9, 2.1]) = [-2., -1.,  1.,  1.,  2.]</p>
<p>The storage type of $trunc$ output depends upon the input storage type:</p>
<ul>
<li>trunc(default) = default</li>
<li>trunc(row<em>sparse) = row</em>sparse</li>
<li>trunc(csr) = csr</li>
</ul>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_basic.cc:L856</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L364' class='documenter-source'>source</a><br></p>
<p><a id='LinearAlgebra.diag-Tuple{Vararg{SymbolicNode,N} where N}' href='#LinearAlgebra.diag-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>LinearAlgebra.diag</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">diag(data, k, axis1, axis2)
</code></pre>

<p>Extracts a diagonal or constructs a diagonal array.</p>
<p>$diag$'s behavior depends on the input array dimensions:</p>
<ul>
<li>1-D arrays: constructs a 2-D array with the input as its diagonal, all other elements are zero.</li>
<li>
<p>N-D arrays: extracts the diagonals of the sub-arrays with axes specified by $axis1$ and $axis2$. The output shape would be decided by removing the axes numbered $axis1$ and $axis2$ from the input shape and appending to the result a new axis with the size of the diagonals in question.</p>
<p>For example, when the input shape is <code>(2, 3, 4, 5)</code>, $axis1$ and $axis2$ are 0 and 2 respectively and $k$ is 0, the resulting shape would be <code>(3, 5, 2)</code>.</p>
</li>
</ul>
<p>Examples::</p>
<p>x = [[1, 2, 3],        [4, 5, 6]]</p>
<p>diag(x) = [1, 5]</p>
<p>diag(x, k=1) = [2, 6]</p>
<p>diag(x, k=-1) = [4]</p>
<p>x = [1, 2, 3]</p>
<p>diag(x) = [[1, 0, 0],              [0, 2, 0],              [0, 0, 3]]</p>
<p>diag(x, k=1) = [[0, 1, 0],                   [0, 0, 2],                   [0, 0, 0]]</p>
<p>diag(x, k=-1) = [[0, 0, 0],                    [1, 0, 0],                    [0, 2, 0]]</p>
<p>x = [[[1, 2],         [3, 4]],</p>
<pre><code>   [[5, 6],
    [7, 8]]]
</code></pre>

<p>diag(x) = [[1, 7],              [2, 8]]</p>
<p>diag(x, k=1) = [[3],                   [4]]</p>
<p>diag(x, axis1=-2, axis2=-1) = [[1, 4],                                  [5, 8]]</p>
<p>Defined in src/operator/tensor/diag_op.cc:L87</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input ndarray</li>
<li><code>k::int, optional, default='0'</code>: Diagonal in question. The default is 0. Use k&gt;0 for diagonals above the main diagonal, and k&lt;0 for diagonals below the main diagonal. If input has shape (S0 S1) k must be between -S0 and S1</li>
<li><code>axis1::int, optional, default='0'</code>: The first axis of the sub-arrays of interest. Ignored when the input is a 1-D array.</li>
<li><code>axis2::int, optional, default='1'</code>: The second axis of the sub-arrays of interest. Ignored when the input is a 1-D array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L407' class='documenter-source'>source</a><br></p>
<p><a id='LinearAlgebra.dot-Tuple{Vararg{SymbolicNode,N} where N}' href='#LinearAlgebra.dot-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>LinearAlgebra.dot</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">dot(lhs, rhs, transpose_a, transpose_b, forward_stype)
</code></pre>

<p>Dot product of two arrays.</p>
<p>$dot$'s behavior depends on the input array dimensions:</p>
<ul>
<li>1-D arrays: inner product of vectors</li>
<li>2-D arrays: matrix multiplication</li>
<li>
<p>N-D arrays: a sum product over the last axis of the first input and the first axis of the second input</p>
<p>For example, given 3-D $x$ with shape <code>(n,m,k)</code> and $y$ with shape <code>(k,r,s)</code>, the result array will have shape <code>(n,m,r,s)</code>. It is computed by::</p>
<p>dot(x,y)[i,j,a,b] = sum(x[i,j,:]*y[:,a,b])</p>
<p>Example::</p>
<p>x = reshape([0,1,2,3,4,5,6,7], shape=(2,2,2))   y = reshape([7,6,5,4,3,2,1,0], shape=(2,2,2))   dot(x,y)[0,0,1,1] = 0   sum(x[0,0,:]*y[:,1,1]) = 0</p>
</li>
</ul>
<p>The storage type of $dot$ output depends on storage types of inputs, transpose option and forward_stype option for output storage type. Implemented sparse operations include:</p>
<ul>
<li>dot(default, default, transpose<em>a=True/False, transpose</em>b=True/False) = default</li>
<li>dot(csr, default, transpose_a=True) = default</li>
<li>dot(csr, default, transpose<em>a=True) = row</em>sparse</li>
<li>dot(csr, default) = default</li>
<li>dot(csr, row_sparse) = default</li>
<li>dot(default, csr) = csr (CPU only)</li>
<li>dot(default, csr, forward_stype='default') = default</li>
<li>dot(default, csr, transpose<em>b=True, forward</em>stype='default') = default</li>
</ul>
<p>If the combination of input storage types and forward_stype does not match any of the above patterns, $dot$ will fallback and generate output with default storage.</p>
<p>.. Note::</p>
<pre><code>If the storage type of the lhs is &quot;csr&quot;, the storage type of gradient w.r.t rhs will be
&quot;row_sparse&quot;. Only a subset of optimizers support sparse gradients, including SGD, AdaGrad
and Adam. Note that by default lazy updates is turned on, which may perform differently
from standard updates. For more details, please check the Optimization API at:
https://mxnet.incubator.apache.org/api/python/optimization/optimization.html
</code></pre>

<p>Defined in src/operator/tensor/dot.cc:L77</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: The first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: The second input</li>
<li><code>transpose_a::boolean, optional, default=0</code>: If true then transpose the first input before dot.</li>
<li><code>transpose_b::boolean, optional, default=0</code>: If true then transpose the second input before dot.</li>
<li><code>forward_stype::{None, 'csr', 'default', 'row_sparse'},optional, default='None'</code>: The desired storage type of the forward output given by user, if thecombination of input storage types and this hint does not matchany implemented ones, the dot operator will perform fallback operationand still produce an output of the desired storage type.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L401' class='documenter-source'>source</a><br></p>
<p><a id='LinearAlgebra.norm-Tuple{Vararg{SymbolicNode,N} where N}' href='#LinearAlgebra.norm-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>LinearAlgebra.norm</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">norm(data, ord, axis, out_dtype, keepdims)
</code></pre>

<p>Computes the norm on an NDArray.</p>
<p>This operator computes the norm on an NDArray with the specified axis, depending on the value of the ord parameter. By default, it computes the L2 norm on the entire array. Currently only ord=2 supports sparse ndarrays.</p>
<p>Examples::</p>
<p>x = [[[1, 2],         [3, 4]],        [[2, 2],         [5, 6]]]</p>
<p>norm(x, ord=2, axis=1) = [[3.1622777 4.472136 ]                             [5.3851647 6.3245554]]</p>
<p>norm(x, ord=1, axis=1) = [[4., 6.],                             [7., 8.]]</p>
<p>rsp = x.cast<em>storage('row</em>sparse')</p>
<p>norm(rsp) = [5.47722578]</p>
<p>csr = x.cast_storage('csr')</p>
<p>norm(csr) = [5.47722578]</p>
<p>Defined in src/operator/tensor/broadcast<em>reduce</em>norm_value.cc:L89</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input</li>
<li><code>ord::int, optional, default='2'</code>: Order of the norm. Currently ord=1 and ord=2 is supported.</li>
<li><code>axis::Shape or None, optional, default=None</code>: The axis or axes along which to perform the reduction.     The default, <code>axis=()</code>, will compute over all elements into a     scalar array with shape <code>(1,)</code>.     If <code>axis</code> is int, a reduction is performed on a particular axis.     If <code>axis</code> is a 2-tuple, it specifies the axes that hold 2-D matrices,     and the matrix norms of these matrices are computed.</li>
<li><code>out_dtype::{None, 'float16', 'float32', 'float64', 'int32', 'int64', 'int8'},optional, default='None'</code>: The data type of the output.</li>
<li><code>keepdims::boolean, optional, default=0</code>: If this is set to <code>True</code>, the reduced axis is left in the result as dimension with size one.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L389' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.Activation-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.Activation-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.Activation</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">Activation(data, act_type)
</code></pre>

<p>Applies an activation function element-wise to the input.</p>
<p>The following activation functions are supported:</p>
<ul>
<li><code>relu</code>: Rectified Linear Unit, :math:<code>y = max(x, 0)</code></li>
<li><code>sigmoid</code>: :math:<code>y = \frac{1}{1 + exp(-x)}</code></li>
<li><code>tanh</code>: Hyperbolic tangent, :math:<code>y = \frac{exp(x) - exp(-x)}{exp(x) + exp(-x)}</code></li>
<li><code>softrelu</code>: Soft ReLU, or SoftPlus, :math:<code>y = log(1 + exp(x))</code></li>
<li><code>softsign</code>: :math:<code>y = \frac{x}{1 + abs(x)}</code></li>
</ul>
<p>Defined in src/operator/nn/activation.cc:L165</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>act_type::{'relu', 'sigmoid', 'softrelu', 'softsign', 'tanh'}, required</code>: Activation function to be applied.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L361' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.BatchNorm-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.BatchNorm-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.BatchNorm</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">BatchNorm(data, gamma, beta, moving_mean, moving_var, eps, momentum, fix_gamma, use_global_stats, output_mean_var, axis, cudnn_off, min_calib_range, max_calib_range)
</code></pre>

<p>Batch normalization.</p>
<p>Normalizes a data batch by mean and variance, and applies a scale $gamma$ as well as offset $beta$.</p>
<p>Assume the input has more than one dimension and we normalize along axis 1. We first compute the mean and variance along this axis:</p>
<p>.. math::</p>
<p>data_mean[i] = mean(data[:,i,:,...]) \
  data_var[i] = var(data[:,i,:,...])</p>
<p>Then compute the normalized output, which has the same shape as input, as following:</p>
<p>.. math::</p>
<p>out[:,i,:,...] = \frac{data[:,i,:,...] - data_mean[i]}{\sqrt{data_var[i]+\epsilon}} * gamma[i] + beta[i]</p>
<p>Both <em>mean</em> and <em>var</em> returns a scalar by treating the input as a vector.</p>
<p>Assume the input has size <em>k</em> on axis 1, then both $gamma$ and $beta$ have shape <em>(k,)</em>. If $output_mean_var$ is set to be true, then outputs both $data_mean$ and the inverse of $data_var$, which are needed for the backward pass. Note that gradient of these two outputs are blocked.</p>
<p>Besides the inputs and the outputs, this operator accepts two auxiliary states, $moving_mean$ and $moving_var$, which are <em>k</em>-length vectors. They are global statistics for the whole dataset, which are updated by::</p>
<p>moving<em>mean = moving</em>mean * momentum + data<em>mean * (1 - momentum)   moving</em>var = moving<em>var * momentum + data</em>var * (1 - momentum)</p>
<p>If $use_global_stats$ is set to be true, then $moving_mean$ and $moving_var$ are used instead of $data_mean$ and $data_var$ to compute the output. It is often used during inference.</p>
<p>The parameter $axis$ specifies which axis of the input shape denotes the 'channel' (separately normalized groups).  The default is 1.  Specifying -1 sets the channel axis to be the last item in the input shape.</p>
<p>Both $gamma$ and $beta$ are learnable parameters. But if $fix_gamma$ is true, then set $gamma$ to 1 and its gradient to 0.</p>
<p>.. Note::   When $fix_gamma$ is set to True, no sparse support is provided. If $fix_gamma is$ set to False,   the sparse tensors will fallback.</p>
<p>Defined in src/operator/nn/batch_norm.cc:L545</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data to batch normalization</li>
<li><code>gamma::NDArray-or-SymbolicNode</code>: gamma array</li>
<li><code>beta::NDArray-or-SymbolicNode</code>: beta array</li>
<li><code>moving_mean::NDArray-or-SymbolicNode</code>: running mean of input</li>
<li><code>moving_var::NDArray-or-SymbolicNode</code>: running variance of input</li>
<li><code>eps::double, optional, default=0.0010000000474974513</code>: Epsilon to prevent div 0. Must be no less than CUDNN<em>BN</em>MIN_EPSILON defined in cudnn.h when using cudnn (usually 1e-5)</li>
<li><code>momentum::float, optional, default=0.899999976</code>: Momentum for moving average</li>
<li><code>fix_gamma::boolean, optional, default=1</code>: Fix gamma while training</li>
<li><code>use_global_stats::boolean, optional, default=0</code>: Whether use global moving statistics instead of local batch-norm. This will force change batch-norm into a scale shift operator.</li>
<li><code>output_mean_var::boolean, optional, default=0</code>: Output the mean and inverse std</li>
<li><code>axis::int, optional, default='1'</code>: Specify which shape axis the channel is specified</li>
<li><code>cudnn_off::boolean, optional, default=0</code>: Do not select CUDNN operator, if available</li>
<li><code>min_calib_range::float or None, optional, default=None</code>: The minimum scalar value in the form of float32 obtained through calibration. If present, it will be used to by quantized batch norm op to calculate primitive scale.Note: this calib_range is to calib bn output.</li>
<li><code>max_calib_range::float or None, optional, default=None</code>: The maximum scalar value in the form of float32 obtained through calibration. If present, it will be used to by quantized batch norm op to calculate primitive scale.Note: this calib_range is to calib bn output.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L424' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.BatchNorm_v1-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.BatchNorm_v1-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.BatchNorm_v1</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">BatchNorm_v1(data, gamma, beta, eps, momentum, fix_gamma, use_global_stats, output_mean_var)
</code></pre>

<p>Batch normalization.</p>
<p>This operator is DEPRECATED. Perform BatchNorm on the input.</p>
<p>Normalizes a data batch by mean and variance, and applies a scale $gamma$ as well as offset $beta$.</p>
<p>Assume the input has more than one dimension and we normalize along axis 1. We first compute the mean and variance along this axis:</p>
<p>.. math::</p>
<p>data_mean[i] = mean(data[:,i,:,...]) \
  data_var[i] = var(data[:,i,:,...])</p>
<p>Then compute the normalized output, which has the same shape as input, as following:</p>
<p>.. math::</p>
<p>out[:,i,:,...] = \frac{data[:,i,:,...] - data_mean[i]}{\sqrt{data_var[i]+\epsilon}} * gamma[i] + beta[i]</p>
<p>Both <em>mean</em> and <em>var</em> returns a scalar by treating the input as a vector.</p>
<p>Assume the input has size <em>k</em> on axis 1, then both $gamma$ and $beta$ have shape <em>(k,)</em>. If $output_mean_var$ is set to be true, then outputs both $data_mean$ and $data_var$ as well, which are needed for the backward pass.</p>
<p>Besides the inputs and the outputs, this operator accepts two auxiliary states, $moving_mean$ and $moving_var$, which are <em>k</em>-length vectors. They are global statistics for the whole dataset, which are updated by::</p>
<p>moving<em>mean = moving</em>mean * momentum + data<em>mean * (1 - momentum)   moving</em>var = moving<em>var * momentum + data</em>var * (1 - momentum)</p>
<p>If $use_global_stats$ is set to be true, then $moving_mean$ and $moving_var$ are used instead of $data_mean$ and $data_var$ to compute the output. It is often used during inference.</p>
<p>Both $gamma$ and $beta$ are learnable parameters. But if $fix_gamma$ is true, then set $gamma$ to 1 and its gradient to 0.</p>
<p>There's no sparse support for this operator, and it will exhibit problematic behavior if used with sparse tensors.</p>
<p>Defined in src/operator/batch<em>norm</em>v1.cc:L95</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data to batch normalization</li>
<li><code>gamma::NDArray-or-SymbolicNode</code>: gamma array</li>
<li><code>beta::NDArray-or-SymbolicNode</code>: beta array</li>
<li><code>eps::float, optional, default=0.00100000005</code>: Epsilon to prevent div 0</li>
<li><code>momentum::float, optional, default=0.899999976</code>: Momentum for moving average</li>
<li><code>fix_gamma::boolean, optional, default=1</code>: Fix gamma while training</li>
<li><code>use_global_stats::boolean, optional, default=0</code>: Whether use global moving statistics instead of local batch-norm. This will force change batch-norm into a scale shift operator.</li>
<li><code>output_mean_var::boolean, optional, default=0</code>: Output All,normal mean and var</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L408' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.BilinearSampler-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.BilinearSampler-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.BilinearSampler</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">BilinearSampler(data, grid, cudnn_off)
</code></pre>

<p>Applies bilinear sampling to input feature map.</p>
<p>Bilinear Sampling is the key of  [NIPS2015] \"Spatial Transformer Networks\". The usage of the operator is very similar to remap function in OpenCV, except that the operator has the backward pass.</p>
<p>Given :math:<code>data</code> and :math:<code>grid</code>, then the output is computed by</p>
<p>.. math::   x<em dst="dst">{src} = grid[batch, 0, y</em>, x<em src="src">{dst}] \
  y</em> = grid[batch, 1, y<em dst="dst">{dst}, x</em>] \
  output[batch, channel, y<em dst="dst">{dst}, x</em>] = G(data[batch, channel, y<em src="src">{src}, x</em>)</p>
<p>:math:<code>x_{dst}</code>, :math:<code>y_{dst}</code> enumerate all spatial locations in :math:<code>output</code>, and :math:<code>G()</code> denotes the bilinear interpolation kernel. The out-boundary points will be padded with zeros.The shape of the output will be (data.shape[0], data.shape[1], grid.shape[2], grid.shape[3]).</p>
<p>The operator assumes that :math:<code>data</code> has 'NCHW' layout and :math:<code>grid</code> has been normalized to [-1, 1].</p>
<p>BilinearSampler often cooperates with GridGenerator which generates sampling grids for BilinearSampler. GridGenerator supports two kinds of transformation: $affine$ and $warp$. If users want to design a CustomOp to manipulate :math:<code>grid</code>, please firstly refer to the code of GridGenerator.</p>
<p>Example 1::</p>
<p><strong>Zoom out data two times</strong></p>
<p>data = array([[[[1, 4, 3, 6],                   [1, 8, 8, 9],                   [0, 4, 1, 5],                   [1, 0, 1, 3]]]])</p>
<p>affine_matrix = array([[2, 0, 0],                          [0, 2, 0]])</p>
<p>affine<em>matrix = reshape(affine</em>matrix, shape=(1, 6))</p>
<p>grid = GridGenerator(data=affine<em>matrix, transform</em>type='affine', target_shape=(4, 4))</p>
<p>out = BilinearSampler(data, grid)</p>
<p>out   [[[[ 0,   0,     0,   0],      [ 0,   3.5,   6.5, 0],      [ 0,   1.25,  2.5, 0],      [ 0,   0,     0,   0]]]</p>
<p>Example 2::</p>
<p><strong>shift data horizontally by -1 pixel</strong></p>
<p>data = array([[[[1, 4, 3, 6],                   [1, 8, 8, 9],                   [0, 4, 1, 5],                   [1, 0, 1, 3]]]])</p>
<p>warp_maxtrix = array([[[[1, 1, 1, 1],                           [1, 1, 1, 1],                           [1, 1, 1, 1],                           [1, 1, 1, 1]],                          [[0, 0, 0, 0],                           [0, 0, 0, 0],                           [0, 0, 0, 0],                           [0, 0, 0, 0]]]])</p>
<p>grid = GridGenerator(data=warp<em>matrix, transform</em>type='warp')   out = BilinearSampler(data, grid)</p>
<p>out   [[[[ 4,  3,  6,  0],      [ 8,  8,  9,  0],      [ 4,  1,  5,  0],      [ 0,  1,  3,  0]]]</p>
<p>Defined in src/operator/bilinear_sampler.cc:L256</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data to the BilinearsamplerOp.</li>
<li><code>grid::NDArray-or-SymbolicNode</code>: Input grid to the BilinearsamplerOp.grid has two channels: x<em>src, y</em>src</li>
<li><code>cudnn_off::boolean or None, optional, default=None</code>: whether to turn cudnn off</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L424' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.BlockGrad-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.BlockGrad-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.BlockGrad</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">BlockGrad(data)
</code></pre>

<p>Stops gradient computation.</p>
<p>Stops the accumulated gradient of the inputs from flowing through this operator in the backward direction. In other words, this operator prevents the contribution of its inputs to be taken into account for computing gradients.</p>
<p>Example::</p>
<p>v1 = [1, 2]   v2 = [0, 1]   a = Variable('a')   b = Variable('b')   b<em>stop</em>grad = stop<em>gradient(3 * b)   loss = MakeLoss(b</em>stop_grad + a)</p>
<p>executor = loss.simple<em>bind(ctx=cpu(), a=(1,2), b=(1,2))   executor.forward(is</em>train=True, a=v1, b=v2)   executor.outputs   [ 1.  5.]</p>
<p>executor.backward()   executor.grad_arrays   [ 0.  0.]   [ 1.  1.]</p>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_basic.cc:L325</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L374' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.CTCLoss-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.CTCLoss-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.CTCLoss</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">CTCLoss(data, label, data_lengths, label_lengths, use_data_lengths, use_label_lengths, blank_label)
</code></pre>

<p>Connectionist Temporal Classification Loss.</p>
<p>.. note:: The existing alias $contrib_CTCLoss$ is deprecated.</p>
<p>The shapes of the inputs and outputs:</p>
<ul>
<li><strong>data</strong>: <code>(sequence_length, batch_size, alphabet_size)</code></li>
<li><strong>label</strong>: <code>(batch_size, label_sequence_length)</code></li>
<li><strong>out</strong>: <code>(batch_size)</code></li>
</ul>
<p>The <code>data</code> tensor consists of sequences of activation vectors (without applying softmax), with i-th channel in the last dimension corresponding to i-th label for i between 0 and alphabet*size-1 (i.e always 0-indexed). Alphabet size should include one additional value reserved for blank label. When <code>blank*label</code>is<code>"first"</code>, the<code>0</code>-th channel is be reserved for activation of blank label, or otherwise if it is "last",<code>(alphabet_size-1)</code>-th channel should be reserved for blank label.</p>
<p>$label$ is an index matrix of integers. When <code>blank_label</code> is $"first"$, the value 0 is then reserved for blank label, and should not be passed in this matrix. Otherwise, when <code>blank_label</code> is $"last"$, the value <code>(alphabet_size-1)</code> is reserved for blank label.</p>
<p>If a sequence of labels is shorter than <em>label</em>sequence<em>length</em>, use the special padding value at the end of the sequence to conform it to the correct length. The padding value is <code>0</code> when <code>blank_label</code> is $"first"$, and <code>-1</code> otherwise.</p>
<p>For example, suppose the vocabulary is <code>[a, b, c]</code>, and in one batch we have three sequences 'ba', 'cbb', and 'abac'. When <code>blank_label</code> is $"first"$, we can index the labels as <code>{'a': 1, 'b': 2, 'c': 3}</code>, and we reserve the 0-th channel for blank label in data tensor. The resulting <code>label</code> tensor should be padded to be::</p>
<p>[[2, 1, 0, 0], [3, 2, 2, 0], [1, 2, 1, 3]]</p>
<p>When <code>blank_label</code> is $"last"$, we can index the labels as <code>{'a': 0, 'b': 1, 'c': 2}</code>, and we reserve the channel index 3 for blank label in data tensor. The resulting <code>label</code> tensor should be padded to be::</p>
<p>[[1, 0, -1, -1], [2, 1, 1, -1], [0, 1, 0, 2]]</p>
<p>$out$ is a list of CTC loss values, one per example in the batch.</p>
<p>See <em>Connectionist Temporal Classification: Labelling Unsegmented Sequence Data with Recurrent Neural Networks</em>, A. Graves <em>et al</em>. for more information on the definition and the algorithm.</p>
<p>Defined in src/operator/nn/ctc_loss.cc:L100</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input ndarray</li>
<li><code>label::NDArray-or-SymbolicNode</code>: Ground-truth labels for the loss.</li>
<li><code>data_lengths::NDArray-or-SymbolicNode</code>: Lengths of data for each of the samples. Only required when use<em>data</em>lengths is true.</li>
<li><code>label_lengths::NDArray-or-SymbolicNode</code>: Lengths of labels for each of the samples. Only required when use<em>label</em>lengths is true.</li>
<li><code>use_data_lengths::boolean, optional, default=0</code>: Whether the data lenghts are decided by <code>data_lengths</code>. If false, the lengths are equal to the max sequence length.</li>
<li><code>use_label_lengths::boolean, optional, default=0</code>: Whether the label lenghts are decided by <code>label_lengths</code>, or derived from <code>padding_mask</code>. If false, the lengths are derived from the first occurrence of the value of <code>padding_mask</code>. The value of <code>padding_mask</code> is $0$ when first CTC label is reserved for blank, and $-1$ when last label is reserved for blank. See <code>blank_label</code>.</li>
<li><code>blank_label::{'first', 'last'},optional, default='first'</code>: Set the label that is reserved for blank label.If "first", 0-th label is reserved, and label values for tokens in the vocabulary are between $1$ and $alphabet_size-1$, and the padding mask is $-1$. If "last", last label value $alphabet_size-1$ is reserved for blank label instead, and label values for tokens in the vocabulary are between $0$ and $alphabet_size-2$, and the padding mask is $0$.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L406' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.Cast-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.Cast-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.Cast</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">Cast(data, dtype)
</code></pre>

<p>Casts all elements of the input to a new type.</p>
<p>.. note:: $Cast$ is deprecated. Use $cast$ instead.</p>
<p>Example::</p>
<p>cast([0.9, 1.3], dtype='int32') = [0, 1]    cast([1e20, 11.1], dtype='float16') = [inf, 11.09375]    cast([300, 11.1, 10.9, -1, -3], dtype='uint8') = [44, 11, 10, 255, 253]</p>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_basic.cc:L664</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input.</li>
<li><code>dtype::{'bfloat16', 'bool', 'float16', 'float32', 'float64', 'int32', 'int64', 'int8', 'uint8'}, required</code>: Output data type.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L361' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.Concat-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.Concat-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.Concat</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">Concat(data, num_args, dim)
</code></pre>

<p><strong>Note</strong>: Concat takes variable number of positional inputs. So instead of calling as Concat([x, y, z], num<em>args=3), one should call via Concat(x, y, z), and num</em>args will be determined automatically.</p>
<p>Joins input arrays along a given axis.</p>
<p>.. note:: <code>Concat</code> is deprecated. Use <code>concat</code> instead.</p>
<p>The dimensions of the input arrays should be the same except the axis along which they will be concatenated. The dimension of the output array along the concatenated axis will be equal to the sum of the corresponding dimensions of the input arrays.</p>
<p>The storage type of $concat$ output depends on storage types of inputs</p>
<ul>
<li>concat(csr, csr, ..., csr, dim=0) = csr</li>
<li>otherwise, $concat$ generates output with default storage</li>
</ul>
<p>Example::</p>
<p>x = [[1,1],[2,2]]    y = [[3,3],[4,4],[5,5]]    z = [[6,6], [7,7],[8,8]]</p>
<p>concat(x,y,z,dim=0) = [[ 1.,  1.],                           [ 2.,  2.],                           [ 3.,  3.],                           [ 4.,  4.],                           [ 5.,  5.],                           [ 6.,  6.],                           [ 7.,  7.],                           [ 8.,  8.]]</p>
<p>Note that you cannot concat x,y,z along dimension 1 since dimension    0 is not the same for all the input arrays.</p>
<p>concat(y,z,dim=1) = [[ 3.,  3.,  6.,  6.],                          [ 4.,  4.,  7.,  7.],                          [ 5.,  5.,  8.,  8.]]</p>
<p>Defined in src/operator/nn/concat.cc:L385</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode[]</code>: List of arrays to concatenate</li>
<li><code>num_args::int, required</code>: Number of inputs to be concated.</li>
<li><code>dim::int, optional, default='1'</code>: the dimension to be concated.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L391' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.Convolution-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.Convolution-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.Convolution</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">Convolution(data, weight, bias, kernel, stride, dilate, pad, num_filter, num_group, workspace, no_bias, cudnn_tune, cudnn_off, layout)
</code></pre>

<p>Compute <em>N</em>-D convolution on <em>(N+2)</em>-D input.</p>
<p>In the 2-D convolution, given input data with shape <em>(batch_size, channel, height, width)</em>, the output is computed by</p>
<p>.. math::</p>
<p>out[n,i,:,:] = bias[i] + \sum_{j=0}^{channel} data[n,j,:,:] \star    weight[i,j,:,:]</p>
<p>where :math:<code>\star</code> is the 2-D cross-correlation operator.</p>
<p>For general 2-D convolution, the shapes are</p>
<ul>
<li><strong>data</strong>: <em>(batch_size, channel, height, width)</em></li>
<li><strong>weight</strong>: <em>(num_filter, channel, kernel[0], kernel[1])</em></li>
<li><strong>bias</strong>: <em>(num_filter,)</em></li>
<li><strong>out</strong>: <em>(batch</em>size, num<em>filter, out</em>height, out<em>width)</em>.</li>
</ul>
<p>Define::</p>
<p>f(x,k,p,s,d) = floor((x+2<em>p-d</em>(k-1)-1)/s)+1</p>
<p>then we have::</p>
<p>out<em>height=f(height, kernel[0], pad[0], stride[0], dilate[0])   out</em>width=f(width, kernel[1], pad[1], stride[1], dilate[1])</p>
<p>If $no_bias$ is set to be true, then the $bias$ term is ignored.</p>
<p>The default data $layout$ is <em>NCHW</em>, namely <em>(batch_size, channel, height, width)</em>. We can choose other layouts such as <em>NWC</em>.</p>
<p>If $num_group$ is larger than 1, denoted by <em>g</em>, then split the input $data$ evenly into <em>g</em> parts along the channel axis, and also evenly split $weight$ along the first dimension. Next compute the convolution on the <em>i</em>-th part of the data with the <em>i</em>-th weight part. The output is obtained by concatenating all the <em>g</em> results.</p>
<p>1-D convolution does not have <em>height</em> dimension but only <em>width</em> in space.</p>
<ul>
<li><strong>data</strong>: <em>(batch_size, channel, width)</em></li>
<li><strong>weight</strong>: <em>(num_filter, channel, kernel[0])</em></li>
<li><strong>bias</strong>: <em>(num_filter,)</em></li>
<li><strong>out</strong>: <em>(batch</em>size, num<em>filter, out_width)</em>.</li>
</ul>
<p>3-D convolution adds an additional <em>depth</em> dimension besides <em>height</em> and <em>width</em>. The shapes are</p>
<ul>
<li><strong>data</strong>: <em>(batch_size, channel, depth, height, width)</em></li>
<li><strong>weight</strong>: <em>(num_filter, channel, kernel[0], kernel[1], kernel[2])</em></li>
<li><strong>bias</strong>: <em>(num_filter,)</em></li>
<li><strong>out</strong>: <em>(batch</em>size, num<em>filter, out</em>depth, out<em>height, out_width)</em>.</li>
</ul>
<p>Both $weight$ and $bias$ are learnable parameters.</p>
<p>There are other options to tune the performance.</p>
<ul>
<li>
<p><strong>cudnn_tune</strong>: enable this option leads to higher startup time but may give faster speed. Options are</p>
<ul>
<li><strong>off</strong>: no tuning</li>
<li><strong>limited_workspace</strong>:run test and pick the fastest algorithm that doesn't exceed workspace limit.</li>
<li><strong>fastest</strong>: pick the fastest algorithm and ignore workspace limit.</li>
<li><strong>None</strong> (default): the behavior is determined by environment variable $MXNET_CUDNN_AUTOTUNE_DEFAULT$. 0 for off, 1 for limited workspace (default), 2 for fastest.</li>
<li><strong>workspace</strong>: A large number leads to more (GPU) memory usage but may improve the performance.</li>
</ul>
</li>
</ul>
<p>Defined in src/operator/nn/convolution.cc:L469</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data to the ConvolutionOp.</li>
<li><code>weight::NDArray-or-SymbolicNode</code>: Weight matrix.</li>
<li><code>bias::NDArray-or-SymbolicNode</code>: Bias parameter.</li>
<li><code>kernel::Shape(tuple), required</code>: Convolution kernel size: (w,), (h, w) or (d, h, w)</li>
<li><code>stride::Shape(tuple), optional, default=[]</code>: Convolution stride: (w,), (h, w) or (d, h, w). Defaults to 1 for each dimension.</li>
<li><code>dilate::Shape(tuple), optional, default=[]</code>: Convolution dilate: (w,), (h, w) or (d, h, w). Defaults to 1 for each dimension.</li>
<li><code>pad::Shape(tuple), optional, default=[]</code>: Zero pad for convolution: (w,), (h, w) or (d, h, w). Defaults to no padding.</li>
<li><code>num_filter::int (non-negative), required</code>: Convolution filter(channel) number</li>
<li><code>num_group::int (non-negative), optional, default=1</code>: Number of group partitions.</li>
<li><code>workspace::long (non-negative), optional, default=1024</code>: Maximum temporary workspace allowed (MB) in convolution.This parameter has two usages. When CUDNN is not used, it determines the effective batch size of the convolution kernel. When CUDNN is used, it controls the maximum temporary storage used for tuning the best CUDNN kernel when <code>limited_workspace</code> strategy is used.</li>
<li><code>no_bias::boolean, optional, default=0</code>: Whether to disable bias parameter.</li>
<li><code>cudnn_tune::{None, 'fastest', 'limited_workspace', 'off'},optional, default='None'</code>: Whether to pick convolution algo by running performance test.</li>
<li><code>cudnn_off::boolean, optional, default=0</code>: Turn off cudnn for this layer.</li>
<li><code>layout::{None, 'NCDHW', 'NCHW', 'NCW', 'NDHWC', 'NHWC'},optional, default='None'</code>: Set layout for input, output and weight. Empty for   default layout: NCW for 1d, NCHW for 2d and NCDHW for 3d.NHWC and NDHWC are only supported on GPU.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L448' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.Convolution_v1-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.Convolution_v1-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.Convolution_v1</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">Convolution_v1(data, weight, bias, kernel, stride, dilate, pad, num_filter, num_group, workspace, no_bias, cudnn_tune, cudnn_off, layout)
</code></pre>

<p>This operator is DEPRECATED. Apply convolution to input then add a bias.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data to the ConvolutionV1Op.</li>
<li><code>weight::NDArray-or-SymbolicNode</code>: Weight matrix.</li>
<li><code>bias::NDArray-or-SymbolicNode</code>: Bias parameter.</li>
<li><code>kernel::Shape(tuple), required</code>: convolution kernel size: (h, w) or (d, h, w)</li>
<li><code>stride::Shape(tuple), optional, default=[]</code>: convolution stride: (h, w) or (d, h, w)</li>
<li><code>dilate::Shape(tuple), optional, default=[]</code>: convolution dilate: (h, w) or (d, h, w)</li>
<li><code>pad::Shape(tuple), optional, default=[]</code>: pad for convolution: (h, w) or (d, h, w)</li>
<li><code>num_filter::int (non-negative), required</code>: convolution filter(channel) number</li>
<li><code>num_group::int (non-negative), optional, default=1</code>: Number of group partitions. Equivalent to slicing input into num_group   partitions, apply convolution on each, then concatenate the results</li>
<li><code>workspace::long (non-negative), optional, default=1024</code>: Maximum temporary workspace allowed for convolution (MB).This parameter determines the effective batch size of the convolution kernel, which may be smaller than the given batch size. Also, the workspace will be automatically enlarged to make sure that we can run the kernel with batch_size=1</li>
<li><code>no_bias::boolean, optional, default=0</code>: Whether to disable bias parameter.</li>
<li><code>cudnn_tune::{None, 'fastest', 'limited_workspace', 'off'},optional, default='None'</code>: Whether to pick convolution algo by running performance test.   Leads to higher startup time but may give faster speed. Options are:   'off': no tuning   'limited<em>workspace': run test and pick the fastest algorithm that doesn't exceed workspace limit.   'fastest': pick the fastest algorithm and ignore workspace limit.   If set to None (default), behavior is determined by environment   variable MXNET</em>CUDNN<em>AUTOTUNE</em>DEFAULT: 0 for off,   1 for limited workspace (default), 2 for fastest.</li>
<li><code>cudnn_off::boolean, optional, default=0</code>: Turn off cudnn for this layer.</li>
<li><code>layout::{None, 'NCDHW', 'NCHW', 'NDHWC', 'NHWC'},optional, default='None'</code>: Set layout for input, output and weight. Empty for   default layout: NCHW for 2d and NCDHW for 3d.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L382' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.Correlation-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.Correlation-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.Correlation</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">Correlation(data1, data2, kernel_size, max_displacement, stride1, stride2, pad_size, is_multiply)
</code></pre>

<p>Applies correlation to inputs.</p>
<p>The correlation layer performs multiplicative patch comparisons between two feature maps.</p>
<p>Given two multi-channel feature maps :math:<code>f_{1}, f_{2}</code>, with :math:<code>w</code>, :math:<code>h</code>, and :math:<code>c</code> being their width, height, and number of channels, the correlation layer lets the network compare each patch from :math:<code>f_{1}</code> with each patch from :math:<code>f_{2}</code>.</p>
<p>For now we consider only a single comparison of two patches. The 'correlation' of two patches centered at :math:<code>x_{1}</code> in the first map and :math:<code>x_{2}</code> in the second map is then defined as:</p>
<p>.. math::</p>
<p>c(x<em 2="2">{1}, x</em>) = \sum*{o \in [-k,k] \times [-k,k]} <f*{1}(x*{1} + o), f*{2}(x_{2} + o)></p>
<p>for a square patch of size :math:<code>K:=2k+1</code>.</p>
<p>Note that the equation above is identical to one step of a convolution in neural networks, but instead of convolving data with a filter, it convolves data with other data. For this reason, it has no training weights.</p>
<p>Computing :math:<code>c(x_{1}, x_{2})</code> involves :math:<code>c * K^{2}</code> multiplications. Comparing all patch combinations involves :math:<code>w^{2}*h^{2}</code> such computations.</p>
<p>Given a maximum displacement :math:<code>d</code>, for each location :math:<code>x_{1}</code> it computes correlations :math:<code>c(x_{1}, x_{2})</code> only in a neighborhood of size :math:<code>D:=2d+1</code>, by limiting the range of :math:<code>x_{2}</code>. We use strides :math:<code>s_{1}, s_{2}</code>, to quantize :math:<code>x_{1}</code> globally and to quantize :math:<code>x_{2}</code> within the neighborhood centered around :math:<code>x_{1}</code>.</p>
<p>The final output is defined by the following expression:</p>
<p>.. math::   out[n, q, i, j] = c(x<em q="q">{i, j}, x</em>)</p>
<p>where :math:<code>i</code> and :math:<code>j</code> enumerate spatial locations in :math:<code>f_{1}</code>, and :math:<code>q</code> denotes the :math:<code>q^{th}</code> neighborhood of :math:<code>x_{i,j}</code>.</p>
<p>Defined in src/operator/correlation.cc:L198</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data1::NDArray-or-SymbolicNode</code>: Input data1 to the correlation.</li>
<li><code>data2::NDArray-or-SymbolicNode</code>: Input data2 to the correlation.</li>
<li><code>kernel_size::int (non-negative), optional, default=1</code>: kernel size for Correlation must be an odd number</li>
<li><code>max_displacement::int (non-negative), optional, default=1</code>: Max displacement of Correlation</li>
<li><code>stride1::int (non-negative), optional, default=1</code>: stride1 quantize data1 globally</li>
<li><code>stride2::int (non-negative), optional, default=1</code>: stride2 quantize data2 within the neighborhood centered around data1</li>
<li><code>pad_size::int (non-negative), optional, default=0</code>: pad for Correlation</li>
<li><code>is_multiply::boolean, optional, default=1</code>: operation type is either multiplication or subduction</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L394' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.Crop-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.Crop-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.Crop</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">Crop(data, num_args, offset, h_w, center_crop)
</code></pre>

<p><strong>Note</strong>: Crop takes variable number of positional inputs. So instead of calling as Crop([x, y, z], num<em>args=3), one should call via Crop(x, y, z), and num</em>args will be determined automatically.</p>
<p>.. note:: <code>Crop</code> is deprecated. Use <code>slice</code> instead.</p>
<p>Crop the 2nd and 3rd dim of input data, with the corresponding size of h<em>w or with width and height of the second input symbol, i.e., with one input, we need h</em>w to specify the crop height and width, otherwise the second input symbol's size will be used</p>
<p>Defined in src/operator/crop.cc:L50</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::SymbolicNode or SymbolicNode[]</code>: Tensor or List of Tensors, the second input will be used as crop_like shape reference</li>
<li><code>num_args::int, required</code>: Number of inputs for crop, if equals one, then we will use the h<em>wfor crop height and width, else if equals two, then we will use the heightand width of the second input symbol, we name crop</em>like here</li>
<li><code>offset::Shape(tuple), optional, default=[0,0]</code>: crop offset coordinate: (y, x)</li>
<li><code>h_w::Shape(tuple), optional, default=[0,0]</code>: crop height and width: (h, w)</li>
<li><code>center_crop::boolean, optional, default=0</code>: If set to true, then it will use be the center<em>crop,or it will crop using the shape of crop</em>like</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L366' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.Custom-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.Custom-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.Custom</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">Custom(data, op_type)
</code></pre>

<p>Apply a custom operator implemented in a frontend language (like Python).</p>
<p>Custom operators should override required methods like <code>forward</code> and <code>backward</code>. The custom operator must be registered before it can be used. Please check the tutorial here: https://mxnet.incubator.apache.org/api/faq/new_op</p>
<p>Defined in src/operator/custom/custom.cc:L547</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode[]</code>: Input data for the custom operator.</li>
<li><code>op_type::string</code>: Name of the custom operator. This is the name that is passed to <code>mx.operator.register</code> to register the operator.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L357' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.Deconvolution-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.Deconvolution-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.Deconvolution</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">Deconvolution(data, weight, bias, kernel, stride, dilate, pad, adj, target_shape, num_filter, num_group, workspace, no_bias, cudnn_tune, cudnn_off, layout)
</code></pre>

<p>Computes 1D or 2D transposed convolution (aka fractionally strided convolution) of the input tensor. This operation can be seen as the gradient of Convolution operation with respect to its input. Convolution usually reduces the size of the input. Transposed convolution works the other way, going from a smaller input to a larger output while preserving the connectivity pattern.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input tensor to the deconvolution operation.</li>
<li><code>weight::NDArray-or-SymbolicNode</code>: Weights representing the kernel.</li>
<li><code>bias::NDArray-or-SymbolicNode</code>: Bias added to the result after the deconvolution operation.</li>
<li><code>kernel::Shape(tuple), required</code>: Deconvolution kernel size: (w,), (h, w) or (d, h, w). This is same as the kernel size used for the corresponding convolution</li>
<li><code>stride::Shape(tuple), optional, default=[]</code>: The stride used for the corresponding convolution: (w,), (h, w) or (d, h, w). Defaults to 1 for each dimension.</li>
<li><code>dilate::Shape(tuple), optional, default=[]</code>: Dilation factor for each dimension of the input: (w,), (h, w) or (d, h, w). Defaults to 1 for each dimension.</li>
<li><code>pad::Shape(tuple), optional, default=[]</code>: The amount of implicit zero padding added during convolution for each dimension of the input: (w,), (h, w) or (d, h, w). $(kernel-1)/2$ is usually a good choice. If <code>target_shape</code> is set, <code>pad</code> will be ignored and a padding that will generate the target shape will be used. Defaults to no padding.</li>
<li><code>adj::Shape(tuple), optional, default=[]</code>: Adjustment for output shape: (w,), (h, w) or (d, h, w). If <code>target_shape</code> is set, <code>adj</code> will be ignored and computed accordingly.</li>
<li><code>target_shape::Shape(tuple), optional, default=[]</code>: Shape of the output tensor: (w,), (h, w) or (d, h, w).</li>
<li><code>num_filter::int (non-negative), required</code>: Number of output filters.</li>
<li><code>num_group::int (non-negative), optional, default=1</code>: Number of groups partition.</li>
<li><code>workspace::long (non-negative), optional, default=512</code>: Maximum temporary workspace allowed (MB) in deconvolution.This parameter has two usages. When CUDNN is not used, it determines the effective batch size of the deconvolution kernel. When CUDNN is used, it controls the maximum temporary storage used for tuning the best CUDNN kernel when <code>limited_workspace</code> strategy is used.</li>
<li><code>no_bias::boolean, optional, default=1</code>: Whether to disable bias parameter.</li>
<li><code>cudnn_tune::{None, 'fastest', 'limited_workspace', 'off'},optional, default='None'</code>: Whether to pick convolution algorithm by running performance test.</li>
<li><code>cudnn_off::boolean, optional, default=0</code>: Turn off cudnn for this layer.</li>
<li><code>layout::{None, 'NCDHW', 'NCHW', 'NCW', 'NDHWC', 'NHWC'},optional, default='None'</code>: Set layout for input, output and weight. Empty for default layout, NCW for 1d, NCHW for 2d and NCDHW for 3d.NHWC and NDHWC are only supported on GPU.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L377' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.Dropout-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.Dropout-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.Dropout</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">Dropout(data, p, mode, axes, cudnn_off)
</code></pre>

<p>Applies dropout operation to input array.</p>
<ul>
<li>During training, each element of the input is set to zero with probability p. The whole array is rescaled by :math:<code>1/(1-p)</code> to keep the expected sum of the input unchanged.</li>
<li>During testing, this operator does not change the input if mode is 'training'. If mode is 'always', the same computaion as during training will be applied.</li>
</ul>
<p>Example::</p>
<p>random.seed(998)   input<em>array = array([[3., 0.5,  -0.5,  2., 7.],                       [2., -0.4,   7.,  3., 0.2]])   a = symbol.Variable('a')   dropout = symbol.Dropout(a, p = 0.2)   executor = dropout.simple</em>bind(a = input_array.shape)</p>
<p><strong>If training</strong></p>
<p>executor.forward(is<em>train = True, a = input</em>array)   executor.outputs   [[ 3.75   0.625 -0.     2.5    8.75 ]    [ 2.5   -0.5    8.75   3.75   0.   ]]</p>
<p><strong>If testing</strong></p>
<p>executor.forward(is<em>train = False, a = input</em>array)   executor.outputs   [[ 3.     0.5   -0.5    2.     7.   ]    [ 2.    -0.4    7.     3.     0.2  ]]</p>
<p>Defined in src/operator/nn/dropout.cc:L96</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input array to which dropout will be applied.</li>
<li><code>p::float, optional, default=0.5</code>: Fraction of the input that gets dropped out during training time.</li>
<li><code>mode::{'always', 'training'},optional, default='training'</code>: Whether to only turn on dropout during training or to also turn on for inference.</li>
<li><code>axes::Shape(tuple), optional, default=[]</code>: Axes for variational dropout kernel.</li>
<li><code>cudnn_off::boolean or None, optional, default=0</code>: Whether to turn off cudnn in dropout operator. This option is ignored if axes is specified.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L386' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.ElementWiseSum-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.ElementWiseSum-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.ElementWiseSum</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">ElementWiseSum(args)
</code></pre>

<p>ElementWiseSum is an alias of add_n.</p>
<p><strong>Note</strong>: ElementWiseSum takes variable number of positional inputs. So instead of calling as ElementWiseSum([x, y, z], num<em>args=3), one should call via ElementWiseSum(x, y, z), and num</em>args will be determined automatically.</p>
<p>Adds all input arguments element-wise.</p>
<p>.. math::    add_n(a<em>1, a</em>2, ..., a<em>n) = a</em>1 + a<em>2 + ... + a</em>n</p>
<p>$add_n$ is potentially more efficient than calling $add$ by <code>n</code> times.</p>
<p>The storage type of $add_n$ output depends on storage types of inputs</p>
<ul>
<li>add<em>n(row</em>sparse, row<em>sparse, ..) = row</em>sparse</li>
<li>add_n(default, csr, default) = default</li>
<li>add_n(any input combinations longer than 4 (&gt;4) with at least one default type) = default</li>
<li>otherwise, $add_n$ falls all inputs back to default storage and generates default storage</li>
</ul>
<p>Defined in src/operator/tensor/elemwise_sum.cc:L155</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>args::NDArray-or-SymbolicNode[]</code>: Positional input arguments</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L367' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.Embedding-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.Embedding-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.Embedding</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">Embedding(data, weight, input_dim, output_dim, dtype, sparse_grad)
</code></pre>

<p>Maps integer indices to vector representations (embeddings).</p>
<p>This operator maps words to real-valued vectors in a high-dimensional space, called word embeddings. These embeddings can capture semantic and syntactic properties of the words. For example, it has been noted that in the learned embedding spaces, similar words tend to be close to each other and dissimilar words far apart.</p>
<p>For an input array of shape (d1, ..., dK), the shape of an output array is (d1, ..., dK, output<em>dim). All the input values should be integers in the range [0, input</em>dim).</p>
<p>If the input<em>dim is ip0 and output</em>dim is op0, then shape of the embedding weight matrix must be (ip0, op0).</p>
<p>When "sparse<em>grad" is False, if any index mentioned is too large, it is replaced by the index that addresses the last vector in an embedding matrix. When "sparse</em>grad" is True, an error will be raised if invalid indices are found.</p>
<p>Examples::</p>
<p>input<em>dim = 4   output</em>dim = 5</p>
<p>// Each row in weight matrix y represents a word. So, y = (w0,w1,w2,w3)   y = [[  0.,   1.,   2.,   3.,   4.],        [  5.,   6.,   7.,   8.,   9.],        [ 10.,  11.,  12.,  13.,  14.],        [ 15.,  16.,  17.,  18.,  19.]]</p>
<p>// Input array x represents n-grams(2-gram). So, x = [(w1,w3), (w0,w2)]   x = [[ 1.,  3.],        [ 0.,  2.]]</p>
<p>// Mapped input x to its vector representation y.   Embedding(x, y, 4, 5) = [[[  5.,   6.,   7.,   8.,   9.],                             [ 15.,  16.,  17.,  18.,  19.]],</p>
<pre><code>                       [[  0.,   1.,   2.,   3.,   4.],
                        [ 10.,  11.,  12.,  13.,  14.]]]
</code></pre>

<p>The storage type of weight can be either row_sparse or default.</p>
<p>.. Note::</p>
<pre><code>If &quot;sparse_grad&quot; is set to True, the storage type of gradient w.r.t weights will be
&quot;row_sparse&quot;. Only a subset of optimizers support sparse gradients, including SGD, AdaGrad
and Adam. Note that by default lazy updates is turned on, which may perform differently
from standard updates. For more details, please check the Optimization API at:
https://mxnet.incubator.apache.org/api/python/optimization/optimization.html
</code></pre>

<p>Defined in src/operator/tensor/indexing_op.cc:L603</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array to the embedding operator.</li>
<li><code>weight::NDArray-or-SymbolicNode</code>: The embedding weight matrix.</li>
<li><code>input_dim::int, required</code>: Vocabulary size of the input indices.</li>
<li><code>output_dim::int, required</code>: Dimension of the embedding vectors.</li>
<li><code>dtype::{'bfloat16', 'float16', 'float32', 'float64', 'int32', 'int64', 'int8', 'uint8'},optional, default='float32'</code>: Data type of weight.</li>
<li><code>sparse_grad::boolean, optional, default=0</code>: Compute row sparse gradient in the backward calculation. If set to True, the grad's storage type is row_sparse.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L410' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.FullyConnected-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.FullyConnected-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.FullyConnected</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">FullyConnected(data, weight, bias, num_hidden, no_bias, flatten)
</code></pre>

<p>Applies a linear transformation: :math:<code>Y = XW^T + b</code>.</p>
<p>If $flatten$ is set to be true, then the shapes are:</p>
<ul>
<li><strong>data</strong>: <code>(batch_size, x1, x2, ..., xn)</code></li>
<li><strong>weight</strong>: <code>(num_hidden, x1 * x2 * ... * xn)</code></li>
<li><strong>bias</strong>: <code>(num_hidden,)</code></li>
<li><strong>out</strong>: <code>(batch_size, num_hidden)</code></li>
</ul>
<p>If $flatten$ is set to be false, then the shapes are:</p>
<ul>
<li><strong>data</strong>: <code>(x1, x2, ..., xn, input_dim)</code></li>
<li><strong>weight</strong>: <code>(num_hidden, input_dim)</code></li>
<li><strong>bias</strong>: <code>(num_hidden,)</code></li>
<li><strong>out</strong>: <code>(x1, x2, ..., xn, num_hidden)</code></li>
</ul>
<p>The learnable parameters include both $weight$ and $bias$.</p>
<p>If $no_bias$ is set to be true, then the $bias$ term is ignored.</p>
<p>.. Note::</p>
<pre><code>The sparse support for FullyConnected is limited to forward evaluation with `row_sparse`
weight and bias, where the length of `weight.indices` and `bias.indices` must be equal
to `num_hidden`. This could be useful for model inference with `row_sparse` weights
trained with importance sampling or noise contrastive estimation.

To compute linear transformation with 'csr' sparse data, sparse.dot is recommended instead
of sparse.FullyConnected.
</code></pre>

<p>Defined in src/operator/nn/fully_connected.cc:L287</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data.</li>
<li><code>weight::NDArray-or-SymbolicNode</code>: Weight matrix.</li>
<li><code>bias::NDArray-or-SymbolicNode</code>: Bias parameter.</li>
<li><code>num_hidden::int, required</code>: Number of hidden nodes of the output.</li>
<li><code>no_bias::boolean, optional, default=0</code>: Whether to disable bias parameter.</li>
<li><code>flatten::boolean, optional, default=1</code>: Whether to collapse all but the first axis of the input data tensor.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L389' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.GridGenerator-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.GridGenerator-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.GridGenerator</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">GridGenerator(data, transform_type, target_shape)
</code></pre>

<p>Generates 2D sampling grid for bilinear sampling.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data to the function.</li>
<li><code>transform_type::{'affine', 'warp'}, required</code>: The type of transformation. For <code>affine</code>, input data should be an affine matrix of size (batch, 6). For <code>warp</code>, input data should be an optical flow of size (batch, 2, h, w).</li>
<li><code>target_shape::Shape(tuple), optional, default=[0,0]</code>: Specifies the output shape (H, W). This is required if transformation type is <code>affine</code>. If transformation type is <code>warp</code>, this parameter is ignored.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.GroupNorm-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.GroupNorm-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.GroupNorm</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">GroupNorm(data, gamma, beta, num_groups, eps, output_mean_var)
</code></pre>

<p>Group normalization.</p>
<p>The input channels are separated into $num_groups$ groups, each containing $num_channels / num_groups$ channels. The mean and standard-deviation are calculated separately over the each group.</p>
<p>.. math::</p>
<p>data = data.reshape((N, num<em>groups, C // num</em>groups, ...))   out = \frac{data - mean(data, axis)}{\sqrt{var(data, axis) + \epsilon}} * gamma + beta</p>
<p>Both $gamma$ and $beta$ are learnable parameters.</p>
<p>Defined in src/operator/nn/group_norm.cc:L77</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data</li>
<li><code>gamma::NDArray-or-SymbolicNode</code>: gamma array</li>
<li><code>beta::NDArray-or-SymbolicNode</code>: beta array</li>
<li><code>num_groups::int, optional, default='1'</code>: Total number of groups.</li>
<li><code>eps::float, optional, default=9.99999975e-06</code>: An <code>epsilon</code> parameter to prevent division by 0.</li>
<li><code>output_mean_var::boolean, optional, default=0</code>: Output the mean and std calculated along the given axis.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L371' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.IdentityAttachKLSparseReg-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.IdentityAttachKLSparseReg-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.IdentityAttachKLSparseReg</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">IdentityAttachKLSparseReg(data, sparseness_target, penalty, momentum)
</code></pre>

<p>Apply a sparse regularization to the output a sigmoid activation function.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data.</li>
<li><code>sparseness_target::float, optional, default=0.100000001</code>: The sparseness target</li>
<li><code>penalty::float, optional, default=0.00100000005</code>: The tradeoff parameter for the sparseness penalty</li>
<li><code>momentum::float, optional, default=0.899999976</code>: The momentum for running average</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L353' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.InstanceNorm-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.InstanceNorm-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.InstanceNorm</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">InstanceNorm(data, gamma, beta, eps)
</code></pre>

<p>Applies instance normalization to the n-dimensional input array.</p>
<p>This operator takes an n-dimensional input array where (n&gt;2) and normalizes the input using the following formula:</p>
<p>.. math::</p>
<p>out = \frac{x - mean[data]}{ \sqrt{Var[data]} + \epsilon} * gamma + beta</p>
<p>This layer is similar to batch normalization layer (<code>BatchNorm</code>) with two differences: first, the normalization is carried out per example (instance), not over a batch. Second, the same normalization is applied both at test and train time. This operation is also known as <code>contrast normalization</code>.</p>
<p>If the input data is of shape [batch, channel, spacial<em>dim1, spacial</em>dim2, ...], <code>gamma</code> and <code>beta</code> parameters must be vectors of shape [channel].</p>
<p>This implementation is based on this paper [1]_</p>
<p>.. [1] Instance Normalization: The Missing Ingredient for Fast Stylization,    D. Ulyanov, A. Vedaldi, V. Lempitsky, 2016 (arXiv:1607.08022v2).</p>
<p>Examples::</p>
<p>// Input of shape (2,1,2)   x = [[[ 1.1,  2.2]],        [[ 3.3,  4.4]]]</p>
<p>// gamma parameter of length 1   gamma = [1.5]</p>
<p>// beta parameter of length 1   beta = [0.5]</p>
<p>// Instance normalization is calculated with the above formula   InstanceNorm(x,gamma,beta) = [[[-0.997527  ,  1.99752665]],                                 [[-0.99752653,  1.99752724]]]</p>
<p>Defined in src/operator/instance_norm.cc:L95</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: An n-dimensional input array (n &gt; 2) of the form [batch, channel, spatial<em>dim1, spatial</em>dim2, ...].</li>
<li><code>gamma::NDArray-or-SymbolicNode</code>: A vector of length 'channel', which multiplies the normalized input.</li>
<li><code>beta::NDArray-or-SymbolicNode</code>: A vector of length 'channel', which is added to the product of the normalized input and the weight.</li>
<li><code>eps::float, optional, default=0.00100000005</code>: An <code>epsilon</code> parameter to prevent division by 0.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L394' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.L2Normalization-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.L2Normalization-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.L2Normalization</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">L2Normalization(data, eps, mode)
</code></pre>

<p>Normalize the input array using the L2 norm.</p>
<p>For 1-D NDArray, it computes::</p>
<p>out = data / sqrt(sum(data ** 2) + eps)</p>
<p>For N-D NDArray, if the input array has shape (N, N, ..., N),</p>
<p>with $mode$ = $instance$, it normalizes each instance in the multidimensional array by its L2 norm.::</p>
<p>for i in 0...N     out[i,:,:,...,:] = data[i,:,:,...,:] / sqrt(sum(data[i,:,:,...,:] ** 2) + eps)</p>
<p>with $mode$ = $channel$, it normalizes each channel in the array by its L2 norm.::</p>
<p>for i in 0...N     out[:,i,:,...,:] = data[:,i,:,...,:] / sqrt(sum(data[:,i,:,...,:] ** 2) + eps)</p>
<p>with $mode$ = $spatial$, it normalizes the cross channel norm for each position in the array by its L2 norm.::</p>
<p>for dim in 2...N     for i in 0...N       out[.....,i,...] = take(out, indices=i, axis=dim) / sqrt(sum(take(out, indices=i, axis=dim) ** 2) + eps)           -dim-</p>
<p>Example::</p>
<p>x = [[[1,2],         [3,4]],        [[2,2],         [5,6]]]</p>
<p>L2Normalization(x, mode='instance')   =[[[ 0.18257418  0.36514837]      [ 0.54772252  0.73029673]]     [[ 0.24077171  0.24077171]      [ 0.60192931  0.72231513]]]</p>
<p>L2Normalization(x, mode='channel')   =[[[ 0.31622776  0.44721359]      [ 0.94868326  0.89442718]]     [[ 0.37139067  0.31622776]      [ 0.92847669  0.94868326]]]</p>
<p>L2Normalization(x, mode='spatial')   =[[[ 0.44721359  0.89442718]      [ 0.60000002  0.80000001]]     [[ 0.70710677  0.70710677]      [ 0.6401844   0.76822126]]]</p>
<p>Defined in src/operator/l2_normalization.cc:L196</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input array to normalize.</li>
<li><code>eps::float, optional, default=1.00000001e-10</code>: A small constant for numerical stability.</li>
<li><code>mode::{'channel', 'instance', 'spatial'},optional, default='instance'</code>: Specify the dimension along which to compute L2 norm.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L405' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.LRN-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.LRN-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.LRN</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">LRN(data, alpha, beta, knorm, nsize)
</code></pre>

<p>Applies local response normalization to the input.</p>
<p>The local response normalization layer performs "lateral inhibition" by normalizing over local input regions.</p>
<p>If :math:<code>a_{x,y}^{i}</code> is the activity of a neuron computed by applying kernel :math:<code>i</code> at position :math:<code>(x, y)</code> and then applying the ReLU nonlinearity, the response-normalized activity :math:<code>b_{x,y}^{i}</code> is given by the expression:</p>
<p>.. math::    b<em x_y="x,y">{x,y}^{i} = \frac{a</em>^{i}}{\Bigg({k + \frac{\alpha}{n} \sum<em x_y="x,y">{j=max(0, i-\frac{n}{2})}^{min(N-1, i+\frac{n}{2})} (a</em>^{j})^{2}}\Bigg)^{\beta}}</p>
<p>where the sum runs over :math:<code>n</code> "adjacent" kernel maps at the same spatial position, and :math:<code>N</code> is the total number of kernels in the layer.</p>
<p>Defined in src/operator/nn/lrn.cc:L158</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data to LRN</li>
<li><code>alpha::float, optional, default=9.99999975e-05</code>: The variance scaling parameter :math:<code>lpha</code> in the LRN expression.</li>
<li><code>beta::float, optional, default=0.75</code>: The power parameter :math:<code>eta</code> in the LRN expression.</li>
<li><code>knorm::float, optional, default=2</code>: The parameter :math:<code>k</code> in the LRN expression.</li>
<li><code>nsize::int (non-negative), required</code>: normalization window width in elements.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L372' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.LayerNorm-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.LayerNorm-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.LayerNorm</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">LayerNorm(data, gamma, beta, axis, eps, output_mean_var)
</code></pre>

<p>Layer normalization.</p>
<p>Normalizes the channels of the input tensor by mean and variance, and applies a scale $gamma$ as well as offset $beta$.</p>
<p>Assume the input has more than one dimension and we normalize along axis 1. We first compute the mean and variance along this axis and then  compute the normalized output, which has the same shape as input, as following:</p>
<p>.. math::</p>
<p>out = \frac{data - mean(data, axis)}{\sqrt{var(data, axis) + \epsilon}} * gamma + beta</p>
<p>Both $gamma$ and $beta$ are learnable parameters.</p>
<p>Unlike BatchNorm and InstanceNorm,  the <em>mean</em> and <em>var</em> are computed along the channel dimension.</p>
<p>Assume the input has size <em>k</em> on axis 1, then both $gamma$ and $beta$ have shape <em>(k,)</em>. If $output_mean_var$ is set to be true, then outputs both $data_mean$ and $data_std$. Note that no gradient will be passed through these two outputs.</p>
<p>The parameter $axis$ specifies which axis of the input shape denotes the 'channel' (separately normalized groups).  The default is -1, which sets the channel axis to be the last item in the input shape.</p>
<p>Defined in src/operator/nn/layer_norm.cc:L158</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data to layer normalization</li>
<li><code>gamma::NDArray-or-SymbolicNode</code>: gamma array</li>
<li><code>beta::NDArray-or-SymbolicNode</code>: beta array</li>
<li><code>axis::int, optional, default='-1'</code>: The axis to perform layer normalization. Usually, this should be be axis of the channel dimension. Negative values means indexing from right to left.</li>
<li><code>eps::float, optional, default=9.99999975e-06</code>: An <code>epsilon</code> parameter to prevent division by 0.</li>
<li><code>output_mean_var::boolean, optional, default=0</code>: Output the mean and std calculated along the given axis.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L384' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.LeakyReLU-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.LeakyReLU-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.LeakyReLU</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">LeakyReLU(data, gamma, act_type, slope, lower_bound, upper_bound)
</code></pre>

<p>Applies Leaky rectified linear unit activation element-wise to the input.</p>
<p>Leaky ReLUs attempt to fix the "dying ReLU" problem by allowing a small <code>slope</code> when the input is negative and has a slope of one when input is positive.</p>
<p>The following modified ReLU Activation functions are supported:</p>
<ul>
<li><em>elu</em>: Exponential Linear Unit. <code>y = x &gt; 0 ? x : slope * (exp(x)-1)</code></li>
<li><em>selu</em>: Scaled Exponential Linear Unit. <code>y = lambda * (x &gt; 0 ? x : alpha * (exp(x) - 1))</code> where <em>lambda = 1.0507009873554804934193349852946</em> and <em>alpha = 1.6732632423543772848170429916717</em>.</li>
<li><em>leaky</em>: Leaky ReLU. <code>y = x &gt; 0 ? x : slope * x</code></li>
<li><em>prelu</em>: Parametric ReLU. This is same as <em>leaky</em> except that <code>slope</code> is learnt during training.</li>
<li><em>rrelu</em>: Randomized ReLU. same as <em>leaky</em> but the <code>slope</code> is uniformly and randomly chosen from <em>[lower</em>bound, upper<em>bound)</em> for training, while fixed to be <em>(lower</em>bound+upper<em>bound)/2</em> for inference.</li>
</ul>
<p>Defined in src/operator/leaky_relu.cc:L161</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data to activation function.</li>
<li><code>gamma::NDArray-or-SymbolicNode</code>: Input data to activation function.</li>
<li><code>act_type::{'elu', 'gelu', 'leaky', 'prelu', 'rrelu', 'selu'},optional, default='leaky'</code>: Activation function to be applied.</li>
<li><code>slope::float, optional, default=0.25</code>: Init slope for the activation. (For leaky and elu only)</li>
<li><code>lower_bound::float, optional, default=0.125</code>: Lower bound of random slope. (For rrelu only)</li>
<li><code>upper_bound::float, optional, default=0.333999991</code>: Upper bound of random slope. (For rrelu only)</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L375' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.LinearRegressionOutput-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.LinearRegressionOutput-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.LinearRegressionOutput</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">LinearRegressionOutput(data, label, grad_scale)
</code></pre>

<p>Computes and optimizes for squared loss during backward propagation. Just outputs $data$ during forward propagation.</p>
<p>If :math:<code>\hat{y}_i</code> is the predicted value of the i-th sample, and :math:<code>y_i</code> is the corresponding target value, then the squared loss estimated over :math:<code>n</code> samples is defined as</p>
<p>:math:<code>\text{SquaredLoss}(\textbf{Y}, \hat{\textbf{Y}} ) = \frac{1}{n} \sum_{i=0}^{n-1} \lVert  \textbf{y}_i - \hat{\textbf{y}}_i  \rVert_2</code></p>
<p>.. note::    Use the LinearRegressionOutput as the final output layer of a net.</p>
<p>The storage type of $label$ can be $default$ or $csr$</p>
<ul>
<li>LinearRegressionOutput(default, default) = default</li>
<li>LinearRegressionOutput(default, csr) = default</li>
</ul>
<p>By default, gradients of this loss function are scaled by factor <code>1/m</code>, where m is the number of regression outputs of a training example. The parameter <code>grad_scale</code> can be used to change this scale to <code>grad_scale/m</code>.</p>
<p>Defined in src/operator/regression_output.cc:L92</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data to the function.</li>
<li><code>label::NDArray-or-SymbolicNode</code>: Input label to the function.</li>
<li><code>grad_scale::float, optional, default=1</code>: Scale the gradient by a float factor</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L372' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.LogisticRegressionOutput-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.LogisticRegressionOutput-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.LogisticRegressionOutput</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">LogisticRegressionOutput(data, label, grad_scale)
</code></pre>

<p>Applies a logistic function to the input.</p>
<p>The logistic function, also known as the sigmoid function, is computed as :math:<code>\frac{1}{1+exp(-\textbf{x})}</code>.</p>
<p>Commonly, the sigmoid is used to squash the real-valued output of a linear model :math:<code>wTx+b</code> into the [0,1] range so that it can be interpreted as a probability. It is suitable for binary classification or probability prediction tasks.</p>
<p>.. note::    Use the LogisticRegressionOutput as the final output layer of a net.</p>
<p>The storage type of $label$ can be $default$ or $csr$</p>
<ul>
<li>LogisticRegressionOutput(default, default) = default</li>
<li>LogisticRegressionOutput(default, csr) = default</li>
</ul>
<p>The loss function used is the Binary Cross Entropy Loss:</p>
<p>:math:<code>-{(y\log(p) + (1 - y)\log(1 - p))}</code></p>
<p>Where <code>y</code> is the ground truth probability of positive outcome for a given example, and <code>p</code> the probability predicted by the model. By default, gradients of this loss function are scaled by factor <code>1/m</code>, where m is the number of regression outputs of a training example. The parameter <code>grad_scale</code> can be used to change this scale to <code>grad_scale/m</code>.</p>
<p>Defined in src/operator/regression_output.cc:L152</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data to the function.</li>
<li><code>label::NDArray-or-SymbolicNode</code>: Input label to the function.</li>
<li><code>grad_scale::float, optional, default=1</code>: Scale the gradient by a float factor</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L377' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.MAERegressionOutput-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.MAERegressionOutput-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.MAERegressionOutput</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">MAERegressionOutput(data, label, grad_scale)
</code></pre>

<p>Computes mean absolute error of the input.</p>
<p>MAE is a risk metric corresponding to the expected value of the absolute error.</p>
<p>If :math:<code>\hat{y}_i</code> is the predicted value of the i-th sample, and :math:<code>y_i</code> is the corresponding target value, then the mean absolute error (MAE) estimated over :math:<code>n</code> samples is defined as</p>
<p>:math:<code>\text{MAE}(\textbf{Y}, \hat{\textbf{Y}} ) = \frac{1}{n} \sum_{i=0}^{n-1} \lVert \textbf{y}_i - \hat{\textbf{y}}_i \rVert_1</code></p>
<p>.. note::    Use the MAERegressionOutput as the final output layer of a net.</p>
<p>The storage type of $label$ can be $default$ or $csr$</p>
<ul>
<li>MAERegressionOutput(default, default) = default</li>
<li>MAERegressionOutput(default, csr) = default</li>
</ul>
<p>By default, gradients of this loss function are scaled by factor <code>1/m</code>, where m is the number of regression outputs of a training example. The parameter <code>grad_scale</code> can be used to change this scale to <code>grad_scale/m</code>.</p>
<p>Defined in src/operator/regression_output.cc:L120</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data to the function.</li>
<li><code>label::NDArray-or-SymbolicNode</code>: Input label to the function.</li>
<li><code>grad_scale::float, optional, default=1</code>: Scale the gradient by a float factor</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L373' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.MakeLoss-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.MakeLoss-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.MakeLoss</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">MakeLoss(data, grad_scale, valid_thresh, normalization)
</code></pre>

<p>Make your own loss function in network construction.</p>
<p>This operator accepts a customized loss function symbol as a terminal loss and the symbol should be an operator with no backward dependency. The output of this function is the gradient of loss with respect to the input data.</p>
<p>For example, if you are a making a cross entropy loss function. Assume $out$ is the predicted output and $label$ is the true label, then the cross entropy can be defined as::</p>
<p>cross<em>entropy = label * log(out) + (1 - label) * log(1 - out)   loss = MakeLoss(cross</em>entropy)</p>
<p>We will need to use $MakeLoss$ when we are creating our own loss function or we want to combine multiple loss functions. Also we may want to stop some variables' gradients from backpropagation. See more detail in $BlockGrad$ or $stop_gradient$.</p>
<p>In addition, we can give a scale to the loss by setting $grad_scale$, so that the gradient of the loss will be rescaled in the backpropagation.</p>
<p>.. note:: This operator should be used as a Symbol instead of NDArray.</p>
<p>Defined in src/operator/make_loss.cc:L71</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input array.</li>
<li><code>grad_scale::float, optional, default=1</code>: Gradient scale as a supplement to unary and binary operators</li>
<li><code>valid_thresh::float, optional, default=0</code>: clip each element in the array to 0 when it is less than $valid_thresh$. This is used when $normalization$ is set to $'valid'$.</li>
<li><code>normalization::{'batch', 'null', 'valid'},optional, default='null'</code>: If this is set to null, the output gradient will not be normalized. If this is set to batch, the output gradient will be divided by the batch size. If this is set to valid, the output gradient will be divided by the number of valid input elements.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L376' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.Pad-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.Pad-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.Pad</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">Pad(data, mode, pad_width, constant_value)
</code></pre>

<p>Pads an input array with a constant or edge values of the array.</p>
<p>.. note:: <code>Pad</code> is deprecated. Use <code>pad</code> instead.</p>
<p>.. note:: Current implementation only supports 4D and 5D input arrays with padding applied    only on axes 1, 2 and 3. Expects axes 4 and 5 in <code>pad_width</code> to be zero.</p>
<p>This operation pads an input array with either a <code>constant_value</code> or edge values along each axis of the input array. The amount of padding is specified by <code>pad_width</code>.</p>
<p><code>pad_width</code> is a tuple of integer padding widths for each axis of the format $(before_1, after_1, ... , before_N, after_N)$. The <code>pad_width</code> should be of length $2*N$ where $N$ is the number of dimensions of the array.</p>
<p>For dimension $N$ of the input array, $before_N$ and $after_N$ indicates how many values to add before and after the elements of the array along dimension $N$. The widths of the higher two dimensions $before_1$, $after_1$, $before_2$, $after_2$ must be 0.</p>
<p>Example::</p>
<p>x = [[[[  1.   2.   3.]           [  4.   5.   6.]]</p>
<pre><code>     [[  7.   8.   9.]
      [ 10.  11.  12.]]]


    [[[ 11.  12.  13.]
      [ 14.  15.  16.]]

     [[ 17.  18.  19.]
      [ 20.  21.  22.]]]]
</code></pre>

<p>pad(x,mode="edge", pad_width=(0,0,0,0,1,1,1,1)) =</p>
<pre><code>     [[[[  1.   1.   2.   3.   3.]
        [  1.   1.   2.   3.   3.]
        [  4.   4.   5.   6.   6.]
        [  4.   4.   5.   6.   6.]]

       [[  7.   7.   8.   9.   9.]
        [  7.   7.   8.   9.   9.]
        [ 10.  10.  11.  12.  12.]
        [ 10.  10.  11.  12.  12.]]]


      [[[ 11.  11.  12.  13.  13.]
        [ 11.  11.  12.  13.  13.]
        [ 14.  14.  15.  16.  16.]
        [ 14.  14.  15.  16.  16.]]

       [[ 17.  17.  18.  19.  19.]
        [ 17.  17.  18.  19.  19.]
        [ 20.  20.  21.  22.  22.]
        [ 20.  20.  21.  22.  22.]]]]
</code></pre>

<p>pad(x, mode="constant", constant<em>value=0, pad</em>width=(0,0,0,0,1,1,1,1)) =</p>
<pre><code>     [[[[  0.   0.   0.   0.   0.]
        [  0.   1.   2.   3.   0.]
        [  0.   4.   5.   6.   0.]
        [  0.   0.   0.   0.   0.]]

       [[  0.   0.   0.   0.   0.]
        [  0.   7.   8.   9.   0.]
        [  0.  10.  11.  12.   0.]
        [  0.   0.   0.   0.   0.]]]


      [[[  0.   0.   0.   0.   0.]
        [  0.  11.  12.  13.   0.]
        [  0.  14.  15.  16.   0.]
        [  0.   0.   0.   0.   0.]]

       [[  0.   0.   0.   0.   0.]
        [  0.  17.  18.  19.   0.]
        [  0.  20.  21.  22.   0.]
        [  0.   0.   0.   0.   0.]]]]
</code></pre>

<p>Defined in src/operator/pad.cc:L766</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: An n-dimensional input array.</li>
<li><code>mode::{'constant', 'edge', 'reflect'}, required</code>: Padding type to use. "constant" pads with <code>constant_value</code> "edge" pads using the edge values of the input array "reflect" pads by reflecting values with respect to the edges.</li>
<li><code>pad_width::Shape(tuple), required</code>: Widths of the padding regions applied to the edges of each axis. It is a tuple of integer padding widths for each axis of the format $(before_1, after_1, ... , before_N, after_N)$. It should be of length $2*N$ where $N$ is the number of dimensions of the array.This is equivalent to pad_width in numpy.pad, but flattened.</li>
<li><code>constant_value::double, optional, default=0</code>: The value used for padding when <code>mode</code> is "constant".</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L436' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.Pooling-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.Pooling-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.Pooling</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">Pooling(data, kernel, pool_type, global_pool, cudnn_off, pooling_convention, stride, pad, p_value, count_include_pad, layout)
</code></pre>

<p>Performs pooling on the input.</p>
<p>The shapes for 1-D pooling are</p>
<ul>
<li><strong>data</strong> and <strong>out</strong>: <em>(batch_size, channel, width)</em> (NCW layout) or <em>(batch_size, width, channel)</em> (NWC layout),</li>
</ul>
<p>The shapes for 2-D pooling are</p>
<ul>
<li>
<p><strong>data</strong> and <strong>out</strong>: <em>(batch_size, channel, height, width)</em> (NCHW layout) or <em>(batch_size, height, width, channel)</em> (NHWC layout),</p>
<p>out<em>height = f(height, kernel[0], pad[0], stride[0])   out</em>width = f(width, kernel[1], pad[1], stride[1])</p>
</li>
</ul>
<p>The definition of <em>f</em> depends on $pooling_convention$, which has two options:</p>
<ul>
<li>
<p><strong>valid</strong> (default)::</p>
<p>f(x, k, p, s) = floor((x+2*p-k)/s)+1
  * <strong>full</strong>, which is compatible with Caffe::</p>
<p>f(x, k, p, s) = ceil((x+2*p-k)/s)+1</p>
</li>
</ul>
<p>When $global_pool$ is set to be true, then global pooling is performed. It will reset $kernel=(height, width)$ and set the appropiate padding to 0.</p>
<p>Three pooling options are supported by $pool_type$:</p>
<ul>
<li><strong>avg</strong>: average pooling</li>
<li><strong>max</strong>: max pooling</li>
<li><strong>sum</strong>: sum pooling</li>
<li><strong>lp</strong>: Lp pooling</li>
</ul>
<p>For 3-D pooling, an additional <em>depth</em> dimension is added before <em>height</em>. Namely the input data and output will have shape <em>(batch_size, channel, depth, height, width)</em> (NCDHW layout) or <em>(batch_size, depth, height, width, channel)</em> (NDHWC layout).</p>
<p>Notes on Lp pooling:</p>
<p>Lp pooling was first introduced by this paper: https://arxiv.org/pdf/1204.3968.pdf. L-1 pooling is simply sum pooling, while L-inf pooling is simply max pooling. We can see that Lp pooling stands between those two, in practice the most common value for p is 2.</p>
<p>For each window $X$, the mathematical expression for Lp pooling is:</p>
<p>:math:<code>f(X) = \sqrt[p]{\sum_{x}^{X} x^p}</code></p>
<p>Defined in src/operator/nn/pooling.cc:L416</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data to the pooling operator.</li>
<li><code>kernel::Shape(tuple), optional, default=[]</code>: Pooling kernel size: (y, x) or (d, y, x)</li>
<li><code>pool_type::{'avg', 'lp', 'max', 'sum'},optional, default='max'</code>: Pooling type to be applied.</li>
<li><code>global_pool::boolean, optional, default=0</code>: Ignore kernel size, do global pooling based on current input feature map.</li>
<li><code>cudnn_off::boolean, optional, default=0</code>: Turn off cudnn pooling and use MXNet pooling operator.</li>
<li><code>pooling_convention::{'full', 'same', 'valid'},optional, default='valid'</code>: Pooling convention to be applied.</li>
<li><code>stride::Shape(tuple), optional, default=[]</code>: Stride: for pooling (y, x) or (d, y, x). Defaults to 1 for each dimension.</li>
<li><code>pad::Shape(tuple), optional, default=[]</code>: Pad for pooling: (y, x) or (d, y, x). Defaults to no padding.</li>
<li><code>p_value::int or None, optional, default='None'</code>: Value of p for Lp pooling, can be 1 or 2, required for Lp Pooling.</li>
<li><code>count_include_pad::boolean or None, optional, default=None</code>: Only used for AvgPool, specify whether to count padding elements for averagecalculation. For example, with a 5<em>5 kernel on a 3</em>3 corner of a image,the sum of the 9 valid elements will be divided by 25 if this is set to true,or it will be divided by 9 if this is set to false. Defaults to true.</li>
<li><code>layout::{None, 'NCDHW', 'NCHW', 'NCW', 'NDHWC', 'NHWC', 'NWC'},optional, default='None'</code>: Set layout for input and output. Empty for   default layout: NCW for 1d, NCHW for 2d and NCDHW for 3d.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L419' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.Pooling_v1-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.Pooling_v1-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.Pooling_v1</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">Pooling_v1(data, kernel, pool_type, global_pool, pooling_convention, stride, pad)
</code></pre>

<p>This operator is DEPRECATED. Perform pooling on the input.</p>
<p>The shapes for 2-D pooling is</p>
<ul>
<li><strong>data</strong>: <em>(batch_size, channel, height, width)</em></li>
<li>
<p><strong>out</strong>: <em>(batch</em>size, num<em>filter, out</em>height, out<em>width)</em>, with::</p>
<p>out<em>height = f(height, kernel[0], pad[0], stride[0])   out</em>width = f(width, kernel[1], pad[1], stride[1])</p>
</li>
</ul>
<p>The definition of <em>f</em> depends on $pooling_convention$, which has two options:</p>
<ul>
<li>
<p><strong>valid</strong> (default)::</p>
<p>f(x, k, p, s) = floor((x+2*p-k)/s)+1
  * <strong>full</strong>, which is compatible with Caffe::</p>
<p>f(x, k, p, s) = ceil((x+2*p-k)/s)+1</p>
</li>
</ul>
<p>But $global_pool$ is set to be true, then do a global pooling, namely reset $kernel=(height, width)$.</p>
<p>Three pooling options are supported by $pool_type$:</p>
<ul>
<li><strong>avg</strong>: average pooling</li>
<li><strong>max</strong>: max pooling</li>
<li><strong>sum</strong>: sum pooling</li>
</ul>
<p>1-D pooling is special case of 2-D pooling with <em>weight=1</em> and <em>kernel[1]=1</em>.</p>
<p>For 3-D pooling, an additional <em>depth</em> dimension is added before <em>height</em>. Namely the input data will have shape <em>(batch_size, channel, depth, height, width)</em>.</p>
<p>Defined in src/operator/pooling_v1.cc:L104</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data to the pooling operator.</li>
<li><code>kernel::Shape(tuple), optional, default=[]</code>: pooling kernel size: (y, x) or (d, y, x)</li>
<li><code>pool_type::{'avg', 'max', 'sum'},optional, default='max'</code>: Pooling type to be applied.</li>
<li><code>global_pool::boolean, optional, default=0</code>: Ignore kernel size, do global pooling based on current input feature map.</li>
<li><code>pooling_convention::{'full', 'valid'},optional, default='valid'</code>: Pooling convention to be applied.</li>
<li><code>stride::Shape(tuple), optional, default=[]</code>: stride: for pooling (y, x) or (d, y, x)</li>
<li><code>pad::Shape(tuple), optional, default=[]</code>: pad for pooling: (y, x) or (d, y, x)</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L398' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.RNN-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.RNN-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.RNN</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">RNN(data, parameters, state, state_cell, sequence_length, state_size, num_layers, bidirectional, mode, p, state_outputs, projection_size, lstm_state_clip_min, lstm_state_clip_max, lstm_state_clip_nan, use_sequence_length)
</code></pre>

<p>Applies recurrent layers to input data. Currently, vanilla RNN, LSTM and GRU are implemented, with both multi-layer and bidirectional support.</p>
<p>When the input data is of type float32 and the environment variables MXNET<em>CUDA</em>ALLOW<em>TENSOR</em>CORE and MXNET<em>CUDA</em>TENSOR<em>OP</em>MATH<em>ALLOW</em>CONVERSION are set to 1, this operator will try to use pseudo-float16 precision (float32 math with float16 I/O) precision in order to use Tensor Cores on suitable NVIDIA GPUs. This can sometimes give significant speedups.</p>
<p><strong>Vanilla RNN</strong></p>
<p>Applies a single-gate recurrent layer to input X. Two kinds of activation function are supported: ReLU and Tanh.</p>
<p>With ReLU activation function:</p>
<p>.. math::     h<em ih="ih">t = relu(W</em> * x<em ih="ih">t + b</em>  +  W<em _t-1_="(t-1)">{hh} * h</em> + b_{hh})</p>
<p>With Tanh activtion function:</p>
<p>.. math::     h<em ih="ih">t = \tanh(W</em> * x<em ih="ih">t + b</em>  +  W<em _t-1_="(t-1)">{hh} * h</em> + b_{hh})</p>
<p>Reference paper: Finding structure in time - Elman, 1988. https://crl.ucsd.edu/~elman/Papers/fsit.pdf</p>
<p><strong>LSTM</strong></p>
<p>Long Short-Term Memory - Hochreiter, 1997. http://www.bioinf.jku.at/publications/older/2604.pdf</p>
<p>.. math::   <script type="math/tex; mode=display">\begin{array}{ll}             i*t = \mathrm{sigmoid}(W*{ii} x*t + b*{ii} + W*{hi} h*{(t-1)} + b*{hi}) \
            f*t = \mathrm{sigmoid}(W*{if} x*t + b*{if} + W*{hf} h*{(t-1)} + b*{hf}) \
            g*t = \tanh(W*{ig} x*t + b*{ig} + W*{hc} h*{(t-1)} + b*{hg}) \
            o*t = \mathrm{sigmoid}(W*{io} x*t + b*{io} + W*{ho} h*{(t-1)} + b*{ho}) \
            c*t = f*t * c*{(t-1)} + i*t * g*t \
            h*t = o*t * \tanh(c*t)             \end{array}</script>
</p>
<p>With the projection size being set, LSTM could use the projection feature to reduce the parameters size and give some speedups without significant damage to the accuracy.</p>
<p>Long Short-Term Memory Based Recurrent Neural Network Architectures for Large Vocabulary Speech Recognition - Sak et al. 2014. https://arxiv.org/abs/1402.1128</p>
<p>.. math::   <script type="math/tex; mode=display">\begin{array}{ll}             i*t = \mathrm{sigmoid}(W*{ii} x*t + b*{ii} + W*{ri} r*{(t-1)} + b*{ri}) \
            f*t = \mathrm{sigmoid}(W*{if} x*t + b*{if} + W*{rf} r*{(t-1)} + b*{rf}) \
            g*t = \tanh(W*{ig} x*t + b*{ig} + W*{rc} r*{(t-1)} + b*{rg}) \
            o*t = \mathrm{sigmoid}(W*{io} x*t + b*{o} + W*{ro} r*{(t-1)} + b*{ro}) \
            c*t = f*t * c*{(t-1)} + i*t * g*t \
            h*t = o*t * \tanh(c*t)             r*t = W*{hr} h_t             \end{array}</script>
</p>
<p><strong>GRU</strong></p>
<p>Gated Recurrent Unit - Cho et al. 2014. http://arxiv.org/abs/1406.1078</p>
<p>The definition of GRU here is slightly different from paper but compatible with CUDNN.</p>
<p>.. math::   <script type="math/tex; mode=display">\begin{array}{ll}             r*t = \mathrm{sigmoid}(W*{ir} x*t + b*{ir} + W*{hr} h*{(t-1)} + b*{hr}) \
            z*t = \mathrm{sigmoid}(W*{iz} x*t + b*{iz} + W*{hz} h*{(t-1)} + b*{hz}) \
            n*t = \tanh(W*{in} x*t + b*{in} + r*t * (W*{hn} h*{(t-1)}+ b*{hn})) \
            h*t = (1 - z*t) * n*t + z*t * h_{(t-1)} \
            \end{array}</script>
</p>
<p>Defined in src/operator/rnn.cc:L368</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data to RNN</li>
<li><code>parameters::NDArray-or-SymbolicNode</code>: Vector of all RNN trainable parameters concatenated</li>
<li><code>state::NDArray-or-SymbolicNode</code>: initial hidden state of the RNN</li>
<li><code>state_cell::NDArray-or-SymbolicNode</code>: initial cell state for LSTM networks (only for LSTM)</li>
<li><code>sequence_length::NDArray-or-SymbolicNode</code>: Vector of valid sequence lengths for each element in batch. (Only used if use<em>sequence</em>length kwarg is True)</li>
<li><code>state_size::int (non-negative), required</code>: size of the state for each layer</li>
<li><code>num_layers::int (non-negative), required</code>: number of stacked layers</li>
<li><code>bidirectional::boolean, optional, default=0</code>: whether to use bidirectional recurrent layers</li>
<li><code>mode::{'gru', 'lstm', 'rnn_relu', 'rnn_tanh'}, required</code>: the type of RNN to compute</li>
<li><code>p::float, optional, default=0</code>: drop rate of the dropout on the outputs of each RNN layer, except the last layer.</li>
<li><code>state_outputs::boolean, optional, default=0</code>: Whether to have the states as symbol outputs.</li>
<li><code>projection_size::int or None, optional, default='None'</code>: size of project size</li>
<li><code>lstm_state_clip_min::double or None, optional, default=None</code>: Minimum clip value of LSTM states. This option must be used together with lstm<em>state</em>clip_max.</li>
<li><code>lstm_state_clip_max::double or None, optional, default=None</code>: Maximum clip value of LSTM states. This option must be used together with lstm<em>state</em>clip_min.</li>
<li><code>lstm_state_clip_nan::boolean, optional, default=0</code>: Whether to stop NaN from propagating in state by clipping it to min/max. If clipping range is not specified, this option is ignored.</li>
<li><code>use_sequence_length::boolean, optional, default=0</code>: If set to true, this layer takes in an extra input parameter <code>sequence_length</code> to specify variable length sequence</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L449' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.ROIPooling-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.ROIPooling-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.ROIPooling</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">ROIPooling(data, rois, pooled_size, spatial_scale)
</code></pre>

<p>Performs region of interest(ROI) pooling on the input array.</p>
<p>ROI pooling is a variant of a max pooling layer, in which the output size is fixed and region of interest is a parameter. Its purpose is to perform max pooling on the inputs of non-uniform sizes to obtain fixed-size feature maps. ROI pooling is a neural-net layer mostly used in training a <code>Fast R-CNN</code> network for object detection.</p>
<p>This operator takes a 4D feature map as an input array and region proposals as <code>rois</code>, then it pools over sub-regions of input and produces a fixed-sized output array regardless of the ROI size.</p>
<p>To crop the feature map accordingly, you can resize the bounding box coordinates by changing the parameters <code>rois</code> and <code>spatial_scale</code>.</p>
<p>The cropped feature maps are pooled by standard max pooling operation to a fixed size output indicated by a <code>pooled_size</code> parameter. batch_size will change to the number of region bounding boxes after <code>ROIPooling</code>.</p>
<p>The size of each region of interest doesn't have to be perfectly divisible by the number of pooling sections(<code>pooled_size</code>).</p>
<p>Example::</p>
<p>x = [[[[  0.,   1.,   2.,   3.,   4.,   5.],          [  6.,   7.,   8.,   9.,  10.,  11.],          [ 12.,  13.,  14.,  15.,  16.,  17.],          [ 18.,  19.,  20.,  21.,  22.,  23.],          [ 24.,  25.,  26.,  27.,  28.,  29.],          [ 30.,  31.,  32.,  33.,  34.,  35.],          [ 36.,  37.,  38.,  39.,  40.,  41.],          [ 42.,  43.,  44.,  45.,  46.,  47.]]]]</p>
<p>// region of interest i.e. bounding box coordinates.   y = [[0,0,0,4,4]]</p>
<p>// returns array of shape (2,2) according to the given roi with max pooling.   ROIPooling(x, y, (2,2), 1.0) = [[[[ 14.,  16.],                                     [ 26.,  28.]]]]</p>
<p>// region of interest is changed due to the change in <code>spacial_scale</code> parameter.   ROIPooling(x, y, (2,2), 0.7) = [[[[  7.,   9.],                                     [ 19.,  21.]]]]</p>
<p>Defined in src/operator/roi_pooling.cc:L225</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array to the pooling operator,  a 4D Feature maps</li>
<li><code>rois::NDArray-or-SymbolicNode</code>: Bounding box coordinates, a 2D array of [[batch*index, x1, y1, x2, y2]], where (x1, y1) and (x2, y2) are top left and bottom right corners of designated region of interest. <code>batch*index</code> indicates the index of corresponding image in the input array</li>
<li><code>pooled_size::Shape(tuple), required</code>: ROI pooling output shape (h,w)</li>
<li><code>spatial_scale::float, required</code>: Ratio of input feature map height (or w) to raw image height (or w). Equals the reciprocal of total stride in convolutional layers</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L398' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.SVMOutput-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.SVMOutput-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.SVMOutput</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">SVMOutput(data, label, margin, regularization_coefficient, use_linear)
</code></pre>

<p>Computes support vector machine based transformation of the input.</p>
<p>This tutorial demonstrates using SVM as output layer for classification instead of softmax: https://github.com/dmlc/mxnet/tree/master/example/svm_mnist.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data for SVM transformation.</li>
<li><code>label::NDArray-or-SymbolicNode</code>: Class label for the input data.</li>
<li><code>margin::float, optional, default=1</code>: The loss function penalizes outputs that lie outside this margin. Default margin is 1.</li>
<li><code>regularization_coefficient::float, optional, default=1</code>: Regularization parameter for the SVM. This balances the tradeoff between coefficient size and error.</li>
<li><code>use_linear::boolean, optional, default=0</code>: Whether to use L1-SVM objective. L2-SVM objective is used by default.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L360' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.SequenceLast-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.SequenceLast-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.SequenceLast</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">SequenceLast(data, sequence_length, use_sequence_length, axis)
</code></pre>

<p>Takes the last element of a sequence.</p>
<p>This function takes an n-dimensional input array of the form [max<em>sequence</em>length, batch<em>size, other</em>feature<em>dims] and returns a (n-1)-dimensional array of the form [batch</em>size, other<em>feature</em>dims].</p>
<p>Parameter <code>sequence_length</code> is used to handle variable-length sequences. <code>sequence_length</code> should be an input array of positive ints of dimension [batch*size]. To use this parameter, set <code>use*sequence_length</code>to<code>True</code>, otherwise each example in the batch is assumed to have the max sequence length.</p>
<p>.. note:: Alternatively, you can also use <code>take</code> operator.</p>
<p>Example::</p>
<p>x = [[[  1.,   2.,   3.],          [  4.,   5.,   6.],          [  7.,   8.,   9.]],</p>
<pre><code>    [[ 10.,   11.,   12.],
     [ 13.,   14.,   15.],
     [ 16.,   17.,   18.]],

    [[  19.,   20.,   21.],
     [  22.,   23.,   24.],
     [  25.,   26.,   27.]]]
</code></pre>

<p>// returns last sequence when sequence_length parameter is not used    SequenceLast(x) = [[  19.,   20.,   21.],                       [  22.,   23.,   24.],                       [  25.,   26.,   27.]]</p>
<p>// sequence<em>length is used    SequenceLast(x, sequence</em>length=[1,1,1], use<em>sequence</em>length=True) =             [[  1.,   2.,   3.],              [  4.,   5.,   6.],              [  7.,   8.,   9.]]</p>
<p>// sequence<em>length is used    SequenceLast(x, sequence</em>length=[1,2,3], use<em>sequence</em>length=True) =             [[  1.,    2.,   3.],              [  13.,  14.,  15.],              [  25.,  26.,  27.]]</p>
<p>Defined in src/operator/sequence_last.cc:L106</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: n-dimensional input array of the form [max<em>sequence</em>length, batch<em>size, other</em>feature_dims] where n&gt;2</li>
<li><code>sequence_length::NDArray-or-SymbolicNode</code>: vector of sequence lengths of the form [batch_size]</li>
<li><code>use_sequence_length::boolean, optional, default=0</code>: If set to true, this layer takes in an extra input parameter <code>sequence_length</code> to specify variable length sequence</li>
<li><code>axis::int, optional, default='0'</code>: The sequence axis. Only values of 0 and 1 are currently supported.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L399' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.SequenceMask-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.SequenceMask-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.SequenceMask</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">SequenceMask(data, sequence_length, use_sequence_length, value, axis)
</code></pre>

<p>Sets all elements outside the sequence to a constant value.</p>
<p>This function takes an n-dimensional input array of the form [max<em>sequence</em>length, batch<em>size, other</em>feature_dims] and returns an array of the same shape.</p>
<p>Parameter <code>sequence_length</code> is used to handle variable-length sequences. <code>sequence_length</code> should be an input array of positive ints of dimension [batch*size]. To use this parameter, set <code>use*sequence_length</code>to<code>True</code>, otherwise each example in the batch is assumed to have the max sequence length and this operator works as the<code>identity</code> operator.</p>
<p>Example::</p>
<p>x = [[[  1.,   2.,   3.],          [  4.,   5.,   6.]],</p>
<pre><code>    [[  7.,   8.,   9.],
     [ 10.,  11.,  12.]],

    [[ 13.,  14.,   15.],
     [ 16.,  17.,   18.]]]
</code></pre>

<p>// Batch 1    B1 = [[  1.,   2.,   3.],          [  7.,   8.,   9.],          [ 13.,  14.,  15.]]</p>
<p>// Batch 2    B2 = [[  4.,   5.,   6.],          [ 10.,  11.,  12.],          [ 16.,  17.,  18.]]</p>
<p>// works as identity operator when sequence_length parameter is not used    SequenceMask(x) = [[[  1.,   2.,   3.],                        [  4.,   5.,   6.]],</p>
<pre><code>                  [[  7.,   8.,   9.],
                   [ 10.,  11.,  12.]],

                  [[ 13.,  14.,   15.],
                   [ 16.,  17.,   18.]]]
</code></pre>

<p>// sequence<em>length [1,1] means 1 of each batch will be kept    // and other rows are masked with default mask value = 0    SequenceMask(x, sequence</em>length=[1,1], use<em>sequence</em>length=True) =                 [[[  1.,   2.,   3.],                   [  4.,   5.,   6.]],</p>
<pre><code>             [[  0.,   0.,   0.],
              [  0.,   0.,   0.]],

             [[  0.,   0.,   0.],
              [  0.,   0.,   0.]]]
</code></pre>

<p>// sequence<em>length [2,3] means 2 of batch B1 and 3 of batch B2 will be kept    // and other rows are masked with value = 1    SequenceMask(x, sequence</em>length=[2,3], use<em>sequence</em>length=True, value=1) =                 [[[  1.,   2.,   3.],                   [  4.,   5.,   6.]],</p>
<pre><code>             [[  7.,   8.,   9.],
              [  10.,  11.,  12.]],

             [[   1.,   1.,   1.],
              [  16.,  17.,  18.]]]
</code></pre>

<p>Defined in src/operator/sequence_mask.cc:L186</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: n-dimensional input array of the form [max<em>sequence</em>length, batch<em>size, other</em>feature_dims] where n&gt;2</li>
<li><code>sequence_length::NDArray-or-SymbolicNode</code>: vector of sequence lengths of the form [batch_size]</li>
<li><code>use_sequence_length::boolean, optional, default=0</code>: If set to true, this layer takes in an extra input parameter <code>sequence_length</code> to specify variable length sequence</li>
<li><code>value::float, optional, default=0</code>: The value to be used as a mask.</li>
<li><code>axis::int, optional, default='0'</code>: The sequence axis. Only values of 0 and 1 are currently supported.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L423' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.SequenceReverse-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.SequenceReverse-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.SequenceReverse</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">SequenceReverse(data, sequence_length, use_sequence_length, axis)
</code></pre>

<p>Reverses the elements of each sequence.</p>
<p>This function takes an n-dimensional input array of the form [max<em>sequence</em>length, batch<em>size, other</em>feature_dims] and returns an array of the same shape.</p>
<p>Parameter <code>sequence_length</code> is used to handle variable-length sequences. <code>sequence_length</code> should be an input array of positive ints of dimension [batch*size]. To use this parameter, set <code>use*sequence_length</code>to<code>True</code>, otherwise each example in the batch is assumed to have the max sequence length.</p>
<p>Example::</p>
<p>x = [[[  1.,   2.,   3.],          [  4.,   5.,   6.]],</p>
<pre><code>    [[  7.,   8.,   9.],
     [ 10.,  11.,  12.]],

    [[ 13.,  14.,   15.],
     [ 16.,  17.,   18.]]]
</code></pre>

<p>// Batch 1    B1 = [[  1.,   2.,   3.],          [  7.,   8.,   9.],          [ 13.,  14.,  15.]]</p>
<p>// Batch 2    B2 = [[  4.,   5.,   6.],          [ 10.,  11.,  12.],          [ 16.,  17.,  18.]]</p>
<p>// returns reverse sequence when sequence_length parameter is not used    SequenceReverse(x) = [[[ 13.,  14.,   15.],                           [ 16.,  17.,   18.]],</p>
<pre><code>                     [[  7.,   8.,   9.],
                      [ 10.,  11.,  12.]],

                     [[  1.,   2.,   3.],
                      [  4.,   5.,   6.]]]
</code></pre>

<p>// sequence<em>length [2,2] means 2 rows of    // both batch B1 and B2 will be reversed.    SequenceReverse(x, sequence</em>length=[2,2], use<em>sequence</em>length=True) =                      [[[  7.,   8.,   9.],                        [ 10.,  11.,  12.]],</p>
<pre><code>                  [[  1.,   2.,   3.],
                   [  4.,   5.,   6.]],

                  [[ 13.,  14.,   15.],
                   [ 16.,  17.,   18.]]]
</code></pre>

<p>// sequence<em>length [2,3] means 2 of batch B2 and 3 of batch B3    // will be reversed.    SequenceReverse(x, sequence</em>length=[2,3], use<em>sequence</em>length=True) =                     [[[  7.,   8.,   9.],                       [ 16.,  17.,  18.]],</p>
<pre><code>                 [[  1.,   2.,   3.],
                  [ 10.,  11.,  12.]],

                 [[ 13.,  14,   15.],
                  [  4.,   5.,   6.]]]
</code></pre>

<p>Defined in src/operator/sequence_reverse.cc:L122</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: n-dimensional input array of the form [max<em>sequence</em>length, batch_size, other dims] where n&gt;2</li>
<li><code>sequence_length::NDArray-or-SymbolicNode</code>: vector of sequence lengths of the form [batch_size]</li>
<li><code>use_sequence_length::boolean, optional, default=0</code>: If set to true, this layer takes in an extra input parameter <code>sequence_length</code> to specify variable length sequence</li>
<li><code>axis::int, optional, default='0'</code>: The sequence axis. Only 0 is currently supported.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L420' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.SliceChannel-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.SliceChannel-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.SliceChannel</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">SliceChannel(data, num_outputs, axis, squeeze_axis)
</code></pre>

<p>Splits an array along a particular axis into multiple sub-arrays.</p>
<p>.. note:: $SliceChannel$ is deprecated. Use $split$ instead.</p>
<p><strong>Note</strong> that <code>num_outputs</code> should evenly divide the length of the axis along which to split the array.</p>
<p>Example::</p>
<p>x  = [[[ 1.]           [ 2.]]          [[ 3.]           [ 4.]]          [[ 5.]           [ 6.]]]    x.shape = (3, 2, 1)</p>
<p>y = split(x, axis=1, num_outputs=2) // a list of 2 arrays with shape (3, 1, 1)    y = [[[ 1.]]         [[ 3.]]         [[ 5.]]]</p>
<pre><code>   [[[ 2.]]
    [[ 4.]]
    [[ 6.]]]
</code></pre>

<p>y[0].shape = (3, 1, 1)</p>
<p>z = split(x, axis=0, num_outputs=3) // a list of 3 arrays with shape (1, 2, 1)    z = [[[ 1.]          [ 2.]]]</p>
<pre><code>   [[[ 3.]
     [ 4.]]]

   [[[ 5.]
     [ 6.]]]
</code></pre>

<p>z[0].shape = (1, 2, 1)</p>
<p><code>squeeze_axis=1</code> removes the axis with length 1 from the shapes of the output arrays. <strong>Note</strong> that setting <code>squeeze_axis</code> to $1$ removes axis with length 1 only along the <code>axis</code> which it is split. Also <code>squeeze_axis</code> can be set to true only if $input.shape[axis] == num_outputs$.</p>
<p>Example::</p>
<p>z = split(x, axis=0, num<em>outputs=3, squeeze</em>axis=1) // a list of 3 arrays with shape (2, 1)    z = [[ 1.]         [ 2.]]</p>
<pre><code>   [[ 3.]
    [ 4.]]

   [[ 5.]
    [ 6.]]
</code></pre>

<p>z[0].shape = (2 ,1 )</p>
<p>Defined in src/operator/slice_channel.cc:L107</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input</li>
<li><code>num_outputs::int, required</code>: Number of splits. Note that this should evenly divide the length of the <code>axis</code>.</li>
<li><code>axis::int, optional, default='1'</code>: Axis along which to split.</li>
<li><code>squeeze_axis::boolean, optional, default=0</code>: If true, Removes the axis with length 1 from the shapes of the output arrays. <strong>Note</strong> that setting <code>squeeze_axis</code> to $true$ removes axis with length 1 only along the <code>axis</code> which it is split. Also <code>squeeze_axis</code> can be set to $true$ only if $input.shape[axis] == num_outputs$.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L413' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.Softmax-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.Softmax-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.Softmax</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">Softmax(data, label, grad_scale, ignore_label, multi_output, use_ignore, preserve_shape, normalization, out_grad, smooth_alpha)
</code></pre>

<p>Softmax is an alias of SoftmaxOutput.</p>
<p>Computes the gradient of cross entropy loss with respect to softmax output.</p>
<ul>
<li>
<p>This operator computes the gradient in two steps. The cross entropy loss does not actually need to be computed.</p>
<ul>
<li>Applies softmax function on the input array.</li>
<li>Computes and returns the gradient of cross entropy loss w.r.t. the softmax output.</li>
<li>
<p>The softmax function, cross entropy loss and gradient is given by:</p>
</li>
<li>
<p>Softmax Function:</p>
<p>.. math:: \text{softmax}(x)<em>i = \frac{exp(x</em>i)}{\sum<em>j exp(x</em>j)}
      * Cross Entropy Function:</p>
<p>.. math:: \text{CE(label, output)} = - \sum<em>i \text{label}</em>i \log(\text{output}_i)
      * The gradient of cross entropy loss w.r.t softmax output:</p>
<p>.. math:: \text{gradient} = \text{output} - \text{label}
  * During forward propagation, the softmax function is computed for each instance in the input array.</p>
</li>
</ul>
<p>For general <em>N</em>-D input arrays with shape :math:<code>(d_1, d_2, ..., d_n)</code>. The size is :math:<code>s=d_1 \cdot d_2 \cdot \cdot \cdot d_n</code>. We can use the parameters <code>preserve_shape</code> and <code>multi_output</code> to specify the way to compute softmax:</p>
<ul>
<li>By default, <code>preserve_shape</code> is $false$. This operator will reshape the input array into a 2-D array with shape :math:<code>(d_1, \frac{s}{d_1})</code> and then compute the softmax function for each row in the reshaped array, and afterwards reshape it back to the original shape :math:<code>(d_1, d_2, ..., d_n)</code>.</li>
<li>If <code>preserve_shape</code> is $true$, the softmax function will be computed along the last axis (<code>axis</code> = $-1$).</li>
<li>If <code>multi_output</code> is $true$, the softmax function will be computed along the second axis (<code>axis</code> = $1$).</li>
<li>
<p>During backward propagation, the gradient of cross-entropy loss w.r.t softmax output array is computed. The provided label can be a one-hot label array or a probability label array.</p>
</li>
<li>
<p>If the parameter <code>use_ignore</code> is $true$, <code>ignore_label</code> can specify input instances with a particular label to be ignored during backward propagation. <strong>This has no effect when softmax <code>output</code> has same shape as <code>label</code></strong>.</p>
<p>Example::</p>
<p>data = [[1,2,3,4],[2,2,2,2],[3,3,3,3],[4,4,4,4]]   label = [1,0,2,3]   ignore<em>label = 1   SoftmaxOutput(data=data, label = label,
                multi</em>output=true, use<em>ignore=true,
                ignore</em>label=ignore_label)</p>
<h2 id="forward-softmax-output">forward softmax output</h2>
<p>[[ 0.0320586   0.08714432  0.23688284  0.64391428]    [ 0.25        0.25        0.25        0.25      ]    [ 0.25        0.25        0.25        0.25      ]    [ 0.25        0.25        0.25        0.25      ]]</p>
<h2 id="backward-gradient-output">backward gradient output</h2>
<p>[[ 0.    0.    0.    0.  ]    [-0.75  0.25  0.25  0.25]    [ 0.25  0.25 -0.75  0.25]    [ 0.25  0.25  0.25 -0.75]]</p>
<h2 id="notice-that-the-first-row-is-all-0-because-label0-is-1-which-is-equal-to-ignore_label">notice that the first row is all 0 because label[0] is 1, which is equal to ignore_label.</h2>
<pre><code>  * The parameter `grad_scale` can be used to rescale the gradient, which is often used to give each loss function different weights.
  * This operator also supports various ways to normalize the gradient by `normalization`, The `normalization` is applied if softmax output has different shape than the labels. The `normalization` mode can be set to the followings:
</code></pre>
<ul>
<li>$'null'$: do nothing.</li>
<li>$'batch'$: divide the gradient by the batch size.</li>
<li>$'valid'$: divide the gradient by the number of instances which are not ignored.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Defined in src/operator/softmax_output.cc:L231</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input array.</li>
<li><code>label::NDArray-or-SymbolicNode</code>: Ground truth label.</li>
<li><code>grad_scale::float, optional, default=1</code>: Scales the gradient by a float factor.</li>
<li><code>ignore_label::float, optional, default=-1</code>: The instances whose <code>labels</code> == <code>ignore_label</code> will be ignored during backward, if <code>use_ignore</code> is set to $true$).</li>
<li><code>multi_output::boolean, optional, default=0</code>: If set to $true$, the softmax function will be computed along axis $1$. This is applied when the shape of input array differs from the shape of label array.</li>
<li><code>use_ignore::boolean, optional, default=0</code>: If set to $true$, the <code>ignore_label</code> value will not contribute to the backward gradient.</li>
<li><code>preserve_shape::boolean, optional, default=0</code>: If set to $true$, the softmax function will be computed along the last axis ($-1$).</li>
<li><code>normalization::{'batch', 'null', 'valid'},optional, default='null'</code>: Normalizes the gradient.</li>
<li><code>out_grad::boolean, optional, default=0</code>: Multiplies gradient with output gradient element-wise.</li>
<li><code>smooth_alpha::float, optional, default=0</code>: Constant for computing a label smoothed version of cross-entropyfor the backwards pass.  This constant gets subtracted from theone-hot encoding of the gold label and distributed uniformly toall other labels.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L444' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.SoftmaxActivation-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.SoftmaxActivation-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.SoftmaxActivation</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">SoftmaxActivation(data, mode)
</code></pre>

<p>Applies softmax activation to input. This is intended for internal layers.</p>
<p>.. note::</p>
<p>This operator has been deprecated, please use <code>softmax</code>.</p>
<p>If <code>mode</code> = $instance$, this operator will compute a softmax for each instance in the batch. This is the default mode.</p>
<p>If <code>mode</code> = $channel$, this operator will compute a k-class softmax at each position of each instance, where <code>k</code> = $num_channel$. This mode can only be used when the input array has at least 3 dimensions. This can be used for <code>fully convolutional network</code>, <code>image segmentation</code>, etc.</p>
<p>Example::</p>
<blockquote>
<blockquote>
<blockquote>
<p>input<em>array = mx.nd.array([[3., 0.5, -0.5, 2., 7.],                            [2., -.4, 7.,   3., 0.2]]) softmax</em>act = mx.nd.SoftmaxActivation(input<em>array) print softmax</em>act.asnumpy()</p>
</blockquote>
</blockquote>
</blockquote>
<p>[[  1.78322066e-02   1.46375655e-03   5.38485940e-04   6.56010211e-03   9.73605454e-01]    [  6.56221947e-03   5.95310994e-04   9.73919690e-01   1.78379621e-02   1.08472735e-03]]</p>
<p>Defined in src/operator/nn/softmax_activation.cc:L59</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>mode::{'channel', 'instance'},optional, default='instance'</code>: Specifies how to compute the softmax. If set to $instance$, it computes softmax for each instance. If set to $channel$, It computes cross channel softmax for each position of each instance.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L374' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.SoftmaxOutput-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.SoftmaxOutput-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.SoftmaxOutput</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">SoftmaxOutput(data, label, grad_scale, ignore_label, multi_output, use_ignore, preserve_shape, normalization, out_grad, smooth_alpha)
</code></pre>

<p>Computes the gradient of cross entropy loss with respect to softmax output.</p>
<ul>
<li>
<p>This operator computes the gradient in two steps. The cross entropy loss does not actually need to be computed.</p>
<ul>
<li>Applies softmax function on the input array.</li>
<li>Computes and returns the gradient of cross entropy loss w.r.t. the softmax output.</li>
<li>
<p>The softmax function, cross entropy loss and gradient is given by:</p>
</li>
<li>
<p>Softmax Function:</p>
<p>.. math:: \text{softmax}(x)<em>i = \frac{exp(x</em>i)}{\sum<em>j exp(x</em>j)}
      * Cross Entropy Function:</p>
<p>.. math:: \text{CE(label, output)} = - \sum<em>i \text{label}</em>i \log(\text{output}_i)
      * The gradient of cross entropy loss w.r.t softmax output:</p>
<p>.. math:: \text{gradient} = \text{output} - \text{label}
  * During forward propagation, the softmax function is computed for each instance in the input array.</p>
</li>
</ul>
<p>For general <em>N</em>-D input arrays with shape :math:<code>(d_1, d_2, ..., d_n)</code>. The size is :math:<code>s=d_1 \cdot d_2 \cdot \cdot \cdot d_n</code>. We can use the parameters <code>preserve_shape</code> and <code>multi_output</code> to specify the way to compute softmax:</p>
<ul>
<li>By default, <code>preserve_shape</code> is $false$. This operator will reshape the input array into a 2-D array with shape :math:<code>(d_1, \frac{s}{d_1})</code> and then compute the softmax function for each row in the reshaped array, and afterwards reshape it back to the original shape :math:<code>(d_1, d_2, ..., d_n)</code>.</li>
<li>If <code>preserve_shape</code> is $true$, the softmax function will be computed along the last axis (<code>axis</code> = $-1$).</li>
<li>If <code>multi_output</code> is $true$, the softmax function will be computed along the second axis (<code>axis</code> = $1$).</li>
<li>
<p>During backward propagation, the gradient of cross-entropy loss w.r.t softmax output array is computed. The provided label can be a one-hot label array or a probability label array.</p>
</li>
<li>
<p>If the parameter <code>use_ignore</code> is $true$, <code>ignore_label</code> can specify input instances with a particular label to be ignored during backward propagation. <strong>This has no effect when softmax <code>output</code> has same shape as <code>label</code></strong>.</p>
<p>Example::</p>
<p>data = [[1,2,3,4],[2,2,2,2],[3,3,3,3],[4,4,4,4]]   label = [1,0,2,3]   ignore<em>label = 1   SoftmaxOutput(data=data, label = label,
                multi</em>output=true, use<em>ignore=true,
                ignore</em>label=ignore_label)</p>
<h2 id="forward-softmax-output_1">forward softmax output</h2>
<p>[[ 0.0320586   0.08714432  0.23688284  0.64391428]    [ 0.25        0.25        0.25        0.25      ]    [ 0.25        0.25        0.25        0.25      ]    [ 0.25        0.25        0.25        0.25      ]]</p>
<h2 id="backward-gradient-output_1">backward gradient output</h2>
<p>[[ 0.    0.    0.    0.  ]    [-0.75  0.25  0.25  0.25]    [ 0.25  0.25 -0.75  0.25]    [ 0.25  0.25  0.25 -0.75]]</p>
<h2 id="notice-that-the-first-row-is-all-0-because-label0-is-1-which-is-equal-to-ignore_label_1">notice that the first row is all 0 because label[0] is 1, which is equal to ignore_label.</h2>
<pre><code>  * The parameter `grad_scale` can be used to rescale the gradient, which is often used to give each loss function different weights.
  * This operator also supports various ways to normalize the gradient by `normalization`, The `normalization` is applied if softmax output has different shape than the labels. The `normalization` mode can be set to the followings:
</code></pre>
<ul>
<li>$'null'$: do nothing.</li>
<li>$'batch'$: divide the gradient by the batch size.</li>
<li>$'valid'$: divide the gradient by the number of instances which are not ignored.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Defined in src/operator/softmax_output.cc:L231</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input array.</li>
<li><code>label::NDArray-or-SymbolicNode</code>: Ground truth label.</li>
<li><code>grad_scale::float, optional, default=1</code>: Scales the gradient by a float factor.</li>
<li><code>ignore_label::float, optional, default=-1</code>: The instances whose <code>labels</code> == <code>ignore_label</code> will be ignored during backward, if <code>use_ignore</code> is set to $true$).</li>
<li><code>multi_output::boolean, optional, default=0</code>: If set to $true$, the softmax function will be computed along axis $1$. This is applied when the shape of input array differs from the shape of label array.</li>
<li><code>use_ignore::boolean, optional, default=0</code>: If set to $true$, the <code>ignore_label</code> value will not contribute to the backward gradient.</li>
<li><code>preserve_shape::boolean, optional, default=0</code>: If set to $true$, the softmax function will be computed along the last axis ($-1$).</li>
<li><code>normalization::{'batch', 'null', 'valid'},optional, default='null'</code>: Normalizes the gradient.</li>
<li><code>out_grad::boolean, optional, default=0</code>: Multiplies gradient with output gradient element-wise.</li>
<li><code>smooth_alpha::float, optional, default=0</code>: Constant for computing a label smoothed version of cross-entropyfor the backwards pass.  This constant gets subtracted from theone-hot encoding of the gold label and distributed uniformly toall other labels.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L442' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.SpatialTransformer-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.SpatialTransformer-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.SpatialTransformer</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">SpatialTransformer(data, loc, target_shape, transform_type, sampler_type, cudnn_off)
</code></pre>

<p>Applies a spatial transformer to input feature map.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data to the SpatialTransformerOp.</li>
<li><code>loc::NDArray-or-SymbolicNode</code>: localisation net, the output dim should be 6 when transform_type is affine. You shold initialize the weight and bias with identity tranform.</li>
<li><code>target_shape::Shape(tuple), optional, default=[0,0]</code>: output shape(h, w) of spatial transformer: (y, x)</li>
<li><code>transform_type::{'affine'}, required</code>: transformation type</li>
<li><code>sampler_type::{'bilinear'}, required</code>: sampling type</li>
<li><code>cudnn_off::boolean or None, optional, default=None</code>: whether to turn cudnn off</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L357' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.SwapAxis-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.SwapAxis-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.SwapAxis</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">SwapAxis(data, dim1, dim2)
</code></pre>

<p>Interchanges two axes of an array.</p>
<p>Examples::</p>
<p>x = [[1, 2, 3]])   swapaxes(x, 0, 1) = [[ 1],                        [ 2],                        [ 3]]</p>
<p>x = [[[ 0, 1],         [ 2, 3]],        [[ 4, 5],         [ 6, 7]]]  // (2,2,2) array</p>
<p>swapaxes(x, 0, 2) = [[[ 0, 4],                        [ 2, 6]],                       [[ 1, 5],                        [ 3, 7]]]</p>
<p>Defined in src/operator/swapaxis.cc:L70</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input array.</li>
<li><code>dim1::int, optional, default='0'</code>: the first axis to be swapped.</li>
<li><code>dim2::int, optional, default='0'</code>: the second axis to be swapped.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L371' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.UpSampling-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.UpSampling-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.UpSampling</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">UpSampling(data, scale, num_filter, sample_type, multi_input_mode, num_args, workspace)
</code></pre>

<p><strong>Note</strong>: UpSampling takes variable number of positional inputs. So instead of calling as UpSampling([x, y, z], num<em>args=3), one should call via UpSampling(x, y, z), and num</em>args will be determined automatically.</p>
<p>Upsamples the given input data.</p>
<p>Two algorithms ($sample_type$) are available for upsampling:</p>
<ul>
<li>Nearest Neighbor</li>
<li>Bilinear</li>
</ul>
<p><strong>Nearest Neighbor Upsampling</strong></p>
<p>Input data is expected to be NCHW.</p>
<p>Example::</p>
<p>x = [[[[1. 1. 1.]          [1. 1. 1.]          [1. 1. 1.]]]]</p>
<p>UpSampling(x, scale=2, sample_type='nearest') = [[[[1. 1. 1. 1. 1. 1.]                                                      [1. 1. 1. 1. 1. 1.]                                                      [1. 1. 1. 1. 1. 1.]                                                      [1. 1. 1. 1. 1. 1.]                                                      [1. 1. 1. 1. 1. 1.]                                                      [1. 1. 1. 1. 1. 1.]]]]</p>
<p><strong>Bilinear Upsampling</strong></p>
<p>Uses <code>deconvolution</code> algorithm under the hood. You need provide both input data and the kernel.</p>
<p>Input data is expected to be NCHW.</p>
<p><code>num_filter</code> is expected to be same as the number of channels.</p>
<p>Example::</p>
<p>x = [[[[1. 1. 1.]          [1. 1. 1.]          [1. 1. 1.]]]]</p>
<p>w = [[[[1. 1. 1. 1.]          [1. 1. 1. 1.]          [1. 1. 1. 1.]          [1. 1. 1. 1.]]]]</p>
<p>UpSampling(x, w, scale=2, sample<em>type='bilinear', num</em>filter=1) = [[[[1. 2. 2. 2. 2. 1.]                                                                        [2. 4. 4. 4. 4. 2.]                                                                        [2. 4. 4. 4. 4. 2.]                                                                        [2. 4. 4. 4. 4. 2.]                                                                        [2. 4. 4. 4. 4. 2.]                                                                        [1. 2. 2. 2. 2. 1.]]]]</p>
<p>Defined in src/operator/nn/upsampling.cc:L173</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode[]</code>: Array of tensors to upsample. For bilinear upsampling, there should be 2 inputs - 1 data and 1 weight.</li>
<li><code>scale::int, required</code>: Up sampling scale</li>
<li><code>num_filter::int, optional, default='0'</code>: Input filter. Only used by bilinear sample<em>type.Since bilinear upsampling uses deconvolution, num</em>filters is set to the number of channels.</li>
<li><code>sample_type::{'bilinear', 'nearest'}, required</code>: upsampling method</li>
<li><code>multi_input_mode::{'concat', 'sum'},optional, default='concat'</code>: How to handle multiple input. concat means concatenate upsampled images along the channel dimension. sum means add all images together, only available for nearest neighbor upsampling.</li>
<li><code>num_args::int, required</code>: Number of inputs to be upsampled. For nearest neighbor upsampling, this can be 1-N; the size of output will be(scale<em>h_0,scale</em>w_0) and all other inputs will be upsampled to thesame size. For bilinear upsampling this must be 2; 1 input and 1 weight.</li>
<li><code>workspace::long (non-negative), optional, default=512</code>: Tmp workspace for deconvolution (MB)</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L412' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._CachedOp-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._CachedOp-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._CachedOp</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_CachedOp(data)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode[]</code>: input data list</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L347' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._CachedOpThreadSafe-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._CachedOpThreadSafe-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._CachedOpThreadSafe</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_CachedOpThreadSafe(data)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode[]</code>: input data list</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L347' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._CrossDeviceCopy-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._CrossDeviceCopy-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._CrossDeviceCopy</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_CrossDeviceCopy()
</code></pre>

<p>Special op to copy data cross device</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._CustomFunction-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._CustomFunction-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._CustomFunction</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_CustomFunction()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._Div-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._Div-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._Div</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_Div(lhs, rhs)
</code></pre>

<p><em>Div is an alias of elemwise</em>div.</p>
<p>Divides arguments element-wise.</p>
<p>The storage type of $elemwise_div$ output is always dense</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L355' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._DivScalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._DivScalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._DivScalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_DivScalar(data, scalar)
</code></pre>

<p><em>DivScalar is an alias of _div</em>scalar.</p>
<p>Divide an array with a scalar.</p>
<p>$_div_scalar$ only operates on data array of input if input is sparse.</p>
<p>For example, if input of shape (100, 100) has only 2 non zero elements, i.e. input.data = [5, 6], scalar = nan, it will result output.data = [nan, nan] instead of 10000 nans.</p>
<p>Defined in src/operator/tensor/elemwise<em>binary</em>scalar<em>op</em>basic.cc:L171</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L361' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._Equal-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._Equal-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._Equal</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_Equal(lhs, rhs)
</code></pre>

<p>_Equal is an alias of _equal.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._EqualScalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._EqualScalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._EqualScalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_EqualScalar(data, scalar)
</code></pre>

<p><em>EqualScalar is an alias of _equal</em>scalar.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._Greater-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._Greater-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._Greater</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_Greater(lhs, rhs)
</code></pre>

<p>_Greater is an alias of _greater.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._GreaterEqualScalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._GreaterEqualScalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._GreaterEqualScalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_GreaterEqualScalar(data, scalar)
</code></pre>

<p><em>GreaterEqualScalar is an alias of _greater</em>equal_scalar.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._GreaterScalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._GreaterScalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._GreaterScalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_GreaterScalar(data, scalar)
</code></pre>

<p><em>GreaterScalar is an alias of _greater</em>scalar.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._Greater_Equal-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._Greater_Equal-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._Greater_Equal</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_Greater_Equal(lhs, rhs)
</code></pre>

<p><em>Greater</em>Equal is an alias of <em>greater</em>equal.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._Hypot-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._Hypot-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._Hypot</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_Hypot(lhs, rhs)
</code></pre>

<p>_Hypot is an alias of _hypot.</p>
<p>Given the "legs" of a right triangle, return its hypotenuse.</p>
<p>Defined in src/operator/tensor/elemwise<em>binary</em>op_extended.cc:L79</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L355' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._HypotScalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._HypotScalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._HypotScalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_HypotScalar(data, scalar)
</code></pre>

<p><em>HypotScalar is an alias of _hypot</em>scalar.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._Lesser-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._Lesser-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._Lesser</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_Lesser(lhs, rhs)
</code></pre>

<p>_Lesser is an alias of _lesser.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._LesserEqualScalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._LesserEqualScalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._LesserEqualScalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_LesserEqualScalar(data, scalar)
</code></pre>

<p><em>LesserEqualScalar is an alias of _lesser</em>equal_scalar.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._LesserScalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._LesserScalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._LesserScalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_LesserScalar(data, scalar)
</code></pre>

<p><em>LesserScalar is an alias of _lesser</em>scalar.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._Lesser_Equal-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._Lesser_Equal-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._Lesser_Equal</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_Lesser_Equal(lhs, rhs)
</code></pre>

<p><em>Lesser</em>Equal is an alias of <em>lesser</em>equal.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._LogicalAndScalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._LogicalAndScalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._LogicalAndScalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_LogicalAndScalar(data, scalar)
</code></pre>

<p><em>LogicalAndScalar is an alias of _logical</em>and_scalar.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._LogicalOrScalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._LogicalOrScalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._LogicalOrScalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_LogicalOrScalar(data, scalar)
</code></pre>

<p><em>LogicalOrScalar is an alias of _logical</em>or_scalar.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._LogicalXorScalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._LogicalXorScalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._LogicalXorScalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_LogicalXorScalar(data, scalar)
</code></pre>

<p><em>LogicalXorScalar is an alias of _logical</em>xor_scalar.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._Logical_And-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._Logical_And-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._Logical_And</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_Logical_And(lhs, rhs)
</code></pre>

<p><em>Logical</em>And is an alias of <em>logical</em>and.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._Logical_Or-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._Logical_Or-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._Logical_Or</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_Logical_Or(lhs, rhs)
</code></pre>

<p><em>Logical</em>Or is an alias of <em>logical</em>or.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._Logical_Xor-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._Logical_Xor-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._Logical_Xor</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_Logical_Xor(lhs, rhs)
</code></pre>

<p><em>Logical</em>Xor is an alias of <em>logical</em>xor.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._Maximum-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._Maximum-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._Maximum</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_Maximum(lhs, rhs)
</code></pre>

<p>_Maximum is an alias of _maximum.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._MaximumScalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._MaximumScalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._MaximumScalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_MaximumScalar(data, scalar)
</code></pre>

<p><em>MaximumScalar is an alias of _maximum</em>scalar.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._Minimum-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._Minimum-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._Minimum</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_Minimum(lhs, rhs)
</code></pre>

<p>_Minimum is an alias of _minimum.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._MinimumScalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._MinimumScalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._MinimumScalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_MinimumScalar(data, scalar)
</code></pre>

<p><em>MinimumScalar is an alias of _minimum</em>scalar.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._Minus-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._Minus-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._Minus</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_Minus(lhs, rhs)
</code></pre>

<p><em>Minus is an alias of elemwise</em>sub.</p>
<p>Subtracts arguments element-wise.</p>
<p>The storage type of $elemwise_sub$ output depends on storage types of inputs</p>
<ul>
<li>elemwise<em>sub(row</em>sparse, row<em>sparse) = row</em>sparse</li>
<li>elemwise_sub(csr, csr) = csr</li>
<li>elemwise_sub(default, csr) = default</li>
<li>elemwise_sub(csr, default) = default</li>
<li>elemwise_sub(default, rsp) = default</li>
<li>elemwise_sub(rsp, default) = default</li>
<li>otherwise, $elemwise_sub$ generates output with default storage</li>
</ul>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L363' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._MinusScalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._MinusScalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._MinusScalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_MinusScalar(data, scalar)
</code></pre>

<p><em>MinusScalar is an alias of _minus</em>scalar.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._Mod-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._Mod-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._Mod</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_Mod(lhs, rhs)
</code></pre>

<p>_Mod is an alias of _mod.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._ModScalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._ModScalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._ModScalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_ModScalar(data, scalar)
</code></pre>

<p><em>ModScalar is an alias of _mod</em>scalar.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._Mul-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._Mul-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._Mul</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_Mul(lhs, rhs)
</code></pre>

<p><em>Mul is an alias of elemwise</em>mul.</p>
<p>Multiplies arguments element-wise.</p>
<p>The storage type of $elemwise_mul$ output depends on storage types of inputs</p>
<ul>
<li>elemwise_mul(default, default) = default</li>
<li>elemwise<em>mul(row</em>sparse, row<em>sparse) = row</em>sparse</li>
<li>elemwise<em>mul(default, row</em>sparse) = row_sparse</li>
<li>elemwise<em>mul(row</em>sparse, default) = row_sparse</li>
<li>elemwise_mul(csr, csr) = csr</li>
<li>otherwise, $elemwise_mul$ generates output with default storage</li>
</ul>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L362' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._MulScalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._MulScalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._MulScalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_MulScalar(data, scalar)
</code></pre>

<p><em>MulScalar is an alias of _mul</em>scalar.</p>
<p>Multiply an array with a scalar.</p>
<p>$_mul_scalar$ only operates on data array of input if input is sparse.</p>
<p>For example, if input of shape (100, 100) has only 2 non zero elements, i.e. input.data = [5, 6], scalar = nan, it will result output.data = [nan, nan] instead of 10000 nans.</p>
<p>Defined in src/operator/tensor/elemwise<em>binary</em>scalar<em>op</em>basic.cc:L149</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L361' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._NDArray-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._NDArray-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._NDArray</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_NDArray(data, info)
</code></pre>

<p>Stub for implementing an operator implemented in native frontend language with ndarray.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode[]</code>: Input data for the custom operator.</li>
<li><code>info::ptr, required</code>:</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._Native-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._Native-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._Native</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_Native(data, info, need_top_grad)
</code></pre>

<p>Stub for implementing an operator implemented in native frontend language.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode[]</code>: Input data for the custom operator.</li>
<li><code>info::ptr, required</code>:</li>
<li><code>need_top_grad::boolean, optional, default=1</code>: Whether this layer needs out grad for backward. Should be false for loss layers.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._NoGradient-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._NoGradient-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._NoGradient</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_NoGradient()
</code></pre>

<p>Place holder for variable who cannot perform gradient</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._NotEqualScalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._NotEqualScalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._NotEqualScalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_NotEqualScalar(data, scalar)
</code></pre>

<p><em>NotEqualScalar is an alias of _not</em>equal_scalar.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._Not_Equal-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._Not_Equal-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._Not_Equal</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_Not_Equal(lhs, rhs)
</code></pre>

<p><em>Not</em>Equal is an alias of <em>not</em>equal.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._Plus-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._Plus-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._Plus</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_Plus(lhs, rhs)
</code></pre>

<p><em>Plus is an alias of elemwise</em>add.</p>
<p>Adds arguments element-wise.</p>
<p>The storage type of $elemwise_add$ output depends on storage types of inputs</p>
<ul>
<li>elemwise<em>add(row</em>sparse, row<em>sparse) = row</em>sparse</li>
<li>elemwise_add(csr, csr) = csr</li>
<li>elemwise_add(default, csr) = default</li>
<li>elemwise_add(csr, default) = default</li>
<li>elemwise_add(default, rsp) = default</li>
<li>elemwise_add(rsp, default) = default</li>
<li>otherwise, $elemwise_add$ generates output with default storage</li>
</ul>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L363' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._PlusScalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._PlusScalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._PlusScalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_PlusScalar(data, scalar)
</code></pre>

<p><em>PlusScalar is an alias of _plus</em>scalar.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._Power-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._Power-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._Power</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_Power(lhs, rhs)
</code></pre>

<p>_Power is an alias of _power.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._PowerScalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._PowerScalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._PowerScalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_PowerScalar(data, scalar)
</code></pre>

<p><em>PowerScalar is an alias of _power</em>scalar.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._RDivScalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._RDivScalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._RDivScalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_RDivScalar(data, scalar)
</code></pre>

<p><em>RDivScalar is an alias of _rdiv</em>scalar.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._RMinusScalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._RMinusScalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._RMinusScalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_RMinusScalar(data, scalar)
</code></pre>

<p><em>RMinusScalar is an alias of _rminus</em>scalar.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._RModScalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._RModScalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._RModScalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_RModScalar(data, scalar)
</code></pre>

<p><em>RModScalar is an alias of _rmod</em>scalar.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._RPowerScalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._RPowerScalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._RPowerScalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_RPowerScalar(data, scalar)
</code></pre>

<p><em>RPowerScalar is an alias of _rpower</em>scalar.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._adamw_update-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._adamw_update-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._adamw_update</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_adamw_update(weight, grad, mean, var, rescale_grad, lr, beta1, beta2, epsilon, wd, eta, clip_gradient)
</code></pre>

<p>Update function for AdamW optimizer. AdamW is seen as a modification of Adam by decoupling the weight decay from the optimization steps taken w.r.t. the loss function.</p>
<p>Adam update consists of the following steps, where g represents gradient and m, v are 1st and 2nd order moment estimates (mean and variance).</p>
<p>.. math::</p>
<p>g<em t-1="t-1">t = \nabla J(W</em>)\
 m<em>t = \beta</em>1 m<em>{t-1} + (1 - \beta</em>1) g<em>t\
 v</em>t = \beta<em t-1="t-1">2 v</em> + (1 - \beta<em>2) g</em>t^2\
 W<em t-1="t-1">t = W</em> - \eta<em>t (\alpha \frac{ m</em>t }{ \sqrt{ v<em t-1="t-1">t } + \epsilon } + wd W</em>)</p>
<p>It updates the weights using::</p>
<p>m = beta1<em>m + (1-beta1)</em>grad  v = beta2<em>v + (1-beta2)</em>(grad**2)  w -= eta * (learning_rate * m / (sqrt(v) + epsilon) + w * wd)</p>
<p>Note that gradient is rescaled to grad = rescale<em>grad * grad. If rescale</em>grad is NaN, Inf, or 0, the update is skipped.</p>
<p>Defined in src/operator/contrib/adamw.cc:L101</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>weight::NDArray-or-SymbolicNode</code>: Weight</li>
<li><code>grad::NDArray-or-SymbolicNode</code>: Gradient</li>
<li><code>mean::NDArray-or-SymbolicNode</code>: Moving mean</li>
<li><code>var::NDArray-or-SymbolicNode</code>: Moving variance</li>
<li><code>rescale_grad::NDArray-or-SymbolicNode</code>: Rescale gradient to rescale_grad * grad. If NaN, Inf, or 0, the update is skipped.</li>
<li><code>lr::float, required</code>: Learning rate</li>
<li><code>beta1::float, optional, default=0.899999976</code>: The decay rate for the 1st moment estimates.</li>
<li><code>beta2::float, optional, default=0.999000013</code>: The decay rate for the 2nd moment estimates.</li>
<li><code>epsilon::float, optional, default=9.99999994e-09</code>: A small constant for numerical stability.</li>
<li><code>wd::float, optional, default=0</code>: Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</li>
<li><code>eta::float, required</code>: Learning rate schedule multiplier</li>
<li><code>clip_gradient::float, optional, default=-1</code>: Clip gradient to the range of [-clip<em>gradient, clip</em>gradient] If clip<em>gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip</em>gradient), -clip_gradient).</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L392' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._add-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._add-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._add</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_add(lhs, rhs)
</code></pre>

<p><em>add is an alias of elemwise</em>add.</p>
<p>Adds arguments element-wise.</p>
<p>The storage type of $elemwise_add$ output depends on storage types of inputs</p>
<ul>
<li>elemwise<em>add(row</em>sparse, row<em>sparse) = row</em>sparse</li>
<li>elemwise_add(csr, csr) = csr</li>
<li>elemwise_add(default, csr) = default</li>
<li>elemwise_add(csr, default) = default</li>
<li>elemwise_add(default, rsp) = default</li>
<li>elemwise_add(rsp, default) = default</li>
<li>otherwise, $elemwise_add$ generates output with default storage</li>
</ul>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L363' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._arange-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._arange-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._arange</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_arange(start, stop, step, repeat, infer_range, ctx, dtype)
</code></pre>

<p>Return evenly spaced values within a given interval. Similar to Numpy</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>start::double, required</code>: Start of interval. The interval includes this value. The default start value is 0.</li>
<li><code>stop::double or None, optional, default=None</code>: End of interval. The interval does not include this value, except in some cases where step is not an integer and floating point round-off affects the length of out.</li>
<li><code>step::double, optional, default=1</code>: Spacing between values.</li>
<li><code>repeat::int, optional, default='1'</code>: The repeating time of all elements. E.g repeat=3, the element a will be repeated three times –&gt; a, a, a.</li>
<li><code>infer_range::boolean, optional, default=0</code>: When set to True, infer the stop position from the start, step, repeat, and output tensor size.</li>
<li><code>ctx::string, optional, default=''</code>: Context of output, in format <a href="n">cpu|gpu|cpu_pinned</a>.Only used for imperative calls.</li>
<li><code>dtype::{'bfloat16', 'float16', 'float32', 'float64', 'int32', 'int64', 'int8', 'uint8'},optional, default='float32'</code>: Target data type.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L359' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_Activation-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_Activation-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_Activation</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_Activation()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_BatchNorm-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_BatchNorm-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_BatchNorm</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_BatchNorm()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_BatchNorm_v1-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_BatchNorm_v1-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_BatchNorm_v1</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_BatchNorm_v1()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_BilinearSampler-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_BilinearSampler-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_BilinearSampler</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_BilinearSampler()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_CachedOp-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_CachedOp-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_CachedOp</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_CachedOp()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_Concat-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_Concat-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_Concat</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_Concat()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_Convolution-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_Convolution-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_Convolution</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_Convolution()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_Convolution_v1-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_Convolution_v1-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_Convolution_v1</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_Convolution_v1()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_Correlation-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_Correlation-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_Correlation</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_Correlation()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_Crop-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_Crop-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_Crop</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_Crop()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_Custom-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_Custom-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_Custom</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_Custom()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_CustomFunction-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_CustomFunction-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_CustomFunction</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_CustomFunction()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_Deconvolution-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_Deconvolution-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_Deconvolution</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_Deconvolution()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_Dropout-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_Dropout-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_Dropout</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_Dropout()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_Embedding-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_Embedding-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_Embedding</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_Embedding()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_FullyConnected-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_FullyConnected-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_FullyConnected</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_FullyConnected()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_GridGenerator-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_GridGenerator-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_GridGenerator</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_GridGenerator()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_GroupNorm-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_GroupNorm-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_GroupNorm</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_GroupNorm()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_IdentityAttachKLSparseReg-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_IdentityAttachKLSparseReg-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_IdentityAttachKLSparseReg</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_IdentityAttachKLSparseReg()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_InstanceNorm-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_InstanceNorm-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_InstanceNorm</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_InstanceNorm()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_L2Normalization-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_L2Normalization-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_L2Normalization</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_L2Normalization()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_LRN-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_LRN-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_LRN</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_LRN()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_LayerNorm-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_LayerNorm-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_LayerNorm</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_LayerNorm()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_LeakyReLU-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_LeakyReLU-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_LeakyReLU</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_LeakyReLU()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_MakeLoss-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_MakeLoss-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_MakeLoss</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_MakeLoss()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_Pad-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_Pad-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_Pad</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_Pad()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_Pooling-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_Pooling-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_Pooling</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_Pooling()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_Pooling_v1-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_Pooling_v1-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_Pooling_v1</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_Pooling_v1()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_RNN-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_RNN-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_RNN</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_RNN()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_ROIAlign-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_ROIAlign-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_ROIAlign</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_ROIAlign()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_ROIPooling-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_ROIPooling-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_ROIPooling</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_ROIPooling()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_RROIAlign-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_RROIAlign-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_RROIAlign</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_RROIAlign()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_SVMOutput-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_SVMOutput-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_SVMOutput</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_SVMOutput()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_SequenceLast-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_SequenceLast-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_SequenceLast</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_SequenceLast()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_SequenceMask-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_SequenceMask-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_SequenceMask</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_SequenceMask()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_SequenceReverse-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_SequenceReverse-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_SequenceReverse</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_SequenceReverse()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_SliceChannel-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_SliceChannel-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_SliceChannel</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_SliceChannel()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_SoftmaxActivation-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_SoftmaxActivation-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_SoftmaxActivation</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_SoftmaxActivation()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_SoftmaxOutput-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_SoftmaxOutput-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_SoftmaxOutput</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_SoftmaxOutput()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_SparseEmbedding-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_SparseEmbedding-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_SparseEmbedding</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_SparseEmbedding()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_SpatialTransformer-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_SpatialTransformer-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_SpatialTransformer</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_SpatialTransformer()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_SwapAxis-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_SwapAxis-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_SwapAxis</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_SwapAxis()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_UpSampling-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_UpSampling-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_UpSampling</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_UpSampling()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward__CrossDeviceCopy-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward__CrossDeviceCopy-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward__CrossDeviceCopy</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward__CrossDeviceCopy()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward__NDArray-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward__NDArray-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward__NDArray</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward__NDArray()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward__Native-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward__Native-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward__Native</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward__Native()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward__contrib_DeformableConvolution-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward__contrib_DeformableConvolution-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward__contrib_DeformableConvolution</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward__contrib_DeformableConvolution()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward__contrib_DeformablePSROIPooling-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward__contrib_DeformablePSROIPooling-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward__contrib_DeformablePSROIPooling</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward__contrib_DeformablePSROIPooling()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward__contrib_ModulatedDeformableConvolution-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward__contrib_ModulatedDeformableConvolution-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward__contrib_ModulatedDeformableConvolution</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward__contrib_ModulatedDeformableConvolution()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward__contrib_MultiBoxDetection-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward__contrib_MultiBoxDetection-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward__contrib_MultiBoxDetection</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward__contrib_MultiBoxDetection()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward__contrib_MultiBoxPrior-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward__contrib_MultiBoxPrior-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward__contrib_MultiBoxPrior</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward__contrib_MultiBoxPrior()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward__contrib_MultiBoxTarget-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward__contrib_MultiBoxTarget-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward__contrib_MultiBoxTarget</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward__contrib_MultiBoxTarget()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward__contrib_MultiProposal-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward__contrib_MultiProposal-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward__contrib_MultiProposal</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward__contrib_MultiProposal()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward__contrib_PSROIPooling-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward__contrib_PSROIPooling-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward__contrib_PSROIPooling</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward__contrib_PSROIPooling()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward__contrib_Proposal-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward__contrib_Proposal-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward__contrib_Proposal</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward__contrib_Proposal()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward__contrib_SyncBatchNorm-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward__contrib_SyncBatchNorm-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward__contrib_SyncBatchNorm</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward__contrib_SyncBatchNorm()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward__contrib_count_sketch-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward__contrib_count_sketch-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward__contrib_count_sketch</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward__contrib_count_sketch()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward__contrib_fft-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward__contrib_fft-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward__contrib_fft</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward__contrib_fft()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward__contrib_ifft-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward__contrib_ifft-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward__contrib_ifft</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward__contrib_ifft()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_abs-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_abs-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_abs</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_abs(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_add-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_add-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_add</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_add()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_amp_cast-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_amp_cast-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_amp_cast</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_amp_cast()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_amp_multicast-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_amp_multicast-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_amp_multicast</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_amp_multicast(grad, num_outputs, cast_narrow)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>grad::NDArray-or-SymbolicNode[]</code>: Gradients</li>
<li><code>num_outputs::int, required</code>: Number of input/output pairs to be casted to the widest type.</li>
<li><code>cast_narrow::boolean, optional, default=0</code>: Whether to cast to the narrowest type</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_arccos-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_arccos-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_arccos</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_arccos(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_arccosh-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_arccosh-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_arccosh</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_arccosh(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_arcsin-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_arcsin-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_arcsin</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_arcsin(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_arcsinh-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_arcsinh-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_arcsinh</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_arcsinh(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_arctan-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_arctan-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_arctan</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_arctan(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_arctanh-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_arctanh-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_arctanh</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_arctanh(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_backward_FullyConnected-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_backward_FullyConnected-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_backward_FullyConnected</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_backward_FullyConnected()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_broadcast_add-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_broadcast_add-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_broadcast_add</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_broadcast_add()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_broadcast_div-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_broadcast_div-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_broadcast_div</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_broadcast_div()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_broadcast_exponential-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_broadcast_exponential-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_broadcast_exponential</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_broadcast_exponential(scale, size, ctx)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>scale::float or None, optional, default=1</code>:</li>
<li><code>size::Shape or None, optional, default=None</code>: Output shape. If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn. Default is None, in which case a single value is returned.</li>
<li><code>ctx::string, optional, default='cpu'</code>: Context of output, in format <a href="n">cpu|gpu|cpu_pinned</a>. Only used for imperative calls.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_broadcast_gumbel-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_broadcast_gumbel-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_broadcast_gumbel</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_broadcast_gumbel(loc, scale, size, ctx)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>loc::float or None, required</code>:</li>
<li><code>scale::float or None, required</code>:</li>
<li><code>size::Shape or None, optional, default=None</code>: Output shape. If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn. Default is None, in which case a single value is returned.</li>
<li><code>ctx::string, optional, default='cpu'</code>: Context of output, in format <a href="n">cpu|gpu|cpu_pinned</a>. Only used for imperative calls.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L353' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_broadcast_hypot-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_broadcast_hypot-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_broadcast_hypot</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_broadcast_hypot()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_broadcast_logistic-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_broadcast_logistic-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_broadcast_logistic</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_broadcast_logistic(loc, scale, size, ctx)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>loc::float or None, required</code>:</li>
<li><code>scale::float or None, required</code>:</li>
<li><code>size::Shape or None, optional, default=None</code>: Output shape. If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn. Default is None, in which case a single value is returned.</li>
<li><code>ctx::string, optional, default='cpu'</code>: Context of output, in format <a href="n">cpu|gpu|cpu_pinned</a>. Only used for imperative calls.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L353' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_broadcast_maximum-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_broadcast_maximum-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_broadcast_maximum</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_broadcast_maximum()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_broadcast_minimum-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_broadcast_minimum-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_broadcast_minimum</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_broadcast_minimum()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_broadcast_mod-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_broadcast_mod-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_broadcast_mod</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_broadcast_mod()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_broadcast_mul-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_broadcast_mul-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_broadcast_mul</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_broadcast_mul()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_broadcast_normal-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_broadcast_normal-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_broadcast_normal</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_broadcast_normal(loc, scale, size, ctx, dtype)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>loc::float or None, required</code>:</li>
<li><code>scale::float or None, required</code>:</li>
<li><code>size::Shape or None, optional, default=None</code>: Output shape. If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn. Default is None, in which case a single value is returned.</li>
<li><code>ctx::string, optional, default='cpu'</code>: Context of output, in format <a href="n">cpu|gpu|cpu_pinned</a>. Only used for imperative calls.</li>
<li><code>dtype::{'float16', 'float32', 'float64'},optional, default='float32'</code>: DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L355' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_broadcast_pareto-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_broadcast_pareto-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_broadcast_pareto</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_broadcast_pareto(a, size, ctx)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>a::float or None, optional, default=None</code>:</li>
<li><code>size::Shape or None, optional, default=None</code>: Output shape. If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn. Default is None, in which case a single value is returned.</li>
<li><code>ctx::string, optional, default='cpu'</code>: Context of output, in format <a href="n">cpu|gpu|cpu_pinned</a>. Only used for imperative calls.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_broadcast_power-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_broadcast_power-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_broadcast_power</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_broadcast_power()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_broadcast_rayleigh-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_broadcast_rayleigh-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_broadcast_rayleigh</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_broadcast_rayleigh(scale, size, ctx)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>scale::float or None, optional, default=1</code>:</li>
<li><code>size::Shape or None, optional, default=None</code>: Output shape. If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn. Default is None, in which case a single value is returned.</li>
<li><code>ctx::string, optional, default='cpu'</code>: Context of output, in format <a href="n">cpu|gpu|cpu_pinned</a>. Only used for imperative calls.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_broadcast_sub-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_broadcast_sub-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_broadcast_sub</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_broadcast_sub()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_broadcast_weibull-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_broadcast_weibull-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_broadcast_weibull</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_broadcast_weibull(a, size, ctx)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>a::float or None, optional, default=None</code>:</li>
<li><code>size::Shape or None, optional, default=None</code>: Output shape. If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn. Default is None, in which case a single value is returned.</li>
<li><code>ctx::string, optional, default='cpu'</code>: Context of output, in format <a href="n">cpu|gpu|cpu_pinned</a>. Only used for imperative calls.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_cast-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_cast-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_cast</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_cast()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_cbrt-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_cbrt-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_cbrt</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_cbrt(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_clip-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_clip-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_clip</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_clip()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_col2im-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_col2im-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_col2im</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_col2im()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_cond-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_cond-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_cond</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_cond()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_contrib_AdaptiveAvgPooling2D-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_contrib_AdaptiveAvgPooling2D-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_contrib_AdaptiveAvgPooling2D</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_contrib_AdaptiveAvgPooling2D()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_contrib_BilinearResize2D-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_contrib_BilinearResize2D-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_contrib_BilinearResize2D</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_contrib_BilinearResize2D()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_contrib_bipartite_matching-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_contrib_bipartite_matching-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_contrib_bipartite_matching</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_contrib_bipartite_matching(is_ascend, threshold, topk)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>is_ascend::boolean, optional, default=0</code>: Use ascend order for scores instead of descending. Please set threshold accordingly.</li>
<li><code>threshold::float, required</code>: Ignore matching when score &lt; thresh, if is<em>ascend=false, or ignore score &gt; thresh, if is</em>ascend=true.</li>
<li><code>topk::int, optional, default='-1'</code>: Limit the number of matches to topk, set -1 for no limit</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_contrib_boolean_mask-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_contrib_boolean_mask-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_contrib_boolean_mask</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_contrib_boolean_mask(axis)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>axis::int, optional, default='0'</code>: An integer that represents the axis in NDArray to mask from.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L347' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_contrib_box_iou-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_contrib_box_iou-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_contrib_box_iou</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_contrib_box_iou(format)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>format::{'center', 'corner'},optional, default='corner'</code>: The box encoding type.</li>
</ul>
<p>"corner" means boxes are encoded as [xmin, ymin, xmax, ymax], "center" means boxes are encodes as [x, y, width, height].</p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L348' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_contrib_box_nms-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_contrib_box_nms-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_contrib_box_nms</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_contrib_box_nms(overlap_thresh, valid_thresh, topk, coord_start, score_index, id_index, background_id, force_suppress, in_format, out_format)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>overlap_thresh::float, optional, default=0.5</code>: Overlapping(IoU) threshold to suppress object with smaller score.</li>
<li><code>valid_thresh::float, optional, default=0</code>: Filter input boxes to those whose scores greater than valid_thresh.</li>
<li><code>topk::int, optional, default='-1'</code>: Apply nms to topk boxes with descending scores, -1 to no restriction.</li>
<li><code>coord_start::int, optional, default='2'</code>: Start index of the consecutive 4 coordinates.</li>
<li><code>score_index::int, optional, default='1'</code>: Index of the scores/confidence of boxes.</li>
<li><code>id_index::int, optional, default='-1'</code>: Optional, index of the class categories, -1 to disable.</li>
<li><code>background_id::int, optional, default='-1'</code>: Optional, id of the background class which will be ignored in nms.</li>
<li><code>force_suppress::boolean, optional, default=0</code>: Optional, if set false and id_index is provided, nms will only apply to boxes belongs to the same category</li>
<li><code>in_format::{'center', 'corner'},optional, default='corner'</code>: The input box encoding type.</li>
</ul>
<p>"corner" means boxes are encoded as [xmin, ymin, xmax, ymax], "center" means boxes are encodes as [x, y, width, height].</p>
<ul>
<li><code>out_format::{'center', 'corner'},optional, default='corner'</code>: The output box encoding type.</li>
</ul>
<p>"corner" means boxes are encoded as [xmin, ymin, xmax, ymax], "center" means boxes are encodes as [x, y, width, height].</p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L367' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_copy-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_copy-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_copy</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_copy()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_cos-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_cos-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_cos</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_cos(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_cosh-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_cosh-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_cosh</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_cosh(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_ctc_loss-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_ctc_loss-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_ctc_loss</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_ctc_loss()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_degrees-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_degrees-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_degrees</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_degrees(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_diag-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_diag-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_diag</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_diag()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_div-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_div-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_div</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_div()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_div_scalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_div_scalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_div_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_div_scalar(data, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_dot-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_dot-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_dot</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_dot(transpose_a, transpose_b, forward_stype)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>transpose_a::boolean, optional, default=0</code>: If true then transpose the first input before dot.</li>
<li><code>transpose_b::boolean, optional, default=0</code>: If true then transpose the second input before dot.</li>
<li><code>forward_stype::{None, 'csr', 'default', 'row_sparse'},optional, default='None'</code>: The desired storage type of the forward output given by user, if thecombination of input storage types and this hint does not matchany implemented ones, the dot operator will perform fallback operationand still produce an output of the desired storage type.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_erf-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_erf-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_erf</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_erf(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_erfinv-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_erfinv-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_erfinv</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_erfinv(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_expm1-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_expm1-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_expm1</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_expm1(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_foreach-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_foreach-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_foreach</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_foreach()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_gamma-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_gamma-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_gamma</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_gamma(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_gammaln-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_gammaln-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_gammaln</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_gammaln(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_gather_nd-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_gather_nd-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_gather_nd</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_gather_nd(data, indices, shape)
</code></pre>

<p>Accumulates data according to indices and get the result. It's the backward of <code>gather_nd</code>.</p>
<p>Given <code>data</code> with shape <code>(Y_0, ..., Y_{K-1}, X_M, ..., X_{N-1})</code> and indices with shape <code>(M, Y_0, ..., Y_{K-1})</code>, the output will have shape <code>(X_0, X_1, ..., X_{N-1})</code>, where <code>M &lt;= N</code>. If <code>M == N</code>, data shape should simply be <code>(Y_0, ..., Y_{K-1})</code>.</p>
<p>The elements in output is defined as follows::</p>
<p>output[indices[0, y<em K-1="K-1">0, ..., y</em>],          ...,          indices[M-1, y<em K-1="K-1">0, ..., y</em>],          x<em N-1="N-1">M, ..., x</em>] += data[y<em K-1="K-1">0, ..., y</em>, x<em N-1="N-1">M, ..., x</em>]</p>
<p>all other entries in output are 0 or the original value if AddTo is triggered.</p>
<p>Examples::</p>
<p>data = [2, 3, 0]   indices = [[1, 1, 0], [0, 1, 0]]   shape = (2, 2)   <em>backward</em>gather<em>nd(data, indices, shape) = [[0, 0], [2, 3]] # Same as scatter</em>nd</p>
<p><strong>The difference between scatter<em>nd and scatter</em>nd_acc is the latter will accumulate</strong></p>
<p><strong>the values that point to the same index.</strong></p>
<p>data = [2, 3, 0]   indices = [[1, 1, 0], [1, 1, 0]]   shape = (2, 2)   <em>backward</em>gather_nd(data, indices, shape) = [[0, 0], [0, 5]]</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: data</li>
<li><code>indices::NDArray-or-SymbolicNode</code>: indices</li>
<li><code>shape::Shape(tuple), required</code>: Shape of output.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L382' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_hard_sigmoid-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_hard_sigmoid-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_hard_sigmoid</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_hard_sigmoid()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_hypot-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_hypot-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_hypot</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_hypot()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_hypot_scalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_hypot_scalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_hypot_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_hypot_scalar(lhs, rhs, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>scalar::float</code>: scalar value</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_im2col-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_im2col-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_im2col</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_im2col()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_image_crop-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_image_crop-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_image_crop</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_image_crop()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_image_normalize-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_image_normalize-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_image_normalize</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_image_normalize()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_interleaved_matmul_encdec_qk-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_interleaved_matmul_encdec_qk-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_interleaved_matmul_encdec_qk</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_interleaved_matmul_encdec_qk()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_interleaved_matmul_encdec_valatt-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_interleaved_matmul_encdec_valatt-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_interleaved_matmul_encdec_valatt</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_interleaved_matmul_encdec_valatt()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_interleaved_matmul_selfatt_qk-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_interleaved_matmul_selfatt_qk-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_interleaved_matmul_selfatt_qk</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_interleaved_matmul_selfatt_qk()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_interleaved_matmul_selfatt_valatt-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_interleaved_matmul_selfatt_valatt-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_interleaved_matmul_selfatt_valatt</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_interleaved_matmul_selfatt_valatt()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_linalg_det-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_linalg_det-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_linalg_det</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_linalg_det()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_linalg_extractdiag-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_linalg_extractdiag-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_linalg_extractdiag</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_linalg_extractdiag()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_linalg_extracttrian-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_linalg_extracttrian-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_linalg_extracttrian</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_linalg_extracttrian()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_linalg_gelqf-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_linalg_gelqf-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_linalg_gelqf</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_linalg_gelqf()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_linalg_gemm-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_linalg_gemm-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_linalg_gemm</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_linalg_gemm()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_linalg_gemm2-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_linalg_gemm2-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_linalg_gemm2</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_linalg_gemm2()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_linalg_inverse-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_linalg_inverse-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_linalg_inverse</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_linalg_inverse()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_linalg_makediag-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_linalg_makediag-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_linalg_makediag</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_linalg_makediag()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_linalg_maketrian-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_linalg_maketrian-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_linalg_maketrian</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_linalg_maketrian()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_linalg_potrf-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_linalg_potrf-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_linalg_potrf</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_linalg_potrf()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_linalg_potri-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_linalg_potri-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_linalg_potri</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_linalg_potri()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_linalg_slogdet-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_linalg_slogdet-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_linalg_slogdet</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_linalg_slogdet()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_linalg_sumlogdiag-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_linalg_sumlogdiag-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_linalg_sumlogdiag</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_linalg_sumlogdiag()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_linalg_syevd-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_linalg_syevd-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_linalg_syevd</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_linalg_syevd()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_linalg_syrk-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_linalg_syrk-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_linalg_syrk</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_linalg_syrk()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_linalg_trmm-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_linalg_trmm-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_linalg_trmm</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_linalg_trmm()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_linalg_trsm-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_linalg_trsm-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_linalg_trsm</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_linalg_trsm()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_linear_reg_out-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_linear_reg_out-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_linear_reg_out</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_linear_reg_out()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_log-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_log-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_log</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_log(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_log10-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_log10-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_log10</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_log10(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_log1p-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_log1p-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_log1p</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_log1p(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_log2-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_log2-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_log2</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_log2(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_log_softmax-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_log_softmax-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_log_softmax</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_log_softmax(args)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>args::NDArray-or-SymbolicNode[]</code>: Positional input arguments</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L347' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_logistic_reg_out-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_logistic_reg_out-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_logistic_reg_out</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_logistic_reg_out()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_mae_reg_out-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_mae_reg_out-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_mae_reg_out</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_mae_reg_out()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_max-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_max-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_max</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_max()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_maximum-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_maximum-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_maximum</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_maximum()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_maximum_scalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_maximum_scalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_maximum_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_maximum_scalar(lhs, rhs, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>scalar::float</code>: scalar value</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_mean-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_mean-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_mean</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_mean()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_min-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_min-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_min</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_min()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_minimum-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_minimum-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_minimum</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_minimum()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_minimum_scalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_minimum_scalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_minimum_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_minimum_scalar(lhs, rhs, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>scalar::float</code>: scalar value</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_mod-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_mod-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_mod</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_mod()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_mod_scalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_mod_scalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_mod_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_mod_scalar(lhs, rhs, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>scalar::float</code>: scalar value</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_moments-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_moments-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_moments</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_moments()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_mul-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_mul-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_mul</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_mul()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_mul_scalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_mul_scalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_mul_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_mul_scalar(data, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_nanprod-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_nanprod-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_nanprod</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_nanprod()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_nansum-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_nansum-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_nansum</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_nansum()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_norm-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_norm-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_norm</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_norm()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_np_average-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_np_average-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_np_average</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_np_average()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_np_broadcast_to-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_np_broadcast_to-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_np_broadcast_to</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_np_broadcast_to()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_np_column_stack-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_np_column_stack-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_np_column_stack</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_np_column_stack()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_np_concat-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_np_concat-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_np_concat</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_np_concat()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_np_diag-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_np_diag-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_np_diag</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_np_diag()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_np_diagflat-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_np_diagflat-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_np_diagflat</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_np_diagflat()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_np_diagonal-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_np_diagonal-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_np_diagonal</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_np_diagonal()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_np_dot-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_np_dot-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_np_dot</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_np_dot()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_np_dstack-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_np_dstack-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_np_dstack</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_np_dstack()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_np_hstack-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_np_hstack-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_np_hstack</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_np_hstack()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_np_matmul-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_np_matmul-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_np_matmul</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_np_matmul()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_np_max-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_np_max-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_np_max</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_np_max()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_np_mean-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_np_mean-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_np_mean</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_np_mean()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_np_min-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_np_min-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_np_min</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_np_min()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_np_prod-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_np_prod-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_np_prod</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_np_prod()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_np_sum-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_np_sum-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_np_sum</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_np_sum()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_np_trace-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_np_trace-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_np_trace</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_np_trace()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_np_vstack-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_np_vstack-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_np_vstack</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_np_vstack()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_np_where-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_np_where-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_np_where</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_np_where()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_np_where_lscalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_np_where_lscalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_np_where_lscalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_np_where_lscalar()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_np_where_rscalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_np_where_rscalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_np_where_rscalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_np_where_rscalar()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_npi_arctan2-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_npi_arctan2-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_npi_arctan2</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_npi_arctan2()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_npi_arctan2_scalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_npi_arctan2_scalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_npi_arctan2_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_npi_arctan2_scalar(lhs, rhs, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>scalar::float</code>: scalar value</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_npi_broadcast_mul-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_npi_broadcast_mul-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_npi_broadcast_mul</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_npi_broadcast_mul()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_npi_broadcast_power-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_npi_broadcast_power-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_npi_broadcast_power</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_npi_broadcast_power()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_npi_copysign-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_npi_copysign-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_npi_copysign</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_npi_copysign()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_npi_copysign_scalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_npi_copysign_scalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_npi_copysign_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_npi_copysign_scalar(data, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_npi_cumsum-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_npi_cumsum-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_npi_cumsum</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_npi_cumsum()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_npi_diff-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_npi_diff-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_npi_diff</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_npi_diff()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_npi_einsum-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_npi_einsum-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_npi_einsum</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_npi_einsum()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_npi_flip-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_npi_flip-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_npi_flip</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_npi_flip()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_npi_hypot-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_npi_hypot-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_npi_hypot</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_npi_hypot()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_npi_ldexp-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_npi_ldexp-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_npi_ldexp</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_npi_ldexp()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_npi_ldexp_scalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_npi_ldexp_scalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_npi_ldexp_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_npi_ldexp_scalar(lhs, rhs, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>scalar::float</code>: scalar value</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_npi_norm-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_npi_norm-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_npi_norm</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_npi_norm()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_npi_pad-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_npi_pad-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_npi_pad</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_npi_pad()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_npi_rarctan2_scalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_npi_rarctan2_scalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_npi_rarctan2_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_npi_rarctan2_scalar(lhs, rhs, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>scalar::float</code>: scalar value</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_npi_rcopysign_scalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_npi_rcopysign_scalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_npi_rcopysign_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_npi_rcopysign_scalar(data, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_npi_rldexp_scalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_npi_rldexp_scalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_npi_rldexp_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_npi_rldexp_scalar(lhs, rhs, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>scalar::float</code>: scalar value</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_npi_solve-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_npi_solve-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_npi_solve</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_npi_solve()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_npi_svd-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_npi_svd-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_npi_svd</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_npi_svd()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_npi_tensordot-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_npi_tensordot-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_npi_tensordot</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_npi_tensordot()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_npi_tensordot_int_axes-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_npi_tensordot_int_axes-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_npi_tensordot_int_axes</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_npi_tensordot_int_axes()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_npi_tensorinv-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_npi_tensorinv-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_npi_tensorinv</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_npi_tensorinv()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_npi_tensorsolve-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_npi_tensorsolve-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_npi_tensorsolve</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_npi_tensorsolve()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_pdf_dirichlet-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_pdf_dirichlet-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_pdf_dirichlet</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_pdf_dirichlet()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_pdf_exponential-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_pdf_exponential-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_pdf_exponential</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_pdf_exponential()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_pdf_gamma-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_pdf_gamma-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_pdf_gamma</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_pdf_gamma()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_pdf_generalized_negative_binomial-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_pdf_generalized_negative_binomial-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_pdf_generalized_negative_binomial</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_pdf_generalized_negative_binomial()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_pdf_negative_binomial-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_pdf_negative_binomial-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_pdf_negative_binomial</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_pdf_negative_binomial()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_pdf_normal-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_pdf_normal-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_pdf_normal</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_pdf_normal()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_pdf_poisson-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_pdf_poisson-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_pdf_poisson</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_pdf_poisson()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_pdf_uniform-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_pdf_uniform-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_pdf_uniform</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_pdf_uniform()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_pick-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_pick-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_pick</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_pick()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_power-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_power-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_power</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_power()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_power_scalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_power_scalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_power_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_power_scalar(lhs, rhs, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>scalar::float</code>: scalar value</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_prod-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_prod-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_prod</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_prod()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_radians-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_radians-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_radians</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_radians(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_rcbrt-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_rcbrt-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_rcbrt</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_rcbrt(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_rdiv_scalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_rdiv_scalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_rdiv_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_rdiv_scalar(lhs, rhs, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>scalar::float</code>: scalar value</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_reciprocal-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_reciprocal-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_reciprocal</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_reciprocal(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_relu-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_relu-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_relu</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_relu(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_repeat-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_repeat-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_repeat</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_repeat()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_reshape-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_reshape-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_reshape</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_reshape()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_reverse-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_reverse-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_reverse</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_reverse()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_rmod_scalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_rmod_scalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_rmod_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_rmod_scalar(lhs, rhs, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>scalar::float</code>: scalar value</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_rpower_scalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_rpower_scalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_rpower_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_rpower_scalar(lhs, rhs, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>scalar::float</code>: scalar value</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_rsqrt-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_rsqrt-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_rsqrt</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_rsqrt(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_sample_multinomial-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_sample_multinomial-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_sample_multinomial</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_sample_multinomial()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_sigmoid-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_sigmoid-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_sigmoid</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_sigmoid(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_sign-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_sign-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_sign</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_sign(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_sin-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_sin-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_sin</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_sin(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_sinh-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_sinh-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_sinh</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_sinh(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_slice-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_slice-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_slice</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_slice()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_slice_axis-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_slice_axis-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_slice_axis</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_slice_axis()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_slice_like-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_slice_like-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_slice_like</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_slice_like()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_smooth_l1-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_smooth_l1-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_smooth_l1</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_smooth_l1(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_softmax-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_softmax-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_softmax</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_softmax(args)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>args::NDArray-or-SymbolicNode[]</code>: Positional input arguments</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L347' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_softmax_cross_entropy-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_softmax_cross_entropy-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_softmax_cross_entropy</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_softmax_cross_entropy()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_softmin-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_softmin-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_softmin</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_softmin(args)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>args::NDArray-or-SymbolicNode[]</code>: Positional input arguments</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L347' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_softsign-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_softsign-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_softsign</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_softsign(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_sparse_retain-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_sparse_retain-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_sparse_retain</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_sparse_retain()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_sqrt-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_sqrt-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_sqrt</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_sqrt(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_square-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_square-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_square</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_square(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_square_sum-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_square_sum-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_square_sum</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_square_sum()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_squeeze-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_squeeze-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_squeeze</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_squeeze()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_stack-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_stack-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_stack</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_stack()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_sub-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_sub-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_sub</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_sub()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_sum-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_sum-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_sum</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_sum()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_take-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_take-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_take</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_take()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_tan-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_tan-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_tan</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_tan(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_tanh-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_tanh-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_tanh</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_tanh(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_tile-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_tile-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_tile</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_tile()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_topk-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_topk-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_topk</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_topk()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_tril-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_tril-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_tril</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_tril()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_where-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_where-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_where</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_where()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_while_loop-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._backward_while_loop-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_while_loop</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_backward_while_loop()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._broadcast_backward-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._broadcast_backward-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._broadcast_backward</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_broadcast_backward()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._cond-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._cond-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._cond</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_cond(cond, then_branch, else_branch, data, num_args, num_outputs, cond_input_locs, then_input_locs, else_input_locs)
</code></pre>

<p><strong>Note</strong>: <em>cond takes variable number of positional inputs. So instead of calling as _cond([x, y, z], num</em>args=3), one should call via <em>cond(x, y, z), and num</em>args will be determined automatically.</p>
<p>Run a if-then-else using user-defined condition and computation</p>
<p>From:src/operator/control_flow.cc:1212</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>cond::SymbolicNode</code>: Input graph for the condition.</li>
<li><code>then_branch::SymbolicNode</code>: Input graph for the then branch.</li>
<li><code>else_branch::SymbolicNode</code>: Input graph for the else branch.</li>
<li><code>data::NDArray-or-SymbolicNode[]</code>: The input arrays that include data arrays and states.</li>
<li><code>num_args::int, required</code>: Number of input arguments, including cond, then and else as three symbol inputs.</li>
<li><code>num_outputs::int, required</code>: The number of outputs of the subgraph.</li>
<li><code>cond_input_locs::tuple of &lt;long&gt;, required</code>: The locations of cond's inputs in the given inputs.</li>
<li><code>then_input_locs::tuple of &lt;long&gt;, required</code>: The locations of then's inputs in the given inputs.</li>
<li><code>else_input_locs::tuple of &lt;long&gt;, required</code>: The locations of else's inputs in the given inputs.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L367' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._contrib_AdaptiveAvgPooling2D-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._contrib_AdaptiveAvgPooling2D-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._contrib_AdaptiveAvgPooling2D</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_contrib_AdaptiveAvgPooling2D(data, output_size)
</code></pre>

<p>Applies a 2D adaptive average pooling over a 4D input with the shape of (NCHW). The pooling kernel and stride sizes are automatically chosen for desired output sizes.</p>
<ul>
<li>If a single integer is provided for output<em>size, the output size is 
    (N x C x output</em>size x output_size) for any input (NCHW).</li>
<li>If a tuple of integers (height, width) are provided for output_size, the output size is 
    (N x C x height x width) for any input (NCHW).</li>
</ul>
<p>Defined in src/operator/contrib/adaptive<em>avg</em>pooling.cc:L214</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data</li>
<li><code>output_size::Shape(tuple), optional, default=[]</code>: int (output size) or a tuple of int for output (height, width).</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L361' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._contrib_BilinearResize2D-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._contrib_BilinearResize2D-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._contrib_BilinearResize2D</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_contrib_BilinearResize2D(data, like, height, width, scale_height, scale_width, mode, align_corners)
</code></pre>

<p>Perform 2D resizing (upsampling or downsampling) for 4D input using bilinear interpolation.</p>
<p>Expected input is a 4 dimensional NDArray (NCHW) and the output with the shape of (N x C x height x width).  The key idea of bilinear interpolation is to perform linear interpolation first in one direction, and then again in the other direction. See the wikipedia of <code>Bilinear interpolation  &lt;https://en.wikipedia.org/wiki/Bilinear_interpolation&gt;</code>_ for more details.</p>
<p>Defined in src/operator/contrib/bilinear_resize.cc:L220</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data</li>
<li><code>like::NDArray-or-SymbolicNode</code>: Resize data to it's shape</li>
<li><code>height::int, optional, default='1'</code>: output height (required, but ignored if scale_height is defined or mode is not "size")</li>
<li><code>width::int, optional, default='1'</code>: output width (required, but ignored if scale_width is defined or mode is not "size")</li>
<li><code>scale_height::float or None, optional, default=None</code>: sampling scale of the height (optional, used in modes "scale" and "odd_scale")</li>
<li><code>scale_width::float or None, optional, default=None</code>: sampling scale of the width (optional, used in modes "scale" and "odd_scale")</li>
<li><code>mode::{'like', 'odd_scale', 'size', 'to_even_down', 'to_even_up', 'to_odd_down', 'to_odd_up'},optional, default='size'</code>: resizing mode. "simple" - output height equals parameter "height" if "scale<em>height" parameter is not defined or input height multiplied by "scale</em>height" otherwise. Same for width;"odd<em>scale" - if original height or width is odd, then result height is calculated like result</em>h = (original<em>h - 1) * scale + 1; for scale &gt; 1 the result shape would be like if we did deconvolution with kernel = (1, 1) and stride = (height</em>scale, width<em>scale); and for scale &lt; 1 shape would be like we did convolution with kernel = (1, 1) and stride = (int(1 / height</em>scale), int( 1/ width<em>scale);"like" - resize first input to the height and width of second input; "to</em>even<em>down" - resize input to nearest lower even height and width (if original height is odd then result height = original height - 1);"to</em>even<em>up" - resize input to nearest bigger even height and width (if original height is odd then result height = original height + 1);"to</em>odd<em>down" - resize input to nearest odd height and width (if original height is odd then result height = original height - 1);"to</em>odd_up" - resize input to nearest odd height and width (if original height is odd then result height = original height + 1);</li>
<li><code>align_corners::boolean, optional, default=1</code>: With align_corners = True, the interpolating doesn't proportionally align theoutput and input pixels, and thus the output values can depend on the input size.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L372' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._contrib_CTCLoss-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._contrib_CTCLoss-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._contrib_CTCLoss</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_contrib_CTCLoss(data, label, data_lengths, label_lengths, use_data_lengths, use_label_lengths, blank_label)
</code></pre>

<p><em>contrib</em>CTCLoss is an alias of CTCLoss.</p>
<p>Connectionist Temporal Classification Loss.</p>
<p>.. note:: The existing alias $contrib_CTCLoss$ is deprecated.</p>
<p>The shapes of the inputs and outputs:</p>
<ul>
<li><strong>data</strong>: <code>(sequence_length, batch_size, alphabet_size)</code></li>
<li><strong>label</strong>: <code>(batch_size, label_sequence_length)</code></li>
<li><strong>out</strong>: <code>(batch_size)</code></li>
</ul>
<p>The <code>data</code> tensor consists of sequences of activation vectors (without applying softmax), with i-th channel in the last dimension corresponding to i-th label for i between 0 and alphabet*size-1 (i.e always 0-indexed). Alphabet size should include one additional value reserved for blank label. When <code>blank*label</code>is<code>"first"</code>, the<code>0</code>-th channel is be reserved for activation of blank label, or otherwise if it is "last",<code>(alphabet_size-1)</code>-th channel should be reserved for blank label.</p>
<p>$label$ is an index matrix of integers. When <code>blank_label</code> is $"first"$, the value 0 is then reserved for blank label, and should not be passed in this matrix. Otherwise, when <code>blank_label</code> is $"last"$, the value <code>(alphabet_size-1)</code> is reserved for blank label.</p>
<p>If a sequence of labels is shorter than <em>label</em>sequence<em>length</em>, use the special padding value at the end of the sequence to conform it to the correct length. The padding value is <code>0</code> when <code>blank_label</code> is $"first"$, and <code>-1</code> otherwise.</p>
<p>For example, suppose the vocabulary is <code>[a, b, c]</code>, and in one batch we have three sequences 'ba', 'cbb', and 'abac'. When <code>blank_label</code> is $"first"$, we can index the labels as <code>{'a': 1, 'b': 2, 'c': 3}</code>, and we reserve the 0-th channel for blank label in data tensor. The resulting <code>label</code> tensor should be padded to be::</p>
<p>[[2, 1, 0, 0], [3, 2, 2, 0], [1, 2, 1, 3]]</p>
<p>When <code>blank_label</code> is $"last"$, we can index the labels as <code>{'a': 0, 'b': 1, 'c': 2}</code>, and we reserve the channel index 3 for blank label in data tensor. The resulting <code>label</code> tensor should be padded to be::</p>
<p>[[1, 0, -1, -1], [2, 1, 1, -1], [0, 1, 0, 2]]</p>
<p>$out$ is a list of CTC loss values, one per example in the batch.</p>
<p>See <em>Connectionist Temporal Classification: Labelling Unsegmented Sequence Data with Recurrent Neural Networks</em>, A. Graves <em>et al</em>. for more information on the definition and the algorithm.</p>
<p>Defined in src/operator/nn/ctc_loss.cc:L100</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input ndarray</li>
<li><code>label::NDArray-or-SymbolicNode</code>: Ground-truth labels for the loss.</li>
<li><code>data_lengths::NDArray-or-SymbolicNode</code>: Lengths of data for each of the samples. Only required when use<em>data</em>lengths is true.</li>
<li><code>label_lengths::NDArray-or-SymbolicNode</code>: Lengths of labels for each of the samples. Only required when use<em>label</em>lengths is true.</li>
<li><code>use_data_lengths::boolean, optional, default=0</code>: Whether the data lenghts are decided by <code>data_lengths</code>. If false, the lengths are equal to the max sequence length.</li>
<li><code>use_label_lengths::boolean, optional, default=0</code>: Whether the label lenghts are decided by <code>label_lengths</code>, or derived from <code>padding_mask</code>. If false, the lengths are derived from the first occurrence of the value of <code>padding_mask</code>. The value of <code>padding_mask</code> is $0$ when first CTC label is reserved for blank, and $-1$ when last label is reserved for blank. See <code>blank_label</code>.</li>
<li><code>blank_label::{'first', 'last'},optional, default='first'</code>: Set the label that is reserved for blank label.If "first", 0-th label is reserved, and label values for tokens in the vocabulary are between $1$ and $alphabet_size-1$, and the padding mask is $-1$. If "last", last label value $alphabet_size-1$ is reserved for blank label instead, and label values for tokens in the vocabulary are between $0$ and $alphabet_size-2$, and the padding mask is $0$.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L408' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._contrib_DeformableConvolution-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._contrib_DeformableConvolution-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._contrib_DeformableConvolution</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_contrib_DeformableConvolution(data, offset, weight, bias, kernel, stride, dilate, pad, num_filter, num_group, num_deformable_group, workspace, no_bias, layout)
</code></pre>

<p>Compute 2-D deformable convolution on 4-D input.</p>
<p>The deformable convolution operation is described in https://arxiv.org/abs/1703.06211</p>
<p>For 2-D deformable convolution, the shapes are</p>
<ul>
<li><strong>data</strong>: <em>(batch_size, channel, height, width)</em></li>
<li><strong>offset</strong>: <em>(batch</em>size, num<em>deformable_group * kernel[0] * kernel[1] * 2, height, width)</em></li>
<li><strong>weight</strong>: <em>(num_filter, channel, kernel[0], kernel[1])</em></li>
<li><strong>bias</strong>: <em>(num_filter,)</em></li>
<li><strong>out</strong>: <em>(batch</em>size, num<em>filter, out</em>height, out<em>width)</em>.</li>
</ul>
<p>Define::</p>
<p>f(x,k,p,s,d) = floor((x+2<em>p-d</em>(k-1)-1)/s)+1</p>
<p>then we have::</p>
<p>out<em>height=f(height, kernel[0], pad[0], stride[0], dilate[0])   out</em>width=f(width, kernel[1], pad[1], stride[1], dilate[1])</p>
<p>If $no_bias$ is set to be true, then the $bias$ term is ignored.</p>
<p>The default data $layout$ is <em>NCHW</em>, namely <em>(batch_size, channle, height, width)</em>.</p>
<p>If $num_group$ is larger than 1, denoted by <em>g</em>, then split the input $data$ evenly into <em>g</em> parts along the channel axis, and also evenly split $weight$ along the first dimension. Next compute the convolution on the <em>i</em>-th part of the data with the <em>i</em>-th weight part. The output is obtained by concating all the <em>g</em> results.</p>
<p>If $num_deformable_group$ is larger than 1, denoted by <em>dg</em>, then split the input $offset$ evenly into <em>dg</em> parts along the channel axis, and also evenly split $data$ into <em>dg</em> parts along the channel axis. Next compute the deformable convolution, apply the <em>i</em>-th part of the offset on the <em>i</em>-th part of the data.</p>
<p>Both $weight$ and $bias$ are learnable parameters.</p>
<p>Defined in src/operator/contrib/deformable_convolution.cc:L100</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data to the DeformableConvolutionOp.</li>
<li><code>offset::NDArray-or-SymbolicNode</code>: Input offset to the DeformableConvolutionOp.</li>
<li><code>weight::NDArray-or-SymbolicNode</code>: Weight matrix.</li>
<li><code>bias::NDArray-or-SymbolicNode</code>: Bias parameter.</li>
<li><code>kernel::Shape(tuple), required</code>: Convolution kernel size: (h, w) or (d, h, w)</li>
<li><code>stride::Shape(tuple), optional, default=[]</code>: Convolution stride: (h, w) or (d, h, w). Defaults to 1 for each dimension.</li>
<li><code>dilate::Shape(tuple), optional, default=[]</code>: Convolution dilate: (h, w) or (d, h, w). Defaults to 1 for each dimension.</li>
<li><code>pad::Shape(tuple), optional, default=[]</code>: Zero pad for convolution: (h, w) or (d, h, w). Defaults to no padding.</li>
<li><code>num_filter::int, required</code>: Convolution filter(channel) number</li>
<li><code>num_group::int, optional, default='1'</code>: Number of group partitions.</li>
<li><code>num_deformable_group::int, optional, default='1'</code>: Number of deformable group partitions.</li>
<li><code>workspace::long (non-negative), optional, default=1024</code>: Maximum temperal workspace allowed for convolution (MB).</li>
<li><code>no_bias::boolean, optional, default=0</code>: Whether to disable bias parameter.</li>
<li><code>layout::{None, 'NCDHW', 'NCHW', 'NCW'},optional, default='None'</code>: Set layout for input, output and weight. Empty for   default layout: NCW for 1d, NCHW for 2d and NCDHW for 3d.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L418' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._contrib_DeformablePSROIPooling-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._contrib_DeformablePSROIPooling-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._contrib_DeformablePSROIPooling</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_contrib_DeformablePSROIPooling(data, rois, trans, spatial_scale, output_dim, group_size, pooled_size, part_size, sample_per_part, trans_std, no_trans)
</code></pre>

<p>Performs deformable position-sensitive region-of-interest pooling on inputs. The DeformablePSROIPooling operation is described in https://arxiv.org/abs/1703.06211 .batch_size will change to the number of region bounding boxes after DeformablePSROIPooling</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::SymbolicNode</code>: Input data to the pooling operator, a 4D Feature maps</li>
<li><code>rois::SymbolicNode</code>: Bounding box coordinates, a 2D array of [[batch<em>index, x1, y1, x2, y2]]. (x1, y1) and (x2, y2) are top left and down right corners of designated region of interest. batch</em>index indicates the index of corresponding image in the input data</li>
<li><code>trans::SymbolicNode</code>: transition parameter</li>
<li><code>spatial_scale::float, required</code>: Ratio of input feature map height (or w) to raw image height (or w). Equals the reciprocal of total stride in convolutional layers</li>
<li><code>output_dim::int, required</code>: fix output dim</li>
<li><code>group_size::int, required</code>: fix group size</li>
<li><code>pooled_size::int, required</code>: fix pooled size</li>
<li><code>part_size::int, optional, default='0'</code>: fix part size</li>
<li><code>sample_per_part::int, optional, default='1'</code>: fix samples per part</li>
<li><code>trans_std::float, optional, default=0</code>: fix transition std</li>
<li><code>no_trans::boolean, optional, default=0</code>: Whether to disable trans parameter.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L368' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._contrib_ModulatedDeformableConvolution-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._contrib_ModulatedDeformableConvolution-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._contrib_ModulatedDeformableConvolution</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_contrib_ModulatedDeformableConvolution(data, offset, mask, weight, bias, kernel, stride, dilate, pad, num_filter, num_group, num_deformable_group, workspace, no_bias, im2col_step, layout)
</code></pre>

<p>Compute 2-D modulated deformable convolution on 4-D input.</p>
<p>The modulated deformable convolution operation is described in https://arxiv.org/abs/1811.11168</p>
<p>For 2-D modulated deformable convolution, the shapes are</p>
<ul>
<li><strong>data</strong>: <em>(batch_size, channel, height, width)</em></li>
<li><strong>offset</strong>: <em>(batch</em>size, num<em>deformable_group * kernel[0] * kernel[1] * 2, height, width)</em></li>
<li><strong>mask</strong>: <em>(batch</em>size, num<em>deformable_group * kernel[0] * kernel[1], height, width)</em></li>
<li><strong>weight</strong>: <em>(num_filter, channel, kernel[0], kernel[1])</em></li>
<li><strong>bias</strong>: <em>(num_filter,)</em></li>
<li><strong>out</strong>: <em>(batch</em>size, num<em>filter, out</em>height, out<em>width)</em>.</li>
</ul>
<p>Define::</p>
<p>f(x,k,p,s,d) = floor((x+2<em>p-d</em>(k-1)-1)/s)+1</p>
<p>then we have::</p>
<p>out<em>height=f(height, kernel[0], pad[0], stride[0], dilate[0])   out</em>width=f(width, kernel[1], pad[1], stride[1], dilate[1])</p>
<p>If $no_bias$ is set to be true, then the $bias$ term is ignored.</p>
<p>The default data $layout$ is <em>NCHW</em>, namely <em>(batch_size, channle, height, width)</em>.</p>
<p>If $num_group$ is larger than 1, denoted by <em>g</em>, then split the input $data$ evenly into <em>g</em> parts along the channel axis, and also evenly split $weight$ along the first dimension. Next compute the convolution on the <em>i</em>-th part of the data with the <em>i</em>-th weight part. The output is obtained by concating all the <em>g</em> results.</p>
<p>If $num_deformable_group$ is larger than 1, denoted by <em>dg</em>, then split the input $offset$ evenly into <em>dg</em> parts along the channel axis, and also evenly split $out$ evenly into <em>dg</em> parts along the channel axis. Next compute the deformable convolution, apply the <em>i</em>-th part of the offset part on the <em>i</em>-th out.</p>
<p>Both $weight$ and $bias$ are learnable parameters.</p>
<p>Defined in src/operator/contrib/modulated<em>deformable</em>convolution.cc:L102</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data to the ModulatedDeformableConvolutionOp.</li>
<li><code>offset::NDArray-or-SymbolicNode</code>: Input offset to ModulatedDeformableConvolutionOp.</li>
<li><code>mask::NDArray-or-SymbolicNode</code>: Input mask to the ModulatedDeformableConvolutionOp.</li>
<li><code>weight::NDArray-or-SymbolicNode</code>: Weight matrix.</li>
<li><code>bias::NDArray-or-SymbolicNode</code>: Bias parameter.</li>
<li><code>kernel::Shape(tuple), required</code>: Convolution kernel size: (h, w) or (d, h, w)</li>
<li><code>stride::Shape(tuple), optional, default=[]</code>: Convolution stride: (h, w) or (d, h, w). Defaults to 1 for each dimension.</li>
<li><code>dilate::Shape(tuple), optional, default=[]</code>: Convolution dilate: (h, w) or (d, h, w). Defaults to 1 for each dimension.</li>
<li><code>pad::Shape(tuple), optional, default=[]</code>: Zero pad for convolution: (h, w) or (d, h, w). Defaults to no padding.</li>
<li><code>num_filter::int (non-negative), required</code>: Convolution filter(channel) number</li>
<li><code>num_group::int (non-negative), optional, default=1</code>: Number of group partitions.</li>
<li><code>num_deformable_group::int (non-negative), optional, default=1</code>: Number of deformable group partitions.</li>
<li><code>workspace::long (non-negative), optional, default=1024</code>: Maximum temperal workspace allowed for convolution (MB).</li>
<li><code>no_bias::boolean, optional, default=0</code>: Whether to disable bias parameter.</li>
<li><code>im2col_step::int (non-negative), optional, default=64</code>: Maximum number of images per im2col computation; The total batch size should be divisable by this value or smaller than this value; if you face out of memory problem, you can try to use a smaller value here.</li>
<li><code>layout::{None, 'NCDHW', 'NCHW', 'NCW'},optional, default='None'</code>: Set layout for input, output and weight. Empty for   default layout: NCW for 1d, NCHW for 2d and NCDHW for 3d.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L423' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._contrib_MultiBoxDetection-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._contrib_MultiBoxDetection-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._contrib_MultiBoxDetection</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_contrib_MultiBoxDetection(cls_prob, loc_pred, anchor, clip, threshold, background_id, nms_threshold, force_suppress, variances, nms_topk)
</code></pre>

<p>Convert multibox detection predictions.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>cls_prob::NDArray-or-SymbolicNode</code>: Class probabilities.</li>
<li><code>loc_pred::NDArray-or-SymbolicNode</code>: Location regression predictions.</li>
<li><code>anchor::NDArray-or-SymbolicNode</code>: Multibox prior anchor boxes</li>
<li><code>clip::boolean, optional, default=1</code>: Clip out-of-boundary boxes.</li>
<li><code>threshold::float, optional, default=0.00999999978</code>: Threshold to be a positive prediction.</li>
<li><code>background_id::int, optional, default='0'</code>: Background id.</li>
<li><code>nms_threshold::float, optional, default=0.5</code>: Non-maximum suppression threshold.</li>
<li><code>force_suppress::boolean, optional, default=0</code>: Suppress all detections regardless of class_id.</li>
<li><code>variances::tuple of &lt;float&gt;, optional, default=[0.1,0.1,0.2,0.2]</code>: Variances to be decoded from box regression output.</li>
<li><code>nms_topk::int, optional, default='-1'</code>: Keep maximum top k detections before nms, -1 for no limit.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L365' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._contrib_MultiBoxPrior-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._contrib_MultiBoxPrior-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._contrib_MultiBoxPrior</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_contrib_MultiBoxPrior(data, sizes, ratios, clip, steps, offsets)
</code></pre>

<p>Generate prior(anchor) boxes from data, sizes and ratios.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data.</li>
<li><code>sizes::tuple of &lt;float&gt;, optional, default=[1]</code>: List of sizes of generated MultiBoxPriores.</li>
<li><code>ratios::tuple of &lt;float&gt;, optional, default=[1]</code>: List of aspect ratios of generated MultiBoxPriores.</li>
<li><code>clip::boolean, optional, default=0</code>: Whether to clip out-of-boundary boxes.</li>
<li><code>steps::tuple of &lt;float&gt;, optional, default=[-1,-1]</code>: Priorbox step across y and x, -1 for auto calculation.</li>
<li><code>offsets::tuple of &lt;float&gt;, optional, default=[0.5,0.5]</code>: Priorbox center offsets, y and x respectively</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L357' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._contrib_MultiBoxTarget-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._contrib_MultiBoxTarget-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._contrib_MultiBoxTarget</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_contrib_MultiBoxTarget(anchor, label, cls_pred, overlap_threshold, ignore_label, negative_mining_ratio, negative_mining_thresh, minimum_negative_samples, variances)
</code></pre>

<p>Compute Multibox training targets</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>anchor::NDArray-or-SymbolicNode</code>: Generated anchor boxes.</li>
<li><code>label::NDArray-or-SymbolicNode</code>: Object detection labels.</li>
<li><code>cls_pred::NDArray-or-SymbolicNode</code>: Class predictions.</li>
<li><code>overlap_threshold::float, optional, default=0.5</code>: Anchor-GT overlap threshold to be regarded as a positive match.</li>
<li><code>ignore_label::float, optional, default=-1</code>: Label for ignored anchors.</li>
<li><code>negative_mining_ratio::float, optional, default=-1</code>: Max negative to positive samples ratio, use -1 to disable mining</li>
<li><code>negative_mining_thresh::float, optional, default=0.5</code>: Threshold used for negative mining.</li>
<li><code>minimum_negative_samples::int, optional, default='0'</code>: Minimum number of negative samples.</li>
<li><code>variances::tuple of &lt;float&gt;, optional, default=[0.1,0.1,0.2,0.2]</code>: Variances to be encoded in box regression target.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L363' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._contrib_MultiProposal-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._contrib_MultiProposal-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._contrib_MultiProposal</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_contrib_MultiProposal(cls_prob, bbox_pred, im_info, rpn_pre_nms_top_n, rpn_post_nms_top_n, threshold, rpn_min_size, scales, ratios, feature_stride, output_score, iou_loss)
</code></pre>

<p>Generate region proposals via RPN</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>cls_prob::NDArray-or-SymbolicNode</code>: Score of how likely proposal is object.</li>
<li><code>bbox_pred::NDArray-or-SymbolicNode</code>: BBox Predicted deltas from anchors for proposals</li>
<li><code>im_info::NDArray-or-SymbolicNode</code>: Image size and scale.</li>
<li><code>rpn_pre_nms_top_n::int, optional, default='6000'</code>: Number of top scoring boxes to keep before applying NMS to RPN proposals</li>
<li><code>rpn_post_nms_top_n::int, optional, default='300'</code>: Number of top scoring boxes to keep after applying NMS to RPN proposals</li>
<li><code>threshold::float, optional, default=0.699999988</code>: NMS value, below which to suppress.</li>
<li><code>rpn_min_size::int, optional, default='16'</code>: Minimum height or width in proposal</li>
<li><code>scales::tuple of &lt;float&gt;, optional, default=[4,8,16,32]</code>: Used to generate anchor windows by enumerating scales</li>
<li><code>ratios::tuple of &lt;float&gt;, optional, default=[0.5,1,2]</code>: Used to generate anchor windows by enumerating ratios</li>
<li><code>feature_stride::int, optional, default='16'</code>: The size of the receptive field each unit in the convolution layer of the rpn,for example the product of all stride's prior to this layer.</li>
<li><code>output_score::boolean, optional, default=0</code>: Add score to outputs</li>
<li><code>iou_loss::boolean, optional, default=0</code>: Usage of IoU Loss</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L369' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._contrib_PSROIPooling-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._contrib_PSROIPooling-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._contrib_PSROIPooling</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_contrib_PSROIPooling(data, rois, spatial_scale, output_dim, pooled_size, group_size)
</code></pre>

<p>Performs region-of-interest pooling on inputs. Resize bounding box coordinates by spatial<em>scale and crop input feature maps accordingly. The cropped feature maps are pooled by max pooling to a fixed size output indicated by pooled</em>size. batch_size will change to the number of region bounding boxes after PSROIPooling</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::SymbolicNode</code>: Input data to the pooling operator, a 4D Feature maps</li>
<li><code>rois::SymbolicNode</code>: Bounding box coordinates, a 2D array of [[batch<em>index, x1, y1, x2, y2]]. (x1, y1) and (x2, y2) are top left and down right corners of designated region of interest. batch</em>index indicates the index of corresponding image in the input data</li>
<li><code>spatial_scale::float, required</code>: Ratio of input feature map height (or w) to raw image height (or w). Equals the reciprocal of total stride in convolutional layers</li>
<li><code>output_dim::int, required</code>: fix output dim</li>
<li><code>pooled_size::int, required</code>: fix pooled size</li>
<li><code>group_size::int, optional, default='0'</code>: fix group size</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L357' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._contrib_Proposal-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._contrib_Proposal-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._contrib_Proposal</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_contrib_Proposal(cls_prob, bbox_pred, im_info, rpn_pre_nms_top_n, rpn_post_nms_top_n, threshold, rpn_min_size, scales, ratios, feature_stride, output_score, iou_loss)
</code></pre>

<p>Generate region proposals via RPN</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>cls_prob::NDArray-or-SymbolicNode</code>: Score of how likely proposal is object.</li>
<li><code>bbox_pred::NDArray-or-SymbolicNode</code>: BBox Predicted deltas from anchors for proposals</li>
<li><code>im_info::NDArray-or-SymbolicNode</code>: Image size and scale.</li>
<li><code>rpn_pre_nms_top_n::int, optional, default='6000'</code>: Number of top scoring boxes to keep before applying NMS to RPN proposals</li>
<li><code>rpn_post_nms_top_n::int, optional, default='300'</code>: Number of top scoring boxes to keep after applying NMS to RPN proposals</li>
<li><code>threshold::float, optional, default=0.699999988</code>: NMS value, below which to suppress.</li>
<li><code>rpn_min_size::int, optional, default='16'</code>: Minimum height or width in proposal</li>
<li><code>scales::tuple of &lt;float&gt;, optional, default=[4,8,16,32]</code>: Used to generate anchor windows by enumerating scales</li>
<li><code>ratios::tuple of &lt;float&gt;, optional, default=[0.5,1,2]</code>: Used to generate anchor windows by enumerating ratios</li>
<li><code>feature_stride::int, optional, default='16'</code>: The size of the receptive field each unit in the convolution layer of the rpn,for example the product of all stride's prior to this layer.</li>
<li><code>output_score::boolean, optional, default=0</code>: Add score to outputs</li>
<li><code>iou_loss::boolean, optional, default=0</code>: Usage of IoU Loss</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L369' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._contrib_ROIAlign-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._contrib_ROIAlign-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._contrib_ROIAlign</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_contrib_ROIAlign(data, rois, pooled_size, spatial_scale, sample_ratio, position_sensitive, aligned)
</code></pre>

<p>This operator takes a 4D feature map as an input array and region proposals as <code>rois</code>, then align the feature map over sub-regions of input and produces a fixed-sized output array. This operator is typically used in Faster R-CNN &amp; Mask R-CNN networks. If roi batchid is less  than 0, it will be ignored, and the corresponding output will be set to 0.</p>
<p>Different from ROI pooling, ROI Align removes the harsh quantization, properly aligning the extracted features with the input. RoIAlign computes the value of each sampling point by bilinear interpolation from the nearby grid points on the feature map. No quantization is performed on any coordinates involved in the RoI, its bins, or the sampling points. Bilinear interpolation is used to compute the exact values of the input features at four regularly sampled locations in each RoI bin. Then the feature map can be aggregated by avgpooling.</p>
<p><strong>References</strong></p>
<p>He, Kaiming, et al. "Mask R-CNN." ICCV, 2017</p>
<p>Defined in src/operator/contrib/roi_align.cc:L559</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data to the pooling operator, a 4D Feature maps</li>
<li><code>rois::NDArray-or-SymbolicNode</code>: Bounding box coordinates, a 2D array, if batchid is less than 0, it will be ignored.</li>
<li><code>pooled_size::Shape(tuple), required</code>: ROI Align output roi feature map height and width: (h, w)</li>
<li><code>spatial_scale::float, required</code>: Ratio of input feature map height (or w) to raw image height (or w). Equals the reciprocal of total stride in convolutional layers</li>
<li><code>sample_ratio::int, optional, default='-1'</code>: Optional sampling ratio of ROI align, using adaptive size by default.</li>
<li><code>position_sensitive::boolean, optional, default=0</code>: Whether to perform position-sensitive RoI pooling. PSRoIPooling is first proposaled by R-FCN and it can reduce the input channels by ph*pw times, where (ph, pw) is the pooled_size</li>
<li><code>aligned::boolean, optional, default=0</code>: Center-aligned ROIAlign introduced in Detectron2. To enable, set aligned to True.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L380' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._contrib_RROIAlign-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._contrib_RROIAlign-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._contrib_RROIAlign</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_contrib_RROIAlign(data, rois, pooled_size, spatial_scale, sampling_ratio)
</code></pre>

<p>Performs Rotated ROI Align on the input array.</p>
<p>This operator takes a 4D feature map as an input array and region proposals as <code>rois</code>, then align the feature map over sub-regions of input and produces a fixed-sized output array.</p>
<p>Different from ROI Align, RROI Align uses rotated rois, which is suitable for text detection. RRoIAlign computes the value of each sampling point by bilinear interpolation from the nearby grid points on the rotated feature map. No quantization is performed on any coordinates involved in the RoI, its bins, or the sampling points. Bilinear interpolation is used to compute the exact values of the input features at four regularly sampled locations in each RoI bin. Then the feature map can be aggregated by avgpooling.</p>
<p><strong>References</strong></p>
<p>Ma, Jianqi, et al. "Arbitrary-Oriented Scene Text Detection via Rotation Proposals." IEEE Transactions on Multimedia, 2018.</p>
<p>Defined in src/operator/contrib/rroi_align.cc:L274</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data to the pooling operator, a 4D Feature maps</li>
<li><code>rois::NDArray-or-SymbolicNode</code>: Bounding box coordinates, a 2D array</li>
<li><code>pooled_size::Shape(tuple), required</code>: RROI align output shape (h,w)</li>
<li><code>spatial_scale::float, required</code>: Ratio of input feature map height (or width) to raw image height (or width). Equals the reciprocal of total stride in convolutional layers</li>
<li><code>sampling_ratio::int, optional, default='-1'</code>: Optional sampling ratio of RROI align, using adaptive size by default.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L375' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._contrib_SparseEmbedding-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._contrib_SparseEmbedding-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._contrib_SparseEmbedding</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_contrib_SparseEmbedding(data, weight, input_dim, output_dim, dtype, sparse_grad)
</code></pre>

<p>Maps integer indices to vector representations (embeddings).</p>
<p>note:: $contrib.SparseEmbedding$ is deprecated, use $Embedding$ instead.</p>
<p>This operator maps words to real-valued vectors in a high-dimensional space, called word embeddings. These embeddings can capture semantic and syntactic properties of the words. For example, it has been noted that in the learned embedding spaces, similar words tend to be close to each other and dissimilar words far apart.</p>
<p>For an input array of shape (d1, ..., dK), the shape of an output array is (d1, ..., dK, output<em>dim). All the input values should be integers in the range [0, input</em>dim).</p>
<p>If the input<em>dim is ip0 and output</em>dim is op0, then shape of the embedding weight matrix must be (ip0, op0).</p>
<p>The storage type of the gradient will be <code>row_sparse</code>.</p>
<p>.. Note::</p>
<pre><code>`SparseEmbedding` is designed for the use case where `input_dim` is very large (e.g. 100k).
The operator is available on both CPU and GPU.
When `deterministic` is set to `True`, the accumulation of gradients follows a
deterministic order if a feature appears multiple times in the input. However, the
accumulation is usually slower when the order is enforced on GPU.
When the operator is used on the GPU, the recommended value for `deterministic` is `True`.
</code></pre>

<p>Examples::</p>
<p>input<em>dim = 4   output</em>dim = 5</p>
<p>// Each row in weight matrix y represents a word. So, y = (w0,w1,w2,w3)   y = [[  0.,   1.,   2.,   3.,   4.],        [  5.,   6.,   7.,   8.,   9.],        [ 10.,  11.,  12.,  13.,  14.],        [ 15.,  16.,  17.,  18.,  19.]]</p>
<p>// Input array x represents n-grams(2-gram). So, x = [(w1,w3), (w0,w2)]   x = [[ 1.,  3.],        [ 0.,  2.]]</p>
<p>// Mapped input x to its vector representation y.   SparseEmbedding(x, y, 4, 5) = [[[  5.,   6.,   7.,   8.,   9.],                                  [ 15.,  16.,  17.,  18.,  19.]],</p>
<pre><code>                            [[  0.,   1.,   2.,   3.,   4.],
                             [ 10.,  11.,  12.,  13.,  14.]]]
</code></pre>

<p>Defined in src/operator/tensor/indexing_op.cc:L680</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array to the embedding operator.</li>
<li><code>weight::NDArray-or-SymbolicNode</code>: The embedding weight matrix.</li>
<li><code>input_dim::int, required</code>: Vocabulary size of the input indices.</li>
<li><code>output_dim::int, required</code>: Dimension of the embedding vectors.</li>
<li><code>dtype::{'bfloat16', 'float16', 'float32', 'float64', 'int32', 'int64', 'int8', 'uint8'},optional, default='float32'</code>: Data type of weight.</li>
<li><code>sparse_grad::boolean, optional, default=0</code>: Compute row sparse gradient in the backward calculation. If set to True, the grad's storage type is row_sparse.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L408' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._contrib_SyncBatchNorm-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._contrib_SyncBatchNorm-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._contrib_SyncBatchNorm</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_contrib_SyncBatchNorm(data, gamma, beta, moving_mean, moving_var, eps, momentum, fix_gamma, use_global_stats, output_mean_var, ndev, key)
</code></pre>

<p>Batch normalization.</p>
<p>Normalizes a data batch by mean and variance, and applies a scale $gamma$ as well as offset $beta$. Standard BN [1]<em> implementation only normalize the data within each device. SyncBN normalizes the input within the whole mini-batch. We follow the sync-onece implmentation described in the paper [2]</em>.</p>
<p>Assume the input has more than one dimension and we normalize along axis 1. We first compute the mean and variance along this axis:</p>
<p>.. math::</p>
<p>data_mean[i] = mean(data[:,i,:,...]) \
  data_var[i] = var(data[:,i,:,...])</p>
<p>Then compute the normalized output, which has the same shape as input, as following:</p>
<p>.. math::</p>
<p>out[:,i,:,...] = \frac{data[:,i,:,...] - data_mean[i]}{\sqrt{data_var[i]+\epsilon}} * gamma[i] + beta[i]</p>
<p>Both <em>mean</em> and <em>var</em> returns a scalar by treating the input as a vector.</p>
<p>Assume the input has size <em>k</em> on axis 1, then both $gamma$ and $beta$ have shape <em>(k,)</em>. If $output_mean_var$ is set to be true, then outputs both $data_mean$ and $data_var$ as well, which are needed for the backward pass.</p>
<p>Besides the inputs and the outputs, this operator accepts two auxiliary states, $moving_mean$ and $moving_var$, which are <em>k</em>-length vectors. They are global statistics for the whole dataset, which are updated by::</p>
<p>moving<em>mean = moving</em>mean * momentum + data<em>mean * (1 - momentum)   moving</em>var = moving<em>var * momentum + data</em>var * (1 - momentum)</p>
<p>If $use_global_stats$ is set to be true, then $moving_mean$ and $moving_var$ are used instead of $data_mean$ and $data_var$ to compute the output. It is often used during inference.</p>
<p>Both $gamma$ and $beta$ are learnable parameters. But if $fix_gamma$ is true, then set $gamma$ to 1 and its gradient to 0.</p>
<p>Reference:   .. [1] Ioffe, Sergey, and Christian Szegedy. "Batch normalization: Accelerating 
    deep network training by reducing internal covariate shift." <em>ICML 2015</em>   .. [2] Hang Zhang, Kristin Dana, Jianping Shi, Zhongyue Zhang, Xiaogang Wang, 
    Ambrish Tyagi, and Amit Agrawal. "Context Encoding for Semantic Segmentation." <em>CVPR 2018</em></p>
<p>Defined in src/operator/contrib/sync<em>batch</em>norm.cc:L97</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data to batch normalization</li>
<li><code>gamma::NDArray-or-SymbolicNode</code>: gamma array</li>
<li><code>beta::NDArray-or-SymbolicNode</code>: beta array</li>
<li><code>moving_mean::NDArray-or-SymbolicNode</code>: running mean of input</li>
<li><code>moving_var::NDArray-or-SymbolicNode</code>: running variance of input</li>
<li><code>eps::float, optional, default=0.00100000005</code>: Epsilon to prevent div 0</li>
<li><code>momentum::float, optional, default=0.899999976</code>: Momentum for moving average</li>
<li><code>fix_gamma::boolean, optional, default=1</code>: Fix gamma while training</li>
<li><code>use_global_stats::boolean, optional, default=0</code>: Whether use global moving statistics instead of local batch-norm. This will force change batch-norm into a scale shift operator.</li>
<li><code>output_mean_var::boolean, optional, default=0</code>: Output All,normal mean and var</li>
<li><code>ndev::int, optional, default='1'</code>: The count of GPU devices</li>
<li><code>key::string, required</code>: Hash key for synchronization, please set the same hash key for same layer, Block.prefix is typically used as in :class:<code>gluon.nn.contrib.SyncBatchNorm</code>.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L419' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._contrib_allclose-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._contrib_allclose-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._contrib_allclose</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_contrib_allclose(a, b, rtol, atol, equal_nan)
</code></pre>

<p>This operators implements the numpy.allclose(a, b, rtol=1e-05, atol=1e-08, equal_nan=False)</p>
<p>.. math::</p>
<pre><code>f(x) = |a-b|&lt;=atol+rtol|b|
</code></pre>

<p>where :math:<code>a, b</code> are the input tensors of equal types an shapes :math:<code>atol, rtol</code> the values of absolute and relative tolerance (by default, rtol=1e-05, atol=1e-08)</p>
<p>Examples::</p>
<p>a = [1e10, 1e-7],   b = [1.00001e10, 1e-8]   y = allclose(a, b)   y = False</p>
<p>a = [1e10, 1e-8],   b = [1.00001e10, 1e-9]   y = allclose(a, b)   y = True</p>
<p>Defined in src/operator/contrib/allclose_op.cc:L55</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>a::NDArray-or-SymbolicNode</code>: Input array a</li>
<li><code>b::NDArray-or-SymbolicNode</code>: Input array b</li>
<li><code>rtol::float, optional, default=9.99999975e-06</code>: Relative tolerance.</li>
<li><code>atol::float, optional, default=9.99999994e-09</code>: Absolute tolerance.</li>
<li><code>equal_nan::boolean, optional, default=1</code>: Whether to compare NaN's as equal. If True, NaN's in A will be considered equal to NaN's in B in the output array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L379' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._contrib_arange_like-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._contrib_arange_like-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._contrib_arange_like</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_contrib_arange_like(data, start, step, repeat, ctx, axis)
</code></pre>

<p>Return an array with evenly spaced values. If axis is not given, the output will  have the same shape as the input array. Otherwise, the output will be a 1-D array with size of  the specified axis in input shape.</p>
<p>Examples::</p>
<p>x = [[0.14883883 0.7772398  0.94865847 0.7225052 ]        [0.23729339 0.6112595  0.66538996 0.5132841 ]        [0.30822644 0.9912457  0.15502319 0.7043658 ]]        <NDArray 3x4 @cpu(0)></p>
<p>out = mx.nd.contrib.arange_like(x, start=0)</p>
<pre><code>[[ 0.  1.  2.  3.]
 [ 4.  5.  6.  7.]
 [ 8.  9. 10. 11.]]
 &lt;NDArray 3x4 @cpu(0)&gt;
</code></pre>

<p>out = mx.nd.contrib.arange_like(x, start=0, axis=-1)</p>
<pre><code>[0. 1. 2. 3.]
&lt;NDArray 4 @cpu(0)&gt;
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input</li>
<li><code>start::double, optional, default=0</code>: Start of interval. The interval includes this value. The default start value is 0.</li>
<li><code>step::double, optional, default=1</code>: Spacing between values.</li>
<li><code>repeat::int, optional, default='1'</code>: The repeating time of all elements. E.g repeat=3, the element a will be repeated three times –&gt; a, a, a.</li>
<li><code>ctx::string, optional, default=''</code>: Context of output, in format <a href="n">cpu|gpu|cpu_pinned</a>.Only used for imperative calls.</li>
<li><code>axis::int or None, optional, default='None'</code>: Arange elements according to the size of a certain axis of input array. The negative numbers are interpreted counting from the backward. If not provided, will arange elements according to the input shape.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L379' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._contrib_backward_gradientmultiplier-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._contrib_backward_gradientmultiplier-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._contrib_backward_gradientmultiplier</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_contrib_backward_gradientmultiplier(data, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._contrib_backward_hawkesll-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._contrib_backward_hawkesll-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._contrib_backward_hawkesll</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_contrib_backward_hawkesll()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._contrib_backward_index_copy-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._contrib_backward_index_copy-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._contrib_backward_index_copy</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_contrib_backward_index_copy()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._contrib_backward_quadratic-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._contrib_backward_quadratic-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._contrib_backward_quadratic</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_contrib_backward_quadratic()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._contrib_bipartite_matching-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._contrib_bipartite_matching-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._contrib_bipartite_matching</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_contrib_bipartite_matching(data, is_ascend, threshold, topk)
</code></pre>

<p>Compute bipartite matching.   The matching is performed on score matrix with shape [B, N, M]</p>
<ul>
<li>B: batch_size</li>
<li>N: number of rows to match</li>
<li>M: number of columns as reference to be matched against.</li>
</ul>
<p>Returns:   x : matched column indices. -1 indicating non-matched elements in rows.   y : matched row indices.</p>
<p>Note::</p>
<pre><code>Zero gradients are back-propagated in this op for now.
</code></pre>

<p>Example::</p>
<pre><code>s = [[0.5, 0.6], [0.1, 0.2], [0.3, 0.4]]
x, y = bipartite_matching(x, threshold=1e-12, is_ascend=False)
x = [1, -1, 0]
y = [2, 0]
</code></pre>

<p>Defined in src/operator/contrib/bounding_box.cc:L183</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input</li>
<li><code>is_ascend::boolean, optional, default=0</code>: Use ascend order for scores instead of descending. Please set threshold accordingly.</li>
<li><code>threshold::float, required</code>: Ignore matching when score &lt; thresh, if is<em>ascend=false, or ignore score &gt; thresh, if is</em>ascend=true.</li>
<li><code>topk::int, optional, default='-1'</code>: Limit the number of matches to topk, set -1 for no limit</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L376' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._contrib_boolean_mask-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._contrib_boolean_mask-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._contrib_boolean_mask</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_contrib_boolean_mask(data, index, axis)
</code></pre>

<p>Given an n-d NDArray data, and a 1-d NDArray index, the operator produces an un-predeterminable shaped n-d NDArray out, which stands for the rows in x where the corresonding element in index is non-zero.</p>
<blockquote>
<blockquote>
<blockquote>
<p>data = mx.nd.array([[1, 2, 3],[4, 5, 6],[7, 8, 9]]) index = mx.nd.array([0, 1, 0]) out = mx.nd.contrib.boolean_mask(data, index) out</p>
</blockquote>
</blockquote>
</blockquote>
<p>[[4. 5. 6.]] <NDArray 1x3 @cpu(0)></p>
<p>Defined in src/operator/contrib/boolean_mask.cc:L201</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Data</li>
<li><code>index::NDArray-or-SymbolicNode</code>: Mask</li>
<li><code>axis::int, optional, default='0'</code>: An integer that represents the axis in NDArray to mask from.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L366' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._contrib_box_decode-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._contrib_box_decode-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._contrib_box_decode</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_contrib_box_decode(data, anchors, std0, std1, std2, std3, clip, format)
</code></pre>

<p>Decode bounding boxes training target with normalized center offsets.     Input bounding boxes are using corner type: <code>x_{min}, y_{min}, x_{max}, y_{max}</code>     or center type: `x, y, width, height.) array</p>
<p>Defined in src/operator/contrib/bounding_box.cc:L234</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: (B, N, 4) predicted bbox offset</li>
<li><code>anchors::NDArray-or-SymbolicNode</code>: (1, N, 4) encoded in corner or center</li>
<li><code>std0::float, optional, default=1</code>: value to be divided from the 1st encoded values</li>
<li><code>std1::float, optional, default=1</code>: value to be divided from the 2nd encoded values</li>
<li><code>std2::float, optional, default=1</code>: value to be divided from the 3rd encoded values</li>
<li><code>std3::float, optional, default=1</code>: value to be divided from the 4th encoded values</li>
<li><code>clip::float, optional, default=-1</code>: If larger than 0, bounding box target will be clipped to this value.</li>
<li><code>format::{'center', 'corner'},optional, default='center'</code>: The box encoding type.</li>
</ul>
<p>"corner" means boxes are encoded as [xmin, ymin, xmax, ymax], "center" means boxes are encodes as [x, y, width, height].</p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L367' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._contrib_box_encode-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._contrib_box_encode-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._contrib_box_encode</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_contrib_box_encode(samples, matches, anchors, refs, means, stds)
</code></pre>

<p>Encode bounding boxes training target with normalized center offsets.     Input bounding boxes are using corner type: <code>x_{min}, y_{min}, x_{max}, y_{max}</code>.) array</p>
<p>Defined in src/operator/contrib/bounding_box.cc:L211</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>samples::NDArray-or-SymbolicNode</code>: (B, N) value +1 (positive), -1 (negative), 0 (ignore)</li>
<li><code>matches::NDArray-or-SymbolicNode</code>: (B, N) value range [0, M)</li>
<li><code>anchors::NDArray-or-SymbolicNode</code>: (B, N, 4) encoded in corner</li>
<li><code>refs::NDArray-or-SymbolicNode</code>: (B, M, 4) encoded in corner</li>
<li><code>means::NDArray-or-SymbolicNode</code>: (4,) Mean value to be subtracted from encoded values</li>
<li><code>stds::NDArray-or-SymbolicNode</code>: (4,) Std value to be divided from encoded values</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L361' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._contrib_box_iou-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._contrib_box_iou-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._contrib_box_iou</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_contrib_box_iou(lhs, rhs, format)
</code></pre>

<p>Bounding box overlap of two arrays.   The overlap is defined as Intersection-over-Union, aka, IOU.</p>
<ul>
<li>lhs: (a<em>1, a</em>2, ..., a_n, 4) array</li>
<li>rhs: (b<em>1, b</em>2, ..., b_n, 4) array</li>
<li>output: (a<em>1, a</em>2, ..., a<em>n, b</em>1, b<em>2, ..., b</em>n) array</li>
</ul>
<p>Note::</p>
<pre><code>Zero gradients are back-propagated in this op for now.
</code></pre>

<p>Example::</p>
<pre><code>x = [[0.5, 0.5, 1.0, 1.0], [0.0, 0.0, 0.5, 0.5]]
y = [[0.25, 0.25, 0.75, 0.75]]
box_iou(x, y, format='corner') = [[0.1428], [0.1428]]
</code></pre>

<p>Defined in src/operator/contrib/bounding_box.cc:L137</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: The first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: The second input</li>
<li><code>format::{'center', 'corner'},optional, default='corner'</code>: The box encoding type.</li>
</ul>
<p>"corner" means boxes are encoded as [xmin, ymin, xmax, ymax], "center" means boxes are encodes as [x, y, width, height].</p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L370' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._contrib_box_nms-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._contrib_box_nms-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._contrib_box_nms</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_contrib_box_nms(data, overlap_thresh, valid_thresh, topk, coord_start, score_index, id_index, background_id, force_suppress, in_format, out_format)
</code></pre>

<p>Apply non-maximum suppression to input.</p>
<p>The output will be sorted in descending order according to <code>score</code>. Boxes with overlaps larger than <code>overlap_thresh</code>, smaller scores and background boxes will be removed and filled with -1, the corresponding position will be recorded for backward propogation.</p>
<p>During back-propagation, the gradient will be copied to the original position according to the input index. For positions that have been suppressed, the in_grad will be assigned 0. In summary, gradients are sticked to its boxes, will either be moved or discarded according to its original index in input.</p>
<p>Input requirements::</p>
<ol>
<li>Input tensor have at least 2 dimensions, (n, k), any higher dims will be regarded</li>
</ol>
<p>as batch, e.g. (a, b, c, d, n, k) == (a<em>b</em>c*d, n, k)</p>
<ol>
<li>n is the number of boxes in each batch</li>
<li>k is the width of each box item.</li>
</ol>
<p>By default, a box is [id, score, xmin, ymin, xmax, ymax, ...], additional elements are allowed.</p>
<ul>
<li><code>id_index</code>: optional, use -1 to ignore, useful if <code>force_suppress=False</code>, which means we will skip highly overlapped boxes if one is <code>apple</code> while the other is <code>car</code>.</li>
<li><code>background_id</code>: optional, default=-1, class id for background boxes, useful when <code>id_index &gt;= 0</code> which means boxes with background id will be filtered before nms.</li>
<li>
<p><code>coord_start</code>: required, default=2, the starting index of the 4 coordinates. Two formats are supported:</p>
<ul>
<li><code>corner</code>: [xmin, ymin, xmax, ymax]</li>
<li><code>center</code>: [x, y, width, height]</li>
<li><code>score_index</code>: required, default=1, box score/confidence. When two boxes overlap IOU &gt; <code>overlap_thresh</code>, the one with smaller score will be suppressed.</li>
<li><code>in_format</code> and <code>out_format</code>: default='corner', specify in/out box formats.</li>
</ul>
</li>
</ul>
<p>Examples::</p>
<p>x = [[0, 0.5, 0.1, 0.1, 0.2, 0.2], [1, 0.4, 0.1, 0.1, 0.2, 0.2],        [0, 0.3, 0.1, 0.1, 0.14, 0.14], [2, 0.6, 0.5, 0.5, 0.7, 0.8]]   box<em>nms(x, overlap</em>thresh=0.1, coord<em>start=2, score</em>index=1, id<em>index=0,       force</em>suppress=True, in<em>format='corner', out</em>typ='corner') =       [[2, 0.6, 0.5, 0.5, 0.7, 0.8], [0, 0.5, 0.1, 0.1, 0.2, 0.2],        [-1, -1, -1, -1, -1, -1], [-1, -1, -1, -1, -1, -1]]   out_grad = [[0.1, 0.1, 0.1, 0.1, 0.1, 0.1], [0.2, 0.2, 0.2, 0.2, 0.2, 0.2],               [0.3, 0.3, 0.3, 0.3, 0.3, 0.3], [0.4, 0.4, 0.4, 0.4, 0.4, 0.4]]</p>
<p><strong>exe.backward</strong></p>
<p>in_grad = [[0.2, 0.2, 0.2, 0.2, 0.2, 0.2], [0, 0, 0, 0, 0, 0],              [0, 0, 0, 0, 0, 0], [0.1, 0.1, 0.1, 0.1, 0.1, 0.1]]</p>
<p>Defined in src/operator/contrib/bounding_box.cc:L95</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input</li>
<li><code>overlap_thresh::float, optional, default=0.5</code>: Overlapping(IoU) threshold to suppress object with smaller score.</li>
<li><code>valid_thresh::float, optional, default=0</code>: Filter input boxes to those whose scores greater than valid_thresh.</li>
<li><code>topk::int, optional, default='-1'</code>: Apply nms to topk boxes with descending scores, -1 to no restriction.</li>
<li><code>coord_start::int, optional, default='2'</code>: Start index of the consecutive 4 coordinates.</li>
<li><code>score_index::int, optional, default='1'</code>: Index of the scores/confidence of boxes.</li>
<li><code>id_index::int, optional, default='-1'</code>: Optional, index of the class categories, -1 to disable.</li>
<li><code>background_id::int, optional, default='-1'</code>: Optional, id of the background class which will be ignored in nms.</li>
<li><code>force_suppress::boolean, optional, default=0</code>: Optional, if set false and id_index is provided, nms will only apply to boxes belongs to the same category</li>
<li><code>in_format::{'center', 'corner'},optional, default='corner'</code>: The input box encoding type.</li>
</ul>
<p>"corner" means boxes are encoded as [xmin, ymin, xmax, ymax], "center" means boxes are encodes as [x, y, width, height].</p>
<ul>
<li><code>out_format::{'center', 'corner'},optional, default='corner'</code>: The output box encoding type.</li>
</ul>
<p>"corner" means boxes are encoded as [xmin, ymin, xmax, ymax], "center" means boxes are encodes as [x, y, width, height].</p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L426' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._contrib_box_non_maximum_suppression-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._contrib_box_non_maximum_suppression-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._contrib_box_non_maximum_suppression</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_contrib_box_non_maximum_suppression(data, overlap_thresh, valid_thresh, topk, coord_start, score_index, id_index, background_id, force_suppress, in_format, out_format)
</code></pre>

<p><em>contrib</em>box<em>non</em>maximum<em>suppression is an alias of _contrib</em>box_nms.</p>
<p>Apply non-maximum suppression to input.</p>
<p>The output will be sorted in descending order according to <code>score</code>. Boxes with overlaps larger than <code>overlap_thresh</code>, smaller scores and background boxes will be removed and filled with -1, the corresponding position will be recorded for backward propogation.</p>
<p>During back-propagation, the gradient will be copied to the original position according to the input index. For positions that have been suppressed, the in_grad will be assigned 0. In summary, gradients are sticked to its boxes, will either be moved or discarded according to its original index in input.</p>
<p>Input requirements::</p>
<ol>
<li>Input tensor have at least 2 dimensions, (n, k), any higher dims will be regarded</li>
</ol>
<p>as batch, e.g. (a, b, c, d, n, k) == (a<em>b</em>c*d, n, k)</p>
<ol>
<li>n is the number of boxes in each batch</li>
<li>k is the width of each box item.</li>
</ol>
<p>By default, a box is [id, score, xmin, ymin, xmax, ymax, ...], additional elements are allowed.</p>
<ul>
<li><code>id_index</code>: optional, use -1 to ignore, useful if <code>force_suppress=False</code>, which means we will skip highly overlapped boxes if one is <code>apple</code> while the other is <code>car</code>.</li>
<li><code>background_id</code>: optional, default=-1, class id for background boxes, useful when <code>id_index &gt;= 0</code> which means boxes with background id will be filtered before nms.</li>
<li>
<p><code>coord_start</code>: required, default=2, the starting index of the 4 coordinates. Two formats are supported:</p>
<ul>
<li><code>corner</code>: [xmin, ymin, xmax, ymax]</li>
<li><code>center</code>: [x, y, width, height]</li>
<li><code>score_index</code>: required, default=1, box score/confidence. When two boxes overlap IOU &gt; <code>overlap_thresh</code>, the one with smaller score will be suppressed.</li>
<li><code>in_format</code> and <code>out_format</code>: default='corner', specify in/out box formats.</li>
</ul>
</li>
</ul>
<p>Examples::</p>
<p>x = [[0, 0.5, 0.1, 0.1, 0.2, 0.2], [1, 0.4, 0.1, 0.1, 0.2, 0.2],        [0, 0.3, 0.1, 0.1, 0.14, 0.14], [2, 0.6, 0.5, 0.5, 0.7, 0.8]]   box<em>nms(x, overlap</em>thresh=0.1, coord<em>start=2, score</em>index=1, id<em>index=0,       force</em>suppress=True, in<em>format='corner', out</em>typ='corner') =       [[2, 0.6, 0.5, 0.5, 0.7, 0.8], [0, 0.5, 0.1, 0.1, 0.2, 0.2],        [-1, -1, -1, -1, -1, -1], [-1, -1, -1, -1, -1, -1]]   out_grad = [[0.1, 0.1, 0.1, 0.1, 0.1, 0.1], [0.2, 0.2, 0.2, 0.2, 0.2, 0.2],               [0.3, 0.3, 0.3, 0.3, 0.3, 0.3], [0.4, 0.4, 0.4, 0.4, 0.4, 0.4]]</p>
<p><strong>exe.backward</strong></p>
<p>in_grad = [[0.2, 0.2, 0.2, 0.2, 0.2, 0.2], [0, 0, 0, 0, 0, 0],              [0, 0, 0, 0, 0, 0], [0.1, 0.1, 0.1, 0.1, 0.1, 0.1]]</p>
<p>Defined in src/operator/contrib/bounding_box.cc:L95</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input</li>
<li><code>overlap_thresh::float, optional, default=0.5</code>: Overlapping(IoU) threshold to suppress object with smaller score.</li>
<li><code>valid_thresh::float, optional, default=0</code>: Filter input boxes to those whose scores greater than valid_thresh.</li>
<li><code>topk::int, optional, default='-1'</code>: Apply nms to topk boxes with descending scores, -1 to no restriction.</li>
<li><code>coord_start::int, optional, default='2'</code>: Start index of the consecutive 4 coordinates.</li>
<li><code>score_index::int, optional, default='1'</code>: Index of the scores/confidence of boxes.</li>
<li><code>id_index::int, optional, default='-1'</code>: Optional, index of the class categories, -1 to disable.</li>
<li><code>background_id::int, optional, default='-1'</code>: Optional, id of the background class which will be ignored in nms.</li>
<li><code>force_suppress::boolean, optional, default=0</code>: Optional, if set false and id_index is provided, nms will only apply to boxes belongs to the same category</li>
<li><code>in_format::{'center', 'corner'},optional, default='corner'</code>: The input box encoding type.</li>
</ul>
<p>"corner" means boxes are encoded as [xmin, ymin, xmax, ymax], "center" means boxes are encodes as [x, y, width, height].</p>
<ul>
<li><code>out_format::{'center', 'corner'},optional, default='corner'</code>: The output box encoding type.</li>
</ul>
<p>"corner" means boxes are encoded as [xmin, ymin, xmax, ymax], "center" means boxes are encodes as [x, y, width, height].</p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L428' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._contrib_calibrate_entropy-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._contrib_calibrate_entropy-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._contrib_calibrate_entropy</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_contrib_calibrate_entropy(hist, hist_edges, num_quantized_bins)
</code></pre>

<p>Provide calibrated min/max for input histogram.</p>
<p>.. Note::     This operator only supports forward propagation. DO NOT use it in training.</p>
<p>Defined in src/operator/quantization/calibrate.cc:L197</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>hist::NDArray-or-SymbolicNode</code>: A ndarray/symbol of type <code>float32</code></li>
<li><code>hist_edges::NDArray-or-SymbolicNode</code>: A ndarray/symbol of type <code>float32</code></li>
<li><code>num_quantized_bins::int, optional, default='255'</code>: The number of quantized bins.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L356' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._contrib_count_sketch-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._contrib_count_sketch-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._contrib_count_sketch</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_contrib_count_sketch(data, h, s, out_dim, processing_batch_size)
</code></pre>

<p>Apply CountSketch to input: map a d-dimension data to k-dimension data"</p>
<p>.. note:: <code>count_sketch</code> is only available on GPU.</p>
<p>Assume input data has shape (N, d), sign hash table s has shape (N, d), index hash table h has shape (N, d) and mapping dimension out_dim = k, each element in s is either +1 or -1, each element in h is random integer from 0 to k-1. Then the operator computs:</p>
<p>.. math::    out[h[i]] += data[i] * s[i]</p>
<p>Example::</p>
<p>out<em>dim = 5    x = [[1.2, 2.5, 3.4],[3.2, 5.7, 6.6]]    h = [[0, 3, 4]]    s = [[1, -1, 1]]    mx.contrib.ndarray.count</em>sketch(data=x, h=h, s=s, out_dim = 5) = [[1.2, 0, 0, -2.5, 3.4],                                                                      [3.2, 0, 0, -5.7, 6.6]]</p>
<p>Defined in src/operator/contrib/count_sketch.cc:L67</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data to the CountSketchOp.</li>
<li><code>h::NDArray-or-SymbolicNode</code>: The index vector</li>
<li><code>s::NDArray-or-SymbolicNode</code>: The sign vector</li>
<li><code>out_dim::int, required</code>: The output dimension.</li>
<li><code>processing_batch_size::int, optional, default='32'</code>: How many sketch vectors to process at one time.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L378' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._contrib_ctc_loss-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._contrib_ctc_loss-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._contrib_ctc_loss</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_contrib_ctc_loss(data, label, data_lengths, label_lengths, use_data_lengths, use_label_lengths, blank_label)
</code></pre>

<p><em>contrib</em>ctc_loss is an alias of CTCLoss.</p>
<p>Connectionist Temporal Classification Loss.</p>
<p>.. note:: The existing alias $contrib_CTCLoss$ is deprecated.</p>
<p>The shapes of the inputs and outputs:</p>
<ul>
<li><strong>data</strong>: <code>(sequence_length, batch_size, alphabet_size)</code></li>
<li><strong>label</strong>: <code>(batch_size, label_sequence_length)</code></li>
<li><strong>out</strong>: <code>(batch_size)</code></li>
</ul>
<p>The <code>data</code> tensor consists of sequences of activation vectors (without applying softmax), with i-th channel in the last dimension corresponding to i-th label for i between 0 and alphabet*size-1 (i.e always 0-indexed). Alphabet size should include one additional value reserved for blank label. When <code>blank*label</code>is<code>"first"</code>, the<code>0</code>-th channel is be reserved for activation of blank label, or otherwise if it is "last",<code>(alphabet_size-1)</code>-th channel should be reserved for blank label.</p>
<p>$label$ is an index matrix of integers. When <code>blank_label</code> is $"first"$, the value 0 is then reserved for blank label, and should not be passed in this matrix. Otherwise, when <code>blank_label</code> is $"last"$, the value <code>(alphabet_size-1)</code> is reserved for blank label.</p>
<p>If a sequence of labels is shorter than <em>label</em>sequence<em>length</em>, use the special padding value at the end of the sequence to conform it to the correct length. The padding value is <code>0</code> when <code>blank_label</code> is $"first"$, and <code>-1</code> otherwise.</p>
<p>For example, suppose the vocabulary is <code>[a, b, c]</code>, and in one batch we have three sequences 'ba', 'cbb', and 'abac'. When <code>blank_label</code> is $"first"$, we can index the labels as <code>{'a': 1, 'b': 2, 'c': 3}</code>, and we reserve the 0-th channel for blank label in data tensor. The resulting <code>label</code> tensor should be padded to be::</p>
<p>[[2, 1, 0, 0], [3, 2, 2, 0], [1, 2, 1, 3]]</p>
<p>When <code>blank_label</code> is $"last"$, we can index the labels as <code>{'a': 0, 'b': 1, 'c': 2}</code>, and we reserve the channel index 3 for blank label in data tensor. The resulting <code>label</code> tensor should be padded to be::</p>
<p>[[1, 0, -1, -1], [2, 1, 1, -1], [0, 1, 0, 2]]</p>
<p>$out$ is a list of CTC loss values, one per example in the batch.</p>
<p>See <em>Connectionist Temporal Classification: Labelling Unsegmented Sequence Data with Recurrent Neural Networks</em>, A. Graves <em>et al</em>. for more information on the definition and the algorithm.</p>
<p>Defined in src/operator/nn/ctc_loss.cc:L100</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input ndarray</li>
<li><code>label::NDArray-or-SymbolicNode</code>: Ground-truth labels for the loss.</li>
<li><code>data_lengths::NDArray-or-SymbolicNode</code>: Lengths of data for each of the samples. Only required when use<em>data</em>lengths is true.</li>
<li><code>label_lengths::NDArray-or-SymbolicNode</code>: Lengths of labels for each of the samples. Only required when use<em>label</em>lengths is true.</li>
<li><code>use_data_lengths::boolean, optional, default=0</code>: Whether the data lenghts are decided by <code>data_lengths</code>. If false, the lengths are equal to the max sequence length.</li>
<li><code>use_label_lengths::boolean, optional, default=0</code>: Whether the label lenghts are decided by <code>label_lengths</code>, or derived from <code>padding_mask</code>. If false, the lengths are derived from the first occurrence of the value of <code>padding_mask</code>. The value of <code>padding_mask</code> is $0$ when first CTC label is reserved for blank, and $-1$ when last label is reserved for blank. See <code>blank_label</code>.</li>
<li><code>blank_label::{'first', 'last'},optional, default='first'</code>: Set the label that is reserved for blank label.If "first", 0-th label is reserved, and label values for tokens in the vocabulary are between $1$ and $alphabet_size-1$, and the padding mask is $-1$. If "last", last label value $alphabet_size-1$ is reserved for blank label instead, and label values for tokens in the vocabulary are between $0$ and $alphabet_size-2$, and the padding mask is $0$.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L408' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._contrib_dequantize-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._contrib_dequantize-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._contrib_dequantize</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_contrib_dequantize(data, min_range, max_range, out_type)
</code></pre>

<p>Dequantize the input tensor into a float tensor. min<em>range and max</em>range are scalar floats that specify the range for the output data.</p>
<p>When input data type is <code>uint8</code>, the output is calculated using the following equation:</p>
<p><code>out[i] = in[i] * (max_range - min_range) / 255.0</code>,</p>
<p>When input data type is <code>int8</code>, the output is calculate using the following equation by keep zero centered for the quantized value:</p>
<p><code>out[i] = in[i] * MaxAbs(min_range, max_range) / 127.0</code>,</p>
<p>.. Note::     This operator only supports forward propogation. DO NOT use it in training.</p>
<p>Defined in src/operator/quantization/dequantize.cc:L81</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: A ndarray/symbol of type <code>uint8</code></li>
<li><code>min_range::NDArray-or-SymbolicNode</code>: The minimum scalar value possibly produced for the input in float32</li>
<li><code>max_range::NDArray-or-SymbolicNode</code>: The maximum scalar value possibly produced for the input in float32</li>
<li><code>out_type::{'float32'},optional, default='float32'</code>: Output data type.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L370' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._contrib_dgl_adjacency-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._contrib_dgl_adjacency-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._contrib_dgl_adjacency</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_contrib_dgl_adjacency(data)
</code></pre>

<p>This operator converts a CSR matrix whose values are edge Ids to an adjacency matrix whose values are ones. The output CSR matrix always has the data value of float32.</p>
<p>Example:</p>
<p>.. code:: python</p>
<p>x = [[ 1, 0, 0 ],        [ 0, 2, 0 ],        [ 0, 0, 3 ]]   dgl_adjacency(x) =       [[ 1, 0, 0 ],        [ 0, 1, 0 ],        [ 0, 0, 1 ]]</p>
<p>Defined in src/operator/contrib/dgl_graph.cc:L1393</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input ndarray</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L365' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._contrib_dgl_csr_neighbor_non_uniform_sample-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._contrib_dgl_csr_neighbor_non_uniform_sample-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._contrib_dgl_csr_neighbor_non_uniform_sample</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_contrib_dgl_csr_neighbor_non_uniform_sample(csr_matrix, probability, seed_arrays, num_args, num_hops, num_neighbor, max_num_vertices)
</code></pre>

<p><strong>Note</strong>: <em>contrib</em>dgl<em>csr</em>neighbor<em>non</em>uniform<em>sample takes variable number of positional inputs. So instead of calling as _contrib</em>dgl<em>csr</em>neighbor<em>non</em>uniform<em>sample([x, y, z], num</em>args=3), one should call via <em>contrib</em>dgl<em>csr</em>neighbor<em>non</em>uniform<em>sample(x, y, z), and num</em>args will be determined automatically.</p>
<p>This operator samples sub-graph from a csr graph via an non-uniform probability. The operator is designed for DGL.</p>
<p>The operator outputs four sets of NDArrays to represent the sampled results (the number of NDArrays in each set is the same as the number of seed NDArrays):</p>
<ol>
<li>a set of 1D NDArrays containing the sampled vertices, 2) a set of CSRNDArrays representing</li>
</ol>
<p>the sampled edges, 3) a set of 1D NDArrays with the probability that vertices are sampled,</p>
<ol>
<li>a set of 1D NDArrays indicating the layer where a vertex is sampled.</li>
</ol>
<p>The first set of 1D NDArrays have a length of max<em>num</em>vertices+1. The last element in an NDArray indicate the acutal number of vertices in a subgraph. The third and fourth set of NDArrays have a length of max<em>num</em>vertices, and the valid number of vertices is the same as the ones in the first set.</p>
<p>Example:</p>
<p>.. code:: python</p>
<p>shape = (5, 5)   prob = mx.nd.array([0.9, 0.8, 0.2, 0.4, 0.1], dtype=np.float32)   data<em>np = np.array([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20], dtype=np.int64)   indices</em>np = np.array([1,2,3,4,0,2,3,4,0,1,3,4,0,1,2,4,0,1,2,3], dtype=np.int64)   indptr<em>np = np.array([0,4,8,12,16,20], dtype=np.int64)   a = mx.nd.sparse.csr</em>matrix((data<em>np, indices</em>np, indptr<em>np), shape=shape)   seed = mx.nd.array([0,1,2,3,4], dtype=np.int64)   out = mx.nd.contrib.dgl</em>csr<em>neighbor</em>non<em>uniform</em>sample(a, prob, seed, num<em>args=3, num</em>hops=1, num<em>neighbor=2, max</em>num_vertices=5)</p>
<p>out[0]   [0 1 2 3 4 5]   <NDArray 6 @cpu(0)></p>
<p>out[1].asnumpy()   array([[ 0,  1,  2,  0,  0],          [ 5,  0,  6,  0,  0],          [ 9, 10,  0,  0,  0],          [13, 14,  0,  0,  0],          [ 0, 18, 19,  0,  0]])</p>
<p>out[2]   [0.9 0.8 0.2 0.4 0.1]   <NDArray 5 @cpu(0)></p>
<p>out[3]   [0 0 0 0 0]   <NDArray 5 @cpu(0)></p>
<p>Defined in src/operator/contrib/dgl_graph.cc:L883</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>csr_matrix::NDArray-or-SymbolicNode</code>: csr matrix</li>
<li><code>probability::NDArray-or-SymbolicNode</code>: probability vector</li>
<li><code>seed_arrays::NDArray-or-SymbolicNode[]</code>: seed vertices</li>
<li><code>num_args::int, required</code>: Number of input NDArray.</li>
<li><code>num_hops::long, optional, default=1</code>: Number of hops.</li>
<li><code>num_neighbor::long, optional, default=2</code>: Number of neighbor.</li>
<li><code>max_num_vertices::long, optional, default=100</code>: Max number of vertices.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L407' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._contrib_dgl_csr_neighbor_uniform_sample-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._contrib_dgl_csr_neighbor_uniform_sample-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._contrib_dgl_csr_neighbor_uniform_sample</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_contrib_dgl_csr_neighbor_uniform_sample(csr_matrix, seed_arrays, num_args, num_hops, num_neighbor, max_num_vertices)
</code></pre>

<p><strong>Note</strong>: <em>contrib</em>dgl<em>csr</em>neighbor<em>uniform</em>sample takes variable number of positional inputs. So instead of calling as <em>contrib</em>dgl<em>csr</em>neighbor<em>uniform</em>sample([x, y, z], num<em>args=3), one should call via _contrib</em>dgl<em>csr</em>neighbor<em>uniform</em>sample(x, y, z), and num_args will be determined automatically.</p>
<p>This operator samples sub-graphs from a csr graph via an uniform probability. The operator is designed for DGL.</p>
<p>The operator outputs three sets of NDArrays to represent the sampled results (the number of NDArrays in each set is the same as the number of seed NDArrays):</p>
<ol>
<li>a set of 1D NDArrays containing the sampled vertices, 2) a set of CSRNDArrays representing</li>
</ol>
<p>the sampled edges, 3) a set of 1D NDArrays indicating the layer where a vertex is sampled. The first set of 1D NDArrays have a length of max<em>num</em>vertices+1. The last element in an NDArray indicate the acutal number of vertices in a subgraph. The third set of NDArrays have a length of max<em>num</em>vertices, and the valid number of vertices is the same as the ones in the first set.</p>
<p>Example:</p>
<p>.. code:: python</p>
<p>shape = (5, 5)   data<em>np = np.array([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20], dtype=np.int64)   indices</em>np = np.array([1,2,3,4,0,2,3,4,0,1,3,4,0,1,2,4,0,1,2,3], dtype=np.int64)   indptr<em>np = np.array([0,4,8,12,16,20], dtype=np.int64)   a = mx.nd.sparse.csr</em>matrix((data<em>np, indices</em>np, indptr<em>np), shape=shape)   a.asnumpy()   seed = mx.nd.array([0,1,2,3,4], dtype=np.int64)   out = mx.nd.contrib.dgl</em>csr<em>neighbor</em>uniform<em>sample(a, seed, num</em>args=2, num<em>hops=1, num</em>neighbor=2, max<em>num</em>vertices=5)</p>
<p>out[0]   [0 1 2 3 4 5]   <NDArray 6 @cpu(0)></p>
<p>out[1].asnumpy()   array([[ 0,  1,  0,  3,  0],          [ 5,  0,  0,  7,  0],          [ 9,  0,  0, 11,  0],          [13,  0, 15,  0,  0],          [17,  0, 19,  0,  0]])</p>
<p>out[2]   [0 0 0 0 0]   <NDArray 5 @cpu(0)></p>
<p>Defined in src/operator/contrib/dgl_graph.cc:L784</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>csr_matrix::NDArray-or-SymbolicNode</code>: csr matrix</li>
<li><code>seed_arrays::NDArray-or-SymbolicNode[]</code>: seed vertices</li>
<li><code>num_args::int, required</code>: Number of input NDArray.</li>
<li><code>num_hops::long, optional, default=1</code>: Number of hops.</li>
<li><code>num_neighbor::long, optional, default=2</code>: Number of neighbor.</li>
<li><code>max_num_vertices::long, optional, default=100</code>: Max number of vertices.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L400' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._contrib_dgl_graph_compact-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._contrib_dgl_graph_compact-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._contrib_dgl_graph_compact</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_contrib_dgl_graph_compact(graph_data, num_args, return_mapping, graph_sizes)
</code></pre>

<p><strong>Note</strong>: <em>contrib</em>dgl<em>graph</em>compact takes variable number of positional inputs. So instead of calling as <em>contrib</em>dgl<em>graph</em>compact([x, y, z], num<em>args=3), one should call via _contrib</em>dgl<em>graph</em>compact(x, y, z), and num_args will be determined automatically.</p>
<p>This operator compacts a CSR matrix generated by dgl<em>csr</em>neighbor<em>uniform</em>sample and dgl<em>csr</em>neighbor<em>non</em>uniform_sample. The CSR matrices generated by these two operators may have many empty rows at the end and many empty columns. This operator removes these empty rows and empty columns.</p>
<p>Example:</p>
<p>.. code:: python</p>
<p>shape = (5, 5)   data<em>np = np.array([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20], dtype=np.int64)   indices</em>np = np.array([1,2,3,4,0,2,3,4,0,1,3,4,0,1,2,4,0,1,2,3], dtype=np.int64)   indptr<em>np = np.array([0,4,8,12,16,20], dtype=np.int64)   a = mx.nd.sparse.csr</em>matrix((data<em>np, indices</em>np, indptr<em>np), shape=shape)   seed = mx.nd.array([0,1,2,3,4], dtype=np.int64)   out = mx.nd.contrib.dgl</em>csr<em>neighbor</em>uniform<em>sample(a, seed, num</em>args=2, num<em>hops=1,           num</em>neighbor=2, max<em>num</em>vertices=6)   subg<em>v = out[0]   subg = out[1]   compact = mx.nd.contrib.dgl</em>graph<em>compact(subg, subg</em>v,           graph<em>sizes=(subg</em>v[-1].asnumpy()[0]), return_mapping=False)</p>
<p>compact.asnumpy()   array([[0, 0, 0, 1, 0],          [2, 0, 3, 0, 0],          [0, 4, 0, 0, 5],          [0, 6, 0, 0, 7],          [8, 9, 0, 0, 0]])</p>
<p>Defined in src/operator/contrib/dgl_graph.cc:L1582</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>graph_data::NDArray-or-SymbolicNode[]</code>: Input graphs and input vertex Ids.</li>
<li><code>num_args::int, required</code>: Number of input arguments.</li>
<li><code>return_mapping::boolean, required</code>: Return mapping of vid and eid between the subgraph and the parent graph.</li>
<li><code>graph_sizes::tuple of &lt;long&gt;, required</code>: the number of vertices in each graph.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L387' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._contrib_dgl_subgraph-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._contrib_dgl_subgraph-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._contrib_dgl_subgraph</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_contrib_dgl_subgraph(graph, data, num_args, return_mapping)
</code></pre>

<p><strong>Note</strong>: <em>contrib</em>dgl<em>subgraph takes variable number of positional inputs. So instead of calling as _contrib</em>dgl<em>subgraph([x, y, z], num</em>args=3), one should call via <em>contrib</em>dgl<em>subgraph(x, y, z), and num</em>args will be determined automatically.</p>
<p>This operator constructs an induced subgraph for a given set of vertices from a graph. The operator accepts multiple sets of vertices as input. For each set of vertices, it returns a pair of CSR matrices if return_mapping is True: the first matrix contains edges with new edge Ids, the second matrix contains edges with the original edge Ids.</p>
<p>Example:</p>
<p>.. code:: python</p>
<pre><code> x=[[1, 0, 0, 2],
   [3, 0, 4, 0],
   [0, 5, 0, 0],
   [0, 6, 7, 0]]
 v = [0, 1, 2]
 dgl_subgraph(x, v, return_mapping=True) =
   [[1, 0, 0],
    [2, 0, 3],
    [0, 4, 0]],
   [[1, 0, 0],
    [3, 0, 4],
    [0, 5, 0]]
</code></pre>

<p>Defined in src/operator/contrib/dgl_graph.cc:L1140</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>graph::NDArray-or-SymbolicNode</code>: Input graph where we sample vertices.</li>
<li><code>data::NDArray-or-SymbolicNode[]</code>: The input arrays that include data arrays and states.</li>
<li><code>num_args::int, required</code>: Number of input arguments, including all symbol inputs.</li>
<li><code>return_mapping::boolean, required</code>: Return mapping of vid and eid between the subgraph and the parent graph.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L381' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._contrib_div_sqrt_dim-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._contrib_div_sqrt_dim-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._contrib_div_sqrt_dim</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_contrib_div_sqrt_dim(data)
</code></pre>

<p>Rescale the input by the square root of the channel dimension.</p>
<p>out = data / sqrt(data.shape[-1])</p>
<p>Defined in src/operator/contrib/transformer.cc:L833</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L353' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._contrib_edge_id-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._contrib_edge_id-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._contrib_edge_id</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_contrib_edge_id(data, u, v)
</code></pre>

<p>This operator implements the edge_id function for a graph stored in a CSR matrix (the value of the CSR stores the edge Id of the graph). output[i] = input[u[i], v[i]] if there is an edge between u[i] and v[i]], otherwise output[i] will be -1. Both u and v should be 1D vectors.</p>
<p>Example:</p>
<p>.. code:: python</p>
<pre><code>  x = [[ 1, 0, 0 ],
       [ 0, 2, 0 ],
       [ 0, 0, 3 ]]
  u = [ 0, 0, 1, 1, 2, 2 ]
  v = [ 0, 1, 1, 2, 0, 2 ]
  edge_id(x, u, v) = [ 1, -1, 2, -1, -1, 3 ]
</code></pre>

<p>The storage type of $edge_id$ output depends on storage types of inputs</p>
<ul>
<li>edge_id(csr, default, default) = default</li>
<li>default and rsp inputs are not supported</li>
</ul>
<p>Defined in src/operator/contrib/dgl_graph.cc:L1321</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input ndarray</li>
<li><code>u::NDArray-or-SymbolicNode</code>: u ndarray</li>
<li><code>v::NDArray-or-SymbolicNode</code>: v ndarray</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L373' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._contrib_fft-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._contrib_fft-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._contrib_fft</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_contrib_fft(data, compute_size)
</code></pre>

<p>Apply 1D FFT to input"</p>
<p>.. note:: <code>fft</code> is only available on GPU.</p>
<p>Currently accept 2 input data shapes: (N, d) or (N1, N2, N3, d), data can only be real numbers. The output data has shape: (N, 2<em>d) or (N1, N2, N3, 2</em>d). The format is: [real0, imag0, real1, imag1, ...].</p>
<p>Example::</p>
<p>data = np.random.normal(0,1,(3,4))    out = mx.contrib.ndarray.fft(data = mx.nd.array(data,ctx = mx.gpu(0)))</p>
<p>Defined in src/operator/contrib/fft.cc:L56</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data to the FFTOp.</li>
<li><code>compute_size::int, optional, default='128'</code>: Maximum size of sub-batch to be forwarded at one time</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L363' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._contrib_getnnz-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._contrib_getnnz-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._contrib_getnnz</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_contrib_getnnz(data, axis)
</code></pre>

<p>Number of stored values for a sparse tensor, including explicit zeros.</p>
<p>This operator only supports CSR matrix on CPU.</p>
<p>Defined in src/operator/contrib/nnz.cc:L177</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input</li>
<li><code>axis::int or None, optional, default='None'</code>: Select between the number of values across the whole matrix, in each column, or in each row.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L355' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._contrib_gradientmultiplier-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._contrib_gradientmultiplier-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._contrib_gradientmultiplier</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_contrib_gradientmultiplier(data, scalar)
</code></pre>

<p>This operator implements the gradient multiplier function. In forward pass it acts as an identity transform. During backpropagation it multiplies the gradient from the subsequent level by a scalar factor lambda and passes it to the preceding layer.</p>
<p>Defined in src/operator/contrib/gradient<em>multiplier</em>op.cc:L78</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>scalar::float</code>: lambda multiplier</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L355' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._contrib_group_adagrad_update-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._contrib_group_adagrad_update-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._contrib_group_adagrad_update</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_contrib_group_adagrad_update(weight, grad, history, lr, rescale_grad, clip_gradient, epsilon)
</code></pre>

<p>Update function for Group AdaGrad optimizer.</p>
<p>Referenced from <em>Adaptive Subgradient Methods for Online Learning and Stochastic Optimization</em>, and available at http://www.jmlr.org/papers/volume12/duchi11a/duchi11a.pdf but uses only a single learning rate for every row of the parameter array.</p>
<p>Updates are applied by::</p>
<pre><code>grad = clip(grad * rescale_grad, clip_gradient)
history += mean(square(grad), axis=1, keepdims=True)
div = grad / (sqrt(history) + epsilon)
weight -= div * lr
</code></pre>

<p>Weights are updated lazily if the gradient is sparse.</p>
<p>Note that non-zero values for the weight decay option are not supported.</p>
<p>Defined in src/operator/contrib/optimizer_op.cc:L71</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>weight::NDArray-or-SymbolicNode</code>: Weight</li>
<li><code>grad::NDArray-or-SymbolicNode</code>: Gradient</li>
<li><code>history::NDArray-or-SymbolicNode</code>: History</li>
<li><code>lr::float, required</code>: Learning rate</li>
<li><code>rescale_grad::float, optional, default=1</code>: Rescale gradient to grad = rescale_grad*grad.</li>
<li><code>clip_gradient::float, optional, default=-1</code>: Clip gradient to the range of [-clip<em>gradient, clip</em>gradient] If clip<em>gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip</em>gradient), -clip_gradient).</li>
<li><code>epsilon::float, optional, default=9.99999975e-06</code>: Epsilon for numerical stability</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L378' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._contrib_hawkesll-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._contrib_hawkesll-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._contrib_hawkesll</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_contrib_hawkesll(lda, alpha, beta, state, lags, marks, valid_length, max_time)
</code></pre>

<p>Computes the log likelihood of a univariate Hawkes process.</p>
<p>The log likelihood is calculated on point process observations represented as <em>ragged</em> matrices for <em>lags</em> (interarrival times w.r.t. the previous point), and <em>marks</em> (identifiers for the process ID). Note that each mark is considered independent, i.e., computes the joint likelihood of a set of Hawkes processes determined by the conditional intensity:</p>
<p>.. math::</p>
<p>\lambda<em>k^</em>(t) = \lambda<em>k + \alpha</em>k \sum<em>{{t</em>i &lt; t, y<em>i = k}} \beta</em>k \exp(-\beta*k (t - t_i))</p>
<p>where :math:<code>\lambda_k</code> specifies the background intensity $lda$, :math:<code>\alpha_k</code> specifies the <em>branching ratio</em> or $alpha$, and :math:<code>\beta_k</code> the delay density parameter $beta$.</p>
<p>$lags$ and $marks$ are two NDArrays of shape (N, T) and correspond to the representation of the point process observation, the first dimension corresponds to the batch index, and the second to the sequence. These are "left-aligned" <em>ragged</em> matrices (the first index of the second dimension is the beginning of every sequence. The length of each sequence is given by $valid_length$, of shape (N,) where $valid_length[i]$ corresponds to the number of valid points in $lags[i, :]$ and $marks[i, :]$.</p>
<p>$max_time$ is the length of the observation period of the point process. That is, specifying $max_time[i] = 5$ computes the likelihood of the i-th sample as observed on the time interval :math:<code>(0, 5]</code>. Naturally, the sum of all valid $lags[i, :valid_length[i]]$ must be less than or equal to 5.</p>
<p>The input $state$ specifies the <em>memory</em> of the Hawkes process. Invoking the memoryless property of exponential decays, we compute the <em>memory</em> as</p>
<p>.. math::</p>
<pre><code>s_k(t) = \sum_{t_i &lt; t} \exp(-\beta_k (t - t_i)).
</code></pre>

<p>The $state$ to be provided is :math:<code>s_k(0)</code> and carries the added intensity due to past events before the current batch. :math:<code>s_k(T)</code> is returned from the function where :math:<code>T</code> is $max_time[T]$.</p>
<p>Example::</p>
<p><strong>define the Hawkes process parameters</strong></p>
<p>lda = nd.array([1.5, 2.0, 3.0]).tile((N, 1))   alpha = nd.array([0.2, 0.3, 0.4])  # branching ratios should be &lt; 1   beta = nd.array([1.0, 2.0, 3.0])</p>
<p><strong>the "data", or observations</strong></p>
<p>ia_times = nd.array([[6, 7, 8, 9], [1, 2, 3, 4], [3, 4, 5, 6], [8, 9, 10, 11]])   marks = nd.zeros((N, T)).astype(np.int32)</p>
<p><strong>starting "state" of the process</strong></p>
<p>states = nd.zeros((N, K))</p>
<p>valid<em>length = nd.array([1, 2, 3, 4])  # number of valid points in each sequence   max</em>time = nd.ones((N,)) * 100.0  # length of the observation period</p>
<p>A = nd.contrib.hawkesll(       lda, alpha, beta, states, ia<em>times, marks, valid</em>length, max_time   )</p>
<p>References:</p>
<ul>
<li>Bacry, E., Mastromatteo, I., &amp; Muzy, J. F. (2015).  Hawkes processes in finance. Market Microstructure and Liquidity  , 1(01), 1550005.</li>
</ul>
<p>Defined in src/operator/contrib/hawkes_ll.cc:L84</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lda::NDArray-or-SymbolicNode</code>: Shape (N, K) The intensity for each of the K processes, for each sample</li>
<li><code>alpha::NDArray-or-SymbolicNode</code>: Shape (K,) The infectivity factor (branching ratio) for each process</li>
<li><code>beta::NDArray-or-SymbolicNode</code>: Shape (K,) The decay parameter for each process</li>
<li><code>state::NDArray-or-SymbolicNode</code>: Shape (N, K) the Hawkes state for each process</li>
<li><code>lags::NDArray-or-SymbolicNode</code>: Shape (N, T) the interarrival times</li>
<li><code>marks::NDArray-or-SymbolicNode</code>: Shape (N, T) the marks (process ids)</li>
<li><code>valid_length::NDArray-or-SymbolicNode</code>: The number of valid points in the process</li>
<li><code>max_time::NDArray-or-SymbolicNode</code>: the length of the interval where the processes were sampled</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L414' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._contrib_ifft-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._contrib_ifft-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._contrib_ifft</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_contrib_ifft(data, compute_size)
</code></pre>

<p>Apply 1D ifft to input"</p>
<p>.. note:: <code>ifft</code> is only available on GPU.</p>
<p>Currently accept 2 input data shapes: (N, d) or (N1, N2, N3, d). Data is in format: [real0, imag0, real1, imag1, ...]. Last dimension must be an even number. The output data has shape: (N, d/2) or (N1, N2, N3, d/2). It is only the real part of the result.</p>
<p>Example::</p>
<p>data = np.random.normal(0,1,(3,4))    out = mx.contrib.ndarray.ifft(data = mx.nd.array(data,ctx = mx.gpu(0)))</p>
<p>Defined in src/operator/contrib/ifft.cc:L58</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data to the IFFTOp.</li>
<li><code>compute_size::int, optional, default='128'</code>: Maximum size of sub-batch to be forwarded at one time</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L364' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._contrib_index_array-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._contrib_index_array-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._contrib_index_array</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_contrib_index_array(data, axes)
</code></pre>

<p>Returns an array of indexes of the input array.</p>
<p>For an input array with shape  :math:<code>(d_1, d_2, ..., d_n)</code>, <code>index_array</code> returns a :math:<code>(d_1, d_2, ..., d_n, n)</code> array <code>idx</code>, where :math:<code>idx[i_1, i_2, ..., i_n, :] = [i_1, i_2, ..., i_n]</code>.</p>
<p>Additionally, when the parameter <code>axes</code> is specified, <code>idx</code> will be a :math:<code>(d_1, d_2, ..., d_n, m)</code> array where <code>m</code> is the length of <code>axes</code>, and the following equality will hold: :math:<code>idx[i_1, i_2, ..., i_n, j] = i_{axes[j]}</code>.</p>
<p>Examples::</p>
<pre><code>x = mx.nd.ones((3, 2))

mx.nd.contrib.index_array(x) = [[[0 0]
                                 [0 1]]

                                [[1 0]
                                 [1 1]]

                                [[2 0]
                                 [2 1]]]

x = mx.nd.ones((3, 2, 2))

mx.nd.contrib.index_array(x, axes=(1, 0)) = [[[[0 0]
                                               [0 0]]

                                              [[1 0]
                                               [1 0]]]


                                             [[[0 1]
                                               [0 1]]

                                              [[1 1]
                                               [1 1]]]


                                             [[[0 2]
                                               [0 2]]

                                              [[1 2]
                                               [1 2]]]]
</code></pre>

<p>Defined in src/operator/contrib/index_array.cc:L118</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data</li>
<li><code>axes::Shape or None, optional, default=None</code>: The axes to include in the index array. Supports negative values.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L396' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._contrib_index_copy-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._contrib_index_copy-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._contrib_index_copy</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_contrib_index_copy(old_tensor, index_vector, new_tensor)
</code></pre>

<p>Copies the elements of a <code>new_tensor</code> into the <code>old_tensor</code>.</p>
<p>This operator copies the elements by selecting the indices in the order given in <code>index</code>. The output will be a new tensor containing the rest elements of old tensor and the copied elements of new tensor. For example, if <code>index[i] == j</code>, then the <code>i</code> th row of <code>new_tensor</code> is copied to the <code>j</code> th row of output.</p>
<p>The <code>index</code> must be a vector and it must have the same size with the <code>0</code> th dimension of <code>new_tensor</code>. Also, the <code>0</code> th dimension of old*tensor must <code>&gt;=</code> the <code>0</code> th dimension of <code>new*tensor</code>, or an error will be raised.</p>
<p>Examples::</p>
<pre><code>x = mx.nd.zeros((5,3))
t = mx.nd.array([[1,2,3],[4,5,6],[7,8,9]])
index = mx.nd.array([0,4,2])

mx.nd.contrib.index_copy(x, index, t)

[[1. 2. 3.]
 [0. 0. 0.]
 [7. 8. 9.]
 [0. 0. 0.]
 [4. 5. 6.]]
&lt;NDArray 5x3 @cpu(0)&gt;
</code></pre>

<p>Defined in src/operator/contrib/index_copy.cc:L193</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>old_tensor::NDArray-or-SymbolicNode</code>: Old tensor</li>
<li><code>index_vector::NDArray-or-SymbolicNode</code>: Index vector</li>
<li><code>new_tensor::NDArray-or-SymbolicNode</code>: New tensor to be copied</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L380' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._contrib_interleaved_matmul_encdec_qk-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._contrib_interleaved_matmul_encdec_qk-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._contrib_interleaved_matmul_encdec_qk</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_contrib_interleaved_matmul_encdec_qk(queries, keys_values, heads)
</code></pre>

<p>Compute the matrix multiplication between the projections of queries and keys in multihead attention use as encoder-decoder.</p>
<p>the inputs must be a tensor of projections of queries following the layout: (seq<em>length, batch</em>size, num<em>heads * head</em>dim)</p>
<p>and a tensor of interleaved projections of values and keys following the layout: (seq<em>length, batch</em>size, num<em>heads * head</em>dim * 2)</p>
<p>the equivalent code would be: q<em>proj = mx.nd.transpose(queries, axes=(1, 2, 0, 3)) q</em>proj = mx.nd.reshape(q<em>proj, shape=(-1, 0, 0), reverse=True) q</em>proj = mx.nd.contrib.div<em>sqrt</em>dim(q<em>proj) tmp = mx.nd.reshape(keys</em>values, shape=(0, 0, num<em>heads, 2, -1)) k</em>proj = mx.nd.transpose(tmp[:,:,:,0,:], axes=(1, 2, 0, 3)) k<em>proj = mx.nd.reshap(k</em>proj, shape=(-1, 0, 0), reverse=True) output = mx.nd.batch<em>dot(q</em>proj, k<em>proj, transpose</em>b=True)</p>
<p>Defined in src/operator/contrib/transformer.cc:L754</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>queries::NDArray-or-SymbolicNode</code>: Queries</li>
<li><code>keys_values::NDArray-or-SymbolicNode</code>: Keys and values interleaved</li>
<li><code>heads::int, required</code>: Set number of heads</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L370' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._contrib_interleaved_matmul_encdec_valatt-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._contrib_interleaved_matmul_encdec_valatt-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._contrib_interleaved_matmul_encdec_valatt</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_contrib_interleaved_matmul_encdec_valatt(keys_values, attention, heads)
</code></pre>

<p>Compute the matrix multiplication between the projections of values and the attention weights in multihead attention use as encoder-decoder.</p>
<p>the inputs must be a tensor of interleaved projections of keys and values following the layout: (seq<em>length, batch</em>size, num<em>heads * head</em>dim * 2)</p>
<p>and the attention weights following the layout: (batch<em>size, seq</em>length, seq_length)</p>
<p>the equivalent code would be:</p>
<p>tmp = mx.nd.reshape(queries<em>keys</em>values, shape=(0, 0, num<em>heads, 3, -1)) v</em>proj = mx.nd.transpose(tmp[:,:,:,1,:], axes=(1, 2, 0, 3)) v<em>proj = mx.nd.reshape(v</em>proj, shape=(-1, 0, 0), reverse=True) output = mx.nd.batch<em>dot(attention, v</em>proj, transpose<em>b=True) output = mx.nd.reshape(output, shape=(-1, num</em>heads, 0, 0), reverse=True) output = mx.nd.transpose(output, axes=(0, 2, 1, 3)) output = mx.nd.reshape(output, shape=(0, 0, -1))</p>
<p>Defined in src/operator/contrib/transformer.cc:L800</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>keys_values::NDArray-or-SymbolicNode</code>: Keys and values interleaved</li>
<li><code>attention::NDArray-or-SymbolicNode</code>: Attention maps</li>
<li><code>heads::int, required</code>: Set number of heads</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L372' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._contrib_interleaved_matmul_selfatt_qk-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._contrib_interleaved_matmul_selfatt_qk-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._contrib_interleaved_matmul_selfatt_qk</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_contrib_interleaved_matmul_selfatt_qk(queries_keys_values, heads)
</code></pre>

<p>Compute the matrix multiplication between the projections of queries and keys in multihead attention use as self attention.</p>
<p>the input must be a single tensor of interleaved projections of queries, keys and values following the layout: (seq<em>length, batch</em>size, num<em>heads * head</em>dim * 3)</p>
<p>the equivalent code would be: tmp = mx.nd.reshape(queries<em>keys</em>values, shape=(0, 0, num<em>heads, 3, -1)) q</em>proj = mx.nd.transpose(tmp[:,:,:,0,:], axes=(1, 2, 0, 3)) q<em>proj = mx.nd.reshape(q</em>proj, shape=(-1, 0, 0), reverse=True) q<em>proj = mx.nd.contrib.div</em>sqrt<em>dim(q</em>proj) k<em>proj = mx.nd.transpose(tmp[:,:,:,1,:], axes=(1, 2, 0, 3)) k</em>proj = mx.nd.reshap(k<em>proj, shape=(-1, 0, 0), reverse=True) output = mx.nd.batch</em>dot(q<em>proj, k</em>proj, transpose_b=True)</p>
<p>Defined in src/operator/contrib/transformer.cc:L666</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>queries_keys_values::NDArray-or-SymbolicNode</code>: Interleaved queries, keys and values</li>
<li><code>heads::int, required</code>: Set number of heads</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L366' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._contrib_interleaved_matmul_selfatt_valatt-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._contrib_interleaved_matmul_selfatt_valatt-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._contrib_interleaved_matmul_selfatt_valatt</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_contrib_interleaved_matmul_selfatt_valatt(queries_keys_values, attention, heads)
</code></pre>

<p>Compute the matrix multiplication between the projections of values and the attention weights in multihead attention use as self attention.</p>
<p>the inputs must be a tensor of interleaved projections of queries, keys and values following the layout: (seq<em>length, batch</em>size, num<em>heads * head</em>dim * 3)</p>
<p>and the attention weights following the layout: (batch<em>size, seq</em>length, seq_length)</p>
<p>the equivalent code would be: tmp = mx.nd.reshape(queries<em>keys</em>values, shape=(0, 0, num<em>heads, 3, -1)) v</em>proj = mx.nd.transpose(tmp[:,:,:,2,:], axes=(1, 2, 0, 3)) v<em>proj = mx.nd.reshape(v</em>proj, shape=(-1, 0, 0), reverse=True) output = mx.nd.batch<em>dot(attention, v</em>proj, transpose<em>b=True) output = mx.nd.reshape(output, shape=(-1, num</em>heads, 0, 0), reverse=True) output = mx.nd.transpose(output, axes=(0, 2, 1, 3)) output = mx.nd.reshape(output, shape=(0, 0, -1))</p>
<p>Defined in src/operator/contrib/transformer.cc:L710</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>queries_keys_values::NDArray-or-SymbolicNode</code>: Queries, keys and values interleaved</li>
<li><code>attention::NDArray-or-SymbolicNode</code>: Attention maps</li>
<li><code>heads::int, required</code>: Set number of heads</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L371' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._contrib_quadratic-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._contrib_quadratic-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._contrib_quadratic</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_contrib_quadratic(data, a, b, c)
</code></pre>

<p>This operators implements the quadratic function.</p>
<p>.. math::     f(x) = ax^2+bx+c</p>
<p>where :math:<code>x</code> is an input tensor and all operations in the function are element-wise.</p>
<p>Example::</p>
<p>x = [[1, 2], [3, 4]]   y = quadratic(data=x, a=1, b=2, c=3)   y = [[6, 11], [18, 27]]</p>
<p>The storage type of $quadratic$ output depends on storage types of inputs</p>
<ul>
<li>quadratic(csr, a, b, 0) = csr</li>
<li>quadratic(default, a, b, c) = default</li>
</ul>
<p>Defined in src/operator/contrib/quadratic_op.cc:L50</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input ndarray</li>
<li><code>a::float, optional, default=0</code>: Coefficient of the quadratic term in the quadratic function.</li>
<li><code>b::float, optional, default=0</code>: Coefficient of the linear term in the quadratic function.</li>
<li><code>c::float, optional, default=0</code>: Constant term in the quadratic function.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L373' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._contrib_quantize-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._contrib_quantize-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._contrib_quantize</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_contrib_quantize(data, min_range, max_range, out_type)
</code></pre>

<p>Quantize a input tensor from float to <code>out_type</code>, with user-specified <code>min_range</code> and <code>max_range</code>.</p>
<p>min<em>range and max</em>range are scalar floats that specify the range for the input data.</p>
<p>When out_type is <code>uint8</code>, the output is calculated using the following equation:</p>
<p><code>out[i] = (in[i] - min_range) * range(OUTPUT_TYPE) / (max_range - min_range) + 0.5</code>,</p>
<p>where <code>range(T) = numeric_limits&lt;T&gt;::max() - numeric_limits&lt;T&gt;::min()</code>.</p>
<p>When out_type is <code>int8</code>, the output is calculate using the following equation by keep zero centered for the quantized value:</p>
<p><code>out[i] = sign(in[i]) * min(abs(in[i] * scale + 0.5f, quantized_range)</code>,</p>
<p>where <code>quantized_range = MinAbs(max(int8), min(int8))</code> and <code>scale = quantized_range / MaxAbs(min_range, max_range).</code></p>
<p>.. Note::     This operator only supports forward propagation. DO NOT use it in training.</p>
<p>Defined in src/operator/quantization/quantize.cc:L74</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: A ndarray/symbol of type <code>float32</code></li>
<li><code>min_range::NDArray-or-SymbolicNode</code>: The minimum scalar value possibly produced for the input</li>
<li><code>max_range::NDArray-or-SymbolicNode</code>: The maximum scalar value possibly produced for the input</li>
<li><code>out_type::{'int8', 'uint8'},optional, default='uint8'</code>: Output data type.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L377' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._contrib_quantize_v2-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._contrib_quantize_v2-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._contrib_quantize_v2</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_contrib_quantize_v2(data, out_type, min_calib_range, max_calib_range)
</code></pre>

<p>Quantize a input tensor from float to <code>out_type</code>, with user-specified <code>min_calib_range</code> and <code>max_calib_range</code> or the input range collected at runtime.</p>
<p>Output <code>min_range</code> and <code>max_range</code> are scalar floats that specify the range for the input data.</p>
<p>When out_type is <code>uint8</code>, the output is calculated using the following equation:</p>
<p><code>out[i] = (in[i] - min_range) * range(OUTPUT_TYPE) / (max_range - min_range) + 0.5</code>,</p>
<p>where <code>range(T) = numeric_limits&lt;T&gt;::max() - numeric_limits&lt;T&gt;::min()</code>.</p>
<p>When out_type is <code>int8</code>, the output is calculate using the following equation by keep zero centered for the quantized value:</p>
<p><code>out[i] = sign(in[i]) * min(abs(in[i] * scale + 0.5f, quantized_range)</code>,</p>
<p>where <code>quantized_range = MinAbs(max(int8), min(int8))</code> and <code>scale = quantized_range / MaxAbs(min_range, max_range).</code></p>
<p>When out<em>type is <code>auto</code>, the output type is automatically determined by min</em>calib<em>range if presented. If min</em>calib<em>range &lt; 0.0f, the output type will be int8, otherwise will be uint8. If min</em>calib_range isn't presented, the output type will be int8.</p>
<p>.. Note::     This operator only supports forward propagation. DO NOT use it in training.</p>
<p>Defined in src/operator/quantization/quantize_v2.cc:L92</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: A ndarray/symbol of type <code>float32</code></li>
<li><code>out_type::{'auto', 'int8', 'uint8'},optional, default='int8'</code>: Output data type. <code>auto</code> can be specified to automatically determine output type according to min<em>calib</em>range.</li>
<li><code>min_calib_range::float or None, optional, default=None</code>: The minimum scalar value in the form of float32. If present, it will be used to quantize the fp32 data into int8 or uint8.</li>
<li><code>max_calib_range::float or None, optional, default=None</code>: The maximum scalar value in the form of float32. If present, it will be used to quantize the fp32 data into int8 or uint8.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L380' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._contrib_quantized_act-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._contrib_quantized_act-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._contrib_quantized_act</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_contrib_quantized_act(data, min_data, max_data, act_type)
</code></pre>

<p>Activation operator for input and output data type of int8. The input and output data comes with min and max thresholds for quantizing the float32 data into int8.</p>
<p>.. Note::      This operator only supports forward propogation. DO NOT use it in training.      This operator only supports <code>relu</code></p>
<p>Defined in src/operator/quantization/quantized_activation.cc:L91</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data.</li>
<li><code>min_data::NDArray-or-SymbolicNode</code>: Minimum value of data.</li>
<li><code>max_data::NDArray-or-SymbolicNode</code>: Maximum value of data.</li>
<li><code>act_type::{'relu', 'sigmoid', 'softrelu', 'softsign', 'tanh'}, required</code>: Activation function to be applied.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L361' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._contrib_quantized_batch_norm-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._contrib_quantized_batch_norm-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._contrib_quantized_batch_norm</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_contrib_quantized_batch_norm(data, gamma, beta, moving_mean, moving_var, min_data, max_data, eps, momentum, fix_gamma, use_global_stats, output_mean_var, axis, cudnn_off, min_calib_range, max_calib_range)
</code></pre>

<p>BatchNorm operator for input and output data type of int8. The input and output data comes with min and max thresholds for quantizing the float32 data into int8.</p>
<p>.. Note::     This operator only supports forward propogation. DO NOT use it in training.</p>
<p>Defined in src/operator/quantization/quantized<em>batch</em>norm.cc:L95</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data.</li>
<li><code>gamma::NDArray-or-SymbolicNode</code>: gamma.</li>
<li><code>beta::NDArray-or-SymbolicNode</code>: beta.</li>
<li><code>moving_mean::NDArray-or-SymbolicNode</code>: moving_mean.</li>
<li><code>moving_var::NDArray-or-SymbolicNode</code>: moving_var.</li>
<li><code>min_data::NDArray-or-SymbolicNode</code>: Minimum value of data.</li>
<li><code>max_data::NDArray-or-SymbolicNode</code>: Maximum value of data.</li>
<li><code>eps::double, optional, default=0.0010000000474974513</code>: Epsilon to prevent div 0. Must be no less than CUDNN<em>BN</em>MIN_EPSILON defined in cudnn.h when using cudnn (usually 1e-5)</li>
<li><code>momentum::float, optional, default=0.899999976</code>: Momentum for moving average</li>
<li><code>fix_gamma::boolean, optional, default=1</code>: Fix gamma while training</li>
<li><code>use_global_stats::boolean, optional, default=0</code>: Whether use global moving statistics instead of local batch-norm. This will force change batch-norm into a scale shift operator.</li>
<li><code>output_mean_var::boolean, optional, default=0</code>: Output the mean and inverse std</li>
<li><code>axis::int, optional, default='1'</code>: Specify which shape axis the channel is specified</li>
<li><code>cudnn_off::boolean, optional, default=0</code>: Do not select CUDNN operator, if available</li>
<li><code>min_calib_range::float or None, optional, default=None</code>: The minimum scalar value in the form of float32 obtained through calibration. If present, it will be used to by quantized batch norm op to calculate primitive scale.Note: this calib_range is to calib bn output.</li>
<li><code>max_calib_range::float or None, optional, default=None</code>: The maximum scalar value in the form of float32 obtained through calibration. If present, it will be used to by quantized batch norm op to calculate primitive scale.Note: this calib_range is to calib bn output.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L385' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._contrib_quantized_concat-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._contrib_quantized_concat-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._contrib_quantized_concat</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_contrib_quantized_concat(data, num_args, dim)
</code></pre>

<p><strong>Note</strong>: <em>contrib</em>quantized<em>concat takes variable number of positional inputs. So instead of calling as _contrib</em>quantized<em>concat([x, y, z], num</em>args=3), one should call via <em>contrib</em>quantized<em>concat(x, y, z), and num</em>args will be determined automatically.</p>
<p>Joins input arrays along a given axis.</p>
<p>The dimensions of the input arrays should be the same except the axis along which they will be concatenated. The dimension of the output array along the concatenated axis will be equal to the sum of the corresponding dimensions of the input arrays. All inputs with different min/max will be rescaled by using largest [min, max] pairs. If any input holds int8, then the output will be int8. Otherwise output will be uint8.</p>
<p>Defined in src/operator/quantization/quantized_concat.cc:L108</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode[]</code>: List of arrays to concatenate</li>
<li><code>num_args::int, required</code>: Number of inputs to be concated.</li>
<li><code>dim::int, optional, default='1'</code>: the dimension to be concated.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L364' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._contrib_quantized_conv-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._contrib_quantized_conv-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._contrib_quantized_conv</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_contrib_quantized_conv(data, weight, bias, min_data, max_data, min_weight, max_weight, min_bias, max_bias, kernel, stride, dilate, pad, num_filter, num_group, workspace, no_bias, cudnn_tune, cudnn_off, layout)
</code></pre>

<p>Convolution operator for input, weight and bias data type of int8, and accumulates in type int32 for the output. For each argument, two more arguments of type float32 must be provided representing the thresholds of quantizing argument from data type float32 to int8. The final outputs contain the convolution result in int32, and min and max thresholds representing the threholds for quantizing the float32 output into int32.</p>
<p>.. Note::     This operator only supports forward propogation. DO NOT use it in training.</p>
<p>Defined in src/operator/quantization/quantized_conv.cc:L137</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data.</li>
<li><code>weight::NDArray-or-SymbolicNode</code>: weight.</li>
<li><code>bias::NDArray-or-SymbolicNode</code>: bias.</li>
<li><code>min_data::NDArray-or-SymbolicNode</code>: Minimum value of data.</li>
<li><code>max_data::NDArray-or-SymbolicNode</code>: Maximum value of data.</li>
<li><code>min_weight::NDArray-or-SymbolicNode</code>: Minimum value of weight.</li>
<li><code>max_weight::NDArray-or-SymbolicNode</code>: Maximum value of weight.</li>
<li><code>min_bias::NDArray-or-SymbolicNode</code>: Minimum value of bias.</li>
<li><code>max_bias::NDArray-or-SymbolicNode</code>: Maximum value of bias.</li>
<li><code>kernel::Shape(tuple), required</code>: Convolution kernel size: (w,), (h, w) or (d, h, w)</li>
<li><code>stride::Shape(tuple), optional, default=[]</code>: Convolution stride: (w,), (h, w) or (d, h, w). Defaults to 1 for each dimension.</li>
<li><code>dilate::Shape(tuple), optional, default=[]</code>: Convolution dilate: (w,), (h, w) or (d, h, w). Defaults to 1 for each dimension.</li>
<li><code>pad::Shape(tuple), optional, default=[]</code>: Zero pad for convolution: (w,), (h, w) or (d, h, w). Defaults to no padding.</li>
<li><code>num_filter::int (non-negative), required</code>: Convolution filter(channel) number</li>
<li><code>num_group::int (non-negative), optional, default=1</code>: Number of group partitions.</li>
<li><code>workspace::long (non-negative), optional, default=1024</code>: Maximum temporary workspace allowed (MB) in convolution.This parameter has two usages. When CUDNN is not used, it determines the effective batch size of the convolution kernel. When CUDNN is used, it controls the maximum temporary storage used for tuning the best CUDNN kernel when <code>limited_workspace</code> strategy is used.</li>
<li><code>no_bias::boolean, optional, default=0</code>: Whether to disable bias parameter.</li>
<li><code>cudnn_tune::{None, 'fastest', 'limited_workspace', 'off'},optional, default='None'</code>: Whether to pick convolution algo by running performance test.</li>
<li><code>cudnn_off::boolean, optional, default=0</code>: Turn off cudnn for this layer.</li>
<li><code>layout::{None, 'NCDHW', 'NCHW', 'NCW', 'NDHWC', 'NHWC'},optional, default='None'</code>: Set layout for input, output and weight. Empty for   default layout: NCW for 1d, NCHW for 2d and NCDHW for 3d.NHWC and NDHWC are only supported on GPU.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L395' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._contrib_quantized_elemwise_add-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._contrib_quantized_elemwise_add-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._contrib_quantized_elemwise_add</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_contrib_quantized_elemwise_add(lhs, rhs, lhs_min, lhs_max, rhs_min, rhs_max)
</code></pre>

<p>elemwise_add operator for input dataA and input dataB data type of int8, and accumulates in type int32 for the output. For each argument, two more arguments of type float32 must be provided representing the thresholds of quantizing argument from data type float32 to int8. The final outputs contain result in int32, and min and max thresholds representing the threholds for quantizing the float32 output into int32.</p>
<p>.. Note::     This operator only supports forward propogation. DO NOT use it in training.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>lhs_min::NDArray-or-SymbolicNode</code>: 3rd input</li>
<li><code>lhs_max::NDArray-or-SymbolicNode</code>: 4th input</li>
<li><code>rhs_min::NDArray-or-SymbolicNode</code>: 5th input</li>
<li><code>rhs_max::NDArray-or-SymbolicNode</code>: 6th input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L366' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._contrib_quantized_elemwise_mul-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._contrib_quantized_elemwise_mul-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._contrib_quantized_elemwise_mul</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_contrib_quantized_elemwise_mul(lhs, rhs, lhs_min, lhs_max, rhs_min, rhs_max, min_calib_range, max_calib_range, enable_float_output)
</code></pre>

<p>Multiplies arguments int8 element-wise.</p>
<p>Defined in src/operator/quantization/quantized<em>elemwise</em>mul.cc:L222</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>lhs_min::NDArray-or-SymbolicNode</code>: Minimum value of first input.</li>
<li><code>lhs_max::NDArray-or-SymbolicNode</code>: Maximum value of first input.</li>
<li><code>rhs_min::NDArray-or-SymbolicNode</code>: Minimum value of second input.</li>
<li><code>rhs_max::NDArray-or-SymbolicNode</code>: Maximum value of second input.</li>
<li><code>min_calib_range::float or None, optional, default=None</code>: The minimum scalar value in the form of float32 obtained through calibration. If present, it will be used to requantize the int8 output data.</li>
<li><code>max_calib_range::float or None, optional, default=None</code>: The maximum scalar value in the form of float32 obtained through calibration. If present, it will be used to requantize the int8 output data.</li>
<li><code>enable_float_output::boolean, optional, default=0</code>: Whether to enable float32 output</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L366' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._contrib_quantized_embedding-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._contrib_quantized_embedding-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._contrib_quantized_embedding</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_contrib_quantized_embedding(data, weight, min_weight, max_weight, input_dim, output_dim, dtype, sparse_grad)
</code></pre>

<p>Maps integer indices to int8 vector representations (embeddings).</p>
<p>Defined in src/operator/quantization/quantized<em>indexing</em>op.cc:L134</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array to the embedding operator.</li>
<li><code>weight::NDArray-or-SymbolicNode</code>: The embedding weight matrix.</li>
<li><code>min_weight::NDArray-or-SymbolicNode</code>: Minimum value of data.</li>
<li><code>max_weight::NDArray-or-SymbolicNode</code>: Maximum value of data.</li>
<li><code>input_dim::int, required</code>: Vocabulary size of the input indices.</li>
<li><code>output_dim::int, required</code>: Dimension of the embedding vectors.</li>
<li><code>dtype::{'bfloat16', 'float16', 'float32', 'float64', 'int32', 'int64', 'int8', 'uint8'},optional, default='float32'</code>: Data type of weight.</li>
<li><code>sparse_grad::boolean, optional, default=0</code>: Compute row sparse gradient in the backward calculation. If set to True, the grad's storage type is row_sparse.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L364' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._contrib_quantized_flatten-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._contrib_quantized_flatten-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._contrib_quantized_flatten</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_contrib_quantized_flatten(data, min_data, max_data)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: A ndarray/symbol of type <code>float32</code></li>
<li><code>min_data::NDArray-or-SymbolicNode</code>: The minimum scalar value possibly produced for the data</li>
<li><code>max_data::NDArray-or-SymbolicNode</code>: The maximum scalar value possibly produced for the data</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._contrib_quantized_fully_connected-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._contrib_quantized_fully_connected-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._contrib_quantized_fully_connected</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_contrib_quantized_fully_connected(data, weight, bias, min_data, max_data, min_weight, max_weight, min_bias, max_bias, num_hidden, no_bias, flatten)
</code></pre>

<p>Fully Connected operator for input, weight and bias data type of int8, and accumulates in type int32 for the output. For each argument, two more arguments of type float32 must be provided representing the thresholds of quantizing argument from data type float32 to int8. The final outputs contain the convolution result in int32, and min and max thresholds representing the threholds for quantizing the float32 output into int32.</p>
<p>.. Note::     This operator only supports forward propogation. DO NOT use it in training.</p>
<p>Defined in src/operator/quantization/quantized<em>fully</em>connected.cc:L313</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data.</li>
<li><code>weight::NDArray-or-SymbolicNode</code>: weight.</li>
<li><code>bias::NDArray-or-SymbolicNode</code>: bias.</li>
<li><code>min_data::NDArray-or-SymbolicNode</code>: Minimum value of data.</li>
<li><code>max_data::NDArray-or-SymbolicNode</code>: Maximum value of data.</li>
<li><code>min_weight::NDArray-or-SymbolicNode</code>: Minimum value of weight.</li>
<li><code>max_weight::NDArray-or-SymbolicNode</code>: Maximum value of weight.</li>
<li><code>min_bias::NDArray-or-SymbolicNode</code>: Minimum value of bias.</li>
<li><code>max_bias::NDArray-or-SymbolicNode</code>: Maximum value of bias.</li>
<li><code>num_hidden::int, required</code>: Number of hidden nodes of the output.</li>
<li><code>no_bias::boolean, optional, default=0</code>: Whether to disable bias parameter.</li>
<li><code>flatten::boolean, optional, default=1</code>: Whether to collapse all but the first axis of the input data tensor.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L378' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._contrib_quantized_pooling-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._contrib_quantized_pooling-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._contrib_quantized_pooling</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_contrib_quantized_pooling(data, min_data, max_data, kernel, pool_type, global_pool, cudnn_off, pooling_convention, stride, pad, p_value, count_include_pad, layout)
</code></pre>

<p>Pooling operator for input and output data type of int8. The input and output data comes with min and max thresholds for quantizing the float32 data into int8.</p>
<p>.. Note::     This operator only supports forward propogation. DO NOT use it in training.     This operator only supports <code>pool_type</code> of <code>avg</code> or <code>max</code>.</p>
<p>Defined in src/operator/quantization/quantized_pooling.cc:L145</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data.</li>
<li><code>min_data::NDArray-or-SymbolicNode</code>: Minimum value of data.</li>
<li><code>max_data::NDArray-or-SymbolicNode</code>: Maximum value of data.</li>
<li><code>kernel::Shape(tuple), optional, default=[]</code>: Pooling kernel size: (y, x) or (d, y, x)</li>
<li><code>pool_type::{'avg', 'lp', 'max', 'sum'},optional, default='max'</code>: Pooling type to be applied.</li>
<li><code>global_pool::boolean, optional, default=0</code>: Ignore kernel size, do global pooling based on current input feature map.</li>
<li><code>cudnn_off::boolean, optional, default=0</code>: Turn off cudnn pooling and use MXNet pooling operator.</li>
<li><code>pooling_convention::{'full', 'same', 'valid'},optional, default='valid'</code>: Pooling convention to be applied.</li>
<li><code>stride::Shape(tuple), optional, default=[]</code>: Stride: for pooling (y, x) or (d, y, x). Defaults to 1 for each dimension.</li>
<li><code>pad::Shape(tuple), optional, default=[]</code>: Pad for pooling: (y, x) or (d, y, x). Defaults to no padding.</li>
<li><code>p_value::int or None, optional, default='None'</code>: Value of p for Lp pooling, can be 1 or 2, required for Lp Pooling.</li>
<li><code>count_include_pad::boolean or None, optional, default=None</code>: Only used for AvgPool, specify whether to count padding elements for averagecalculation. For example, with a 5<em>5 kernel on a 3</em>3 corner of a image,the sum of the 9 valid elements will be divided by 25 if this is set to true,or it will be divided by 9 if this is set to false. Defaults to true.</li>
<li><code>layout::{None, 'NCDHW', 'NCHW', 'NCW', 'NDHWC', 'NHWC', 'NWC'},optional, default='None'</code>: Set layout for input and output. Empty for   default layout: NCW for 1d, NCHW for 2d and NCDHW for 3d.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L380' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._contrib_requantize-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._contrib_requantize-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._contrib_requantize</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_contrib_requantize(data, min_range, max_range, out_type, min_calib_range, max_calib_range)
</code></pre>

<p>Given data that is quantized in int32 and the corresponding thresholds, requantize the data into int8 using min and max thresholds either calculated at runtime or from calibration. It's highly recommended to pre-calucate the min and max thresholds through calibration since it is able to save the runtime of the operator and improve the inference accuracy.</p>
<p>.. Note::     This operator only supports forward propogation. DO NOT use it in training.</p>
<p>Defined in src/operator/quantization/requantize.cc:L60</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: A ndarray/symbol of type <code>int32</code></li>
<li><code>min_range::NDArray-or-SymbolicNode</code>: The original minimum scalar value in the form of float32 used for quantizing data into int32.</li>
<li><code>max_range::NDArray-or-SymbolicNode</code>: The original maximum scalar value in the form of float32 used for quantizing data into int32.</li>
<li><code>out_type::{'auto', 'int8', 'uint8'},optional, default='int8'</code>: Output data type. <code>auto</code> can be specified to automatically determine output type according to min<em>calib</em>range.</li>
<li><code>min_calib_range::float or None, optional, default=None</code>: The minimum scalar value in the form of float32 obtained through calibration. If present, it will be used to requantize the int32 data into int8.</li>
<li><code>max_calib_range::float or None, optional, default=None</code>: The maximum scalar value in the form of float32 obtained through calibration. If present, it will be used to requantize the int32 data into int8.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L366' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._contrib_round_ste-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._contrib_round_ste-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._contrib_round_ste</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_contrib_round_ste(data)
</code></pre>

<p>Straight-through-estimator of <code>round()</code>.</p>
<p>In forward pass, returns element-wise rounded value to the nearest integer of the input (same as <code>round()</code>).</p>
<p>In backward pass, returns gradients of $1$ everywhere (instead of $0$ everywhere as in <code>round()</code>): :math:<code>\frac{d}{dx}{round\_ste(x)} = 1</code> vs. :math:<code>\frac{d}{dx}{round(x)} = 0</code>. This is useful for quantized training.</p>
<p>Reference: Estimating or Propagating Gradients Through Stochastic Neurons for Conditional Computation.</p>
<p>Example::   x = round_ste([-1.5, 1.5, -1.9, 1.9, 2.7])   x.backward()   x = [-2.,  2., -2.,  2.,  3.]   x.grad() = [1.,  1., 1.,  1.,  1.]</p>
<p>The storage type of $round_ste$ output depends upon the input storage type:</p>
<ul>
<li>round_ste(default) = default</li>
<li>round<em>ste(row</em>sparse) = row_sparse</li>
<li>round_ste(csr) = csr</li>
</ul>
<p>Defined in src/operator/contrib/stes_op.cc:L55</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L369' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._contrib_sign_ste-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._contrib_sign_ste-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._contrib_sign_ste</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_contrib_sign_ste(data)
</code></pre>

<p>Straight-through-estimator of <code>sign()</code>.</p>
<p>In forward pass, returns element-wise sign of the input (same as <code>sign()</code>).</p>
<p>In backward pass, returns gradients of $1$ everywhere (instead of $0$ everywhere as in $sign()$): :math:<code>\frac{d}{dx}{sign\_ste(x)} = 1</code> vs. :math:<code>\frac{d}{dx}{sign(x)} = 0</code>. This is useful for quantized training.</p>
<p>Reference: Estimating or Propagating Gradients Through Stochastic Neurons for Conditional Computation.</p>
<p>Example::   x = sign_ste([-2, 0, 3])   x.backward()   x = [-1.,  0., 1.]   x.grad() = [1.,  1., 1.]</p>
<p>The storage type of $sign_ste$ output depends upon the input storage type:</p>
<ul>
<li>round_ste(default) = default</li>
<li>round<em>ste(row</em>sparse) = row_sparse</li>
<li>round_ste(csr) = csr</li>
</ul>
<p>Defined in src/operator/contrib/stes_op.cc:L80</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L369' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._copy-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._copy-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._copy</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_copy(data)
</code></pre>

<p>Returns a copy of the input.</p>
<p>From:src/operator/tensor/elemwise<em>unary</em>op_basic.cc:244</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._copyto-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._copyto-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._copyto</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_copyto(data)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray</code>: input data</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L347' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._crop_assign-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._crop_assign-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._crop_assign</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_crop_assign(lhs, rhs, begin, end, step)
</code></pre>

<p><em>crop</em>assign is an alias of <em>slice</em>assign.</p>
<p>Assign the rhs to a cropped subset of lhs.</p>
<p><strong>Requirements</strong></p>
<ul>
<li>output should be explicitly given and be the same as lhs.</li>
<li>lhs and rhs are of the same data type, and on the same device.</li>
</ul>
<p>From:src/operator/tensor/matrix_op.cc:515</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: Source input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: value to assign</li>
<li><code>begin::Shape(tuple), required</code>: starting indices for the slice operation, supports negative indices.</li>
<li><code>end::Shape(tuple), required</code>: ending indices for the slice operation, supports negative indices.</li>
<li><code>step::Shape(tuple), optional, default=[]</code>: step for the slice operation, supports negative values.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L365' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._crop_assign_scalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._crop_assign_scalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._crop_assign_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_crop_assign_scalar(data, scalar, begin, end, step)
</code></pre>

<p><em>crop</em>assign<em>scalar is an alias of _slice</em>assign_scalar.</p>
<p>(Assign the scalar to a cropped subset of the input.</p>
<p><strong>Requirements</strong></p>
<ul>
<li>output should be explicitly given and be the same as input</li>
</ul>
<p>)</p>
<p>From:src/operator/tensor/matrix_op.cc:541</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Source input</li>
<li><code>scalar::double, optional, default=0</code>: The scalar value for assignment.</li>
<li><code>begin::Shape(tuple), required</code>: starting indices for the slice operation, supports negative indices.</li>
<li><code>end::Shape(tuple), required</code>: ending indices for the slice operation, supports negative indices.</li>
<li><code>step::Shape(tuple), optional, default=[]</code>: step for the slice operation, supports negative values.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L364' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._cvcopyMakeBorder-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._cvcopyMakeBorder-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._cvcopyMakeBorder</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_cvcopyMakeBorder(src, top, bot, left, right, type, value, values)
</code></pre>

<p>Pad image border with OpenCV. </p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>src::NDArray</code>: source image</li>
<li><code>top::int, required</code>: Top margin.</li>
<li><code>bot::int, required</code>: Bottom margin.</li>
<li><code>left::int, required</code>: Left margin.</li>
<li><code>right::int, required</code>: Right margin.</li>
<li><code>type::int, optional, default='0'</code>: Filling type (default=cv2.BORDER_CONSTANT).</li>
<li><code>value::double, optional, default=0</code>: (Deprecated! Use $values$ instead.) Fill with single value.</li>
<li><code>values::tuple of &lt;double&gt;, optional, default=[]</code>: Fill with value(RGB[A] or gray), up to 4 channels.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L362' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._cvimdecode-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._cvimdecode-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._cvimdecode</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_cvimdecode(buf, flag, to_rgb)
</code></pre>

<p>Decode image with OpenCV.  Note: return image in RGB by default, instead of OpenCV's default BGR.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>buf::NDArray</code>: Buffer containing binary encoded image</li>
<li><code>flag::int, optional, default='1'</code>: Convert decoded image to grayscale (0) or color (1).</li>
<li><code>to_rgb::boolean, optional, default=1</code>: Whether to convert decoded image to mxnet's default RGB format (instead of opencv's default BGR).</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L352' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._cvimread-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._cvimread-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._cvimread</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_cvimread(filename, flag, to_rgb)
</code></pre>

<p>Read and decode image with OpenCV.  Note: return image in RGB by default, instead of OpenCV's default BGR.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>filename::string, required</code>: Name of the image file to be loaded.</li>
<li><code>flag::int, optional, default='1'</code>: Convert decoded image to grayscale (0) or color (1).</li>
<li><code>to_rgb::boolean, optional, default=1</code>: Whether to convert decoded image to mxnet's default RGB format (instead of opencv's default BGR).</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L352' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._cvimresize-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._cvimresize-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._cvimresize</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_cvimresize(src, w, h, interp)
</code></pre>

<p>Resize image with OpenCV. </p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>src::NDArray</code>: source image</li>
<li><code>w::int, required</code>: Width of resized image.</li>
<li><code>h::int, required</code>: Height of resized image.</li>
<li><code>interp::int, optional, default='1'</code>: Interpolation method (default=cv2.INTER_LINEAR).</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L354' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._div_scalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._div_scalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._div_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_div_scalar(data, scalar)
</code></pre>

<p>Divide an array with a scalar.</p>
<p>$_div_scalar$ only operates on data array of input if input is sparse.</p>
<p>For example, if input of shape (100, 100) has only 2 non zero elements, i.e. input.data = [5, 6], scalar = nan, it will result output.data = [nan, nan] instead of 10000 nans.</p>
<p>Defined in src/operator/tensor/elemwise<em>binary</em>scalar<em>op</em>basic.cc:L171</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L359' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._equal-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._equal-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._equal</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_equal(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._equal_scalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._equal_scalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._equal_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_equal_scalar(data, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._eye-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._eye-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._eye</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_eye(N, M, k, ctx, dtype)
</code></pre>

<p>Return a 2-D array with ones on the diagonal and zeros elsewhere.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>N::long, required</code>: Number of rows in the output.</li>
<li><code>M::long, optional, default=0</code>: Number of columns in the output. If 0, defaults to N</li>
<li><code>k::long, optional, default=0</code>: Index of the diagonal. 0 (the default) refers to the main diagonal.A positive value refers to an upper diagonal.A negative value to a lower diagonal.</li>
<li><code>ctx::string, optional, default=''</code>: Context of output, in format <a href="n">cpu|gpu|cpu_pinned</a>.Only used for imperative calls.</li>
<li><code>dtype::{'float16', 'float32', 'float64', 'int32', 'int64', 'int8', 'uint8'},optional, default='float32'</code>: Target data type.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L355' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._foreach-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._foreach-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._foreach</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_foreach(fn, data, num_args, num_outputs, num_out_data, in_state_locs, in_data_locs, remain_locs)
</code></pre>

<p><strong>Note</strong>: <em>foreach takes variable number of positional inputs. So instead of calling as _foreach([x, y, z], num</em>args=3), one should call via <em>foreach(x, y, z), and num</em>args will be determined automatically.</p>
<p>Run a for loop over an NDArray with user-defined computation</p>
<p>From:src/operator/control_flow.cc:1090</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>fn::SymbolicNode</code>: Input graph.</li>
<li><code>data::NDArray-or-SymbolicNode[]</code>: The input arrays that include data arrays and states.</li>
<li><code>num_args::int, required</code>: Number of inputs.</li>
<li><code>num_outputs::int, required</code>: The number of outputs of the subgraph.</li>
<li><code>num_out_data::int, required</code>: The number of output data of the subgraph.</li>
<li><code>in_state_locs::tuple of &lt;long&gt;, required</code>: The locations of loop states among the inputs.</li>
<li><code>in_data_locs::tuple of &lt;long&gt;, required</code>: The locations of input data among the inputs.</li>
<li><code>remain_locs::tuple of &lt;long&gt;, required</code>: The locations of remaining data among the inputs.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L365' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._full-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._full-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._full</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_full(shape, ctx, dtype, value)
</code></pre>

<p>fill target with a scalar value</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>shape::Shape(tuple), optional, default=None</code>: The shape of the output</li>
<li><code>ctx::string, optional, default=''</code>: Context of output, in format <a href="n">cpu|gpu|cpu_pinned</a>.Only used for imperative calls.</li>
<li><code>dtype::{'bfloat16', 'bool', 'float16', 'float32', 'float64', 'int32', 'int64', 'int8', 'uint8'},optional, default='float32'</code>: Target data type.</li>
<li><code>value::double, required</code>: Value with which to fill newly created tensor</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L353' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._grad_add-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._grad_add-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._grad_add</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_grad_add(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._greater-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._greater-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._greater</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_greater(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._greater_equal-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._greater_equal-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._greater_equal</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_greater_equal(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._greater_equal_scalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._greater_equal_scalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._greater_equal_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_greater_equal_scalar(data, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._greater_scalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._greater_scalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._greater_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_greater_scalar(data, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._histogram-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._histogram-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._histogram</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_histogram(data, bins, bin_cnt, range)
</code></pre>

<p>This operators implements the histogram function.</p>
<p>Example::   x = [[0, 1], [2, 2], [3, 4]]   histo, bin<em>edges = histogram(data=x, bin</em>bounds=[], bin<em>cnt=5, range=(0,5))   histo = [1, 1, 2, 1, 1]   bin</em>edges = [0., 1., 2., 3., 4.]   histo, bin<em>edges = histogram(data=x, bin</em>bounds=[0., 2.1, 3.])   histo = [4, 1]</p>
<p>Defined in src/operator/tensor/histogram.cc:L137</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input ndarray</li>
<li><code>bins::NDArray-or-SymbolicNode</code>: Input ndarray</li>
<li><code>bin_cnt::int or None, optional, default='None'</code>: Number of bins for uniform case</li>
<li><code>range::, optional, default=None</code>: The lower and upper range of the bins. if not provided, range is simply (a.min(), a.max()). values outside the range are ignored. the first element of the range must be less than or equal to the second. range affects the automatic bin computation as well. while bin width is computed to be optimal based on the actual data within range, the bin count will fill the entire range including portions containing no data.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L365' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._hypot-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._hypot-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._hypot</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_hypot(lhs, rhs)
</code></pre>

<p>Given the "legs" of a right triangle, return its hypotenuse.</p>
<p>Defined in src/operator/tensor/elemwise<em>binary</em>op_extended.cc:L79</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L353' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._hypot_scalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._hypot_scalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._hypot_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_hypot_scalar(data, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._identity_with_attr_like_rhs-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._identity_with_attr_like_rhs-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._identity_with_attr_like_rhs</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_identity_with_attr_like_rhs(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: First input.</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: Second input.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._image_adjust_lighting-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._image_adjust_lighting-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._image_adjust_lighting</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_image_adjust_lighting(data, alpha)
</code></pre>

<p>Adjust the lighting level of the input. Follow the AlexNet style.</p>
<p>Defined in src/operator/image/image_random.cc:L254</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input.</li>
<li><code>alpha::tuple of &lt;float&gt;, required</code>: The lighting alphas for the R, G, B channels.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._image_crop-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._image_crop-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._image_crop</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_image_crop(data, x, y, width, height)
</code></pre>

<p>Crop an image NDArray of shape (H x W x C) or (N x H x W x C)  to the given size. Example:     .. code-block:: python         image = mx.nd.random.uniform(0, 255, (4, 2, 3)).astype(dtype=np.uint8)         mx.nd.image.crop(image, 1, 1, 2, 2)             [[[144  34   4]               [ 82 157  38]]</p>
<pre><code>         [[156 111 230]
          [177  25  15]]]
        &lt;NDArray 2x2x3 @cpu(0)&gt;
    image = mx.nd.random.uniform(0, 255, (2, 4, 2, 3)).astype(dtype=np.uint8)
    mx.nd.image.crop(image, 1, 1, 2, 2)            
        [[[[ 35 198  50]
           [242  94 168]]

          [[223 119 129]
           [249  14 154]]]


          [[[137 215 106]
            [ 79 174 133]]

           [[116 142 109]
            [ 35 239  50]]]]
        &lt;NDArray 2x2x2x3 @cpu(0)&gt;
</code></pre>

<p>Defined in src/operator/image/crop.cc:L66</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input.</li>
<li><code>x::int, required</code>: Left boundary of the cropping area.</li>
<li><code>y::int, required</code>: Top boundary of the cropping area.</li>
<li><code>width::int, required</code>: Width of the cropping area.</li>
<li><code>height::int, required</code>: Height of the cropping area.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L384' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._image_flip_left_right-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._image_flip_left_right-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._image_flip_left_right</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_image_flip_left_right(data)
</code></pre>

<p>Defined in src/operator/image/image_random.cc:L195</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._image_flip_top_bottom-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._image_flip_top_bottom-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._image_flip_top_bottom</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_image_flip_top_bottom(data)
</code></pre>

<p>Defined in src/operator/image/image_random.cc:L205</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._image_normalize-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._image_normalize-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._image_normalize</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_image_normalize(data, mean, std)
</code></pre>

<p>Normalize an tensor of shape (C x H x W) or (N x C x H x W) with mean and     standard deviation.</p>
<pre><code>Given mean `(m1, ..., mn)` and std `(s\ :sub:`1`\ , ..., s\ :sub:`n`)` for `n` channels,
this transform normalizes each channel of the input tensor with:
</code></pre>

<p>.. math::</p>
<pre><code>    output[i] = (input[i] - m\ :sub:`i`\ ) / s\ :sub:`i`

If mean or std is scalar, the same value will be applied to all channels.

Default value for mean is 0.0 and stand deviation is 1.0.
</code></pre>

<p>Example:</p>
<pre><code>.. code-block:: python
    image = mx.nd.random.uniform(0, 1, (3, 4, 2))
    normalize(image, mean=(0, 1, 2), std=(3, 2, 1))
        [[[ 0.18293785  0.19761486]
          [ 0.23839645  0.28142193]
          [ 0.20092112  0.28598186]
          [ 0.18162774  0.28241724]]
         [[-0.2881726  -0.18821815]
          [-0.17705294 -0.30780914]
          [-0.2812064  -0.3512327 ]
          [-0.05411351 -0.4716435 ]]
         [[-1.0363373  -1.7273437 ]
          [-1.6165586  -1.5223348 ]
          [-1.208275   -1.1878313 ]
          [-1.4711051  -1.5200229 ]]]
        &lt;NDArray 3x4x2 @cpu(0)&gt;

    image = mx.nd.random.uniform(0, 1, (2, 3, 4, 2))
    normalize(image, mean=(0, 1, 2), std=(3, 2, 1))
        [[[[ 0.18934818  0.13092826]
           [ 0.3085322   0.27869293]
           [ 0.02367868  0.11246539]
           [ 0.0290431   0.2160573 ]]
          [[-0.4898908  -0.31587923]
           [-0.08369008 -0.02142242]
           [-0.11092162 -0.42982462]
           [-0.06499392 -0.06495637]]
          [[-1.0213816  -1.526392  ]
           [-1.2008414  -1.1990893 ]
           [-1.5385206  -1.4795225 ]
           [-1.2194707  -1.3211205 ]]]
         [[[ 0.03942481  0.24021089]
           [ 0.21330701  0.1940066 ]
           [ 0.04778443  0.17912441]
           [ 0.31488964  0.25287187]]
          [[-0.23907584 -0.4470462 ]
           [-0.29266903 -0.2631998 ]
           [-0.3677222  -0.40683383]
           [-0.11288315 -0.13154092]]
          [[-1.5438497  -1.7834496 ]
           [-1.431566   -1.8647819 ]
           [-1.9812102  -1.675859  ]
           [-1.3823645  -1.8503251 ]]]]
        &lt;NDArray 2x3x4x2 @cpu(0)&gt;
</code></pre>

<p>Defined in src/operator/image/image_random.cc:L167</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input ndarray</li>
<li><code>mean::tuple of &lt;float&gt;, optional, default=[0,0,0,0]</code>: Sequence of means for each channel. Default value is 0.</li>
<li><code>std::tuple of &lt;float&gt;, optional, default=[1,1,1,1]</code>: Sequence of standard deviations for each channel. Default value is 1.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L413' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._image_random_brightness-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._image_random_brightness-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._image_random_brightness</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_image_random_brightness(data, min_factor, max_factor)
</code></pre>

<p>Defined in src/operator/image/image_random.cc:L215</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input.</li>
<li><code>min_factor::float, required</code>: Minimum factor.</li>
<li><code>max_factor::float, required</code>: Maximum factor.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L353' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._image_random_color_jitter-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._image_random_color_jitter-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._image_random_color_jitter</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_image_random_color_jitter(data, brightness, contrast, saturation, hue)
</code></pre>

<p>Defined in src/operator/image/image_random.cc:L246</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input.</li>
<li><code>brightness::float, required</code>: How much to jitter brightness.</li>
<li><code>contrast::float, required</code>: How much to jitter contrast.</li>
<li><code>saturation::float, required</code>: How much to jitter saturation.</li>
<li><code>hue::float, required</code>: How much to jitter hue.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L357' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._image_random_contrast-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._image_random_contrast-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._image_random_contrast</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_image_random_contrast(data, min_factor, max_factor)
</code></pre>

<p>Defined in src/operator/image/image_random.cc:L222</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input.</li>
<li><code>min_factor::float, required</code>: Minimum factor.</li>
<li><code>max_factor::float, required</code>: Maximum factor.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L353' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._image_random_flip_left_right-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._image_random_flip_left_right-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._image_random_flip_left_right</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_image_random_flip_left_right(data)
</code></pre>

<p>Defined in src/operator/image/image_random.cc:L200</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._image_random_flip_top_bottom-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._image_random_flip_top_bottom-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._image_random_flip_top_bottom</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_image_random_flip_top_bottom(data)
</code></pre>

<p>Defined in src/operator/image/image_random.cc:L210</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._image_random_hue-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._image_random_hue-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._image_random_hue</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_image_random_hue(data, min_factor, max_factor)
</code></pre>

<p>Defined in src/operator/image/image_random.cc:L238</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input.</li>
<li><code>min_factor::float, required</code>: Minimum factor.</li>
<li><code>max_factor::float, required</code>: Maximum factor.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L353' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._image_random_lighting-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._image_random_lighting-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._image_random_lighting</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_image_random_lighting(data, alpha_std)
</code></pre>

<p>Randomly add PCA noise. Follow the AlexNet style.</p>
<p>Defined in src/operator/image/image_random.cc:L262</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input.</li>
<li><code>alpha_std::float, optional, default=0.0500000007</code>: Level of the lighting noise.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._image_random_saturation-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._image_random_saturation-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._image_random_saturation</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_image_random_saturation(data, min_factor, max_factor)
</code></pre>

<p>Defined in src/operator/image/image_random.cc:L230</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input.</li>
<li><code>min_factor::float, required</code>: Minimum factor.</li>
<li><code>max_factor::float, required</code>: Maximum factor.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L353' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._image_resize-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._image_resize-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._image_resize</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_image_resize(data, size, keep_ratio, interp)
</code></pre>

<p>Resize an image NDArray of shape (H x W x C) or (N x H x W x C)  to the given size Example:     .. code-block:: python         image = mx.nd.random.uniform(0, 255, (4, 2, 3)).astype(dtype=np.uint8)         mx.nd.image.resize(image, (3, 3))             [[[124 111 197]               [158  80 155]               [193  50 112]]</p>
<pre><code>         [[110 100 113]
          [134 165 148]
          [157 231 182]]

         [[202 176 134]
          [174 191 149]
          [147 207 164]]]
        &lt;NDArray 3x3x3 @cpu(0)&gt;
    image = mx.nd.random.uniform(0, 255, (2, 4, 2, 3)).astype(dtype=np.uint8)
    mx.nd.image.resize(image, (2, 2))            
        [[[[ 59 133  80]
           [187 114 153]]

          [[ 38 142  39]
           [207 131 124]]]


          [[[117 125 136]
           [191 166 150]]

          [[129  63 113]
           [182 109  48]]]]
        &lt;NDArray 2x2x2x3 @cpu(0)&gt;
</code></pre>

<p>Defined in src/operator/image/resize.cc:L71</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input.</li>
<li><code>size::Shape(tuple), optional, default=[]</code>: Size of new image. Could be (width, height) or (size)</li>
<li><code>keep_ratio::boolean, optional, default=0</code>: Whether to resize the short edge or both edges to <code>size</code>, if size is give as an integer.</li>
<li><code>interp::int, optional, default='1'</code>: Interpolation method for resizing. By default uses bilinear interpolationOptions are INTER<em>NEAREST - a nearest-neighbor interpolationINTER</em>LINEAR - a bilinear interpolationINTER<em>AREA - resampling using pixel area relationINTER</em>CUBIC - a bicubic interpolation over 4x4 pixel neighborhoodINTER_LANCZOS4 - a Lanczos interpolation over 8x8 pixel neighborhoodNote that the GPU version only support bilinear interpolation(1)</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L388' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._image_to_tensor-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._image_to_tensor-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._image_to_tensor</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_image_to_tensor(data)
</code></pre>

<p>Converts an image NDArray of shape (H x W x C) or (N x H x W x C)  with values in the range [0, 255] to a tensor NDArray of shape (C x H x W) or (N x C x H x W) with values in the range [0, 1]</p>
<p>Example:     .. code-block:: python         image = mx.nd.random.uniform(0, 255, (4, 2, 3)).astype(dtype=np.uint8)         to_tensor(image)             [[[ 0.85490197  0.72156864]               [ 0.09019608  0.74117649]               [ 0.61960787  0.92941177]               [ 0.96470588  0.1882353 ]]              [[ 0.6156863   0.73725492]               [ 0.46666667  0.98039216]               [ 0.44705883  0.45490196]               [ 0.01960784  0.8509804 ]]              [[ 0.39607844  0.03137255]               [ 0.72156864  0.52941179]               [ 0.16470589  0.7647059 ]               [ 0.05490196  0.70588237]]]              <NDArray 3x4x2 @cpu(0)></p>
<pre><code>    image = mx.nd.random.uniform(0, 255, (2, 4, 2, 3)).astype(dtype=np.uint8)
    to_tensor(image)
        [[[[0.11764706 0.5803922 ]
           [0.9411765  0.10588235]
           [0.2627451  0.73333335]
           [0.5647059  0.32156864]]
          [[0.7176471  0.14117648]
           [0.75686276 0.4117647 ]
           [0.18431373 0.45490196]
           [0.13333334 0.6156863 ]]
          [[0.6392157  0.5372549 ]
           [0.52156866 0.47058824]
           [0.77254903 0.21568628]
           [0.01568628 0.14901961]]]
         [[[0.6117647  0.38431373]
           [0.6784314  0.6117647 ]
           [0.69411767 0.96862745]
           [0.67058825 0.35686275]]
          [[0.21960784 0.9411765 ]
           [0.44705883 0.43529412]
           [0.09803922 0.6666667 ]
           [0.16862746 0.1254902 ]]
          [[0.6156863  0.9019608 ]
           [0.35686275 0.9019608 ]
           [0.05882353 0.6509804 ]
           [0.20784314 0.7490196 ]]]]
        &lt;NDArray 2x3x4x2 @cpu(0)&gt;
</code></pre>

<p>Defined in src/operator/image/image_random.cc:L92</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input ndarray</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L398' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._imdecode-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._imdecode-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._imdecode</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_imdecode(mean, index, x0, y0, x1, y1, c, size)
</code></pre>

<p>Decode an image, clip to (x0, y0, x1, y1), subtract mean, and write to buffer</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>mean::NDArray-or-SymbolicNode</code>: image mean</li>
<li><code>index::int</code>: buffer position for output</li>
<li><code>x0::int</code>: x0</li>
<li><code>y0::int</code>: y0</li>
<li><code>x1::int</code>: x1</li>
<li><code>y1::int</code>: y1</li>
<li><code>c::int</code>: channel</li>
<li><code>size::int</code>: length of str_img</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L361' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._lesser-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._lesser-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._lesser</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_lesser(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._lesser_equal-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._lesser_equal-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._lesser_equal</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_lesser_equal(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._lesser_equal_scalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._lesser_equal_scalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._lesser_equal_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_lesser_equal_scalar(data, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._lesser_scalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._lesser_scalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._lesser_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_lesser_scalar(data, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._linalg_det-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._linalg_det-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._linalg_det</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_linalg_det(A)
</code></pre>

<p>Compute the determinant of a matrix. Input is a tensor <em>A</em> of dimension <em>n &gt;= 2</em>.</p>
<p>If <em>n=2</em>, <em>A</em> is a square matrix. We compute:</p>
<p><em>out</em> = <em>det(A)</em></p>
<p>If <em>n&gt;2</em>, <em>det</em> is performed separately on the trailing two dimensions for all inputs (batch mode).</p>
<p>.. note:: The operator supports float32 and float64 data types only. .. note:: There is no gradient backwarded when A is non-invertible (which is           equivalent to det(A) = 0) because zero is rarely hit upon in float           point computation and the Jacobi's formula on determinant gradient           is not computationally efficient when A is non-invertible.</p>
<p>Examples::</p>
<p>Single matrix determinant    A = [[1., 4.], [2., 3.]]    det(A) = [-5.]</p>
<p>Batch matrix determinant    A = [[[1., 4.], [2., 3.]],         [[2., 3.], [1., 4.]]]    det(A) = [-5., 5.]</p>
<p>Defined in src/operator/tensor/la_op.cc:L975</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>A::NDArray-or-SymbolicNode</code>: Tensor of square matrix</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L375' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._linalg_extractdiag-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._linalg_extractdiag-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._linalg_extractdiag</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_linalg_extractdiag(A, offset)
</code></pre>

<p>Extracts the diagonal entries of a square matrix. Input is a tensor <em>A</em> of dimension <em>n &gt;= 2</em>.</p>
<p>If <em>n=2</em>, then <em>A</em> represents a single square matrix which diagonal elements get extracted as a 1-dimensional tensor.</p>
<p>If <em>n&gt;2</em>, then <em>A</em> represents a batch of square matrices on the trailing two dimensions. The extracted diagonals are returned as an <em>n-1</em>-dimensional tensor.</p>
<p>.. note:: The operator supports float32 and float64 data types only.</p>
<p>Examples::</p>
<pre><code>Single matrix diagonal extraction
A = [[1.0, 2.0],
     [3.0, 4.0]]

extractdiag(A) = [1.0, 4.0]

extractdiag(A, 1) = [2.0]

Batch matrix diagonal extraction
A = [[[1.0, 2.0],
      [3.0, 4.0]],
     [[5.0, 6.0],
      [7.0, 8.0]]]

extractdiag(A) = [[1.0, 4.0],
                  [5.0, 8.0]]
</code></pre>

<p>Defined in src/operator/tensor/la_op.cc:L495</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>A::NDArray-or-SymbolicNode</code>: Tensor of square matrices</li>
<li><code>offset::int, optional, default='0'</code>: Offset of the diagonal versus the main diagonal. 0 corresponds to the main diagonal, a negative/positive value to diagonals below/above the main diagonal.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L378' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._linalg_extracttrian-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._linalg_extracttrian-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._linalg_extracttrian</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_linalg_extracttrian(A, offset, lower)
</code></pre>

<p>Extracts a triangular sub-matrix from a square matrix. Input is a tensor <em>A</em> of dimension <em>n &gt;= 2</em>.</p>
<p>If <em>n=2</em>, then <em>A</em> represents a single square matrix from which a triangular sub-matrix is extracted as a 1-dimensional tensor.</p>
<p>If <em>n&gt;2</em>, then <em>A</em> represents a batch of square matrices on the trailing two dimensions. The extracted triangular sub-matrices are returned as an <em>n-1</em>-dimensional tensor.</p>
<p>The <em>offset</em> and <em>lower</em> parameters determine the triangle to be extracted:</p>
<ul>
<li>When <em>offset = 0</em> either the lower or upper triangle with respect to the main diagonal is extracted depending on the value of parameter <em>lower</em>.</li>
<li>When <em>offset = k &gt; 0</em> the upper triangle with respect to the k-th diagonal above the main diagonal is extracted.</li>
<li>When <em>offset = k &lt; 0</em> the lower triangle with respect to the k-th diagonal below the main diagonal is extracted.</li>
</ul>
<p>.. note:: The operator supports float32 and float64 data types only.</p>
<p>Examples::</p>
<pre><code>Single triagonal extraction
A = [[1.0, 2.0],
     [3.0, 4.0]]

extracttrian(A) = [1.0, 3.0, 4.0]
extracttrian(A, lower=False) = [1.0, 2.0, 4.0]
extracttrian(A, 1) = [2.0]
extracttrian(A, -1) = [3.0]

Batch triagonal extraction
A = [[[1.0, 2.0],
      [3.0, 4.0]],
     [[5.0, 6.0],
      [7.0, 8.0]]]

extracttrian(A) = [[1.0, 3.0, 4.0],
                   [5.0, 7.0, 8.0]]
</code></pre>

<p>Defined in src/operator/tensor/la_op.cc:L605</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>A::NDArray-or-SymbolicNode</code>: Tensor of square matrices</li>
<li><code>offset::int, optional, default='0'</code>: Offset of the diagonal versus the main diagonal. 0 corresponds to the main diagonal, a negative/positive value to diagonals below/above the main diagonal.</li>
<li><code>lower::boolean, optional, default=1</code>: Refer to the lower triangular matrix if lower=true, refer to the upper otherwise. Only relevant when offset=0</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L387' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._linalg_gelqf-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._linalg_gelqf-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._linalg_gelqf</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_linalg_gelqf(A)
</code></pre>

<p>LQ factorization for general matrix. Input is a tensor <em>A</em> of dimension <em>n &gt;= 2</em>.</p>
<p>If <em>n=2</em>, we compute the LQ factorization (LAPACK <em>gelqf</em>, followed by <em>orglq</em>). <em>A</em> must have shape <em>(x, y)</em> with <em>x &lt;= y</em>, and must have full rank <em>=x</em>. The LQ factorization consists of <em>L</em> with shape <em>(x, x)</em> and <em>Q</em> with shape <em>(x, y)</em>, so that:</p>
<p><em>A</em> = <em>L</em> * <em>Q</em></p>
<p>Here, <em>L</em> is lower triangular (upper triangle equal to zero) with nonzero diagonal, and <em>Q</em> is row-orthonormal, meaning that</p>
<p><em>Q</em> * <em>Q</em>\ :sup:<code>T</code></p>
<p>is equal to the identity matrix of shape <em>(x, x)</em>.</p>
<p>If <em>n&gt;2</em>, <em>gelqf</em> is performed separately on the trailing two dimensions for all inputs (batch mode).</p>
<p>.. note:: The operator supports float32 and float64 data types only.</p>
<p>Examples::</p>
<p>Single LQ factorization    A = [[1., 2., 3.], [4., 5., 6.]]    Q, L = gelqf(A)    Q = [[-0.26726124, -0.53452248, -0.80178373],         [0.87287156, 0.21821789, -0.43643578]]    L = [[-3.74165739, 0.],         [-8.55235974, 1.96396101]]</p>
<p>Batch LQ factorization    A = [[[1., 2., 3.], [4., 5., 6.]],         [[7., 8., 9.], [10., 11., 12.]]]    Q, L = gelqf(A)    Q = [[[-0.26726124, -0.53452248, -0.80178373],          [0.87287156, 0.21821789, -0.43643578]],         [[-0.50257071, -0.57436653, -0.64616234],          [0.7620735, 0.05862104, -0.64483142]]]    L = [[[-3.74165739, 0.],          [-8.55235974, 1.96396101]],         [[-13.92838828, 0.],          [-19.09768702, 0.52758934]]]</p>
<p>Defined in src/operator/tensor/la_op.cc:L798</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>A::NDArray-or-SymbolicNode</code>: Tensor of input matrices to be factorized</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L393' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._linalg_gemm-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._linalg_gemm-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._linalg_gemm</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_linalg_gemm(A, B, C, transpose_a, transpose_b, alpha, beta, axis)
</code></pre>

<p>Performs general matrix multiplication and accumulation. Input are tensors <em>A</em>, <em>B</em>, <em>C</em>, each of dimension <em>n &gt;= 2</em> and having the same shape on the leading <em>n-2</em> dimensions.</p>
<p>If <em>n=2</em>, the BLAS3 function <em>gemm</em> is performed:</p>
<p><em>out</em> = <em>alpha</em> * <em>op</em>\ (<em>A</em>) * <em>op</em>\ (<em>B</em>) + <em>beta</em> * <em>C</em></p>
<p>Here, <em>alpha</em> and <em>beta</em> are scalar parameters, and <em>op()</em> is either the identity or matrix transposition (depending on <em>transpose_a</em>, <em>transpose_b</em>).</p>
<p>If <em>n&gt;2</em>, <em>gemm</em> is performed separately for a batch of matrices. The column indices of the matrices are given by the last dimensions of the tensors, the row indices by the axis specified with the <em>axis</em> parameter. By default, the trailing two dimensions will be used for matrix encoding.</p>
<p>For a non-default axis parameter, the operation performed is equivalent to a series of swapaxes/gemm/swapaxes calls. For example let <em>A</em>, <em>B</em>, <em>C</em> be 5 dimensional tensors. Then gemm(<em>A</em>, <em>B</em>, <em>C</em>, axis=1) is equivalent to the following without the overhead of the additional swapaxis operations::</p>
<pre><code>A1 = swapaxes(A, dim1=1, dim2=3)
B1 = swapaxes(B, dim1=1, dim2=3)
C = swapaxes(C, dim1=1, dim2=3)
C = gemm(A1, B1, C)
C = swapaxis(C, dim1=1, dim2=3)
</code></pre>

<p>When the input data is of type float32 and the environment variables MXNET<em>CUDA</em>ALLOW<em>TENSOR</em>CORE and MXNET<em>CUDA</em>TENSOR<em>OP</em>MATH<em>ALLOW</em>CONVERSION are set to 1, this operator will try to use pseudo-float16 precision (float32 math with float16 I/O) precision in order to use Tensor Cores on suitable NVIDIA GPUs. This can sometimes give significant speedups.</p>
<p>.. note:: The operator supports float32 and float64 data types only.</p>
<p>Examples::</p>
<p>Single matrix multiply-add    A = [[1.0, 1.0], [1.0, 1.0]]    B = [[1.0, 1.0], [1.0, 1.0], [1.0, 1.0]]    C = [[1.0, 1.0, 1.0], [1.0, 1.0, 1.0]]    gemm(A, B, C, transpose_b=True, alpha=2.0, beta=10.0)            = [[14.0, 14.0, 14.0], [14.0, 14.0, 14.0]]</p>
<p>Batch matrix multiply-add    A = [[[1.0, 1.0]], [[0.1, 0.1]]]    B = [[[1.0, 1.0]], [[0.1, 0.1]]]    C = [[[10.0]], [[0.01]]]    gemm(A, B, C, transpose_b=True, alpha=2.0 , beta=10.0)            = [[[104.0]], [[0.14]]]</p>
<p>Defined in src/operator/tensor/la_op.cc:L89</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>A::NDArray-or-SymbolicNode</code>: Tensor of input matrices</li>
<li><code>B::NDArray-or-SymbolicNode</code>: Tensor of input matrices</li>
<li><code>C::NDArray-or-SymbolicNode</code>: Tensor of input matrices</li>
<li><code>transpose_a::boolean, optional, default=0</code>: Multiply with transposed of first input (A).</li>
<li><code>transpose_b::boolean, optional, default=0</code>: Multiply with transposed of second input (B).</li>
<li><code>alpha::double, optional, default=1</code>: Scalar factor multiplied with A*B.</li>
<li><code>beta::double, optional, default=1</code>: Scalar factor multiplied with C.</li>
<li><code>axis::int, optional, default='-2'</code>: Axis corresponding to the matrix rows.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L410' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._linalg_gemm2-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._linalg_gemm2-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._linalg_gemm2</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_linalg_gemm2(A, B, transpose_a, transpose_b, alpha, axis)
</code></pre>

<p>Performs general matrix multiplication. Input are tensors <em>A</em>, <em>B</em>, each of dimension <em>n &gt;= 2</em> and having the same shape on the leading <em>n-2</em> dimensions.</p>
<p>If <em>n=2</em>, the BLAS3 function <em>gemm</em> is performed:</p>
<p><em>out</em> = <em>alpha</em> * <em>op</em>\ (<em>A</em>) * <em>op</em>\ (<em>B</em>)</p>
<p>Here <em>alpha</em> is a scalar parameter and <em>op()</em> is either the identity or the matrix transposition (depending on <em>transpose_a</em>, <em>transpose_b</em>).</p>
<p>If <em>n&gt;2</em>, <em>gemm</em> is performed separately for a batch of matrices. The column indices of the matrices are given by the last dimensions of the tensors, the row indices by the axis specified with the <em>axis</em> parameter. By default, the trailing two dimensions will be used for matrix encoding.</p>
<p>For a non-default axis parameter, the operation performed is equivalent to a series of swapaxes/gemm/swapaxes calls. For example let <em>A</em>, <em>B</em> be 5 dimensional tensors. Then gemm(<em>A</em>, <em>B</em>, axis=1) is equivalent to the following without the overhead of the additional swapaxis operations::</p>
<pre><code>A1 = swapaxes(A, dim1=1, dim2=3)
B1 = swapaxes(B, dim1=1, dim2=3)
C = gemm2(A1, B1)
C = swapaxis(C, dim1=1, dim2=3)
</code></pre>

<p>When the input data is of type float32 and the environment variables MXNET<em>CUDA</em>ALLOW<em>TENSOR</em>CORE and MXNET<em>CUDA</em>TENSOR<em>OP</em>MATH<em>ALLOW</em>CONVERSION are set to 1, this operator will try to use pseudo-float16 precision (float32 math with float16 I/O) precision in order to use Tensor Cores on suitable NVIDIA GPUs. This can sometimes give significant speedups.</p>
<p>.. note:: The operator supports float32 and float64 data types only.</p>
<p>Examples::</p>
<p>Single matrix multiply    A = [[1.0, 1.0], [1.0, 1.0]]    B = [[1.0, 1.0], [1.0, 1.0], [1.0, 1.0]]    gemm2(A, B, transpose_b=True, alpha=2.0)             = [[4.0, 4.0, 4.0], [4.0, 4.0, 4.0]]</p>
<p>Batch matrix multiply    A = [[[1.0, 1.0]], [[0.1, 0.1]]]    B = [[[1.0, 1.0]], [[0.1, 0.1]]]    gemm2(A, B, transpose_b=True, alpha=2.0)            = [[[4.0]], [[0.04 ]]]</p>
<p>Defined in src/operator/tensor/la_op.cc:L163</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>A::NDArray-or-SymbolicNode</code>: Tensor of input matrices</li>
<li><code>B::NDArray-or-SymbolicNode</code>: Tensor of input matrices</li>
<li><code>transpose_a::boolean, optional, default=0</code>: Multiply with transposed of first input (A).</li>
<li><code>transpose_b::boolean, optional, default=0</code>: Multiply with transposed of second input (B).</li>
<li><code>alpha::double, optional, default=1</code>: Scalar factor multiplied with A*B.</li>
<li><code>axis::int, optional, default='-2'</code>: Axis corresponding to the matrix row indices.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L403' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._linalg_inverse-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._linalg_inverse-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._linalg_inverse</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_linalg_inverse(A)
</code></pre>

<p>Compute the inverse of a matrix. Input is a tensor <em>A</em> of dimension <em>n &gt;= 2</em>.</p>
<p>If <em>n=2</em>, <em>A</em> is a square matrix. We compute:</p>
<p><em>out</em> = <em>A</em>\ :sup:<code>-1</code></p>
<p>If <em>n&gt;2</em>, <em>inverse</em> is performed separately on the trailing two dimensions for all inputs (batch mode).</p>
<p>.. note:: The operator supports float32 and float64 data types only.</p>
<p>Examples::</p>
<p>Single matrix inverse    A = [[1., 4.], [2., 3.]]    inverse(A) = [[-0.6, 0.8], [0.4, -0.2]]</p>
<p>Batch matrix inverse    A = [[[1., 4.], [2., 3.]],         [[1., 3.], [2., 4.]]]    inverse(A) = [[[-0.6, 0.8], [0.4, -0.2]],                  [[-2., 1.5], [1., -0.5]]]</p>
<p>Defined in src/operator/tensor/la_op.cc:L920</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>A::NDArray-or-SymbolicNode</code>: Tensor of square matrix</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L372' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._linalg_makediag-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._linalg_makediag-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._linalg_makediag</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_linalg_makediag(A, offset)
</code></pre>

<p>Constructs a square matrix with the input as diagonal. Input is a tensor <em>A</em> of dimension <em>n &gt;= 1</em>.</p>
<p>If <em>n=1</em>, then <em>A</em> represents the diagonal entries of a single square matrix. This matrix will be returned as a 2-dimensional tensor. If <em>n&gt;1</em>, then <em>A</em> represents a batch of diagonals of square matrices. The batch of diagonal matrices will be returned as an <em>n+1</em>-dimensional tensor.</p>
<p>.. note:: The operator supports float32 and float64 data types only.</p>
<p>Examples::</p>
<pre><code>Single diagonal matrix construction
A = [1.0, 2.0]

makediag(A)    = [[1.0, 0.0],
                  [0.0, 2.0]]

makediag(A, 1) = [[0.0, 1.0, 0.0],
                  [0.0, 0.0, 2.0],
                  [0.0, 0.0, 0.0]]

Batch diagonal matrix construction
A = [[1.0, 2.0],
     [3.0, 4.0]]

makediag(A) = [[[1.0, 0.0],
                [0.0, 2.0]],
               [[3.0, 0.0],
                [0.0, 4.0]]]
</code></pre>

<p>Defined in src/operator/tensor/la_op.cc:L547</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>A::NDArray-or-SymbolicNode</code>: Tensor of diagonal entries</li>
<li><code>offset::int, optional, default='0'</code>: Offset of the diagonal versus the main diagonal. 0 corresponds to the main diagonal, a negative/positive value to diagonals below/above the main diagonal.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L379' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._linalg_maketrian-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._linalg_maketrian-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._linalg_maketrian</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_linalg_maketrian(A, offset, lower)
</code></pre>

<p>Constructs a square matrix with the input representing a specific triangular sub-matrix. This is basically the inverse of <em>linalg.extracttrian</em>. Input is a tensor <em>A</em> of dimension <em>n &gt;= 1</em>.</p>
<p>If <em>n=1</em>, then <em>A</em> represents the entries of a triangular matrix which is lower triangular if <em>offset&lt;0</em> or <em>offset=0</em>, <em>lower=true</em>. The resulting matrix is derived by first constructing the square matrix with the entries outside the triangle set to zero and then adding <em>offset</em>-times an additional  diagonal with zero entries to the square matrix. </p>
<p>If <em>n&gt;1</em>, then <em>A</em> represents a batch of triangular sub-matrices. The batch of corresponding square matrices is returned as an <em>n+1</em>-dimensional tensor.</p>
<p>.. note:: The operator supports float32 and float64 data types only.</p>
<p>Examples::</p>
<pre><code>Single  matrix construction
A = [1.0, 2.0, 3.0]

maketrian(A)              = [[1.0, 0.0],
                             [2.0, 3.0]]

maketrian(A, lower=false) = [[1.0, 2.0],
                             [0.0, 3.0]]

maketrian(A, offset=1)    = [[0.0, 1.0, 2.0],
                             [0.0, 0.0, 3.0],
                             [0.0, 0.0, 0.0]]
maketrian(A, offset=-1)   = [[0.0, 0.0, 0.0],
                             [1.0, 0.0, 0.0],
                             [2.0, 3.0, 0.0]]

Batch matrix construction
A = [[1.0, 2.0, 3.0],
     [4.0, 5.0, 6.0]]

maketrian(A)           = [[[1.0, 0.0],
                           [2.0, 3.0]],
                          [[4.0, 0.0],
                           [5.0, 6.0]]]

maketrian(A, offset=1) = [[[0.0, 1.0, 2.0],
                           [0.0, 0.0, 3.0],
                           [0.0, 0.0, 0.0]],
                          [[0.0, 4.0, 5.0],
                           [0.0, 0.0, 6.0],
                           [0.0, 0.0, 0.0]]]
</code></pre>

<p>Defined in src/operator/tensor/la_op.cc:L673</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>A::NDArray-or-SymbolicNode</code>: Tensor of triangular matrices stored as vectors</li>
<li><code>offset::int, optional, default='0'</code>: Offset of the diagonal versus the main diagonal. 0 corresponds to the main diagonal, a negative/positive value to diagonals below/above the main diagonal.</li>
<li><code>lower::boolean, optional, default=1</code>: Refer to the lower triangular matrix if lower=true, refer to the upper otherwise. Only relevant when offset=0</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L397' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._linalg_potrf-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._linalg_potrf-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._linalg_potrf</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_linalg_potrf(A)
</code></pre>

<p>Performs Cholesky factorization of a symmetric positive-definite matrix. Input is a tensor <em>A</em> of dimension <em>n &gt;= 2</em>.</p>
<p>If <em>n=2</em>, the Cholesky factor <em>B</em> of the symmetric, positive definite matrix <em>A</em> is computed. <em>B</em> is triangular (entries of upper or lower triangle are all zero), has positive diagonal entries, and:</p>
<p><em>A</em> = <em>B</em> * <em>B</em>\ :sup:<code>T</code>  if <em>lower</em> = <em>true</em>   <em>A</em> = <em>B</em>\ :sup:<code>T</code> * <em>B</em>  if <em>lower</em> = <em>false</em></p>
<p>If <em>n&gt;2</em>, <em>potrf</em> is performed separately on the trailing two dimensions for all inputs (batch mode).</p>
<p>.. note:: The operator supports float32 and float64 data types only.</p>
<p>Examples::</p>
<p>Single matrix factorization    A = [[4.0, 1.0], [1.0, 4.25]]    potrf(A) = [[2.0, 0], [0.5, 2.0]]</p>
<p>Batch matrix factorization    A = [[[4.0, 1.0], [1.0, 4.25]], [[16.0, 4.0], [4.0, 17.0]]]    potrf(A) = [[[2.0, 0], [0.5, 2.0]], [[4.0, 0], [1.0, 4.0]]]</p>
<p>Defined in src/operator/tensor/la_op.cc:L214</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>A::NDArray-or-SymbolicNode</code>: Tensor of input matrices to be decomposed</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L373' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._linalg_potri-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._linalg_potri-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._linalg_potri</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_linalg_potri(A)
</code></pre>

<p>Performs matrix inversion from a Cholesky factorization. Input is a tensor <em>A</em> of dimension <em>n &gt;= 2</em>.</p>
<p>If <em>n=2</em>, <em>A</em> is a triangular matrix (entries of upper or lower triangle are all zero) with positive diagonal. We compute:</p>
<p><em>out</em> = <em>A</em>\ :sup:<code>-T</code> * <em>A</em>\ :sup:<code>-1</code> if <em>lower</em> = <em>true</em>   <em>out</em> = <em>A</em>\ :sup:<code>-1</code> * <em>A</em>\ :sup:<code>-T</code> if <em>lower</em> = <em>false</em></p>
<p>In other words, if <em>A</em> is the Cholesky factor of a symmetric positive definite matrix <em>B</em> (obtained by <em>potrf</em>), then</p>
<p><em>out</em> = <em>B</em>\ :sup:<code>-1</code></p>
<p>If <em>n&gt;2</em>, <em>potri</em> is performed separately on the trailing two dimensions for all inputs (batch mode).</p>
<p>.. note:: The operator supports float32 and float64 data types only.</p>
<p>.. note:: Use this operator only if you are certain you need the inverse of <em>B</em>, and           cannot use the Cholesky factor <em>A</em> (<em>potrf</em>), together with backsubstitution           (<em>trsm</em>). The latter is numerically much safer, and also cheaper.</p>
<p>Examples::</p>
<p>Single matrix inverse    A = [[2.0, 0], [0.5, 2.0]]    potri(A) = [[0.26563, -0.0625], [-0.0625, 0.25]]</p>
<p>Batch matrix inverse    A = [[[2.0, 0], [0.5, 2.0]], [[4.0, 0], [1.0, 4.0]]]    potri(A) = [[[0.26563, -0.0625], [-0.0625, 0.25]],                [[0.06641, -0.01562], [-0.01562, 0,0625]]]</p>
<p>Defined in src/operator/tensor/la_op.cc:L275</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>A::NDArray-or-SymbolicNode</code>: Tensor of lower triangular matrices</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L382' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._linalg_slogdet-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._linalg_slogdet-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._linalg_slogdet</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_linalg_slogdet(A)
</code></pre>

<p>Compute the sign and log of the determinant of a matrix. Input is a tensor <em>A</em> of dimension <em>n &gt;= 2</em>.</p>
<p>If <em>n=2</em>, <em>A</em> is a square matrix. We compute:</p>
<p><em>sign</em> = <em>sign(det(A))</em>   <em>logabsdet</em> = <em>log(abs(det(A)))</em></p>
<p>If <em>n&gt;2</em>, <em>slogdet</em> is performed separately on the trailing two dimensions for all inputs (batch mode).</p>
<p>.. note:: The operator supports float32 and float64 data types only. .. note:: The gradient is not properly defined on sign, so the gradient of           it is not backwarded. .. note:: No gradient is backwarded when A is non-invertible. Please see           the docs of operator det for detail.</p>
<p>Examples::</p>
<p>Single matrix signed log determinant    A = [[2., 3.], [1., 4.]]    sign, logabsdet = slogdet(A)    sign = [1.]    logabsdet = [1.609438]</p>
<p>Batch matrix signed log determinant    A = [[[2., 3.], [1., 4.]],         [[1., 2.], [2., 4.]],         [[1., 2.], [4., 3.]]]    sign, logabsdet = slogdet(A)    sign = [1., 0., -1.]    logabsdet = [1.609438, -inf, 1.609438]</p>
<p>Defined in src/operator/tensor/la_op.cc:L1034</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>A::NDArray-or-SymbolicNode</code>: Tensor of square matrix</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L381' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._linalg_sumlogdiag-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._linalg_sumlogdiag-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._linalg_sumlogdiag</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_linalg_sumlogdiag(A)
</code></pre>

<p>Computes the sum of the logarithms of the diagonal elements of a square matrix. Input is a tensor <em>A</em> of dimension <em>n &gt;= 2</em>.</p>
<p>If <em>n=2</em>, <em>A</em> must be square with positive diagonal entries. We sum the natural logarithms of the diagonal elements, the result has shape (1,).</p>
<p>If <em>n&gt;2</em>, <em>sumlogdiag</em> is performed separately on the trailing two dimensions for all inputs (batch mode).</p>
<p>.. note:: The operator supports float32 and float64 data types only.</p>
<p>Examples::</p>
<p>Single matrix reduction    A = [[1.0, 1.0], [1.0, 7.0]]    sumlogdiag(A) = [1.9459]</p>
<p>Batch matrix reduction    A = [[[1.0, 1.0], [1.0, 7.0]], [[3.0, 0], [0, 17.0]]]    sumlogdiag(A) = [1.9459, 3.9318]</p>
<p>Defined in src/operator/tensor/la_op.cc:L445</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>A::NDArray-or-SymbolicNode</code>: Tensor of square matrices</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L369' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._linalg_syevd-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._linalg_syevd-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._linalg_syevd</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_linalg_syevd(A)
</code></pre>

<p>Eigendecomposition for symmetric matrix. Input is a tensor <em>A</em> of dimension <em>n &gt;= 2</em>.</p>
<p>If <em>n=2</em>, <em>A</em> must be symmetric, of shape <em>(x, x)</em>. We compute the eigendecomposition, resulting in the orthonormal matrix <em>U</em> of eigenvectors, shape <em>(x, x)</em>, and the vector <em>L</em> of eigenvalues, shape <em>(x,)</em>, so that:</p>
<p><em>U</em> * <em>A</em> = <em>diag(L)</em> * <em>U</em></p>
<p>Here:</p>
<p><em>U</em> * <em>U</em>\ :sup:<code>T</code> = <em>U</em>\ :sup:<code>T</code> * <em>U</em> = <em>I</em></p>
<p>where <em>I</em> is the identity matrix. Also, <em>L(0) &lt;= L(1) &lt;= L(2) &lt;= ...</em> (ascending order).</p>
<p>If <em>n&gt;2</em>, <em>syevd</em> is performed separately on the trailing two dimensions of <em>A</em> (batch mode). In this case, <em>U</em> has <em>n</em> dimensions like <em>A</em>, and <em>L</em> has <em>n-1</em> dimensions.</p>
<p>.. note:: The operator supports float32 and float64 data types only.</p>
<p>.. note:: Derivatives for this operator are defined only if <em>A</em> is such that all its           eigenvalues are distinct, and the eigengaps are not too small. If you need           gradients, do not apply this operator to matrices with multiple eigenvalues.</p>
<p>Examples::</p>
<p>Single symmetric eigendecomposition    A = [[1., 2.], [2., 4.]]    U, L = syevd(A)    U = [[0.89442719, -0.4472136],         [0.4472136, 0.89442719]]    L = [0., 5.]</p>
<p>Batch symmetric eigendecomposition    A = [[[1., 2.], [2., 4.]],         [[1., 2.], [2., 5.]]]    U, L = syevd(A)    U = [[[0.89442719, -0.4472136],          [0.4472136, 0.89442719]],         [[0.92387953, -0.38268343],          [0.38268343, 0.92387953]]]    L = [[0., 5.],         [0.17157288, 5.82842712]]</p>
<p>Defined in src/operator/tensor/la_op.cc:L868</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>A::NDArray-or-SymbolicNode</code>: Tensor of input matrices to be factorized</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L392' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._linalg_syrk-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._linalg_syrk-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._linalg_syrk</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_linalg_syrk(A, transpose, alpha)
</code></pre>

<p>Multiplication of matrix with its transpose. Input is a tensor <em>A</em> of dimension <em>n &gt;= 2</em>.</p>
<p>If <em>n=2</em>, the operator performs the BLAS3 function <em>syrk</em>:</p>
<p><em>out</em> = <em>alpha</em> * <em>A</em> * <em>A</em>\ :sup:<code>T</code></p>
<p>if <em>transpose=False</em>, or</p>
<p><em>out</em> = <em>alpha</em> * <em>A</em>\ :sup:<code>T</code> \ * <em>A</em></p>
<p>if <em>transpose=True</em>.</p>
<p>If <em>n&gt;2</em>, <em>syrk</em> is performed separately on the trailing two dimensions for all inputs (batch mode).</p>
<p>.. note:: The operator supports float32 and float64 data types only.</p>
<p>Examples::</p>
<p>Single matrix multiply    A = [[1., 2., 3.], [4., 5., 6.]]    syrk(A, alpha=1., transpose=False)             = [[14., 32.],                [32., 77.]]    syrk(A, alpha=1., transpose=True)             = [[17., 22., 27.],                [22., 29., 36.],                [27., 36., 45.]]</p>
<p>Batch matrix multiply    A = [[[1., 1.]], [[0.1, 0.1]]]    syrk(A, alpha=2., transpose=False) = [[[4.]], [[0.04]]]</p>
<p>Defined in src/operator/tensor/la_op.cc:L730</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>A::NDArray-or-SymbolicNode</code>: Tensor of input matrices</li>
<li><code>transpose::boolean, optional, default=0</code>: Use transpose of input matrix.</li>
<li><code>alpha::double, optional, default=1</code>: Scalar factor to be applied to the result.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L386' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._linalg_trmm-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._linalg_trmm-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._linalg_trmm</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_linalg_trmm(A, B, transpose, rightside, lower, alpha)
</code></pre>

<p>Performs multiplication with a lower triangular matrix. Input are tensors <em>A</em>, <em>B</em>, each of dimension <em>n &gt;= 2</em> and having the same shape on the leading <em>n-2</em> dimensions.</p>
<p>If <em>n=2</em>, <em>A</em> must be triangular. The operator performs the BLAS3 function <em>trmm</em>:</p>
<p><em>out</em> = <em>alpha</em> * <em>op</em>\ (<em>A</em>) * <em>B</em></p>
<p>if <em>rightside=False</em>, or</p>
<p><em>out</em> = <em>alpha</em> * <em>B</em> * <em>op</em>\ (<em>A</em>)</p>
<p>if <em>rightside=True</em>. Here, <em>alpha</em> is a scalar parameter, and <em>op()</em> is either the identity or the matrix transposition (depending on <em>transpose</em>).</p>
<p>If <em>n&gt;2</em>, <em>trmm</em> is performed separately on the trailing two dimensions for all inputs (batch mode).</p>
<p>.. note:: The operator supports float32 and float64 data types only.</p>
<p>Examples::</p>
<p>Single triangular matrix multiply    A = [[1.0, 0], [1.0, 1.0]]    B = [[1.0, 1.0, 1.0], [1.0, 1.0, 1.0]]    trmm(A, B, alpha=2.0) = [[2.0, 2.0, 2.0], [4.0, 4.0, 4.0]]</p>
<p>Batch triangular matrix multiply    A = [[[1.0, 0], [1.0, 1.0]], [[1.0, 0], [1.0, 1.0]]]    B = [[[1.0, 1.0, 1.0], [1.0, 1.0, 1.0]], [[0.5, 0.5, 0.5], [0.5, 0.5, 0.5]]]    trmm(A, B, alpha=2.0) = [[[2.0, 2.0, 2.0], [4.0, 4.0, 4.0]],                             [[1.0, 1.0, 1.0], [2.0, 2.0, 2.0]]]</p>
<p>Defined in src/operator/tensor/la_op.cc:L333</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>A::NDArray-or-SymbolicNode</code>: Tensor of lower triangular matrices</li>
<li><code>B::NDArray-or-SymbolicNode</code>: Tensor of matrices</li>
<li><code>transpose::boolean, optional, default=0</code>: Use transposed of the triangular matrix</li>
<li><code>rightside::boolean, optional, default=0</code>: Multiply triangular matrix from the right to non-triangular one.</li>
<li><code>lower::boolean, optional, default=1</code>: True if the triangular matrix is lower triangular, false if it is upper triangular.</li>
<li><code>alpha::double, optional, default=1</code>: Scalar factor to be applied to the result.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L392' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._linalg_trsm-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._linalg_trsm-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._linalg_trsm</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_linalg_trsm(A, B, transpose, rightside, lower, alpha)
</code></pre>

<p>Solves matrix equation involving a lower triangular matrix. Input are tensors <em>A</em>, <em>B</em>, each of dimension <em>n &gt;= 2</em> and having the same shape on the leading <em>n-2</em> dimensions.</p>
<p>If <em>n=2</em>, <em>A</em> must be triangular. The operator performs the BLAS3 function <em>trsm</em>, solving for <em>out</em> in:</p>
<p><em>op</em>\ (<em>A</em>) * <em>out</em> = <em>alpha</em> * <em>B</em></p>
<p>if <em>rightside=False</em>, or</p>
<p><em>out</em> * <em>op</em>\ (<em>A</em>) = <em>alpha</em> * <em>B</em></p>
<p>if <em>rightside=True</em>. Here, <em>alpha</em> is a scalar parameter, and <em>op()</em> is either the identity or the matrix transposition (depending on <em>transpose</em>).</p>
<p>If <em>n&gt;2</em>, <em>trsm</em> is performed separately on the trailing two dimensions for all inputs (batch mode).</p>
<p>.. note:: The operator supports float32 and float64 data types only.</p>
<p>Examples::</p>
<p>Single matrix solve    A = [[1.0, 0], [1.0, 1.0]]    B = [[2.0, 2.0, 2.0], [4.0, 4.0, 4.0]]    trsm(A, B, alpha=0.5) = [[1.0, 1.0, 1.0], [1.0, 1.0, 1.0]]</p>
<p>Batch matrix solve    A = [[[1.0, 0], [1.0, 1.0]], [[1.0, 0], [1.0, 1.0]]]    B = [[[2.0, 2.0, 2.0], [4.0, 4.0, 4.0]],         [[4.0, 4.0, 4.0], [8.0, 8.0, 8.0]]]    trsm(A, B, alpha=0.5) = [[[1.0, 1.0, 1.0], [1.0, 1.0, 1.0]],                             [[2.0, 2.0, 2.0], [2.0, 2.0, 2.0]]]</p>
<p>Defined in src/operator/tensor/la_op.cc:L396</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>A::NDArray-or-SymbolicNode</code>: Tensor of lower triangular matrices</li>
<li><code>B::NDArray-or-SymbolicNode</code>: Tensor of matrices</li>
<li><code>transpose::boolean, optional, default=0</code>: Use transposed of the triangular matrix</li>
<li><code>rightside::boolean, optional, default=0</code>: Multiply triangular matrix from the right to non-triangular one.</li>
<li><code>lower::boolean, optional, default=1</code>: True if the triangular matrix is lower triangular, false if it is upper triangular.</li>
<li><code>alpha::double, optional, default=1</code>: Scalar factor to be applied to the result.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L393' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._logical_and-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._logical_and-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._logical_and</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_logical_and(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._logical_and_scalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._logical_and_scalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._logical_and_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_logical_and_scalar(data, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._logical_or-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._logical_or-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._logical_or</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_logical_or(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._logical_or_scalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._logical_or_scalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._logical_or_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_logical_or_scalar(data, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._logical_xor-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._logical_xor-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._logical_xor</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_logical_xor(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._logical_xor_scalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._logical_xor_scalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._logical_xor_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_logical_xor_scalar(data, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._maximum_scalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._maximum_scalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._maximum_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_maximum_scalar(data, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._minimum_scalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._minimum_scalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._minimum_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_minimum_scalar(data, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._minus-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._minus-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._minus</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_minus(lhs, rhs)
</code></pre>

<p><em>minus is an alias of elemwise</em>sub.</p>
<p>Subtracts arguments element-wise.</p>
<p>The storage type of $elemwise_sub$ output depends on storage types of inputs</p>
<ul>
<li>elemwise<em>sub(row</em>sparse, row<em>sparse) = row</em>sparse</li>
<li>elemwise_sub(csr, csr) = csr</li>
<li>elemwise_sub(default, csr) = default</li>
<li>elemwise_sub(csr, default) = default</li>
<li>elemwise_sub(default, rsp) = default</li>
<li>elemwise_sub(rsp, default) = default</li>
<li>otherwise, $elemwise_sub$ generates output with default storage</li>
</ul>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L363' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._minus_scalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._minus_scalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._minus_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_minus_scalar(data, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._mod-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._mod-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._mod</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_mod(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._mod_scalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._mod_scalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._mod_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_mod_scalar(data, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._mp_adamw_update-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._mp_adamw_update-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._mp_adamw_update</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_mp_adamw_update(weight, grad, mean, var, weight32, rescale_grad, lr, beta1, beta2, epsilon, wd, eta, clip_gradient)
</code></pre>

<p>Update function for multi-precision AdamW optimizer.</p>
<p>AdamW is seen as a modification of Adam by decoupling the weight decay from the optimization steps taken w.r.t. the loss function.</p>
<p>Adam update consists of the following steps, where g represents gradient and m, v are 1st and 2nd order moment estimates (mean and variance).</p>
<p>.. math::</p>
<p>g<em t-1="t-1">t = \nabla J(W</em>)\
 m<em>t = \beta</em>1 m<em>{t-1} + (1 - \beta</em>1) g<em>t\
 v</em>t = \beta<em t-1="t-1">2 v</em> + (1 - \beta<em>2) g</em>t^2\
 W<em t-1="t-1">t = W</em> - \eta<em>t (\alpha \frac{ m</em>t }{ \sqrt{ v<em t-1="t-1">t } + \epsilon } + wd W</em>)</p>
<p>It updates the weights using::</p>
<p>m = beta1<em>m + (1-beta1)</em>grad  v = beta2<em>v + (1-beta2)</em>(grad**2)  w -= eta * (learning_rate * m / (sqrt(v) + epsilon) + w * wd)</p>
<p>Note that gradient is rescaled to grad = rescale<em>grad * grad. If rescale</em>grad is NaN, Inf, or 0, the update is skipped.</p>
<p>Defined in src/operator/contrib/adamw.cc:L58</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>weight::NDArray-or-SymbolicNode</code>: Weight</li>
<li><code>grad::NDArray-or-SymbolicNode</code>: Gradient</li>
<li><code>mean::NDArray-or-SymbolicNode</code>: Moving mean</li>
<li><code>var::NDArray-or-SymbolicNode</code>: Moving variance</li>
<li><code>weight32::NDArray-or-SymbolicNode</code>: Weight32</li>
<li><code>rescale_grad::NDArray-or-SymbolicNode</code>: Rescale gradient to rescale_grad * grad. If NaN, Inf, or 0, the update is skipped.</li>
<li><code>lr::float, required</code>: Learning rate</li>
<li><code>beta1::float, optional, default=0.899999976</code>: The decay rate for the 1st moment estimates.</li>
<li><code>beta2::float, optional, default=0.999000013</code>: The decay rate for the 2nd moment estimates.</li>
<li><code>epsilon::float, optional, default=9.99999994e-09</code>: A small constant for numerical stability.</li>
<li><code>wd::float, optional, default=0</code>: Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</li>
<li><code>eta::float, required</code>: Learning rate schedule multiplier</li>
<li><code>clip_gradient::float, optional, default=-1</code>: Clip gradient to the range of [-clip<em>gradient, clip</em>gradient] If clip<em>gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip</em>gradient), -clip_gradient).</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L396' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._mul-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._mul-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._mul</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_mul(lhs, rhs)
</code></pre>

<p><em>mul is an alias of elemwise</em>mul.</p>
<p>Multiplies arguments element-wise.</p>
<p>The storage type of $elemwise_mul$ output depends on storage types of inputs</p>
<ul>
<li>elemwise_mul(default, default) = default</li>
<li>elemwise<em>mul(row</em>sparse, row<em>sparse) = row</em>sparse</li>
<li>elemwise<em>mul(default, row</em>sparse) = row_sparse</li>
<li>elemwise<em>mul(row</em>sparse, default) = row_sparse</li>
<li>elemwise_mul(csr, csr) = csr</li>
<li>otherwise, $elemwise_mul$ generates output with default storage</li>
</ul>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L362' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._mul_scalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._mul_scalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._mul_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_mul_scalar(data, scalar)
</code></pre>

<p>Multiply an array with a scalar.</p>
<p>$_mul_scalar$ only operates on data array of input if input is sparse.</p>
<p>For example, if input of shape (100, 100) has only 2 non zero elements, i.e. input.data = [5, 6], scalar = nan, it will result output.data = [nan, nan] instead of 10000 nans.</p>
<p>Defined in src/operator/tensor/elemwise<em>binary</em>scalar<em>op</em>basic.cc:L149</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L359' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._multi_adamw_update-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._multi_adamw_update-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._multi_adamw_update</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_multi_adamw_update(data, lrs, beta1, beta2, epsilon, wds, etas, clip_gradient, num_weights)
</code></pre>

<p>Update function for AdamW optimizer.</p>
<p>AdamW is seen as a modification of Adam by decoupling the weight decay from the optimization steps taken w.r.t. the loss function.</p>
<p>Adam update consists of the following steps, where g represents gradient and m, v are 1st and 2nd order moment estimates (mean and variance).</p>
<p>.. math::</p>
<p>g<em t-1="t-1">t = \nabla J(W</em>)\
 m<em>t = \beta</em>1 m<em>{t-1} + (1 - \beta</em>1) g<em>t\
 v</em>t = \beta<em t-1="t-1">2 v</em> + (1 - \beta<em>2) g</em>t^2\
 W<em t-1="t-1">t = W</em> - \eta<em>t (\alpha \frac{ m</em>t }{ \sqrt{ v<em t-1="t-1">t } + \epsilon } + wd W</em>)</p>
<p>It updates the weights using::</p>
<p>m = beta1<em>m + (1-beta1)</em>grad  v = beta2<em>v + (1-beta2)</em>(grad**2)  w -= eta * (learning_rate * m / (sqrt(v) + epsilon) + w * wd)</p>
<p>Note that gradient is rescaled to grad = rescale<em>grad * grad. If rescale</em>grad is NaN, Inf, or 0, the update is skipped.</p>
<p>Defined in src/operator/contrib/adamw.cc:L167</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode[]</code>: data</li>
<li><code>lrs::tuple of &lt;float&gt;, required</code>: Learning rates</li>
<li><code>beta1::float, optional, default=0.899999976</code>: The decay rate for the 1st moment estimates.</li>
<li><code>beta2::float, optional, default=0.999000013</code>: The decay rate for the 2nd moment estimates.</li>
<li><code>epsilon::float, optional, default=9.99999994e-09</code>: A small constant for numerical stability.</li>
<li><code>wds::tuple of &lt;float&gt;, required</code>: Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</li>
<li><code>etas::tuple of &lt;float&gt;, required</code>: Learning rates schedule multiplier</li>
<li><code>clip_gradient::float, optional, default=-1</code>: Clip gradient to the range of [-clip<em>gradient, clip</em>gradient] If clip<em>gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip</em>gradient), -clip_gradient).</li>
<li><code>num_weights::int, optional, default='1'</code>: Number of updated weights.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L388' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._multi_lamb_update-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._multi_lamb_update-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._multi_lamb_update</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_multi_lamb_update(data, learning_rates, beta1, beta2, epsilon, wds, rescale_grad, lower_bound, upper_bound, clip_gradient, bias_correction, step_count, num_tensors)
</code></pre>

<p>Compute the LAMB coefficients of multiple weights and grads"</p>
<p>Defined in src/operator/contrib/multi_lamb.cc:L176</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode[]</code>: data</li>
<li><code>learning_rates::tuple of &lt;float&gt;, required</code>: List of learning rates</li>
<li><code>beta1::float, optional, default=0.899999976</code>: Exponential decay rate for the first moment estimates.</li>
<li><code>beta2::float, optional, default=0.999000013</code>: Exponential decay rate for the second moment estimates.</li>
<li><code>epsilon::float, optional, default=9.99999997e-07</code>: Small value to avoid division by 0.</li>
<li><code>wds::tuple of &lt;float&gt;, required</code>: List of Weight decays.Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</li>
<li><code>rescale_grad::float, optional, default=1</code>: Gradient rescaling factor</li>
<li><code>lower_bound::float, optional, default=-1</code>: Lower limit of norm of weight. If lower_bound &lt;= 0, Lower limit is not set</li>
<li><code>upper_bound::float, optional, default=-1</code>: Upper limit of norm of weight. If upper_bound &lt;= 0, Upper limit is not set</li>
<li><code>clip_gradient::float, optional, default=-1</code>: Clip gradient to the range of [-clip<em>gradient, clip</em>gradient] If clip<em>gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip</em>gradient), -clip_gradient).</li>
<li><code>bias_correction::boolean, optional, default=1</code>: Whether to use bias correction.</li>
<li><code>step_count::Shape(tuple), required</code>: Step count for each tensor</li>
<li><code>num_tensors::int, optional, default='1'</code>: Number of tensors</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L374' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._multi_mp_adamw_update-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._multi_mp_adamw_update-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._multi_mp_adamw_update</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_multi_mp_adamw_update(data, lrs, beta1, beta2, epsilon, wds, etas, clip_gradient, num_weights)
</code></pre>

<p>Update function for multi-precision AdamW optimizer.</p>
<p>AdamW is seen as a modification of Adam by decoupling the weight decay from the optimization steps taken w.r.t. the loss function.</p>
<p>Adam update consists of the following steps, where g represents gradient and m, v are 1st and 2nd order moment estimates (mean and variance).</p>
<p>.. math::</p>
<p>g<em t-1="t-1">t = \nabla J(W</em>)\
 m<em>t = \beta</em>1 m<em>{t-1} + (1 - \beta</em>1) g<em>t\
 v</em>t = \beta<em t-1="t-1">2 v</em> + (1 - \beta<em>2) g</em>t^2\
 W<em t-1="t-1">t = W</em> - \eta<em>t (\alpha \frac{ m</em>t }{ \sqrt{ v<em t-1="t-1">t } + \epsilon } + wd W</em>)</p>
<p>It updates the weights using::</p>
<p>m = beta1<em>m + (1-beta1)</em>grad  v = beta2<em>v + (1-beta2)</em>(grad**2)  w -= eta * (learning_rate * m / (sqrt(v) + epsilon) + w * wd)</p>
<p>Note that gradient is rescaled to grad = rescale<em>grad * grad. If rescale</em>grad is NaN, Inf, or 0, the update is skipped.</p>
<p>Defined in src/operator/contrib/adamw.cc:L223</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode[]</code>: data</li>
<li><code>lrs::tuple of &lt;float&gt;, required</code>: Learning rates</li>
<li><code>beta1::float, optional, default=0.899999976</code>: The decay rate for the 1st moment estimates.</li>
<li><code>beta2::float, optional, default=0.999000013</code>: The decay rate for the 2nd moment estimates.</li>
<li><code>epsilon::float, optional, default=9.99999994e-09</code>: A small constant for numerical stability.</li>
<li><code>wds::tuple of &lt;float&gt;, required</code>: Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</li>
<li><code>etas::tuple of &lt;float&gt;, required</code>: Learning rates schedule multiplier</li>
<li><code>clip_gradient::float, optional, default=-1</code>: Clip gradient to the range of [-clip<em>gradient, clip</em>gradient] If clip<em>gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip</em>gradient), -clip_gradient).</li>
<li><code>num_weights::int, optional, default='1'</code>: Number of updated weights.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L388' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._multi_mp_lamb_update-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._multi_mp_lamb_update-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._multi_mp_lamb_update</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_multi_mp_lamb_update(data, learning_rates, beta1, beta2, epsilon, wds, rescale_grad, lower_bound, upper_bound, clip_gradient, bias_correction, step_count, num_tensors)
</code></pre>

<p>Compute the LAMB coefficients of multiple weights and grads with Mix Precision"</p>
<p>Defined in src/operator/contrib/multi_lamb.cc:L214</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode[]</code>: data</li>
<li><code>learning_rates::tuple of &lt;float&gt;, required</code>: List of learning rates</li>
<li><code>beta1::float, optional, default=0.899999976</code>: Exponential decay rate for the first moment estimates.</li>
<li><code>beta2::float, optional, default=0.999000013</code>: Exponential decay rate for the second moment estimates.</li>
<li><code>epsilon::float, optional, default=9.99999997e-07</code>: Small value to avoid division by 0.</li>
<li><code>wds::tuple of &lt;float&gt;, required</code>: List of Weight decays.Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</li>
<li><code>rescale_grad::float, optional, default=1</code>: Gradient rescaling factor</li>
<li><code>lower_bound::float, optional, default=-1</code>: Lower limit of norm of weight. If lower_bound &lt;= 0, Lower limit is not set</li>
<li><code>upper_bound::float, optional, default=-1</code>: Upper limit of norm of weight. If upper_bound &lt;= 0, Upper limit is not set</li>
<li><code>clip_gradient::float, optional, default=-1</code>: Clip gradient to the range of [-clip<em>gradient, clip</em>gradient] If clip<em>gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip</em>gradient), -clip_gradient).</li>
<li><code>bias_correction::boolean, optional, default=1</code>: Whether to use bias correction.</li>
<li><code>step_count::Shape(tuple), required</code>: Step count for each tensor</li>
<li><code>num_tensors::int, optional, default='1'</code>: Number of tensors</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L374' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._not_equal-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._not_equal-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._not_equal</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_not_equal(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._not_equal_scalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._not_equal_scalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._not_equal_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_not_equal_scalar(data, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._np_amax-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._np_amax-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._np_amax</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_np_amax(a, axis, keepdims, initial)
</code></pre>

<p><em>np</em>amax is an alias of <em>np</em>max.</p>
<p>Defined in src/operator/numpy/np<em>broadcast</em>reduce<em>op</em>value.cc:L170</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>a::NDArray-or-SymbolicNode</code>: The input</li>
<li><code>axis::Shape or None, optional, default=None</code>: Axis or axes along which a sum is performed. The default, axis=None, will sum all of the elements of the input array. If axis is negative it counts from the last to the first axis.</li>
<li><code>keepdims::boolean, optional, default=0</code>: If this is set to <code>True</code>, the reduced axes are left in the result as dimension with size one.</li>
<li><code>initial::double or None, optional, default=None</code>: Starting value for the sum.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L357' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._np_amin-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._np_amin-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._np_amin</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_np_amin(a, axis, keepdims, initial)
</code></pre>

<p><em>np</em>amin is an alias of <em>np</em>min.</p>
<p>Defined in src/operator/numpy/np<em>broadcast</em>reduce<em>op</em>value.cc:L199</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>a::NDArray-or-SymbolicNode</code>: The input</li>
<li><code>axis::Shape or None, optional, default=None</code>: Axis or axes along which a sum is performed. The default, axis=None, will sum all of the elements of the input array. If axis is negative it counts from the last to the first axis.</li>
<li><code>keepdims::boolean, optional, default=0</code>: If this is set to <code>True</code>, the reduced axes are left in the result as dimension with size one.</li>
<li><code>initial::double or None, optional, default=None</code>: Starting value for the sum.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L357' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._np_atleast_1d-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._np_atleast_1d-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._np_atleast_1d</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_np_atleast_1d(arys, num_args)
</code></pre>

<p><strong>Note</strong>: <em>np</em>atleast<em>1d takes variable number of positional inputs. So instead of calling as _np</em>atleast<em>1d([x, y, z], num</em>args=3), one should call via <em>np</em>atleast<em>1d(x, y, z), and num</em>args will be determined automatically.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>arys::NDArray-or-SymbolicNode[]</code>: List of input arrays</li>
<li><code>num_args::int, required</code>: Number of input arrays.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._np_atleast_2d-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._np_atleast_2d-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._np_atleast_2d</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_np_atleast_2d(arys, num_args)
</code></pre>

<p><strong>Note</strong>: <em>np</em>atleast<em>2d takes variable number of positional inputs. So instead of calling as _np</em>atleast<em>2d([x, y, z], num</em>args=3), one should call via <em>np</em>atleast<em>2d(x, y, z), and num</em>args will be determined automatically.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>arys::NDArray-or-SymbolicNode[]</code>: List of input arrays</li>
<li><code>num_args::int, required</code>: Number of input arrays.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._np_atleast_3d-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._np_atleast_3d-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._np_atleast_3d</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_np_atleast_3d(arys, num_args)
</code></pre>

<p><strong>Note</strong>: <em>np</em>atleast<em>3d takes variable number of positional inputs. So instead of calling as _np</em>atleast<em>3d([x, y, z], num</em>args=3), one should call via <em>np</em>atleast<em>3d(x, y, z), and num</em>args will be determined automatically.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>arys::NDArray-or-SymbolicNode[]</code>: List of input arrays</li>
<li><code>num_args::int, required</code>: Number of input arrays.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._np_copy-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._np_copy-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._np_copy</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_np_copy(a)
</code></pre>

<p>Return an array copy of the given object.</p>
<p>Defined in src/operator/numpy/np<em>elemwise</em>unary<em>op</em>basic.cc:L47</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>a::NDArray-or-SymbolicNode</code>: The input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._np_diag-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._np_diag-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._np_diag</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_np_diag(data, k)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input ndarray</li>
<li><code>k::int, optional, default='0'</code>: Diagonal in question. The default is 0. Use k&gt;0 for diagonals above the main diagonal, and k&lt;0 for diagonals below the main diagonal.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._np_diagflat-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._np_diagflat-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._np_diagflat</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_np_diagflat(data, k)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input ndarray</li>
<li><code>k::int, optional, default='0'</code>: Diagonal in question. The default is 0. Use k&gt;0 for diagonals above the main diagonal, and k&lt;0 for diagonals below the main diagonal.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._np_diagonal-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._np_diagonal-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._np_diagonal</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_np_diagonal(data, offset, axis1, axis2)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input ndarray</li>
<li><code>offset::int, optional, default='0'</code>: Diagonal in question. The default is 0. Use k&gt;0 for diagonals above the main diagonal, and k&lt;0 for diagonals below the main diagonal. If input has shape (S0 S1) k must be between -S0 and S1</li>
<li><code>axis1::int, optional, default='0'</code>: The first axis of the sub-arrays of interest. Ignored when the input is a 1-D array.</li>
<li><code>axis2::int, optional, default='1'</code>: The second axis of the sub-arrays of interest. Ignored when the input is a 1-D array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L353' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._np_dot-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._np_dot-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._np_dot</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_np_dot(a, b)
</code></pre>

<p>Dot product of two arrays. Specifically,</p>
<ul>
<li>If both a and b are 1-D arrays, it is inner product of vectors.</li>
<li>If both a and b are 2-D arrays, it is matrix multiplication.</li>
<li>If either a or b is 0-D (scalar), it is equivalent to multiply and using numpy.multiply(a, b) or a * b is preferred.</li>
<li>If a is an N-D array and b is a 1-D array, it is a sum product over the last axis of a and b.</li>
<li>
<p>If a is an N-D array and b is an M-D array (where M&gt;=2), it is a sum product over the last axis of a and the second-to-last axis of b:</p>
<p>Example ::</p>
<p>dot(a, b)[i,j,k,m] = sum(a[i,j,:] * b[k,:,m])</p>
</li>
</ul>
<p>Defined in src/operator/numpy/np_dot.cc:L121</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>a::NDArray-or-SymbolicNode</code>: First input</li>
<li><code>b::NDArray-or-SymbolicNode</code>: Second input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L367' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._np_max-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._np_max-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._np_max</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_np_max(a, axis, keepdims, initial)
</code></pre>

<p>Defined in src/operator/numpy/np<em>broadcast</em>reduce<em>op</em>value.cc:L170</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>a::NDArray-or-SymbolicNode</code>: The input</li>
<li><code>axis::Shape or None, optional, default=None</code>: Axis or axes along which a sum is performed. The default, axis=None, will sum all of the elements of the input array. If axis is negative it counts from the last to the first axis.</li>
<li><code>keepdims::boolean, optional, default=0</code>: If this is set to <code>True</code>, the reduced axes are left in the result as dimension with size one.</li>
<li><code>initial::double or None, optional, default=None</code>: Starting value for the sum.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L355' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._np_min-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._np_min-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._np_min</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_np_min(a, axis, keepdims, initial)
</code></pre>

<p>Defined in src/operator/numpy/np<em>broadcast</em>reduce<em>op</em>value.cc:L199</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>a::NDArray-or-SymbolicNode</code>: The input</li>
<li><code>axis::Shape or None, optional, default=None</code>: Axis or axes along which a sum is performed. The default, axis=None, will sum all of the elements of the input array. If axis is negative it counts from the last to the first axis.</li>
<li><code>keepdims::boolean, optional, default=0</code>: If this is set to <code>True</code>, the reduced axes are left in the result as dimension with size one.</li>
<li><code>initial::double or None, optional, default=None</code>: Starting value for the sum.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L355' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._np_moveaxis-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._np_moveaxis-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._np_moveaxis</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_np_moveaxis(a, source, destination)
</code></pre>

<p>Move axes of an array to new positions. Other axes remain in their original order.</p>
<p>Defined in src/operator/numpy/np<em>matrix</em>op.cc:L1264</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>a::NDArray-or-SymbolicNode</code>: Source input</li>
<li><code>source::Shape(tuple), required</code>: Original positions of the axes to move. These must be unique.</li>
<li><code>destination::Shape(tuple), required</code>: Destination positions for each of the original axes. These must also be unique.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L355' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._np_prod-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._np_prod-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._np_prod</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_np_prod(axis, dtype, keepdims, initial, a)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>axis::Shape or None, optional, default=None</code>: Axis or axes along which a sum is performed. The default, axis=None, will sum all of the elements of the input array. If axis is negative it counts from the last to the first axis.</li>
<li><code>dtype::{None, 'bool', 'float16', 'float32', 'float64', 'int32', 'int64', 'int8'},optional, default='None'</code>: The type of the returned array and of the accumulator in which the elements are summed. The dtype of a is used by default unless a has an integer dtype of less precision than the default platform integer. In that case, if a is signed then the platform integer is used while if a is unsigned then an unsigned integer of the same precision as the platform integer is used.</li>
<li><code>keepdims::boolean, optional, default=0</code>: If this is set to <code>True</code>, the reduced axes are left in the result as dimension with size one.</li>
<li><code>initial::double or None, optional, default=None</code>: Starting value for the sum.</li>
<li><code>a::NDArray-or-SymbolicNode</code>: The input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L355' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._np_product-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._np_product-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._np_product</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_np_product(axis, dtype, keepdims, initial, a)
</code></pre>

<p><em>np</em>product is an alias of <em>np</em>prod.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>axis::Shape or None, optional, default=None</code>: Axis or axes along which a sum is performed. The default, axis=None, will sum all of the elements of the input array. If axis is negative it counts from the last to the first axis.</li>
<li><code>dtype::{None, 'bool', 'float16', 'float32', 'float64', 'int32', 'int64', 'int8'},optional, default='None'</code>: The type of the returned array and of the accumulator in which the elements are summed. The dtype of a is used by default unless a has an integer dtype of less precision than the default platform integer. In that case, if a is signed then the platform integer is used while if a is unsigned then an unsigned integer of the same precision as the platform integer is used.</li>
<li><code>keepdims::boolean, optional, default=0</code>: If this is set to <code>True</code>, the reduced axes are left in the result as dimension with size one.</li>
<li><code>initial::double or None, optional, default=None</code>: Starting value for the sum.</li>
<li><code>a::NDArray-or-SymbolicNode</code>: The input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L357' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._np_repeat-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._np_repeat-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._np_repeat</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_np_repeat(data, repeats, axis)
</code></pre>

<p><em>np</em>repeat is an alias of repeat.</p>
<p>Repeats elements of an array. By default, $repeat$ flattens the input array into 1-D and then repeats the elements::   x = [[ 1, 2],        [ 3, 4]]   repeat(x, repeats=2) = [ 1.,  1.,  2.,  2.,  3.,  3.,  4.,  4.] The parameter $axis$ specifies the axis along which to perform repeat::   repeat(x, repeats=2, axis=1) = [[ 1.,  1.,  2.,  2.],                                   [ 3.,  3.,  4.,  4.]]   repeat(x, repeats=2, axis=0) = [[ 1.,  2.],                                   [ 1.,  2.],                                   [ 3.,  4.],                                   [ 3.,  4.]]   repeat(x, repeats=2, axis=-1) = [[ 1.,  1.,  2.,  2.],                                    [ 3.,  3.,  4.,  4.]]</p>
<p>Defined in src/operator/tensor/matrix_op.cc:L744</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data array</li>
<li><code>repeats::int, required</code>: The number of repetitions for each element.</li>
<li><code>axis::int or None, optional, default='None'</code>: The axis along which to repeat values. The negative numbers are interpreted counting from the backward. By default, use the flattened input array, and return a flat output array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L370' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._np_reshape-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._np_reshape-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._np_reshape</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_np_reshape(a, newshape, order)
</code></pre>

<p>Defined in src/operator/numpy/np<em>matrix</em>op.cc:L357</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>a::NDArray-or-SymbolicNode</code>: Array to be reshaped.</li>
<li><code>newshape::Shape(tuple), required</code>: The new shape should be compatible with the original shape. If an integer, then the result will be a 1-D array of that length. One shape dimension can be -1. In this case, the value is inferred from the length of the array and remaining dimensions.</li>
<li><code>order::string, optional, default='C'</code>: Read the elements of a using this index order, and place the elements into the reshaped array using this index order. 'C' means to read/write the elements using C-like index order, with the last axis index changing fastest, back to the first axis index changing slowest. Note that currently only C-like order is supported</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L353' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._np_sometrue-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._np_sometrue-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._np_sometrue</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_np_sometrue(data, axis, keepdims)
</code></pre>

<p><em>np</em>sometrue is an alias of <em>npi</em>any.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input ndarray</li>
<li><code>axis::Shape or None, optional, default=None</code>: Axis or axes along which a sum is performed. The default, axis=None, will sum all of the elements of the input array. If axis is negative it counts from the last to the first axis.</li>
<li><code>keepdims::boolean, optional, default=0</code>: If this is set to <code>True</code>, the reduced axes are left in the result as dimension with size one.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L353' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._np_squeeze-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._np_squeeze-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._np_squeeze</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_np_squeeze(a, axis)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>a::NDArray-or-SymbolicNode</code>: data to squeeze</li>
<li><code>axis::Shape or None, optional, default=None</code>: Selects a subset of the single-dimensional entries in the shape. If an axis is selected with shape entry greater than one, an error is raised.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._np_sum-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._np_sum-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._np_sum</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_np_sum(a, axis, dtype, keepdims, initial)
</code></pre>

<p>Defined in src/operator/numpy/np<em>broadcast</em>reduce<em>op</em>value.cc:L130</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>a::NDArray-or-SymbolicNode</code>: The input</li>
<li><code>axis::Shape or None, optional, default=None</code>: Axis or axes along which a sum is performed. The default, axis=None, will sum all of the elements of the input array. If axis is negative it counts from the last to the first axis.</li>
<li><code>dtype::{None, 'bool', 'float16', 'float32', 'float64', 'int32', 'int64', 'int8'},optional, default='None'</code>: The type of the returned array and of the accumulator in which the elements are summed. The dtype of a is used by default unless a has an integer dtype of less precision than the default platform integer. In that case, if a is signed then the platform integer is used while if a is unsigned then an unsigned integer of the same precision as the platform integer is used.</li>
<li><code>keepdims::boolean, optional, default=0</code>: If this is set to <code>True</code>, the reduced axes are left in the result as dimension with size one.</li>
<li><code>initial::double or None, optional, default=None</code>: Starting value for the sum.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L357' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._np_trace-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._np_trace-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._np_trace</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_np_trace(data, offset, axis1, axis2)
</code></pre>

<p>Computes the sum of the diagonal elements of a matrix. Input is a tensor <em>A</em> of dimension <em>n &gt;= 2</em>.</p>
<p>If <em>n=2</em>, we sum the diagonal elements. The result has shape ().</p>
<p>If <em>n&gt;2</em>, <em>trace</em> is performed separately on the matrix defined by <em>axis1</em> and <em>axis2</em> for all inputs (batch mode).</p>
<p>Examples::</p>
<p>// Single matrix reduction    A = [[1.0, 1.0], [1.0, 7.0]]    trace(A) = 8.0</p>
<p>// Batch matrix reduction    A = [[[1.0, 1.0], [1.0, 7.0]], [[3.0, 0], [0, 17.0]]]    trace(A) = [1.0, 18.0]</p>
<p>Defined in src/operator/numpy/np<em>trace</em>op.cc:L75</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input ndarray</li>
<li><code>offset::int, optional, default='0'</code>: Offset of the diagonal from the main diagonal. Can be both positive and negative. Defaults to 0.</li>
<li><code>axis1::int, optional, default='0'</code>: Axes to be used as the first axis of the 2-D sub-arrays from which the diagonals should be taken. Defaults to 0.</li>
<li><code>axis2::int, optional, default='1'</code>: Axes to be used as the second axis of the 2-D sub-arrays from which the diagonals should be taken. Defaults to 1.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L372' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._np_transpose-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._np_transpose-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._np_transpose</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_np_transpose(a, axes)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>a::NDArray-or-SymbolicNode</code>: Source input</li>
<li><code>axes::Shape(tuple), optional, default=None</code>: By default, reverse the dimensions, otherwise permute the axes according to the values given.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_Custom-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_Custom-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_Custom</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_Custom(data, op_type)
</code></pre>

<p><em>npi</em>Custom is an alias of Custom.</p>
<p>Apply a custom operator implemented in a frontend language (like Python).</p>
<p>Custom operators should override required methods like <code>forward</code> and <code>backward</code>. The custom operator must be registered before it can be used. Please check the tutorial here: https://mxnet.incubator.apache.org/api/faq/new_op</p>
<p>Defined in src/operator/custom/custom.cc:L547</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode[]</code>: Input data for the custom operator.</li>
<li><code>op_type::string</code>: Name of the custom operator. This is the name that is passed to <code>mx.operator.register</code> to register the operator.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L359' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_abs-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_abs-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_abs</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_abs(x)
</code></pre>

<p><em>npi</em>abs is an alias of <em>npi</em>absolute.</p>
<p>Returns element-wise absolute value of the input. Example::    absolute([-2, 0, 3]) = [2, 0, 3]</p>
<p>Defined in src/operator/numpy/np<em>elemwise</em>unary<em>op</em>basic.cc:L139</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>x::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L354' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_absolute-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_absolute-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_absolute</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_absolute(x)
</code></pre>

<p>Returns element-wise absolute value of the input. Example::    absolute([-2, 0, 3]) = [2, 0, 3]</p>
<p>Defined in src/operator/numpy/np<em>elemwise</em>unary<em>op</em>basic.cc:L139</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>x::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L352' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_add-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_add-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_add</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_add(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: First input to the function</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: Second input to the function</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_add_scalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_add_scalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_add_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_add_scalar(data, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_all-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_all-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_all</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_all(data, axis, keepdims)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input ndarray</li>
<li><code>axis::Shape or None, optional, default=None</code>: Axis or axes along which a sum is performed. The default, axis=None, will sum all of the elements of the input array. If axis is negative it counts from the last to the first axis.</li>
<li><code>keepdims::boolean, optional, default=0</code>: If this is set to <code>True</code>, the reduced axes are left in the result as dimension with size one.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_any-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_any-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_any</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_any(data, axis, keepdims)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input ndarray</li>
<li><code>axis::Shape or None, optional, default=None</code>: Axis or axes along which a sum is performed. The default, axis=None, will sum all of the elements of the input array. If axis is negative it counts from the last to the first axis.</li>
<li><code>keepdims::boolean, optional, default=0</code>: If this is set to <code>True</code>, the reduced axes are left in the result as dimension with size one.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_arange-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_arange-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_arange</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_arange(start, stop, step, repeat, infer_range, ctx, dtype)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>start::double, required</code>: Start of interval. The interval includes this value. The default start value is 0.</li>
<li><code>stop::double or None, optional, default=None</code>: End of interval. The interval does not include this value, except in some cases where step is not an integer and floating point round-off affects the length of out.</li>
<li><code>step::double, optional, default=1</code>: Spacing between values.</li>
<li><code>repeat::int, optional, default='1'</code>: The repeating time of all elements. E.g repeat=3, the element a will be repeated three times –&gt; a, a, a.</li>
<li><code>infer_range::boolean, optional, default=0</code>: When set to True, infer the stop position from the start, step, repeat, and output tensor size.</li>
<li><code>ctx::string, optional, default=''</code>: Context of output, in format <a href="n">cpu|gpu|cpu_pinned</a>.Only used for imperative calls.</li>
<li><code>dtype::{'bfloat16', 'float16', 'float32', 'float64', 'int32', 'int64', 'int8', 'uint8'},optional, default='float32'</code>: Target data type.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L359' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_arccos-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_arccos-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_arccos</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_arccos(x)
</code></pre>

<p>Returns element-wise inverse cosine of the input array. The input should be in range <code>[-1, 1]</code>. The output is in the closed interval :math:<code>[0, \pi]</code> .. math::    arccos([-1, -.707, 0, .707, 1]) = [\pi, 3\pi/4, \pi/2, \pi/4, 0] The storage type of $arccos$ output is always dense</p>
<p>Defined in src/operator/numpy/np<em>elemwise</em>unary<em>op</em>basic.cc:L355</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>x::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L355' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_arccosh-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_arccosh-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_arccosh</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_arccosh(x)
</code></pre>

<p>Returns the element-wise inverse hyperbolic cosine of the input array, 
computed element-wise.</p>
<p>Defined in src/operator/numpy/np<em>elemwise</em>unary<em>op</em>basic.cc:L417</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>x::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_arcsin-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_arcsin-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_arcsin</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_arcsin(x)
</code></pre>

<p>Returns element-wise inverse sine of the input array. .. math::    arcsin([-1, -.707, 0, .707, 1]) = [-\pi/2, -\pi/4, 0, \pi/4, \pi/2]</p>
<p>Defined in src/operator/numpy/np<em>elemwise</em>unary<em>op</em>basic.cc:L344</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>x::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L352' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_arcsinh-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_arcsinh-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_arcsinh</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_arcsinh(x)
</code></pre>

<p>Returns the element-wise inverse hyperbolic sine of the input array, 
computed element-wise.</p>
<p>Defined in src/operator/numpy/np<em>elemwise</em>unary<em>op</em>basic.cc:L410</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>x::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_arctan-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_arctan-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_arctan</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_arctan(x)
</code></pre>

<p>Returns element-wise inverse tangent of the input array. .. math::    arctan([-1, 0, 1]) = [-\pi/4, 0, \pi/4]</p>
<p>Defined in src/operator/numpy/np<em>elemwise</em>unary<em>op</em>basic.cc:L363</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>x::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L352' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_arctan2-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_arctan2-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_arctan2</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_arctan2(x1, x2)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>x1::NDArray-or-SymbolicNode</code>: The input array</li>
<li><code>x2::NDArray-or-SymbolicNode</code>: The input array</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_arctan2_scalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_arctan2_scalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_arctan2_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_arctan2_scalar(data, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_arctanh-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_arctanh-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_arctanh</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_arctanh(x)
</code></pre>

<p>Returns the element-wise inverse hyperbolic tangent of the input array, 
computed element-wise.</p>
<p>Defined in src/operator/numpy/np<em>elemwise</em>unary<em>op</em>basic.cc:L424</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>x::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_argmax-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_argmax-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_argmax</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_argmax(data, axis, keepdims)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input</li>
<li><code>axis::int or None, optional, default='None'</code>: The axis along which to perform the reduction. Negative values means indexing from right to left. $Requires axis to be set as int, because global reduction is not supported yet.$</li>
<li><code>keepdims::boolean, optional, default=0</code>: If this is set to <code>True</code>, the reduced axis is left in the result as dimension with size one.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_argmin-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_argmin-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_argmin</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_argmin(data, axis, keepdims)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input</li>
<li><code>axis::int or None, optional, default='None'</code>: The axis along which to perform the reduction. Negative values means indexing from right to left. $Requires axis to be set as int, because global reduction is not supported yet.$</li>
<li><code>keepdims::boolean, optional, default=0</code>: If this is set to <code>True</code>, the reduced axis is left in the result as dimension with size one.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_argsort-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_argsort-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_argsort</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_argsort(data, axis, is_ascend, dtype)
</code></pre>

<p><em>npi</em>argsort is an alias of argsort.</p>
<p>Returns the indices that would sort an input array along the given axis.</p>
<p>This function performs sorting along the given axis and returns an array of indices having same shape as an input array that index data in sorted order.</p>
<p>Examples::</p>
<p>x = [[ 0.3,  0.2,  0.4],        [ 0.1,  0.3,  0.2]]</p>
<p>// sort along axis -1   argsort(x) = [[ 1.,  0.,  2.],                 [ 0.,  2.,  1.]]</p>
<p>// sort along axis 0   argsort(x, axis=0) = [[ 1.,  0.,  1.]                         [ 0.,  1.,  0.]]</p>
<p>// flatten and then sort   argsort(x, axis=None) = [ 3.,  1.,  5.,  0.,  4.,  2.]</p>
<p>Defined in src/operator/tensor/ordering_op.cc:L185</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array</li>
<li><code>axis::int or None, optional, default='-1'</code>: Axis along which to sort the input tensor. If not given, the flattened array is used. Default is -1.</li>
<li><code>is_ascend::boolean, optional, default=1</code>: Whether to sort in ascending or descending order.</li>
<li><code>dtype::{'float16', 'float32', 'float64', 'int32', 'int64', 'uint8'},optional, default='float32'</code>: DType of the output indices. It is only valid when ret_typ is "indices" or "both". An error will be raised if the selected data type cannot precisely represent the indices.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L377' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_around-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_around-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_around</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_around(x, decimals)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>x::NDArray-or-SymbolicNode</code>: Input ndarray</li>
<li><code>decimals::int, optional, default='0'</code>: Number of decimal places to round to.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_average-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_average-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_average</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_average(a, weights, axis, returned, weighted)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>a::NDArray-or-SymbolicNode</code>: The input</li>
<li><code>weights::NDArray-or-SymbolicNode</code>: The weights to calculate average</li>
<li><code>axis::Shape or None, optional, default=None</code>: Axis or axes along which a average is performed. The default, axis=None, will average all of the elements of the input array. If axis is negative it counts from the last to the first axis.</li>
<li><code>returned::boolean, optional, default=0</code>: If True, the tuple (average, sum<em>of</em>weights) is returned,otherwise only the average is returned.If weights=None, sum<em>of</em>weights is equivalent tothe number of elements over which the average is taken.</li>
<li><code>weighted::boolean, optional, default=1</code>: Auxiliary flag to deal with none weights.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L355' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_backward_ediff1d-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_backward_ediff1d-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_backward_ediff1d</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_backward_ediff1d()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_backward_nan_to_num-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_backward_nan_to_num-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_backward_nan_to_num</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_backward_nan_to_num()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_backward_polyval-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_backward_polyval-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_backward_polyval</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_backward_polyval()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_bernoulli-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_bernoulli-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_bernoulli</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_bernoulli(input1, prob, logit, size, ctx, dtype, is_logit)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>input1::NDArray-or-SymbolicNode</code>: Source input</li>
<li><code>prob::float or None, required</code>:</li>
<li><code>logit::float or None, required</code>:</li>
<li><code>size::Shape or None, optional, default=None</code>: Output shape. If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn. Default is None, in which case a single value is returned.</li>
<li><code>ctx::string, optional, default='cpu'</code>: Context of output, in format <a href="n">cpu|gpu|cpu_pinned</a>. Only used for imperative calls.</li>
<li><code>dtype::{'bool', 'float16', 'float32', 'float64', 'int32', 'uint8'},optional, default='float32'</code>: DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).</li>
<li><code>is_logit::boolean, required</code>:</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L359' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_bincount-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_bincount-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_bincount</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_bincount(data, weights, minlength, has_weights)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Data</li>
<li><code>weights::NDArray-or-SymbolicNode</code>: Weights</li>
<li><code>minlength::int, optional, default='0'</code>: A minimum number of bins for the output arrayIf minlength is specified, there will be at least thisnumber of bins in the output array</li>
<li><code>has_weights::boolean, optional, default=0</code>: Determine whether Bincount has weights.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L353' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_bitwise_and-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_bitwise_and-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_bitwise_and</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_bitwise_and(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: First input to the function</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: Second input to the function</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_bitwise_and_scalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_bitwise_and_scalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_bitwise_and_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_bitwise_and_scalar(data, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::int</code>: scalar input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_bitwise_not-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_bitwise_not-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_bitwise_not</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_bitwise_not(x)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>x::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L347' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_bitwise_or-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_bitwise_or-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_bitwise_or</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_bitwise_or(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: First input to the function</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: Second input to the function</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_bitwise_or_scalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_bitwise_or_scalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_bitwise_or_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_bitwise_or_scalar(data, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::int</code>: scalar input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_bitwise_xor-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_bitwise_xor-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_bitwise_xor</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_bitwise_xor(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: First input to the function</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: Second input to the function</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_bitwise_xor_scalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_bitwise_xor_scalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_bitwise_xor_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_bitwise_xor_scalar(data, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::int</code>: scalar input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_blackman-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_blackman-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_blackman</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_blackman(M, ctx, dtype)
</code></pre>

<p>Return the Blackman window.The Blackman window is a taper formed by using a weighted cosine.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>M::, optional, default=None</code>: Number of points in the output window. If zero or less, an empty array is returned.</li>
<li><code>ctx::string, optional, default=''</code>: Context of output, in format <a href="n">cpu|gpu|cpu_pinned</a>.Only used for imperative calls.</li>
<li><code>dtype::{'bfloat16', 'float16', 'float32', 'float64', 'int32', 'int64', 'int8', 'uint8'},optional, default='float32'</code>: Data-type of the returned array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_boolean_mask-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_boolean_mask-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_boolean_mask</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_boolean_mask(data, index, axis)
</code></pre>

<p><em>npi</em>boolean<em>mask is an alias of _contrib</em>boolean_mask.</p>
<p>Given an n-d NDArray data, and a 1-d NDArray index, the operator produces an un-predeterminable shaped n-d NDArray out, which stands for the rows in x where the corresonding element in index is non-zero.</p>
<blockquote>
<blockquote>
<blockquote>
<p>data = mx.nd.array([[1, 2, 3],[4, 5, 6],[7, 8, 9]]) index = mx.nd.array([0, 1, 0]) out = mx.nd.contrib.boolean_mask(data, index) out</p>
</blockquote>
</blockquote>
</blockquote>
<p>[[4. 5. 6.]] <NDArray 1x3 @cpu(0)></p>
<p>Defined in src/operator/contrib/boolean_mask.cc:L201</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Data</li>
<li><code>index::NDArray-or-SymbolicNode</code>: Mask</li>
<li><code>axis::int, optional, default='0'</code>: An integer that represents the axis in NDArray to mask from.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L368' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_boolean_mask_assign_scalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_boolean_mask_assign_scalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_boolean_mask_assign_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_boolean_mask_assign_scalar(data, mask, value, start_axis)
</code></pre>

<p>Scalar version of boolean assign</p>
<p>Defined in src/operator/numpy/np<em>boolean</em>mask_assign.cc:L281</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: input</li>
<li><code>mask::NDArray-or-SymbolicNode</code>: mask</li>
<li><code>value::float</code>: value to be assigned to masked positions</li>
<li><code>start_axis::int</code>: starting axis of boolean mask</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L355' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_boolean_mask_assign_tensor-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_boolean_mask_assign_tensor-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_boolean_mask_assign_tensor</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_boolean_mask_assign_tensor(data, mask, value, start_axis)
</code></pre>

<p>Tensor version of boolean assign</p>
<p>Defined in src/operator/numpy/np<em>boolean</em>mask_assign.cc:L306</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: input</li>
<li><code>mask::NDArray-or-SymbolicNode</code>: mask</li>
<li><code>value::NDArray-or-SymbolicNode</code>: assignment</li>
<li><code>start_axis::int</code>: starting axis of boolean mask</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L355' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_broadcast_to-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_broadcast_to-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_broadcast_to</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_broadcast_to(array, shape)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>array::NDArray-or-SymbolicNode</code>: The input</li>
<li><code>shape::Shape(tuple), optional, default=[]</code>: The shape of the desired array. We can set the dim to zero if it's same as the original. E.g <code>A = broadcast_to(B, shape=(10, 0, 0))</code> has the same meaning as <code>A = broadcast_axis(B, axis=0, size=10)</code>.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_cast-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_cast-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_cast</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_cast(data, dtype)
</code></pre>

<p><em>npi</em>cast is an alias of Cast.</p>
<p>Casts all elements of the input to a new type.</p>
<p>.. note:: $Cast$ is deprecated. Use $cast$ instead.</p>
<p>Example::</p>
<p>cast([0.9, 1.3], dtype='int32') = [0, 1]    cast([1e20, 11.1], dtype='float16') = [inf, 11.09375]    cast([300, 11.1, 10.9, -1, -3], dtype='uint8') = [44, 11, 10, 255, 253]</p>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_basic.cc:L664</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input.</li>
<li><code>dtype::{'bfloat16', 'bool', 'float16', 'float32', 'float64', 'int32', 'int64', 'int8', 'uint8'}, required</code>: Output data type.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L363' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_cbrt-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_cbrt-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_cbrt</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_cbrt(x)
</code></pre>

<p>Return the cube-root of an array, element-wise. Example::    cbrt([1, 8, -125]) = [1, 2, -5]</p>
<p>Defined in src/operator/numpy/np<em>elemwise</em>unary<em>op</em>basic.cc:L232</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>x::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L352' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_ceil-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_ceil-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_ceil</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_ceil(x)
</code></pre>

<p>Return the ceiling of the input, element-wise. The ceil of the scalar x is the smallest integer i, such that i &gt;= x. Example::    ceil([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0]) = [-1., -1., -0.,  1.,  2.,  2.,  2.]</p>
<p>Defined in src/operator/numpy/np<em>elemwise</em>unary<em>op</em>basic.cc:L165</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>x::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L353' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_choice-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_choice-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_choice</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_choice(input1, input2, a, size, ctx, replace, weighted)
</code></pre>

<p>random choice</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>input1::NDArray-or-SymbolicNode</code>: Source input</li>
<li><code>input2::NDArray-or-SymbolicNode</code>: Source input</li>
<li><code>a::, required</code>:</li>
<li><code>size::, required</code>:</li>
<li><code>ctx::string, optional, default='cpu'</code>:</li>
<li><code>replace::boolean, optional, default=1</code>:</li>
<li><code>weighted::boolean, optional, default=0</code>:</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L359' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_cholesky-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_cholesky-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_cholesky</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_cholesky(A)
</code></pre>

<p>Defined in src/operator/numpy/linalg/np_potrf.cc:L47</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>A::NDArray-or-SymbolicNode</code>: Tensor of input matrices to be decomposed</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_clip-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_clip-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_clip</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_clip(data, a_min, a_max)
</code></pre>

<p><em>npi</em>clip is an alias of clip.</p>
<p>Clips (limits) the values in an array. Given an interval, values outside the interval are clipped to the interval edges. Clipping $x$ between <code>a_min</code> and <code>a_max</code> would be:: .. math::    clip(x, a<em>min, a</em>max) = \max(\min(x, a<em>max), a</em>min)) Example::     x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]     clip(x,1,8) = [ 1.,  1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  8.] The storage type of $clip$ output depends on storage types of inputs and the a<em>min, a</em>max 
parameter values:</p>
<ul>
<li>clip(default) = default</li>
<li>clip(row<em>sparse, a</em>min &lt;= 0, a<em>max &gt;= 0) = row</em>sparse</li>
<li>clip(csr, a<em>min &lt;= 0, a</em>max &gt;= 0) = csr</li>
<li>clip(row<em>sparse, a</em>min &lt; 0, a_max &lt; 0) = default</li>
<li>clip(row<em>sparse, a</em>min &gt; 0, a_max &gt; 0) = default</li>
<li>clip(csr, a<em>min &lt; 0, a</em>max &lt; 0) = csr</li>
<li>clip(csr, a<em>min &gt; 0, a</em>max &gt; 0) = csr</li>
</ul>
<p>Defined in src/operator/tensor/matrix_op.cc:L677</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input array.</li>
<li><code>a_min::float, required</code>: Minimum value</li>
<li><code>a_max::float, required</code>: Maximum value</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L372' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_column_stack-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_column_stack-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_column_stack</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_column_stack(data, num_args)
</code></pre>

<p><strong>Note</strong>: <em>npi</em>column<em>stack takes variable number of positional inputs. So instead of calling as _npi</em>column<em>stack([x, y, z], num</em>args=3), one should call via <em>npi</em>column<em>stack(x, y, z), and num</em>args will be determined automatically.</p>
<p>Defined in src/operator/numpy/np<em>matrix</em>op.cc:L866</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode[]</code>: List of arrays to column_stack</li>
<li><code>num_args::int, required</code>: Number of inputs to be column stacked</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L353' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_concatenate-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_concatenate-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_concatenate</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_concatenate(data, num_args, dim)
</code></pre>

<p><strong>Note</strong>: <em>npi</em>concatenate takes variable number of positional inputs. So instead of calling as <em>npi</em>concatenate([x, y, z], num<em>args=3), one should call via _npi</em>concatenate(x, y, z), and num_args will be determined automatically.</p>
<p>Join a sequence of arrays along an existing axis.</p>
<p>Defined in src/operator/numpy/np<em>matrix</em>op.cc:L678</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode[]</code>: List of arrays to concatenate</li>
<li><code>num_args::int, required</code>: Number of inputs to be concated.</li>
<li><code>dim::int, optional, default='1'</code>: the dimension to be concated.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L355' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_copysign-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_copysign-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_copysign</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_copysign(lhs, rhs)
</code></pre>

<p>Defined in src/operator/numpy/np<em>elemwise</em>broadcast<em>op</em>extended.cc:L49</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: First input to the function</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: Second input to the function</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_copysign_scalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_copysign_scalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_copysign_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_copysign_scalar(data, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_copyto-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_copyto-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_copyto</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_copyto(data)
</code></pre>

<p><em>npi</em>copyto is an alias of _copyto.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray</code>: input data</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_cos-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_cos-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_cos</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_cos(x)
</code></pre>

<p>Computes the element-wise cosine of the input array. .. math::    cos([0, \pi/4, \pi/2]) = [1, 0.707, 0]</p>
<p>Defined in src/operator/numpy/np<em>elemwise</em>unary<em>op</em>basic.cc:L328</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>x::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L352' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_cosh-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_cosh-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_cosh</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_cosh(x)
</code></pre>

<p>Returns the hyperbolic cosine  of the input array, computed element-wise. .. math::    cosh(x) = 0.5\times(exp(x) + exp(-x))</p>
<p>Defined in src/operator/numpy/np<em>elemwise</em>unary<em>op</em>basic.cc:L395</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>x::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L352' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_cumsum-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_cumsum-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_cumsum</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_cumsum(a, axis, dtype)
</code></pre>

<p>Return the cumulative sum of the elements along a given axis.</p>
<p>Defined in src/operator/numpy/np_cumsum.cc:L70</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>a::NDArray-or-SymbolicNode</code>: Input ndarray</li>
<li><code>axis::int or None, optional, default='None'</code>: Axis along which the cumulative sum is computed. The default (None) is to compute the cumsum over the flattened array.</li>
<li><code>dtype::{None, 'float16', 'float32', 'float64', 'int32', 'int64', 'int8'},optional, default='None'</code>: Type of the returned array and of the accumulator in which the elements are summed. If dtype is not specified, it defaults to the dtype of a, unless a has an integer dtype with a precision less than that of the default platform integer. In that case, the default platform integer is used.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L353' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_cvimdecode-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_cvimdecode-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_cvimdecode</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_cvimdecode(buf, flag, to_rgb)
</code></pre>

<p><em>npi</em>cvimdecode is an alias of _cvimdecode.</p>
<p>Decode image with OpenCV.  Note: return image in RGB by default, instead of OpenCV's default BGR.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>buf::NDArray</code>: Buffer containing binary encoded image</li>
<li><code>flag::int, optional, default='1'</code>: Convert decoded image to grayscale (0) or color (1).</li>
<li><code>to_rgb::boolean, optional, default=1</code>: Whether to convert decoded image to mxnet's default RGB format (instead of opencv's default BGR).</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L354' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_cvimread-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_cvimread-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_cvimread</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_cvimread(filename, flag, to_rgb)
</code></pre>

<p><em>npi</em>cvimread is an alias of _cvimread.</p>
<p>Read and decode image with OpenCV.  Note: return image in RGB by default, instead of OpenCV's default BGR.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>filename::string, required</code>: Name of the image file to be loaded.</li>
<li><code>flag::int, optional, default='1'</code>: Convert decoded image to grayscale (0) or color (1).</li>
<li><code>to_rgb::boolean, optional, default=1</code>: Whether to convert decoded image to mxnet's default RGB format (instead of opencv's default BGR).</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L354' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_cvimresize-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_cvimresize-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_cvimresize</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_cvimresize(src, w, h, interp)
</code></pre>

<p><em>npi</em>cvimresize is an alias of _cvimresize.</p>
<p>Resize image with OpenCV. </p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>src::NDArray</code>: source image</li>
<li><code>w::int, required</code>: Width of resized image.</li>
<li><code>h::int, required</code>: Height of resized image.</li>
<li><code>interp::int, optional, default='1'</code>: Interpolation method (default=cv2.INTER_LINEAR).</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L356' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_degrees-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_degrees-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_degrees</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_degrees(x)
</code></pre>

<p>Converts each element of the input array from radians to degrees. .. math::    degrees([0, \pi/2, \pi, 3\pi/2, 2\pi]) = [0, 90, 180, 270, 360]</p>
<p>Defined in src/operator/numpy/np<em>elemwise</em>unary<em>op</em>basic.cc:L371</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>x::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L352' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_delete-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_delete-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_delete</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_delete(arr, obj, start, stop, step, int_ind, axis)
</code></pre>

<p>Delete values along the given axis before the given indices.</p>
<p>Defined in src/operator/numpy/np<em>delete</em>op.cc:L72</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>arr::NDArray-or-SymbolicNode</code>: Input ndarray</li>
<li><code>obj::NDArray-or-SymbolicNode</code>: Input ndarray</li>
<li><code>start::int or None, optional, default='None'</code>: If 'obj' is slice, 'start' is one of it's arguments.</li>
<li><code>stop::int or None, optional, default='None'</code>: If 'obj' is slice, 'stop' is one of it's arguments.</li>
<li><code>step::int or None, optional, default='None'</code>: If 'obj' is slice, 'step' is one of it's arguments.</li>
<li><code>int_ind::int or None, optional, default='None'</code>: If 'obj' is int, 'int_ind' is the index before which'values' is inserted</li>
<li><code>axis::int or None, optional, default='None'</code>: Axis along which to insert <code>values</code>.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L361' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_det-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_det-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_det</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_det(A)
</code></pre>

<p><em>npi</em>det is an alias of <em>linalg</em>det.</p>
<p>Compute the determinant of a matrix. Input is a tensor <em>A</em> of dimension <em>n &gt;= 2</em>.</p>
<p>If <em>n=2</em>, <em>A</em> is a square matrix. We compute:</p>
<p><em>out</em> = <em>det(A)</em></p>
<p>If <em>n&gt;2</em>, <em>det</em> is performed separately on the trailing two dimensions for all inputs (batch mode).</p>
<p>.. note:: The operator supports float32 and float64 data types only. .. note:: There is no gradient backwarded when A is non-invertible (which is           equivalent to det(A) = 0) because zero is rarely hit upon in float           point computation and the Jacobi's formula on determinant gradient           is not computationally efficient when A is non-invertible.</p>
<p>Examples::</p>
<p>Single matrix determinant    A = [[1., 4.], [2., 3.]]    det(A) = [-5.]</p>
<p>Batch matrix determinant    A = [[[1., 4.], [2., 3.]],         [[2., 3.], [1., 4.]]]    det(A) = [-5., 5.]</p>
<p>Defined in src/operator/tensor/la_op.cc:L975</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>A::NDArray-or-SymbolicNode</code>: Tensor of square matrix</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L377' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_diag_indices_from-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_diag_indices_from-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_diag_indices_from</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_diag_indices_from(data)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input ndarray</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L347' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_diff-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_diff-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_diff</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_diff(a, n, axis)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>a::NDArray-or-SymbolicNode</code>: Input ndarray</li>
<li><code>n::int, optional, default='1'</code>: The number of times values are differenced. If zero, the input is returned as-is.</li>
<li><code>axis::int, optional, default='-1'</code>: Axis along which the cumulative sum is computed. The default (None) is to compute the diff over the flattened array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_dsplit-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_dsplit-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_dsplit</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_dsplit(data, indices, axis, squeeze_axis, sections)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input</li>
<li><code>indices::Shape(tuple), required</code>: Indices of splits. The elements should denote the boundaries of at which split is performed along the <code>axis</code>.</li>
<li><code>axis::int, optional, default='1'</code>: Axis along which to split.</li>
<li><code>squeeze_axis::boolean, optional, default=0</code>: If true, Removes the axis with length 1 from the shapes of the output arrays. <strong>Note</strong> that setting <code>squeeze_axis</code> to $true$ removes axis with length 1 only along the <code>axis</code> which it is split. Also <code>squeeze_axis</code> can be set to $true$ only if $input.shape[axis] == num_outputs$.</li>
<li><code>sections::int, optional, default='0'</code>: Number of sections if equally splitted. Default to 0 which means split by indices.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L355' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_dstack-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_dstack-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_dstack</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_dstack(data, num_args, dim)
</code></pre>

<p><strong>Note</strong>: <em>npi</em>dstack takes variable number of positional inputs. So instead of calling as <em>npi</em>dstack([x, y, z], num<em>args=3), one should call via _npi</em>dstack(x, y, z), and num_args will be determined automatically.</p>
<p>Stack tensors in sequence depthwise (in third dimension)</p>
<p>Defined in src/operator/numpy/np<em>matrix</em>op.cc:L1081</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode[]</code>: List of arrays to concatenate</li>
<li><code>num_args::int, required</code>: Number of inputs to be concated.</li>
<li><code>dim::int, optional, default='1'</code>: the dimension to be concated.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L355' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_ediff1d-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_ediff1d-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_ediff1d</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_ediff1d(input1, input2, input3, to_begin_arr_given, to_end_arr_given, to_begin_scalar, to_end_scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>input1::NDArray-or-SymbolicNode</code>: Source input</li>
<li><code>input2::NDArray-or-SymbolicNode</code>: Source input</li>
<li><code>input3::NDArray-or-SymbolicNode</code>: Source input</li>
<li><code>to_begin_arr_given::boolean, optional, default=0</code>: To determine whether the <code>to_begin</code> parameter is an array.</li>
<li><code>to_end_arr_given::boolean, optional, default=0</code>: To determine whether the <code>to_end</code> parameter is an array.</li>
<li><code>to_begin_scalar::double or None, optional, default=None</code>: If the <code>to_begin</code>is a scalar, the value of this parameter.</li>
<li><code>to_end_scalar::double or None, optional, default=None</code>: If the <code>to_end</code>is a scalar, the value of this parameter.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L359' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_eig-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_eig-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_eig</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_eig(A)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>A::NDArray-or-SymbolicNode</code>: Tensor of square matrix</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L347' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_eigh-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_eigh-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_eigh</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_eigh(A, UPLO)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>A::NDArray-or-SymbolicNode</code>: Tensor of real matrices</li>
<li><code>UPLO::, optional, default=L</code>: Specifies whether the calculation is done with the lower or upper triangular part.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_eigvals-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_eigvals-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_eigvals</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_eigvals(A)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>A::NDArray-or-SymbolicNode</code>: Tensor of square matrix</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L347' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_eigvalsh-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_eigvalsh-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_eigvalsh</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_eigvalsh(A, UPLO)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>A::NDArray-or-SymbolicNode</code>: Tensor of square matrix</li>
<li><code>UPLO::, optional, default=L</code>: Specifies whether the calculation is done with the lower or upper triangular part.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_einsum-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_einsum-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_einsum</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_einsum(data, num_args, subscripts, optimize)
</code></pre>

<p><strong>Note</strong>: <em>npi</em>einsum takes variable number of positional inputs. So instead of calling as <em>npi</em>einsum([x, y, z], num<em>args=3), one should call via _npi</em>einsum(x, y, z), and num_args will be determined automatically.</p>
<p>Defined in src/operator/numpy/np<em>einsum</em>op.cc:L333</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode[]</code>: List of eimsum operands</li>
<li><code>num_args::int, required</code>: Number of input arrays.</li>
<li><code>subscripts::string, optional, default=''</code>: Specifies the subscripts for summation as comma separated list of subscript labels. An implicit (classical Einstein summation) calculation is performed unless the explicit indicator '-&gt;' is included as well as subscript labels of the precise output form.</li>
<li><code>optimize::int, optional, default='0'</code>:</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L357' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_equal-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_equal-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_equal</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_equal(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: First input to the function</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: Second input to the function</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_equal_scalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_equal_scalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_equal_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_equal_scalar(data, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: First input to the function</li>
<li><code>scalar::float</code>: scalar input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_exp-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_exp-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_exp</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_exp(x)
</code></pre>

<p>Calculate the exponential of all elements in the input array. Example::    exp([0, 1, 2]) = [1., 2.71828175, 7.38905621]</p>
<p>Defined in src/operator/numpy/np<em>elemwise</em>unary<em>op</em>basic.cc:L240</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>x::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L352' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_expand_dims-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_expand_dims-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_expand_dims</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_expand_dims(data, axis)
</code></pre>

<p><em>npi</em>expand<em>dims is an alias of expand</em>dims.</p>
<p>Inserts a new axis of size 1 into the array shape For example, given $x$ with shape $(2,3,4)$, then $expand_dims(x, axis=1)$ will return a new array with shape $(2,1,3,4)$.</p>
<p>Defined in src/operator/tensor/matrix_op.cc:L395</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Source input</li>
<li><code>axis::int, required</code>: Position where new axis is to be inserted. Suppose that the input <code>NDArray</code>'s dimension is <code>ndim</code>, the range of the inserted axis is <code>[-ndim, ndim]</code></li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L356' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_expm1-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_expm1-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_expm1</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_expm1(x)
</code></pre>

<p>Calculate $exp(x) - 1$ for all elements in the array.</p>
<p>Defined in src/operator/numpy/np<em>elemwise</em>unary<em>op</em>basic.cc:L287</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>x::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_exponential-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_exponential-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_exponential</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_exponential(input1, scale, size, ctx)
</code></pre>

<p>Numpy behavior exponential</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>input1::NDArray-or-SymbolicNode</code>: Source input</li>
<li><code>scale::float or None, optional, default=1</code>:</li>
<li><code>size::Shape or None, optional, default=None</code>: Output shape. If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn. Default is None, in which case a single value is returned.</li>
<li><code>ctx::string, optional, default='cpu'</code>: Context of output, in format <a href="n">cpu|gpu|cpu_pinned</a>. Only used for imperative calls.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L353' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_eye-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_eye-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_eye</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_eye(N, M, k, ctx, dtype)
</code></pre>

<p>Return a 2-D array with ones on the diagonal and zeros elsewhere.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>N::long, required</code>: Number of rows in the output.</li>
<li><code>M::, optional, default=None</code>: Number of columns in the output. If None, defaults to N.</li>
<li><code>k::long, optional, default=0</code>: Index of the diagonal. 0 (the default) refers to the main diagonal,a positive value refers to an upper diagonal.and a negative value to a lower diagonal.</li>
<li><code>ctx::string, optional, default=''</code>: Context of output, in format <a href="n">cpu|gpu|cpu_pinned</a>.Only used for imperative calls.</li>
<li><code>dtype::{'bfloat16', 'float16', 'float32', 'float64', 'int32', 'int64', 'int8', 'uint8'},optional, default='float32'</code>: Data-type of the returned array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L355' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_fix-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_fix-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_fix</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_fix(x)
</code></pre>

<p>Round to nearest integer towards zero. Round an array of floats element-wise to nearest integer towards zero. The rounded values are returned as floats. Example::    fix([-2.1, -1.9, 1.9, 2.1]) = [-2., -1.,  1., 2.]</p>
<p>Defined in src/operator/numpy/np<em>elemwise</em>unary<em>op</em>basic.cc:L208</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>x::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L354' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_flip-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_flip-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_flip</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_flip(data, axis)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data array</li>
<li><code>axis::Shape(tuple), required</code>: The axis which to flip elements.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_floor-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_floor-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_floor</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_floor(x)
</code></pre>

<p>Return the floor of the input, element-wise. The floor of the scalar x is the largest integer i, such that i &lt;= x. Example::    floor([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0]) = [-2., -2., -1.,  0.,  1.,  1.,  2.]</p>
<p>Defined in src/operator/numpy/np<em>elemwise</em>unary<em>op</em>basic.cc:L174</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>x::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L353' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_full-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_full-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_full</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_full(shape, ctx, dtype, value)
</code></pre>

<p><em>npi</em>full is an alias of _full.</p>
<p>fill target with a scalar value</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>shape::Shape(tuple), optional, default=None</code>: The shape of the output</li>
<li><code>ctx::string, optional, default=''</code>: Context of output, in format <a href="n">cpu|gpu|cpu_pinned</a>.Only used for imperative calls.</li>
<li><code>dtype::{'bfloat16', 'bool', 'float16', 'float32', 'float64', 'int32', 'int64', 'int8', 'uint8'},optional, default='float32'</code>: Target data type.</li>
<li><code>value::double, required</code>: Value with which to fill newly created tensor</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L355' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_full_like-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_full_like-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_full_like</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_full_like(a, fill_value, ctx, dtype)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>a::NDArray-or-SymbolicNode</code>: The shape and data-type of a define these same attributes of the returned array.</li>
<li><code>fill_value::double, required</code>: Value with which to fill newly created tensor</li>
<li><code>ctx::string, optional, default=''</code>: Context of output, in format <a href="n">cpu|gpu|cpu_pinned</a>.Only used for imperative calls.</li>
<li><code>dtype::{None, 'bfloat16', 'bool', 'float16', 'float32', 'float64', 'int32', 'int64', 'int8', 'uint8'},optional, default='None'</code>: Target data type.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L353' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_gamma-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_gamma-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_gamma</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_gamma(input1, input2, shape, scale, size, ctx, dtype)
</code></pre>

<p>Numpy behavior gamma</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>input1::NDArray-or-SymbolicNode</code>: Source input</li>
<li><code>input2::NDArray-or-SymbolicNode</code>: Source input</li>
<li><code>shape::float or None, required</code>:</li>
<li><code>scale::float or None, required</code>:</li>
<li><code>size::Shape or None, optional, default=None</code>: Output shape. If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn. Default is None, in which case a single value is returned.</li>
<li><code>ctx::string, optional, default='cpu'</code>: Context of output, in format <a href="n">xpu|xpu|xpu_pinned</a>. Only used for imperative calls.</li>
<li><code>dtype::{'float16', 'float32', 'float64'},optional, default='float32'</code>: DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L359' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_gather_nd-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_gather_nd-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_gather_nd</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_gather_nd(data, indices)
</code></pre>

<p><em>npi</em>gather<em>nd is an alias of gather</em>nd.</p>
<p>Gather elements or slices from <code>data</code> and store to a tensor whose shape is defined by <code>indices</code>.</p>
<p>Given <code>data</code> with shape <code>(X_0, X_1, ..., X_{N-1})</code> and indices with shape <code>(M, Y_0, ..., Y_{K-1})</code>, the output will have shape <code>(Y_0, ..., Y_{K-1}, X_M, ..., X_{N-1})</code>, where <code>M &lt;= N</code>. If <code>M == N</code>, output shape will simply be <code>(Y_0, ..., Y_{K-1})</code>.</p>
<p>The elements in output is defined as follows::</p>
<p>output[y<em K-1="K-1">0, ..., y</em>, x<em N-1="N-1">M, ..., x</em>] = data[indices[0, y<em K-1="K-1">0, ..., y</em>],                                                       ...,                                                       indices[M-1, y<em K-1="K-1">0, ..., y</em>],                                                       x<em N-1="N-1">M, ..., x</em>]</p>
<p>Examples::</p>
<p>data = [[0, 1], [2, 3]]   indices = [[1, 1, 0], [0, 1, 0]]   gather_nd(data, indices) = [2, 3, 0]</p>
<p>data = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]   indices = [[0, 1], [1, 0]]   gather_nd(data, indices) = [[3, 4], [5, 6]]</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: data</li>
<li><code>indices::NDArray-or-SymbolicNode</code>: indices</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L375' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_greater-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_greater-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_greater</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_greater(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: First input to the function</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: Second input to the function</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_greater_equal-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_greater_equal-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_greater_equal</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_greater_equal(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: First input to the function</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: Second input to the function</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_greater_equal_scalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_greater_equal_scalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_greater_equal_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_greater_equal_scalar(data, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: First input to the function</li>
<li><code>scalar::float</code>: scalar input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_greater_scalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_greater_scalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_greater_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_greater_scalar(data, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: First input to the function</li>
<li><code>scalar::float</code>: scalar input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_gumbel-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_gumbel-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_gumbel</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_gumbel(input1, input2, loc, scale, size, ctx)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>input1::NDArray-or-SymbolicNode</code>: Source input</li>
<li><code>input2::NDArray-or-SymbolicNode</code>: Source input</li>
<li><code>loc::float or None, required</code>:</li>
<li><code>scale::float or None, required</code>:</li>
<li><code>size::Shape or None, optional, default=None</code>: Output shape. If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn. Default is None, in which case a single value is returned.</li>
<li><code>ctx::string, optional, default='cpu'</code>: Context of output, in format <a href="n">cpu|gpu|cpu_pinned</a>. Only used for imperative calls.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L357' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_hamming-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_hamming-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_hamming</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_hamming(M, ctx, dtype)
</code></pre>

<p>Return the Hamming window.The Hamming window is a taper formed by using a weighted cosine.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>M::, optional, default=None</code>: Number of points in the output window. If zero or less, an empty array is returned.</li>
<li><code>ctx::string, optional, default=''</code>: Context of output, in format <a href="n">cpu|gpu|cpu_pinned</a>.Only used for imperative calls.</li>
<li><code>dtype::{'bfloat16', 'float16', 'float32', 'float64', 'int32', 'int64', 'int8', 'uint8'},optional, default='float32'</code>: Data-type of the returned array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_hanning-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_hanning-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_hanning</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_hanning(M, ctx, dtype)
</code></pre>

<p>Return the Hanning window.The Hanning window is a taper formed by using a weighted cosine.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>M::, optional, default=None</code>: Number of points in the output window. If zero or less, an empty array is returned.</li>
<li><code>ctx::string, optional, default=''</code>: Context of output, in format <a href="n">cpu|gpu|cpu_pinned</a>.Only used for imperative calls.</li>
<li><code>dtype::{'bfloat16', 'float16', 'float32', 'float64', 'int32', 'int64', 'int8', 'uint8'},optional, default='float32'</code>: Data-type of the returned array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_histogram-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_histogram-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_histogram</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_histogram(data, bins, bin_cnt, range)
</code></pre>

<p><em>npi</em>histogram is an alias of _histogram.</p>
<p>This operators implements the histogram function.</p>
<p>Example::   x = [[0, 1], [2, 2], [3, 4]]   histo, bin<em>edges = histogram(data=x, bin</em>bounds=[], bin<em>cnt=5, range=(0,5))   histo = [1, 1, 2, 1, 1]   bin</em>edges = [0., 1., 2., 3., 4.]   histo, bin<em>edges = histogram(data=x, bin</em>bounds=[0., 2.1, 3.])   histo = [4, 1]</p>
<p>Defined in src/operator/tensor/histogram.cc:L137</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input ndarray</li>
<li><code>bins::NDArray-or-SymbolicNode</code>: Input ndarray</li>
<li><code>bin_cnt::int or None, optional, default='None'</code>: Number of bins for uniform case</li>
<li><code>range::, optional, default=None</code>: The lower and upper range of the bins. if not provided, range is simply (a.min(), a.max()). values outside the range are ignored. the first element of the range must be less than or equal to the second. range affects the automatic bin computation as well. while bin width is computed to be optimal based on the actual data within range, the bin count will fill the entire range including portions containing no data.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L367' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_hsplit-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_hsplit-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_hsplit</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_hsplit(data, indices, axis, squeeze_axis, sections)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input</li>
<li><code>indices::Shape(tuple), required</code>: Indices of splits. The elements should denote the boundaries of at which split is performed along the <code>axis</code>.</li>
<li><code>axis::int, optional, default='1'</code>: Axis along which to split.</li>
<li><code>squeeze_axis::boolean, optional, default=0</code>: If true, Removes the axis with length 1 from the shapes of the output arrays. <strong>Note</strong> that setting <code>squeeze_axis</code> to $true$ removes axis with length 1 only along the <code>axis</code> which it is split. Also <code>squeeze_axis</code> can be set to $true$ only if $input.shape[axis] == num_outputs$.</li>
<li><code>sections::int, optional, default='0'</code>: Number of sections if equally splitted. Default to 0 which means split by indices.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L355' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_hsplit_backward-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_hsplit_backward-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_hsplit_backward</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_hsplit_backward()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_hstack-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_hstack-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_hstack</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_hstack(data, num_args, dim)
</code></pre>

<p><strong>Note</strong>: <em>npi</em>hstack takes variable number of positional inputs. So instead of calling as <em>npi</em>hstack([x, y, z], num<em>args=3), one should call via _npi</em>hstack(x, y, z), and num_args will be determined automatically.</p>
<p>Stack tensors horizontally (in second dimension)</p>
<p>Defined in src/operator/numpy/np<em>matrix</em>op.cc:L1043</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode[]</code>: List of arrays to concatenate</li>
<li><code>num_args::int, required</code>: Number of inputs to be concated.</li>
<li><code>dim::int, optional, default='1'</code>: the dimension to be concated.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L355' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_hypot-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_hypot-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_hypot</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_hypot(x1, x2)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>x1::NDArray-or-SymbolicNode</code>: The input array</li>
<li><code>x2::NDArray-or-SymbolicNode</code>: The input array</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_hypot_scalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_hypot_scalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_hypot_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_hypot_scalar(data, scalar)
</code></pre>

<p><em>npi</em>hypot<em>scalar is an alias of _hypot</em>scalar.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_identity-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_identity-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_identity</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_identity(shape, ctx, dtype)
</code></pre>

<p>Return a new identity array of given shape, type, and context.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>shape::Shape(tuple), optional, default=[]</code>: The shape of the output</li>
<li><code>ctx::string, optional, default=''</code>: Context of output, in format <a href="n">cpu|gpu|cpu_pinned</a>.Only used for imperative calls.</li>
<li><code>dtype::{'bfloat16', 'bool', 'float16', 'float32', 'float64', 'int32', 'int64', 'int8', 'uint8'},optional, default='float32'</code>: Target data type.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_indices-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_indices-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_indices</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_indices(dimensions, dtype, ctx)
</code></pre>

<p>Return an array representing the indices of a grid.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>dimensions::Shape(tuple), required</code>: The shape of the grid.</li>
<li><code>dtype::{'bfloat16', 'float16', 'float32', 'float64', 'int32', 'int64', 'int8', 'uint8'},optional, default='int32'</code>: Target data type.</li>
<li><code>ctx::string, optional, default=''</code>: Context of output, in format <a href="n">cpu|gpu|cpu_pinned</a>.Only used for imperative calls.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_insert_scalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_insert_scalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_insert_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_insert_scalar(arr, values, val, start, stop, step, int_ind, axis)
</code></pre>

<p>Insert values along the given axis before the given indices.</p>
<p>Defined in src/operator/numpy/np<em>insert</em>op_scalar.cc:L106</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>arr::NDArray-or-SymbolicNode</code>: Input ndarray</li>
<li><code>values::NDArray-or-SymbolicNode</code>: Input ndarray</li>
<li><code>val::double or None, optional, default=None</code>: A scaler to be inserted into 'array'</li>
<li><code>start::int or None, optional, default='None'</code>: If 'obj' is slice, 'start' is one of it's arguments.</li>
<li><code>stop::int or None, optional, default='None'</code>: If 'obj' is slice, 'stop' is one of it's arguments.</li>
<li><code>step::int or None, optional, default='None'</code>: If 'obj' is slice, 'step' is one of it's arguments.</li>
<li><code>int_ind::int or None, optional, default='None'</code>: If 'obj' is int, 'int_ind' is the index before which'values' is inserted</li>
<li><code>axis::int or None, optional, default='None'</code>: Axis along which to insert 'values'.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L363' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_insert_slice-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_insert_slice-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_insert_slice</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_insert_slice(arr, values, val, start, stop, step, int_ind, axis)
</code></pre>

<p>Insert values along the given axis before the given indices.</p>
<p>Defined in src/operator/numpy/np<em>insert</em>op_slice.cc:L132</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>arr::NDArray-or-SymbolicNode</code>: Input ndarray</li>
<li><code>values::NDArray-or-SymbolicNode</code>: Input ndarray</li>
<li><code>val::double or None, optional, default=None</code>: A scaler to be inserted into 'array'</li>
<li><code>start::int or None, optional, default='None'</code>: If 'obj' is slice, 'start' is one of it's arguments.</li>
<li><code>stop::int or None, optional, default='None'</code>: If 'obj' is slice, 'stop' is one of it's arguments.</li>
<li><code>step::int or None, optional, default='None'</code>: If 'obj' is slice, 'step' is one of it's arguments.</li>
<li><code>int_ind::int or None, optional, default='None'</code>: If 'obj' is int, 'int_ind' is the index before which'values' is inserted</li>
<li><code>axis::int or None, optional, default='None'</code>: Axis along which to insert 'values'.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L363' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_insert_tensor-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_insert_tensor-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_insert_tensor</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_insert_tensor(arr, values, obj, val, start, stop, step, int_ind, axis)
</code></pre>

<p>Insert values along the given axis before the given indices.           Indices is tensor and ndim &gt; 0.</p>
<p>Defined in src/operator/numpy/np<em>insert</em>op_tensor.cc:L122</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>arr::NDArray-or-SymbolicNode</code>: Input ndarray</li>
<li><code>values::NDArray-or-SymbolicNode</code>: Input ndarray</li>
<li><code>obj::NDArray-or-SymbolicNode</code>: Input ndarray</li>
<li><code>val::double or None, optional, default=None</code>: A scaler to be inserted into 'array'</li>
<li><code>start::int or None, optional, default='None'</code>: If 'obj' is slice, 'start' is one of it's arguments.</li>
<li><code>stop::int or None, optional, default='None'</code>: If 'obj' is slice, 'stop' is one of it's arguments.</li>
<li><code>step::int or None, optional, default='None'</code>: If 'obj' is slice, 'step' is one of it's arguments.</li>
<li><code>int_ind::int or None, optional, default='None'</code>: If 'obj' is int, 'int_ind' is the index before which'values' is inserted</li>
<li><code>axis::int or None, optional, default='None'</code>: Axis along which to insert 'values'.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L366' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_inv-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_inv-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_inv</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_inv(A)
</code></pre>

<p><em>npi</em>inv is an alias of <em>linalg</em>inverse.</p>
<p>Compute the inverse of a matrix. Input is a tensor <em>A</em> of dimension <em>n &gt;= 2</em>.</p>
<p>If <em>n=2</em>, <em>A</em> is a square matrix. We compute:</p>
<p><em>out</em> = <em>A</em>\ :sup:<code>-1</code></p>
<p>If <em>n&gt;2</em>, <em>inverse</em> is performed separately on the trailing two dimensions for all inputs (batch mode).</p>
<p>.. note:: The operator supports float32 and float64 data types only.</p>
<p>Examples::</p>
<p>Single matrix inverse    A = [[1., 4.], [2., 3.]]    inverse(A) = [[-0.6, 0.8], [0.4, -0.2]]</p>
<p>Batch matrix inverse    A = [[[1., 4.], [2., 3.]],         [[1., 3.], [2., 4.]]]    inverse(A) = [[[-0.6, 0.8], [0.4, -0.2]],                  [[-2., 1.5], [1., -0.5]]]</p>
<p>Defined in src/operator/tensor/la_op.cc:L920</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>A::NDArray-or-SymbolicNode</code>: Tensor of square matrix</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L374' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_isfinite-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_isfinite-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_isfinite</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_isfinite(x)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>x::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L347' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_isinf-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_isinf-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_isinf</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_isinf(x)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>x::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L347' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_isnan-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_isnan-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_isnan</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_isnan(x)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>x::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L347' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_isneginf-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_isneginf-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_isneginf</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_isneginf(x)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>x::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L347' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_isposinf-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_isposinf-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_isposinf</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_isposinf(x)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>x::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L347' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_laplace-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_laplace-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_laplace</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_laplace(input1, input2, loc, scale, size, ctx, dtype)
</code></pre>

<p>numpy behavior Laplace</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>input1::NDArray-or-SymbolicNode</code>: Source input</li>
<li><code>input2::NDArray-or-SymbolicNode</code>: Source input</li>
<li><code>loc::float or None, required</code>:</li>
<li><code>scale::float or None, required</code>:</li>
<li><code>size::Shape or None, optional, default=None</code>: Output shape. If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn. Default is None, in which case a single value is returned.</li>
<li><code>ctx::string, optional, default='cpu'</code>: Context of output, in format <a href="n">cpu|gpu|cpu_pinned</a>. Only used for imperative calls.</li>
<li><code>dtype::{'float16', 'float32', 'float64'},optional, default='float32'</code>: DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L359' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_lcm-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_lcm-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_lcm</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_lcm(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: First input to the function</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: Second input to the function</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_lcm_scalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_lcm_scalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_lcm_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_lcm_scalar(data, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::int</code>: scalar input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_ldexp-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_ldexp-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_ldexp</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_ldexp(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: First input to the function</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: Second input to the function</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_ldexp_scalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_ldexp_scalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_ldexp_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_ldexp_scalar(data, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_less-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_less-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_less</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_less(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: First input to the function</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: Second input to the function</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_less_equal-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_less_equal-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_less_equal</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_less_equal(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: First input to the function</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: Second input to the function</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_less_equal_scalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_less_equal_scalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_less_equal_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_less_equal_scalar(data, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: First input to the function</li>
<li><code>scalar::float</code>: scalar input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_less_scalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_less_scalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_less_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_less_scalar(data, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: First input to the function</li>
<li><code>scalar::float</code>: scalar input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_linspace-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_linspace-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_linspace</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_linspace(start, stop, step, repeat, infer_range, ctx, dtype)
</code></pre>

<p><em>npi</em>linspace is an alias of _linspace.</p>
<p>Return evenly spaced numbers over a specified interval. Similar to Numpy</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>start::double, required</code>: Start of interval. The interval includes this value. The default start value is 0.</li>
<li><code>stop::double or None, optional, default=None</code>: End of interval. The interval does not include this value, except in some cases where step is not an integer and floating point round-off affects the length of out.</li>
<li><code>step::double, optional, default=1</code>: Spacing between values.</li>
<li><code>repeat::int, optional, default='1'</code>: The repeating time of all elements. E.g repeat=3, the element a will be repeated three times –&gt; a, a, a.</li>
<li><code>infer_range::boolean, optional, default=0</code>: When set to True, infer the stop position from the start, step, repeat, and output tensor size.</li>
<li><code>ctx::string, optional, default=''</code>: Context of output, in format <a href="n">cpu|gpu|cpu_pinned</a>.Only used for imperative calls.</li>
<li><code>dtype::{'bfloat16', 'float16', 'float32', 'float64', 'int32', 'int64', 'int8', 'uint8'},optional, default='float32'</code>: Target data type.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L361' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_log-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_log-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_log</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_log(x)
</code></pre>

<p>Returns element-wise Natural logarithmic value of the input. The natural logarithm is logarithm in base <em>e</em>, so that $log(exp(x)) = x$</p>
<p>Defined in src/operator/numpy/np<em>elemwise</em>unary<em>op</em>basic.cc:L247</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>x::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_log10-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_log10-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_log10</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_log10(x)
</code></pre>

<p>Returns element-wise Base-10 logarithmic value of the input. $10**log10(x) = x$</p>
<p>Defined in src/operator/numpy/np<em>elemwise</em>unary<em>op</em>basic.cc:L268</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>x::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_log1p-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_log1p-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_log1p</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_log1p(x)
</code></pre>

<p>Return the natural logarithm of one plus the input array, element-wise. Calculates $log(1 + x)$.</p>
<p>Defined in src/operator/numpy/np<em>elemwise</em>unary<em>op</em>basic.cc:L282</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>x::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_log2-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_log2-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_log2</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_log2(x)
</code></pre>

<p>Returns element-wise Base-2 logarithmic value of the input. $2**log2(x) = x$</p>
<p>Defined in src/operator/numpy/np<em>elemwise</em>unary<em>op</em>basic.cc:L275</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>x::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_logical_not-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_logical_not-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_logical_not</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_logical_not(x)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>x::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L347' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_logistic-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_logistic-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_logistic</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_logistic(input1, input2, loc, scale, size, ctx)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>input1::NDArray-or-SymbolicNode</code>: Source input</li>
<li><code>input2::NDArray-or-SymbolicNode</code>: Source input</li>
<li><code>loc::float or None, required</code>:</li>
<li><code>scale::float or None, required</code>:</li>
<li><code>size::Shape or None, optional, default=None</code>: Output shape. If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn. Default is None, in which case a single value is returned.</li>
<li><code>ctx::string, optional, default='cpu'</code>: Context of output, in format <a href="n">cpu|gpu|cpu_pinned</a>. Only used for imperative calls.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L357' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_logspace-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_logspace-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_logspace</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_logspace(start, stop, num, endpoint, base, ctx, dtype)
</code></pre>

<p>Return numbers spaced evenly on a log scale.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>start::double, required</code>: The starting value of the sequence.</li>
<li><code>stop::double, required</code>: The ending value of the sequence</li>
<li><code>num::int, required</code>: Number of samples to generate. Must be non-negative.</li>
<li><code>endpoint::boolean, optional, default=1</code>: If True, stop is the last sample. Otherwise, it is not included.</li>
<li><code>base::double, optional, default=10</code>: The base of the log space. The step size between the elements in ln(samples) / ln(base) (or log_base(samples)) is uniform.</li>
<li><code>ctx::string, optional, default=''</code>: Context of output, in format <a href="n">cpu|gpu|cpu_pinned</a>.Only used for imperative calls.</li>
<li><code>dtype::{'bfloat16', 'float16', 'float32', 'float64', 'int32', 'int64', 'int8', 'uint8'},optional, default='float32'</code>: Target data type.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L359' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_matmul-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_matmul-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_matmul</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_matmul(a, b)
</code></pre>

<p>Defined in src/operator/numpy/np<em>matmul</em>op.cc:L140</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>a::NDArray-or-SymbolicNode</code>: First input</li>
<li><code>b::NDArray-or-SymbolicNode</code>: Second input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_maximum-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_maximum-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_maximum</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_maximum(lhs, rhs)
</code></pre>

<p><em>npi</em>maximum is an alias of broadcast_maximum.</p>
<p>Returns element-wise maximum of the input arrays with broadcasting.</p>
<p>This function compares two input arrays and returns a new array having the element-wise maxima.</p>
<p>Example::</p>
<p>x = [[ 1.,  1.,  1.],         [ 1.,  1.,  1.]]</p>
<p>y = [[ 0.],         [ 1.]]</p>
<p>broadcast_maximum(x, y) = [[ 1.,  1.,  1.],                               [ 1.,  1.,  1.]]</p>
<p>Defined in src/operator/tensor/elemwise<em>binary</em>broadcast<em>op</em>extended.cc:L81</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: First input to the function</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: Second input to the function</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L368' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_maximum_scalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_maximum_scalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_maximum_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_maximum_scalar(data, scalar)
</code></pre>

<p><em>npi</em>maximum<em>scalar is an alias of _maximum</em>scalar.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_mean-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_mean-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_mean</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_mean(a, axis, dtype, keepdims, initial)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>a::NDArray-or-SymbolicNode</code>: The input</li>
<li><code>axis::Shape or None, optional, default=None</code>: Axis or axes along which a sum is performed. The default, axis=None, will sum all of the elements of the input array. If axis is negative it counts from the last to the first axis.</li>
<li><code>dtype::{None, 'bool', 'float16', 'float32', 'float64', 'int32', 'int64', 'int8'},optional, default='None'</code>: The type of the returned array and of the accumulator in which the elements are summed. The dtype of a is used by default unless a has an integer dtype of less precision than the default platform integer. In that case, if a is signed then the platform integer is used while if a is unsigned then an unsigned integer of the same precision as the platform integer is used.</li>
<li><code>keepdims::boolean, optional, default=0</code>: If this is set to <code>True</code>, the reduced axes are left in the result as dimension with size one.</li>
<li><code>initial::double or None, optional, default=None</code>: Starting value for the sum.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L355' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_minimum-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_minimum-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_minimum</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_minimum(lhs, rhs)
</code></pre>

<p><em>npi</em>minimum is an alias of broadcast_minimum.</p>
<p>Returns element-wise minimum of the input arrays with broadcasting.</p>
<p>This function compares two input arrays and returns a new array having the element-wise minima.</p>
<p>Example::</p>
<p>x = [[ 1.,  1.,  1.],         [ 1.,  1.,  1.]]</p>
<p>y = [[ 0.],         [ 1.]]</p>
<p>broadcast_maximum(x, y) = [[ 0.,  0.,  0.],                               [ 1.,  1.,  1.]]</p>
<p>Defined in src/operator/tensor/elemwise<em>binary</em>broadcast<em>op</em>extended.cc:L117</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: First input to the function</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: Second input to the function</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L368' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_minimum_scalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_minimum_scalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_minimum_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_minimum_scalar(data, scalar)
</code></pre>

<p><em>npi</em>minimum<em>scalar is an alias of _minimum</em>scalar.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_mod-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_mod-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_mod</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_mod(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: First input to the function</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: Second input to the function</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_mod_scalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_mod_scalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_mod_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_mod_scalar(data, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_multinomial-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_multinomial-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_multinomial</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_multinomial(a, n, pvals, size)
</code></pre>

<p>Draw samples from a multinomial distribution. " "The multinomial distribution is a multivariate generalisation of the binomial distribution. " "Take an experiment with one of p possible outcomes. " "An example of such an experiment is throwing a dice, where the outcome can be 1 through 6. " "Each sample drawn from the distribution represents n such experiments. " "Its values, X<em>i = [X</em>0, X<em>1, ..., X</em>p], represent the number of times the outcome was i.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>a::NDArray-or-SymbolicNode</code>: Source input</li>
<li><code>n::int, required</code>: Number of experiments.</li>
<li><code>pvals::, optional, default=None</code>: Probabilities of each of the p different outcomes. These should sum to 1 (however, the last element is always assumed to account for the remaining probability, as long as sum(pvals[:-1]) &lt;= 1)Note that this is for internal usage only. This operator will only have either input mx.ndarray or this list of pvals</li>
<li><code>size::Shape or None, optional, default=None</code>: Output shape. If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn. Default is None, in which case a single value is returned.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L359' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_multiply-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_multiply-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_multiply</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_multiply(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: First input to the function</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: Second input to the function</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_multiply_scalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_multiply_scalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_multiply_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_multiply_scalar(data, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_nan_to_num-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_nan_to_num-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_nan_to_num</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_nan_to_num(data, copy, nan, posinf, neginf)
</code></pre>

<p>Defined in src/operator/numpy/np<em>elemwise</em>unary<em>op</em>basic.cc:L464</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input ndarray</li>
<li><code>copy::boolean, optional, default=1</code>: Whether to create a copy of <code>x</code> (True) or to replace valuesin-place (False). The in-place operation only occurs ifcasting to an array does not require a copy.Default is True.</li>
<li><code>nan::double, optional, default=0</code>: Value to be used to fill NaN values. If no value is passedthen NaN values will be replaced with 0.0.</li>
<li><code>posinf::double or None, optional, default=None</code>: Value to be used to fill positive infinity values.If no value is passed then positive infinity values will bereplaced with a very large number.</li>
<li><code>neginf::double or None, optional, default=None</code>: Value to be used to fill negative infinity values.If no value is passed then negative infinity valueswill be replaced with a very small (or negative) number.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L357' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_negative-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_negative-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_negative</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_negative(x)
</code></pre>

<p>Numerical negative, element-wise. Example::     negative([1.,  -1.]) = [-1.,  1.]</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>x::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L350' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_nonzero-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_nonzero-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_nonzero</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_nonzero(x)
</code></pre>

<p><em>npi</em>nonzero is an alias of <em>npx</em>nonzero.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>x::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_norm-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_norm-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_norm</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_norm(data)
</code></pre>

<p>Defined in src/operator/numpy/linalg/np<em>norm</em>forward.cc:L32</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_normal-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_normal-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_normal</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_normal(input1, input2, loc, scale, size, ctx, dtype)
</code></pre>

<p>Numpy behavior normal</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>input1::NDArray-or-SymbolicNode</code>: Source input</li>
<li><code>input2::NDArray-or-SymbolicNode</code>: Source input</li>
<li><code>loc::float or None, required</code>:</li>
<li><code>scale::float or None, required</code>:</li>
<li><code>size::Shape or None, optional, default=None</code>: Output shape. If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn. Default is None, in which case a single value is returned.</li>
<li><code>ctx::string, optional, default='cpu'</code>: Context of output, in format <a href="n">cpu|gpu|cpu_pinned</a>. Only used for imperative calls.</li>
<li><code>dtype::{'float16', 'float32', 'float64'},optional, default='float32'</code>: DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L359' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_normal_n-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_normal_n-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_normal_n</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_normal_n(input1, input2, loc, scale, size, ctx, dtype)
</code></pre>

<p>Ndarray behavior normal</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>input1::NDArray-or-SymbolicNode</code>: Source input</li>
<li><code>input2::NDArray-or-SymbolicNode</code>: Source input</li>
<li><code>loc::float or None, required</code>:</li>
<li><code>scale::float or None, required</code>:</li>
<li><code>size::Shape or None, optional, default=None</code>: Output shape. If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn. Default is None, in which case a single value is returned.</li>
<li><code>ctx::string, optional, default='cpu'</code>: Context of output, in format <a href="n">cpu|gpu|cpu_pinned</a>. Only used for imperative calls.</li>
<li><code>dtype::{'float16', 'float32', 'float64'},optional, default='float32'</code>: DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L359' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_not_equal-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_not_equal-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_not_equal</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_not_equal(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: First input to the function</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: Second input to the function</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_not_equal_scalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_not_equal_scalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_not_equal_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_not_equal_scalar(data, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: First input to the function</li>
<li><code>scalar::float</code>: scalar input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_ones-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_ones-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_ones</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_ones(shape, ctx, dtype)
</code></pre>

<p>Return a new array of given shape, type, and context, filled with ones.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>shape::Shape(tuple), optional, default=[]</code>: The shape of the output</li>
<li><code>ctx::string, optional, default=''</code>: Context of output, in format <a href="n">cpu|gpu|cpu_pinned</a>.Only used for imperative calls.</li>
<li><code>dtype::{'bfloat16', 'bool', 'float16', 'float32', 'float64', 'int32', 'int64', 'int8', 'uint8'},optional, default='float32'</code>: Target data type.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_pad-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_pad-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_pad</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_pad(data, pad_width, mode, constant_value, reflect_type)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input ndarray</li>
<li><code>pad_width::tuple of &lt;Shape(tuple)&gt;, required</code>: Number of values padded to the edges of each axis. ((before<em>1, after</em>1), … (before<em>N,after</em>N)) unique pad widths for each axis. ((before, after),) yields same before andafter pad for each axis. (pad,) or int is a shortcut for before = after = pad width for allaxes.</li>
<li><code>mode::{'constant', 'edge', 'maximum', 'minimum', 'reflect', 'symmetric'},optional, default='constant'</code>: Padding type to use. "constant" pads with <code>constant_value</code> "edge" pads using the edge values of the input array "reflect" Pads with the reflection of the vector mirroredon the first and last values of the vector along each axis. "symmetric" Pads with the reflection of the vector mirroredalong the edge of the array. "maximum" Pads with the maximum value of all or part of thevector along each axis. "minimum" Pads with the minimum value of all or part of thevector along each axis.</li>
<li><code>constant_value::double, optional, default=0</code>: Used in ‘constant’. The values to set the padded values for each axis.((before<em>1, after</em>1), ... (before<em>N, after</em>N)) unique pad constants foreach axis.((before, after),) yields same before and after constants for each axis.(constant,) or constant is a shortcut for before = after = constant for allaxes.Default is 0.</li>
<li><code>reflect_type::string, optional, default='even'</code>: Used in ‘reflect’, and ‘symmetric’. The ‘even’ style is the default with an unaltered reflection around the edge value. For the ‘odd’ style,the extended part of the array is created by subtracting the reflected values from two times the edge value.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L355' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_pareto-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_pareto-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_pareto</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_pareto(input1, a, size, ctx)
</code></pre>

<p>Numpy behavior Pareto</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>input1::NDArray-or-SymbolicNode</code>: Source input</li>
<li><code>a::float or None, optional, default=None</code>:</li>
<li><code>size::Shape or None, optional, default=None</code>: Output shape. If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn. Default is None, in which case a single value is returned.</li>
<li><code>ctx::string, optional, default='cpu'</code>: Context of output, in format <a href="n">cpu|gpu|cpu_pinned</a>. Only used for imperative calls.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L353' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_percentile-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_percentile-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_percentile</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_percentile(a, q, axis, interpolation, keepdims, q_scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>a::NDArray-or-SymbolicNode</code>: Input data</li>
<li><code>q::NDArray-or-SymbolicNode</code>: Input percentile</li>
<li><code>axis::Shape or None, optional, default=None</code>: Axis or axes along which a sum is performed. The default, axis=None, will sum all of the elements of the input array. If axis is negative it counts from the last to the first axis.</li>
<li><code>interpolation::{'higher', 'linear', 'lower', 'midpoint', 'nearest'},optional, default='linear'</code>: his optional parameter specifies the interpolation method to use when thedesired percentile lies between two data points i &lt; j</li>
<li><code>keepdims::boolean, optional, default=0</code>: If this is set to <code>True</code>, the reduced axes are left in the result as dimension with size one.</li>
<li><code>q_scalar::double or None, optional, default=None</code>: inqut q is a scalar</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L357' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_pinv-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_pinv-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_pinv</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_pinv(A, rcond, hermitian)
</code></pre>

<p>Defined in src/operator/numpy/linalg/np_pinv.cc:L99</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>A::NDArray-or-SymbolicNode</code>: Tensor of matrix</li>
<li><code>rcond::NDArray-or-SymbolicNode</code>: Cutoff for small singular values.</li>
<li><code>hermitian::boolean, optional, default=0</code>: If True, A is assumed to be Hermitian (symmetric if real-valued).</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L353' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_pinv_scalar_rcond-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_pinv_scalar_rcond-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_pinv_scalar_rcond</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_pinv_scalar_rcond(A, rcond, hermitian)
</code></pre>

<p>Defined in src/operator/numpy/linalg/np_pinv.cc:L177</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>A::NDArray-or-SymbolicNode</code>: Tensor of matrix</li>
<li><code>rcond::double, optional, default=1.0000000000000001e-15</code>: Cutoff for small singular values.</li>
<li><code>hermitian::boolean, optional, default=0</code>: If True, A is assumed to be Hermitian (symmetric if real-valued).</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L353' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_polyval-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_polyval-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_polyval</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_polyval(p, x)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>p::NDArray-or-SymbolicNode</code>: polynomial coefficients</li>
<li><code>x::NDArray-or-SymbolicNode</code>: variables</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_power-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_power-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_power</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_power(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: First input to the function</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: Second input to the function</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_power_scalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_power_scalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_power_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_power_scalar(data, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_powerd-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_powerd-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_powerd</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_powerd(input1, a, size)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>input1::NDArray-or-SymbolicNode</code>: Source input</li>
<li><code>a::float or None, optional, default=None</code>:</li>
<li><code>size::Shape or None, optional, default=None</code>: Output shape. If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn. Default is None, in which case a single value is returned.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_radians-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_radians-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_radians</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_radians(x)
</code></pre>

<p>Converts each element of the input array from degrees to radians. .. math::    radians([0, 90, 180, 270, 360]) = [0, \pi/2, \pi, 3\pi/2, 2\pi]</p>
<p>Defined in src/operator/numpy/np<em>elemwise</em>unary<em>op</em>basic.cc:L379</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>x::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L352' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_random_randint-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_random_randint-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_random_randint</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_random_randint(low, high, shape, ctx, dtype)
</code></pre>

<p><em>npi</em>random<em>randint is an alias of _random</em>randint.</p>
<p>Draw random samples from a discrete uniform distribution.</p>
<p>Samples are uniformly distributed over the half-open interval <em>[low, high)</em> (includes <em>low</em>, but excludes <em>high</em>).</p>
<p>Example::</p>
<p>randint(low=0, high=5, shape=(2,2)) = [[ 0,  2],                                           [ 3,  1]]</p>
<p>Defined in src/operator/random/sample_op.cc:L194</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>low::long, required</code>: Lower bound of the distribution.</li>
<li><code>high::long, required</code>: Upper bound of the distribution.</li>
<li><code>shape::Shape(tuple), optional, default=None</code>: Shape of the output.</li>
<li><code>ctx::string, optional, default=''</code>: Context of output, in format <a href="n">cpu|gpu|cpu_pinned</a>. Only used for imperative calls.</li>
<li><code>dtype::{'None', 'int32', 'int64'},optional, default='None'</code>: DType of the output in case this can't be inferred. Defaults to int32 if not defined (dtype=None).</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L369' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_rarctan2_scalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_rarctan2_scalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_rarctan2_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_rarctan2_scalar(data, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_rayleigh-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_rayleigh-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_rayleigh</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_rayleigh(input1, scale, size, ctx)
</code></pre>

<p>Numpy behavior rayleigh</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>input1::NDArray-or-SymbolicNode</code>: Source input</li>
<li><code>scale::float or None, optional, default=1</code>:</li>
<li><code>size::Shape or None, optional, default=None</code>: Output shape. If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn. Default is None, in which case a single value is returned.</li>
<li><code>ctx::string, optional, default='cpu'</code>: Context of output, in format <a href="n">cpu|gpu|cpu_pinned</a>. Only used for imperative calls.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L353' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_rcopysign_scalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_rcopysign_scalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_rcopysign_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_rcopysign_scalar(data, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_reciprocal-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_reciprocal-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_reciprocal</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_reciprocal(x)
</code></pre>

<p>Return the reciprocal of the argument, element-wise. Example::     reciprocal([-2, 1, 3, 1.6, 0.2]) = [-0.5, 1.0, 0.33333334, 0.625, 5.0]</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>x::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L350' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_reshape-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_reshape-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_reshape</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_reshape(a, newshape, reverse, order)
</code></pre>

<p><em>npi</em>reshape is an alias of <em>npx</em>reshape.</p>
<p>Defined in src/operator/numpy/np<em>matrix</em>op.cc:L382</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>a::NDArray-or-SymbolicNode</code>: Array to be reshaped.</li>
<li><code>newshape::Shape(tuple), required</code>: The new shape should be compatible with the original shape. If an integer, then the result will be a 1-D array of that length. One shape dimension can be -1. In this case, the value is inferred from the length of the array and remaining dimensions. -2 to -6 are used for data manipulation. -2 copy this dimension from the input to the output shape. -3 will skip current dimension if and only if the current dim size is one. -4 copy all remain of the input dimensions to the output shape. -5 use the product of two consecutive dimensions of the input shape as the output. -6 split one dimension of the input into two dimensions passed subsequent to -6 in the new shape.</li>
<li><code>reverse::boolean, optional, default=0</code>: If true then the special values are inferred from right to left</li>
<li><code>order::string, optional, default='C'</code>: Read the elements of a using this index order, and place the elements into the reshaped array using this index order. 'C' means to read/write the elements using C-like index order, with the last axis index changing fastest, back to the first axis index changing slowest. Note that currently only C-like order is supported</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L357' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_rint-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_rint-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_rint</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_rint(x)
</code></pre>

<p>Round elements of the array to the nearest integer. Example::    rint([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0]) = [-2., -2., -0.,  0.,  2.,  2.,  2.]</p>
<p>Defined in src/operator/numpy/np<em>elemwise</em>unary<em>op</em>basic.cc:L156</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>x::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L352' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_rldexp_scalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_rldexp_scalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_rldexp_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_rldexp_scalar(data, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_rmod_scalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_rmod_scalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_rmod_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_rmod_scalar(data, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_rnn_param_concat-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_rnn_param_concat-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_rnn_param_concat</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_rnn_param_concat(data, num_args, dim)
</code></pre>

<p><em>npi</em>rnn<em>param</em>concat is an alias of <em>rnn</em>param_concat.</p>
<p><strong>Note</strong>: <em>npi</em>rnn<em>param</em>concat takes variable number of positional inputs. So instead of calling as <em>npi</em>rnn<em>param</em>concat([x, y, z], num<em>args=3), one should call via _npi</em>rnn<em>param</em>concat(x, y, z), and num_args will be determined automatically.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode[]</code>: List of arrays to concatenate</li>
<li><code>num_args::int, required</code>: Number of inputs to be concated.</li>
<li><code>dim::int, optional, default='1'</code>: the dimension to be concated.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L355' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_roll-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_roll-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_roll</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_roll(data, shift, axis)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input ndarray</li>
<li><code>shift::Shape or None, optional, default=None</code>: The number of places by which elements are shifted. If a tuple,then axis must be a tuple of the same size, and each of the given axes is shiftedby the corresponding number. If an int while axis is a tuple of ints, then the same value is used for all given axes.</li>
<li><code>axis::Shape or None, optional, default=None</code>: Axis or axes along which elements are shifted. By default, the array is flattenedbefore shifting, after which the original shape is restored.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_rot90-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_rot90-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_rot90</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_rot90(data, k, axes)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input ndarray</li>
<li><code>k::int, optional, default='1'</code>: Number of times the array is rotated by 90 degrees.</li>
<li><code>axes::Shape or None, optional, default=None</code>:  The array is rotated in the plane defined by the axes. Axes must be different.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_rpower_scalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_rpower_scalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_rpower_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_rpower_scalar(data, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_rsubtract_scalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_rsubtract_scalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_rsubtract_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_rsubtract_scalar(data, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_rtrue_divide_scalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_rtrue_divide_scalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_rtrue_divide_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_rtrue_divide_scalar(data, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_scatter_set_nd-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_scatter_set_nd-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_scatter_set_nd</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_scatter_set_nd(lhs, rhs, indices, shape)
</code></pre>

<p><em>npi</em>scatter<em>set</em>nd is an alias of <em>scatter</em>set_nd.</p>
<p>This operator has the same functionality as scatter_nd except that it does not reset the elements not indexed by the input index <code>NDArray</code> in the input data <code>NDArray</code>. output should be explicitly given and be the same as lhs.</p>
<p>.. note:: This operator is for internal use only.</p>
<p>Examples::</p>
<p>data = [2, 3, 0]   indices = [[1, 1, 0], [0, 1, 0]]   out = [[1, 1], [1, 1]]   <em>scatter</em>set_nd(lhs=out, rhs=data, indices=indices, out=out)   out = [[0, 1], [2, 3]]</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: value to assign</li>
<li><code>indices::NDArray-or-SymbolicNode</code>: indices</li>
<li><code>shape::Shape(tuple), required</code>: Shape of output.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L370' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_share_memory-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_share_memory-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_share_memory</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_share_memory(a, b)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>a::NDArray-or-SymbolicNode</code>: First input</li>
<li><code>b::NDArray-or-SymbolicNode</code>: Second input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_shuffle-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_shuffle-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_shuffle</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_shuffle(data)
</code></pre>

<p><em>npi</em>shuffle is an alias of _shuffle.</p>
<p>Randomly shuffle the elements.</p>
<p>This shuffles the array along the first axis. The order of the elements in each subarray does not change. For example, if a 2D array is given, the order of the rows randomly changes, but the order of the elements in each row does not change.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Data to be shuffled.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L355' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_sign-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_sign-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_sign</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_sign(x)
</code></pre>

<p>Returns an element-wise indication of the sign of a number. The sign function returns -1 if x &lt; 0, 0 if x==0, 1 if x &gt; 0. Example::    sign([-2, 0, 3]) = [-1, 0, 1]</p>
<p>Defined in src/operator/numpy/np<em>elemwise</em>unary<em>op</em>basic.cc:L148</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>x::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L353' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_sin-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_sin-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_sin</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_sin(x)
</code></pre>

<p>Trigonometric sine, element-wise. .. math::    sin([0, \pi/4, \pi/2]) = [0, 0.707, 1]</p>
<p>Defined in src/operator/numpy/np<em>elemwise</em>unary<em>op</em>basic.cc:L320</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>x::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L352' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_sinh-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_sinh-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_sinh</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_sinh(x)
</code></pre>

<p>Returns the hyperbolic sine of the input array, computed element-wise. .. math::    sinh(x) = 0.5\times(exp(x) - exp(-x))</p>
<p>Defined in src/operator/numpy/np<em>elemwise</em>unary<em>op</em>basic.cc:L387</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>x::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L352' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_slice-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_slice-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_slice</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_slice(data, begin, end, step)
</code></pre>

<p><em>npi</em>slice is an alias of slice.</p>
<p>Slices a region of the array. .. note:: $crop$ is deprecated. Use $slice$ instead. This function returns a sliced array between the indices given by <code>begin</code> and <code>end</code> with the corresponding <code>step</code>. For an input array of $shape=(d_0, d_1, ..., d_n-1)$, slice operation with $begin=(b_0, b_1...b_m-1)$, $end=(e_0, e_1, ..., e_m-1)$, and $step=(s_0, s_1, ..., s_m-1)$, where m &lt;= n, results in an array with the shape $(|e_0-b_0|/|s_0|, ..., |e_m-1-b_m-1|/|s_m-1|, d_m, ..., d_n-1)$. The resulting array's <em>k</em>-th dimension contains elements from the <em>k</em>-th dimension of the input array starting from index $b_k$ (inclusive) with step $s_k$ until reaching $e_k$ (exclusive). If the <em>k</em>-th elements are <code>None</code> in the sequence of <code>begin</code>, <code>end</code>, and <code>step</code>, the following rule will be used to set default values. If <code>s_k</code> is <code>None</code>, set <code>s_k=1</code>. If <code>s_k &gt; 0</code>, set <code>b_k=0</code>, <code>e_k=d_k</code>; else, set <code>b_k=d_k-1</code>, <code>e_k=-1</code>. The storage type of $slice$ output depends on storage types of inputs</p>
<ul>
<li>slice(csr) = csr</li>
<li>otherwise, $slice$ generates output with default storage</li>
</ul>
<p>.. note:: When input data storage type is csr, it only supports    step=(), or step=(None,), or step=(1,) to generate a csr output.    For other step parameter values, it falls back to slicing    a dense tensor. Example::   x = [[  1.,   2.,   3.,   4.],        [  5.,   6.,   7.,   8.],        [  9.,  10.,  11.,  12.]]   slice(x, begin=(0,1), end=(2,4)) = [[ 2.,  3.,  4.],                                      [ 6.,  7.,  8.]]   slice(x, begin=(None, 0), end=(None, 3), step=(-1, 2)) = [[9., 11.],                                                             [5.,  7.],                                                             [1.,  3.]]</p>
<p>Defined in src/operator/tensor/matrix_op.cc:L482</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Source input</li>
<li><code>begin::Shape(tuple), required</code>: starting indices for the slice operation, supports negative indices.</li>
<li><code>end::Shape(tuple), required</code>: ending indices for the slice operation, supports negative indices.</li>
<li><code>step::Shape(tuple), optional, default=[]</code>: step for the slice operation, supports negative values.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L390' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_slice_assign-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_slice_assign-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_slice_assign</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_slice_assign(lhs, rhs, begin, end, step)
</code></pre>

<p><em>npi</em>slice<em>assign is an alias of _slice</em>assign.</p>
<p>Assign the rhs to a cropped subset of lhs.</p>
<p><strong>Requirements</strong></p>
<ul>
<li>output should be explicitly given and be the same as lhs.</li>
<li>lhs and rhs are of the same data type, and on the same device.</li>
</ul>
<p>From:src/operator/tensor/matrix_op.cc:515</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: Source input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: value to assign</li>
<li><code>begin::Shape(tuple), required</code>: starting indices for the slice operation, supports negative indices.</li>
<li><code>end::Shape(tuple), required</code>: ending indices for the slice operation, supports negative indices.</li>
<li><code>step::Shape(tuple), optional, default=[]</code>: step for the slice operation, supports negative values.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L365' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_slice_assign_scalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_slice_assign_scalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_slice_assign_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_slice_assign_scalar(data, scalar, begin, end, step)
</code></pre>

<p><em>npi</em>slice<em>assign</em>scalar is an alias of <em>slice</em>assign_scalar.</p>
<p>(Assign the scalar to a cropped subset of the input.</p>
<p><strong>Requirements</strong></p>
<ul>
<li>output should be explicitly given and be the same as input</li>
</ul>
<p>)</p>
<p>From:src/operator/tensor/matrix_op.cc:541</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Source input</li>
<li><code>scalar::double, optional, default=0</code>: The scalar value for assignment.</li>
<li><code>begin::Shape(tuple), required</code>: starting indices for the slice operation, supports negative indices.</li>
<li><code>end::Shape(tuple), required</code>: ending indices for the slice operation, supports negative indices.</li>
<li><code>step::Shape(tuple), optional, default=[]</code>: step for the slice operation, supports negative values.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L364' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_slogdet-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_slogdet-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_slogdet</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_slogdet(A)
</code></pre>

<p><em>npi</em>slogdet is an alias of <em>linalg</em>slogdet.</p>
<p>Compute the sign and log of the determinant of a matrix. Input is a tensor <em>A</em> of dimension <em>n &gt;= 2</em>.</p>
<p>If <em>n=2</em>, <em>A</em> is a square matrix. We compute:</p>
<p><em>sign</em> = <em>sign(det(A))</em>   <em>logabsdet</em> = <em>log(abs(det(A)))</em></p>
<p>If <em>n&gt;2</em>, <em>slogdet</em> is performed separately on the trailing two dimensions for all inputs (batch mode).</p>
<p>.. note:: The operator supports float32 and float64 data types only. .. note:: The gradient is not properly defined on sign, so the gradient of           it is not backwarded. .. note:: No gradient is backwarded when A is non-invertible. Please see           the docs of operator det for detail.</p>
<p>Examples::</p>
<p>Single matrix signed log determinant    A = [[2., 3.], [1., 4.]]    sign, logabsdet = slogdet(A)    sign = [1.]    logabsdet = [1.609438]</p>
<p>Batch matrix signed log determinant    A = [[[2., 3.], [1., 4.]],         [[1., 2.], [2., 4.]],         [[1., 2.], [4., 3.]]]    sign, logabsdet = slogdet(A)    sign = [1., 0., -1.]    logabsdet = [1.609438, -inf, 1.609438]</p>
<p>Defined in src/operator/tensor/la_op.cc:L1034</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>A::NDArray-or-SymbolicNode</code>: Tensor of square matrix</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L383' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_solve-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_solve-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_solve</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_solve(A, B)
</code></pre>

<p>Defined in src/operator/numpy/linalg/np_solve.cc:L89</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>A::NDArray-or-SymbolicNode</code>: Tensor of square matrix</li>
<li><code>B::NDArray-or-SymbolicNode</code>: Tensor of right side vector</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_sort-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_sort-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_sort</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_sort(data, axis, is_ascend)
</code></pre>

<p><em>npi</em>sort is an alias of sort.</p>
<p>Returns a sorted copy of an input array along the given axis.</p>
<p>Examples::</p>
<p>x = [[ 1, 4],        [ 3, 1]]</p>
<p>// sorts along the last axis   sort(x) = [[ 1.,  4.],              [ 1.,  3.]]</p>
<p>// flattens and then sorts   sort(x, axis=None) = [ 1.,  1.,  3.,  4.]</p>
<p>// sorts along the first axis   sort(x, axis=0) = [[ 1.,  1.],                      [ 3.,  4.]]</p>
<p>// in a descend order   sort(x, is_ascend=0) = [[ 4.,  1.],                           [ 3.,  1.]]</p>
<p>Defined in src/operator/tensor/ordering_op.cc:L133</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array</li>
<li><code>axis::int or None, optional, default='-1'</code>: Axis along which to choose sort the input tensor. If not given, the flattened array is used. Default is -1.</li>
<li><code>is_ascend::boolean, optional, default=1</code>: Whether to sort in ascending or descending order.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L377' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_split-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_split-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_split</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_split(data, indices, axis, squeeze_axis, sections)
</code></pre>

<p><em>npi</em>split is an alias of <em>split</em>v2.</p>
<p>Splits an array along a particular axis into multiple sub-arrays. Example::    x  = [[[ 1.]           [ 2.]]          [[ 3.]           [ 4.]]          [[ 5.]           [ 6.]]]    x.shape = (3, 2, 1)    y = split<em>v2(x, axis=1, indices</em>or<em>sections=2) // a list of 2 arrays with shape (3, 1, 1)    y = [[[ 1.]]         [[ 3.]]         [[ 5.]]]        [[[ 2.]]         [[ 4.]]         [[ 6.]]]    y[0].shape = (3, 1, 1)    z = split</em>v2(x, axis=0, indices<em>or</em>sections=3) // a list of 3 arrays with shape (1, 2, 1)    z = [[[ 1.]          [ 2.]]]        [[[ 3.]          [ 4.]]]        [[[ 5.]          [ 6.]]]    z[0].shape = (1, 2, 1)    w = split<em>v2(x, axis=0, indices</em>or<em>sections=(1,)) // a list of 2 arrays with shape [(1, 2, 1), (2, 2, 1)]    w = [[[ 1.]          [ 2.]]]        [[[3.]          [4.]]         [[5.]          [6.]]]   w[0].shape = (1, 2, 1)   w[1].shape = (2, 2, 1) <code>squeeze*axis=True</code>removes the axis with length 1 from the shapes of the output arrays. <strong>Note</strong> that setting<code>squeeze*axis</code>to<code>1</code>removes axis with length 1 only along the<code>axis</code>which it is split. Also<code>squeeze*axis</code>can be set to true only if<code>input.shape[axis] == indices_or_sections</code>. Example::    z = split</em>v2(x, axis=0, indices<em>or</em>sections=3, squeeze*axis=1) // a list of 3 arrays with shape (2, 1)    z = [[ 1.]         [ 2.]]        [[ 3.]         [ 4.]]        [[ 5.]         [ 6.]]    z[0].shape = (2, 1)</p>
<p>Defined in src/operator/tensor/matrix_op.cc:L1088</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input</li>
<li><code>indices::Shape(tuple), required</code>: Indices of splits. The elements should denote the boundaries of at which split is performed along the <code>axis</code>.</li>
<li><code>axis::int, optional, default='1'</code>: Axis along which to split.</li>
<li><code>squeeze_axis::boolean, optional, default=0</code>: If true, Removes the axis with length 1 from the shapes of the output arrays. <strong>Note</strong> that setting <code>squeeze_axis</code> to $true$ removes axis with length 1 only along the <code>axis</code> which it is split. Also <code>squeeze_axis</code> can be set to $true$ only if $input.shape[axis] == num_outputs$.</li>
<li><code>sections::int, optional, default='0'</code>: Number of sections if equally splitted. Default to 0 which means split by indices.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L406' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_sqrt-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_sqrt-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_sqrt</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_sqrt(x)
</code></pre>

<p>Return the non-negative square-root of an array, element-wise. Example::    sqrt([4, 9, 16]) = [2, 3, 4]</p>
<p>Defined in src/operator/numpy/np<em>elemwise</em>unary<em>op</em>basic.cc:L224</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>x::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L352' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_square-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_square-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_square</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_square(x)
</code></pre>

<p>Return the element-wise square of the input. Example::    square([2, 3, 4]) = [4, 9, 16]</p>
<p>Defined in src/operator/numpy/np<em>elemwise</em>unary<em>op</em>basic.cc:L216</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>x::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L352' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_stack-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_stack-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_stack</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_stack(data, axis, num_args)
</code></pre>

<p><strong>Note</strong>: <em>npi</em>stack takes variable number of positional inputs. So instead of calling as <em>npi</em>stack([x, y, z], num<em>args=3), one should call via _npi</em>stack(x, y, z), and num_args will be determined automatically.</p>
<p>Join a sequence of arrays along a new axis.</p>
<p>The axis parameter specifies the index of the new axis in the dimensions of the result. For example, if axis=0 it will be the first dimension and if axis=-1 it will be the last dimension.</p>
<p>Examples::</p>
<p>x = [1, 2]   y = [3, 4]</p>
<p>stack(x, y) = [[1, 2],                  [3, 4]]   stack(x, y, axis=1) = [[1, 3],                          [2, 4]]</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode[]</code>: List of arrays to stack</li>
<li><code>axis::int, optional, default='0'</code>: The axis in the result array along which the input arrays are stacked.</li>
<li><code>num_args::int, required</code>: Number of inputs to be stacked.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L368' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_std-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_std-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_std</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_std(a, axis, dtype, ddof, keepdims)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>a::NDArray-or-SymbolicNode</code>: The input</li>
<li><code>axis::Shape or None, optional, default=None</code>: Axis or axes along which a sum is performed. The default, axis=None, will sum all of the elements of the input array. If axis is negative it counts from the last to the first axis.</li>
<li><code>dtype::{None, 'float16', 'float32', 'float64', 'int32', 'int64', 'int8'},optional, default='None'</code>: The type of the returned array and of the accumulator in which the elements are summed. The dtype of a is used by default unless a has an integer dtype of less precision than the default platform integer. In that case, if a is signed then the platform integer is used while if a is unsigned then an unsigned integer of the same precision as the platform integer is used.</li>
<li><code>ddof::int, optional, default='0'</code>: Starting value for the sum.</li>
<li><code>keepdims::boolean, optional, default=0</code>: If this is set to <code>True</code>, the reduced axes are left in the result as dimension with size one.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L355' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_subtract-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_subtract-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_subtract</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_subtract(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: First input to the function</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: Second input to the function</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_subtract_scalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_subtract_scalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_subtract_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_subtract_scalar(data, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_svd-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_svd-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_svd</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_svd(A)
</code></pre>

<p>Defined in src/operator/numpy/linalg/np_gesvd.cc:L93</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>A::NDArray-or-SymbolicNode</code>: Input matrices to be factorized</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_swapaxes-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_swapaxes-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_swapaxes</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_swapaxes(data, dim1, dim2)
</code></pre>

<p><em>npi</em>swapaxes is an alias of SwapAxis.</p>
<p>Interchanges two axes of an array.</p>
<p>Examples::</p>
<p>x = [[1, 2, 3]])   swapaxes(x, 0, 1) = [[ 1],                        [ 2],                        [ 3]]</p>
<p>x = [[[ 0, 1],         [ 2, 3]],        [[ 4, 5],         [ 6, 7]]]  // (2,2,2) array</p>
<p>swapaxes(x, 0, 2) = [[[ 0, 4],                        [ 2, 6]],                       [[ 1, 5],                        [ 3, 7]]]</p>
<p>Defined in src/operator/swapaxis.cc:L70</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input array.</li>
<li><code>dim1::int, optional, default='0'</code>: the first axis to be swapped.</li>
<li><code>dim2::int, optional, default='0'</code>: the second axis to be swapped.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L373' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_take-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_take-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_take</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_take(a, indices, axis, mode)
</code></pre>

<p><em>npi</em>take is an alias of take.</p>
<p>Takes elements from an input array along the given axis.</p>
<p>This function slices the input array along a particular axis with the provided indices.</p>
<p>Given data tensor of rank r &gt;= 1, and indices tensor of rank q, gather entries of the axis dimension of data (by default outer-most one as axis=0) indexed by indices, and concatenates them in an output tensor of rank q + (r - 1).</p>
<p>Examples::</p>
<p>x = [4.  5.  6.]</p>
<p>// Trivial case, take the second element along the first axis.</p>
<p>take(x, [1]) = [ 5. ]</p>
<p>// The other trivial case, axis=-1, take the third element along the first axis</p>
<p>take(x, [3], axis=-1, mode='clip') = [ 6. ]</p>
<p>x = [[ 1.,  2.],        [ 3.,  4.],        [ 5.,  6.]]</p>
<p>// In this case we will get rows 0 and 1, then 1 and 2. Along axis 0</p>
<p>take(x, [[0,1],[1,2]]) = [[[ 1.,  2.],                              [ 3.,  4.]],</p>
<pre><code>                        [[ 3.,  4.],
                         [ 5.,  6.]]]
</code></pre>

<p>// In this case we will get rows 0 and 1, then 1 and 2 (calculated by wrapping around).   // Along axis 1</p>
<p>take(x, [[0, 3], [-1, -2]], axis=1, mode='wrap') = [[[ 1.  2.]                                                        [ 2.  1.]]</p>
<pre><code>                                                  [[ 3.  4.]
                                                   [ 4.  3.]]

                                                  [[ 5.  6.]
                                                   [ 6.  5.]]]
</code></pre>

<p>The storage type of $take$ output depends upon the input storage type:</p>
<ul>
<li>take(default, default) = default</li>
<li>take(csr, default, axis=0) = csr</li>
</ul>
<p>Defined in src/operator/tensor/indexing_op.cc:L782</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>a::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>indices::NDArray-or-SymbolicNode</code>: The indices of the values to be extracted.</li>
<li><code>axis::int, optional, default='0'</code>: The axis of input array to be taken.For input tensor of rank r, it could be in the range of [-r, r-1]</li>
<li><code>mode::{'clip', 'raise', 'wrap'},optional, default='clip'</code>: Specify how out-of-bound indices bahave. Default is "clip". "clip" means clip to the range. So, if all indices mentioned are too large, they are replaced by the index that addresses the last element along an axis. "wrap" means to wrap around. "raise" means to raise an error when index out of range.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L406' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_tan-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_tan-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_tan</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_tan(x)
</code></pre>

<p>Computes the element-wise tangent of the input array. .. math::    tan([0, \pi/4, \pi/2]) = [0, 1, -inf]</p>
<p>Defined in src/operator/numpy/np<em>elemwise</em>unary<em>op</em>basic.cc:L336</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>x::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L352' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_tanh-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_tanh-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_tanh</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_tanh(x)
</code></pre>

<p>Returns the hyperbolic tangent of the input array, computed element-wise. .. math::    tanh(x) = sinh(x) / cosh(x)</p>
<p>Defined in src/operator/numpy/np<em>elemwise</em>unary<em>op</em>basic.cc:L403</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>x::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L352' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_tensordot-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_tensordot-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_tensordot</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_tensordot(a, b, a_axes_summed, b_axes_summed)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>a::NDArray-or-SymbolicNode</code>: First input</li>
<li><code>b::NDArray-or-SymbolicNode</code>: Second input</li>
<li><code>a_axes_summed::Shape(tuple), required</code>:</li>
<li><code>b_axes_summed::Shape(tuple), required</code>:</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L353' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_tensordot_int_axes-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_tensordot_int_axes-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_tensordot_int_axes</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_tensordot_int_axes(a, b, axes)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>a::NDArray-or-SymbolicNode</code>: First input</li>
<li><code>b::NDArray-or-SymbolicNode</code>: Second input</li>
<li><code>axes::int, required</code>:</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_tensorinv-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_tensorinv-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_tensorinv</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_tensorinv(a, ind)
</code></pre>

<p>Defined in src/operator/numpy/linalg/np_tensorinv.cc:L102</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>a::NDArray-or-SymbolicNode</code>: First input</li>
<li><code>ind::int, optional, default='2'</code>: Number of first indices that are involved in the inverse sum.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_tensorsolve-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_tensorsolve-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_tensorsolve</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_tensorsolve(a, b, a_axes)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>a::NDArray-or-SymbolicNode</code>: First input</li>
<li><code>b::NDArray-or-SymbolicNode</code>: Second input</li>
<li><code>a_axes::Shape(tuple), optional, default=[]</code>: Tuple of ints, optional. Axes in a to reorder to the right, before inversion.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_tile-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_tile-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_tile</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_tile(data, reps)
</code></pre>

<p><em>npi</em>tile is an alias of tile.</p>
<p>Repeats the whole array multiple times. If $reps$ has length <em>d</em>, and input array has dimension of <em>n</em>. There are three cases:</p>
<ul>
<li><strong>n=d</strong>. Repeat <em>i</em>-th dimension of the input by $reps[i]$ times::   x = [[1, 2],        [3, 4]]   tile(x, reps=(2,3)) = [[ 1.,  2.,  1.,  2.,  1.,  2.],                          [ 3.,  4.,  3.,  4.,  3.,  4.],                          [ 1.,  2.,  1.,  2.,  1.,  2.],                          [ 3.,  4.,  3.,  4.,  3.,  4.]]</li>
<li><strong>n&gt;d</strong>. $reps$ is promoted to length <em>n</em> by pre-pending 1's to it. Thus for an input shape $(2,3)$, $repos=(2,)$ is treated as $(1,2)$::   tile(x, reps=(2,)) = [[ 1.,  2.,  1.,  2.],                         [ 3.,  4.,  3.,  4.]]</li>
<li><strong>n&lt;d</strong>. The input is promoted to be d-dimensional by prepending new axes. So a shape $(2,2)$ array is promoted to $(1,2,2)$ for 3-D replication::   tile(x, reps=(2,2,3)) = [[[ 1.,  2.,  1.,  2.,  1.,  2.],                             [ 3.,  4.,  3.,  4.,  3.,  4.],                             [ 1.,  2.,  1.,  2.,  1.,  2.],                             [ 3.,  4.,  3.,  4.,  3.,  4.]],                            [[ 1.,  2.,  1.,  2.,  1.,  2.],                             [ 3.,  4.,  3.,  4.,  3.,  4.],                             [ 1.,  2.,  1.,  2.,  1.,  2.],                             [ 3.,  4.,  3.,  4.,  3.,  4.]]]</li>
</ul>
<p>Defined in src/operator/tensor/matrix_op.cc:L796</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data array</li>
<li><code>reps::Shape(tuple), required</code>: The number of times for repeating the tensor a. Each dim size of reps must be a positive integer. If reps has length d, the result will have dimension of max(d, a.ndim); If a.ndim &lt; d, a is promoted to be d-dimensional by prepending new axes. If a.ndim &gt; d, reps is promoted to a.ndim by pre-pending 1's to it.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L377' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_tril-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_tril-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_tril</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_tril(data, k)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input ndarray</li>
<li><code>k::int, optional, default='0'</code>: Diagonal in question. The default is 0. Use k&gt;0 for diagonals above the main diagonal, and k&lt;0 for diagonals below the main diagonal. If input has shape (S0 S1) k must be between -S0 and S1</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_true_divide-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_true_divide-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_true_divide</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_true_divide(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: Dividend array</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: Divisor array</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_true_divide_scalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_true_divide_scalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_true_divide_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_true_divide_scalar(data, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_trunc-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_trunc-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_trunc</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_trunc(x)
</code></pre>

<p>Return the truncated value of the input, element-wise. The truncated value of the scalar x is the nearest integer i which is closer to zero than x is. In short, the fractional part of the signed number x is discarded. Example::    trunc([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0]) = [-1., -1., -0.,  0.,  1.,  1.,  2.]</p>
<p>Defined in src/operator/numpy/np<em>elemwise</em>unary<em>op</em>basic.cc:L198</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>x::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L354' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_uniform-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_uniform-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_uniform</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_uniform(input1, input2, low, high, size, ctx, dtype)
</code></pre>

<p>numpy behavior uniform</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>input1::NDArray-or-SymbolicNode</code>: Source input</li>
<li><code>input2::NDArray-or-SymbolicNode</code>: Source input</li>
<li><code>low::float or None, required</code>:</li>
<li><code>high::float or None, required</code>:</li>
<li><code>size::Shape or None, optional, default=None</code>: Output shape. If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn. Default is None, in which case a single value is returned.</li>
<li><code>ctx::string, optional, default='cpu'</code>: Context of output, in format <a href="n">cpu|gpu|cpu_pinned</a>. Only used for imperative calls.</li>
<li><code>dtype::{'float16', 'float32', 'float64'},optional, default='float32'</code>: DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L359' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_uniform_n-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_uniform_n-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_uniform_n</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_uniform_n(input1, input2, low, high, size, ctx, dtype)
</code></pre>

<p>numpy behavior uniform</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>input1::NDArray-or-SymbolicNode</code>: Source input</li>
<li><code>input2::NDArray-or-SymbolicNode</code>: Source input</li>
<li><code>low::float or None, required</code>:</li>
<li><code>high::float or None, required</code>:</li>
<li><code>size::Shape or None, optional, default=None</code>: Output shape. If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn. Default is None, in which case a single value is returned.</li>
<li><code>ctx::string, optional, default='cpu'</code>: Context of output, in format <a href="n">cpu|gpu|cpu_pinned</a>. Only used for imperative calls.</li>
<li><code>dtype::{'float16', 'float32', 'float64'},optional, default='float32'</code>: DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L359' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_unique-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_unique-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_unique</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_unique(data, return_index, return_inverse, return_counts, axis)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array</li>
<li><code>return_index::boolean, optional, default=0</code>: If true, return the indices of the input.</li>
<li><code>return_inverse::boolean, optional, default=0</code>: If true, return the indices of the input.</li>
<li><code>return_counts::boolean, optional, default=0</code>: If true, return the number of times each unique item appears in input.</li>
<li><code>axis::int or None, optional, default='None'</code>: An integer that represents the axis to operator on.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L355' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_var-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_var-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_var</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_var(a, axis, dtype, ddof, keepdims)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>a::NDArray-or-SymbolicNode</code>: The input</li>
<li><code>axis::Shape or None, optional, default=None</code>: Axis or axes along which a sum is performed. The default, axis=None, will sum all of the elements of the input array. If axis is negative it counts from the last to the first axis.</li>
<li><code>dtype::{None, 'float16', 'float32', 'float64', 'int32', 'int64', 'int8'},optional, default='None'</code>: The type of the returned array and of the accumulator in which the elements are summed. The dtype of a is used by default unless a has an integer dtype of less precision than the default platform integer. In that case, if a is signed then the platform integer is used while if a is unsigned then an unsigned integer of the same precision as the platform integer is used.</li>
<li><code>ddof::int, optional, default='0'</code>: Starting value for the sum.</li>
<li><code>keepdims::boolean, optional, default=0</code>: If this is set to <code>True</code>, the reduced axes are left in the result as dimension with size one.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L355' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_vstack-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_vstack-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_vstack</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_vstack(data, num_args)
</code></pre>

<p><strong>Note</strong>: <em>npi</em>vstack takes variable number of positional inputs. So instead of calling as <em>npi</em>vstack([x, y, z], num<em>args=3), one should call via _npi</em>vstack(x, y, z), and num_args will be determined automatically.</p>
<p>Defined in src/operator/numpy/np<em>matrix</em>op.cc:L1008</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode[]</code>: List of arrays to vstack</li>
<li><code>num_args::int, required</code>: Number of inputs to be vstacked.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L353' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_weibull-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_weibull-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_weibull</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_weibull(input1, a, size, ctx)
</code></pre>

<p>Numpy behavior Weibull</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>input1::NDArray-or-SymbolicNode</code>: Source input</li>
<li><code>a::float or None, optional, default=None</code>:</li>
<li><code>size::Shape or None, optional, default=None</code>: Output shape. If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn. Default is None, in which case a single value is returned.</li>
<li><code>ctx::string, optional, default='cpu'</code>: Context of output, in format <a href="n">cpu|gpu|cpu_pinned</a>. Only used for imperative calls.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L353' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_where-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_where-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_where</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_where(condition, x, y)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>condition::NDArray-or-SymbolicNode</code>: condition array</li>
<li><code>x::NDArray-or-SymbolicNode</code>: input x</li>
<li><code>y::NDArray-or-SymbolicNode</code>: input y</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_where_lscalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_where_lscalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_where_lscalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_where_lscalar(condition, x, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>condition::NDArray-or-SymbolicNode</code>: condition array</li>
<li><code>x::NDArray-or-SymbolicNode</code>: input x</li>
<li><code>scalar::double, optional, default=0</code>: The scalar value of x/y.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_where_rscalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_where_rscalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_where_rscalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_where_rscalar(condition, y, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>condition::NDArray-or-SymbolicNode</code>: condition array</li>
<li><code>y::NDArray-or-SymbolicNode</code>: input y</li>
<li><code>scalar::double, optional, default=0</code>: The scalar value of x/y.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_where_scalar2-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_where_scalar2-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_where_scalar2</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_where_scalar2(condition, x, y)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>condition::NDArray-or-SymbolicNode</code>: condition array</li>
<li><code>x::double, optional, default=0</code>: The scalar value of x.</li>
<li><code>y::double, optional, default=0</code>: The scalar value of y.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npi_zeros-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npi_zeros-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npi_zeros</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npi_zeros(shape, ctx, dtype)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>shape::Shape(tuple), optional, default=[]</code>: The shape of the output</li>
<li><code>ctx::string, optional, default=''</code>: Context of output, in format <a href="n">cpu|gpu|cpu_pinned</a>.Only used for imperative calls.</li>
<li><code>dtype::{'bfloat16', 'bool', 'float16', 'float32', 'float64', 'int32', 'int64', 'int8', 'uint8'},optional, default='float32'</code>: Target data type.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npx__image_adjust_lighting-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npx__image_adjust_lighting-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npx__image_adjust_lighting</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npx__image_adjust_lighting(data, alpha)
</code></pre>

<p><em>npx__image</em>adjust<em>lighting is an alias of _image</em>adjust_lighting.</p>
<p>Adjust the lighting level of the input. Follow the AlexNet style.</p>
<p>Defined in src/operator/image/image_random.cc:L254</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input.</li>
<li><code>alpha::tuple of &lt;float&gt;, required</code>: The lighting alphas for the R, G, B channels.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L353' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npx__image_crop-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npx__image_crop-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npx__image_crop</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npx__image_crop(data, x, y, width, height)
</code></pre>

<p><em>npx__image</em>crop is an alias of <em>image</em>crop.</p>
<p>Crop an image NDArray of shape (H x W x C) or (N x H x W x C)  to the given size. Example:     .. code-block:: python         image = mx.nd.random.uniform(0, 255, (4, 2, 3)).astype(dtype=np.uint8)         mx.nd.image.crop(image, 1, 1, 2, 2)             [[[144  34   4]               [ 82 157  38]]</p>
<pre><code>         [[156 111 230]
          [177  25  15]]]
        &lt;NDArray 2x2x3 @cpu(0)&gt;
    image = mx.nd.random.uniform(0, 255, (2, 4, 2, 3)).astype(dtype=np.uint8)
    mx.nd.image.crop(image, 1, 1, 2, 2)            
        [[[[ 35 198  50]
           [242  94 168]]

          [[223 119 129]
           [249  14 154]]]


          [[[137 215 106]
            [ 79 174 133]]

           [[116 142 109]
            [ 35 239  50]]]]
        &lt;NDArray 2x2x2x3 @cpu(0)&gt;
</code></pre>

<p>Defined in src/operator/image/crop.cc:L66</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input.</li>
<li><code>x::int, required</code>: Left boundary of the cropping area.</li>
<li><code>y::int, required</code>: Top boundary of the cropping area.</li>
<li><code>width::int, required</code>: Width of the cropping area.</li>
<li><code>height::int, required</code>: Height of the cropping area.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L386' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npx__image_flip_left_right-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npx__image_flip_left_right-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npx__image_flip_left_right</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npx__image_flip_left_right(data)
</code></pre>

<p><em>npx__image</em>flip<em>left</em>right is an alias of <em>image</em>flip<em>left</em>right.</p>
<p>Defined in src/operator/image/image_random.cc:L195</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npx__image_flip_top_bottom-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npx__image_flip_top_bottom-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npx__image_flip_top_bottom</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npx__image_flip_top_bottom(data)
</code></pre>

<p><em>npx__image</em>flip<em>top</em>bottom is an alias of <em>image</em>flip<em>top</em>bottom.</p>
<p>Defined in src/operator/image/image_random.cc:L205</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npx__image_normalize-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npx__image_normalize-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npx__image_normalize</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npx__image_normalize(data, mean, std)
</code></pre>

<p><em>npx__image</em>normalize is an alias of <em>image</em>normalize.</p>
<p>Normalize an tensor of shape (C x H x W) or (N x C x H x W) with mean and     standard deviation.</p>
<pre><code>Given mean `(m1, ..., mn)` and std `(s\ :sub:`1`\ , ..., s\ :sub:`n`)` for `n` channels,
this transform normalizes each channel of the input tensor with:
</code></pre>

<p>.. math::</p>
<pre><code>    output[i] = (input[i] - m\ :sub:`i`\ ) / s\ :sub:`i`

If mean or std is scalar, the same value will be applied to all channels.

Default value for mean is 0.0 and stand deviation is 1.0.
</code></pre>

<p>Example:</p>
<pre><code>.. code-block:: python
    image = mx.nd.random.uniform(0, 1, (3, 4, 2))
    normalize(image, mean=(0, 1, 2), std=(3, 2, 1))
        [[[ 0.18293785  0.19761486]
          [ 0.23839645  0.28142193]
          [ 0.20092112  0.28598186]
          [ 0.18162774  0.28241724]]
         [[-0.2881726  -0.18821815]
          [-0.17705294 -0.30780914]
          [-0.2812064  -0.3512327 ]
          [-0.05411351 -0.4716435 ]]
         [[-1.0363373  -1.7273437 ]
          [-1.6165586  -1.5223348 ]
          [-1.208275   -1.1878313 ]
          [-1.4711051  -1.5200229 ]]]
        &lt;NDArray 3x4x2 @cpu(0)&gt;

    image = mx.nd.random.uniform(0, 1, (2, 3, 4, 2))
    normalize(image, mean=(0, 1, 2), std=(3, 2, 1))
        [[[[ 0.18934818  0.13092826]
           [ 0.3085322   0.27869293]
           [ 0.02367868  0.11246539]
           [ 0.0290431   0.2160573 ]]
          [[-0.4898908  -0.31587923]
           [-0.08369008 -0.02142242]
           [-0.11092162 -0.42982462]
           [-0.06499392 -0.06495637]]
          [[-1.0213816  -1.526392  ]
           [-1.2008414  -1.1990893 ]
           [-1.5385206  -1.4795225 ]
           [-1.2194707  -1.3211205 ]]]
         [[[ 0.03942481  0.24021089]
           [ 0.21330701  0.1940066 ]
           [ 0.04778443  0.17912441]
           [ 0.31488964  0.25287187]]
          [[-0.23907584 -0.4470462 ]
           [-0.29266903 -0.2631998 ]
           [-0.3677222  -0.40683383]
           [-0.11288315 -0.13154092]]
          [[-1.5438497  -1.7834496 ]
           [-1.431566   -1.8647819 ]
           [-1.9812102  -1.675859  ]
           [-1.3823645  -1.8503251 ]]]]
        &lt;NDArray 2x3x4x2 @cpu(0)&gt;
</code></pre>

<p>Defined in src/operator/image/image_random.cc:L167</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input ndarray</li>
<li><code>mean::tuple of &lt;float&gt;, optional, default=[0,0,0,0]</code>: Sequence of means for each channel. Default value is 0.</li>
<li><code>std::tuple of &lt;float&gt;, optional, default=[1,1,1,1]</code>: Sequence of standard deviations for each channel. Default value is 1.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L415' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npx__image_random_brightness-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npx__image_random_brightness-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npx__image_random_brightness</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npx__image_random_brightness(data, min_factor, max_factor)
</code></pre>

<p><em>npx__image</em>random<em>brightness is an alias of _image</em>random_brightness.</p>
<p>Defined in src/operator/image/image_random.cc:L215</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input.</li>
<li><code>min_factor::float, required</code>: Minimum factor.</li>
<li><code>max_factor::float, required</code>: Maximum factor.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L355' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npx__image_random_color_jitter-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npx__image_random_color_jitter-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npx__image_random_color_jitter</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npx__image_random_color_jitter(data, brightness, contrast, saturation, hue)
</code></pre>

<p><em>npx__image</em>random<em>color</em>jitter is an alias of <em>image</em>random<em>color</em>jitter.</p>
<p>Defined in src/operator/image/image_random.cc:L246</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input.</li>
<li><code>brightness::float, required</code>: How much to jitter brightness.</li>
<li><code>contrast::float, required</code>: How much to jitter contrast.</li>
<li><code>saturation::float, required</code>: How much to jitter saturation.</li>
<li><code>hue::float, required</code>: How much to jitter hue.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L359' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npx__image_random_contrast-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npx__image_random_contrast-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npx__image_random_contrast</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npx__image_random_contrast(data, min_factor, max_factor)
</code></pre>

<p><em>npx__image</em>random<em>contrast is an alias of _image</em>random_contrast.</p>
<p>Defined in src/operator/image/image_random.cc:L222</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input.</li>
<li><code>min_factor::float, required</code>: Minimum factor.</li>
<li><code>max_factor::float, required</code>: Maximum factor.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L355' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npx__image_random_flip_left_right-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npx__image_random_flip_left_right-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npx__image_random_flip_left_right</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npx__image_random_flip_left_right(data)
</code></pre>

<p><em>npx__image</em>random<em>flip</em>left<em>right is an alias of _image</em>random<em>flip</em>left_right.</p>
<p>Defined in src/operator/image/image_random.cc:L200</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npx__image_random_flip_top_bottom-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npx__image_random_flip_top_bottom-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npx__image_random_flip_top_bottom</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npx__image_random_flip_top_bottom(data)
</code></pre>

<p><em>npx__image</em>random<em>flip</em>top<em>bottom is an alias of _image</em>random<em>flip</em>top_bottom.</p>
<p>Defined in src/operator/image/image_random.cc:L210</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npx__image_random_hue-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npx__image_random_hue-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npx__image_random_hue</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npx__image_random_hue(data, min_factor, max_factor)
</code></pre>

<p><em>npx__image</em>random<em>hue is an alias of _image</em>random_hue.</p>
<p>Defined in src/operator/image/image_random.cc:L238</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input.</li>
<li><code>min_factor::float, required</code>: Minimum factor.</li>
<li><code>max_factor::float, required</code>: Maximum factor.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L355' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npx__image_random_lighting-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npx__image_random_lighting-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npx__image_random_lighting</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npx__image_random_lighting(data, alpha_std)
</code></pre>

<p><em>npx__image</em>random<em>lighting is an alias of _image</em>random_lighting.</p>
<p>Randomly add PCA noise. Follow the AlexNet style.</p>
<p>Defined in src/operator/image/image_random.cc:L262</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input.</li>
<li><code>alpha_std::float, optional, default=0.0500000007</code>: Level of the lighting noise.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L353' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npx__image_random_saturation-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npx__image_random_saturation-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npx__image_random_saturation</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npx__image_random_saturation(data, min_factor, max_factor)
</code></pre>

<p><em>npx__image</em>random<em>saturation is an alias of _image</em>random_saturation.</p>
<p>Defined in src/operator/image/image_random.cc:L230</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input.</li>
<li><code>min_factor::float, required</code>: Minimum factor.</li>
<li><code>max_factor::float, required</code>: Maximum factor.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L355' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npx__image_resize-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npx__image_resize-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npx__image_resize</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npx__image_resize(data, size, keep_ratio, interp)
</code></pre>

<p><em>npx__image</em>resize is an alias of <em>image</em>resize.</p>
<p>Resize an image NDArray of shape (H x W x C) or (N x H x W x C)  to the given size Example:     .. code-block:: python         image = mx.nd.random.uniform(0, 255, (4, 2, 3)).astype(dtype=np.uint8)         mx.nd.image.resize(image, (3, 3))             [[[124 111 197]               [158  80 155]               [193  50 112]]</p>
<pre><code>         [[110 100 113]
          [134 165 148]
          [157 231 182]]

         [[202 176 134]
          [174 191 149]
          [147 207 164]]]
        &lt;NDArray 3x3x3 @cpu(0)&gt;
    image = mx.nd.random.uniform(0, 255, (2, 4, 2, 3)).astype(dtype=np.uint8)
    mx.nd.image.resize(image, (2, 2))            
        [[[[ 59 133  80]
           [187 114 153]]

          [[ 38 142  39]
           [207 131 124]]]


          [[[117 125 136]
           [191 166 150]]

          [[129  63 113]
           [182 109  48]]]]
        &lt;NDArray 2x2x2x3 @cpu(0)&gt;
</code></pre>

<p>Defined in src/operator/image/resize.cc:L71</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input.</li>
<li><code>size::Shape(tuple), optional, default=[]</code>: Size of new image. Could be (width, height) or (size)</li>
<li><code>keep_ratio::boolean, optional, default=0</code>: Whether to resize the short edge or both edges to <code>size</code>, if size is give as an integer.</li>
<li><code>interp::int, optional, default='1'</code>: Interpolation method for resizing. By default uses bilinear interpolationOptions are INTER<em>NEAREST - a nearest-neighbor interpolationINTER</em>LINEAR - a bilinear interpolationINTER<em>AREA - resampling using pixel area relationINTER</em>CUBIC - a bicubic interpolation over 4x4 pixel neighborhoodINTER_LANCZOS4 - a Lanczos interpolation over 8x8 pixel neighborhoodNote that the GPU version only support bilinear interpolation(1)</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L390' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npx__image_to_tensor-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npx__image_to_tensor-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npx__image_to_tensor</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npx__image_to_tensor(data)
</code></pre>

<p><em>npx__image</em>to<em>tensor is an alias of _image</em>to_tensor.</p>
<p>Converts an image NDArray of shape (H x W x C) or (N x H x W x C)  with values in the range [0, 255] to a tensor NDArray of shape (C x H x W) or (N x C x H x W) with values in the range [0, 1]</p>
<p>Example:     .. code-block:: python         image = mx.nd.random.uniform(0, 255, (4, 2, 3)).astype(dtype=np.uint8)         to_tensor(image)             [[[ 0.85490197  0.72156864]               [ 0.09019608  0.74117649]               [ 0.61960787  0.92941177]               [ 0.96470588  0.1882353 ]]              [[ 0.6156863   0.73725492]               [ 0.46666667  0.98039216]               [ 0.44705883  0.45490196]               [ 0.01960784  0.8509804 ]]              [[ 0.39607844  0.03137255]               [ 0.72156864  0.52941179]               [ 0.16470589  0.7647059 ]               [ 0.05490196  0.70588237]]]              <NDArray 3x4x2 @cpu(0)></p>
<pre><code>    image = mx.nd.random.uniform(0, 255, (2, 4, 2, 3)).astype(dtype=np.uint8)
    to_tensor(image)
        [[[[0.11764706 0.5803922 ]
           [0.9411765  0.10588235]
           [0.2627451  0.73333335]
           [0.5647059  0.32156864]]
          [[0.7176471  0.14117648]
           [0.75686276 0.4117647 ]
           [0.18431373 0.45490196]
           [0.13333334 0.6156863 ]]
          [[0.6392157  0.5372549 ]
           [0.52156866 0.47058824]
           [0.77254903 0.21568628]
           [0.01568628 0.14901961]]]
         [[[0.6117647  0.38431373]
           [0.6784314  0.6117647 ]
           [0.69411767 0.96862745]
           [0.67058825 0.35686275]]
          [[0.21960784 0.9411765 ]
           [0.44705883 0.43529412]
           [0.09803922 0.6666667 ]
           [0.16862746 0.1254902 ]]
          [[0.6156863  0.9019608 ]
           [0.35686275 0.9019608 ]
           [0.05882353 0.6509804 ]
           [0.20784314 0.7490196 ]]]]
        &lt;NDArray 2x3x4x2 @cpu(0)&gt;
</code></pre>

<p>Defined in src/operator/image/image_random.cc:L92</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input ndarray</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L400' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npx_activation-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npx_activation-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npx_activation</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npx_activation(data, act_type)
</code></pre>

<p><em>npx</em>activation is an alias of Activation.</p>
<p>Applies an activation function element-wise to the input.</p>
<p>The following activation functions are supported:</p>
<ul>
<li><code>relu</code>: Rectified Linear Unit, :math:<code>y = max(x, 0)</code></li>
<li><code>sigmoid</code>: :math:<code>y = \frac{1}{1 + exp(-x)}</code></li>
<li><code>tanh</code>: Hyperbolic tangent, :math:<code>y = \frac{exp(x) - exp(-x)}{exp(x) + exp(-x)}</code></li>
<li><code>softrelu</code>: Soft ReLU, or SoftPlus, :math:<code>y = log(1 + exp(x))</code></li>
<li><code>softsign</code>: :math:<code>y = \frac{x}{1 + abs(x)}</code></li>
</ul>
<p>Defined in src/operator/nn/activation.cc:L165</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>act_type::{'relu', 'sigmoid', 'softrelu', 'softsign', 'tanh'}, required</code>: Activation function to be applied.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L363' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npx_arange_like-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npx_arange_like-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npx_arange_like</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npx_arange_like(data, start, step, repeat, ctx, axis)
</code></pre>

<p><em>npx</em>arange<em>like is an alias of _contrib</em>arange_like.</p>
<p>Return an array with evenly spaced values. If axis is not given, the output will  have the same shape as the input array. Otherwise, the output will be a 1-D array with size of  the specified axis in input shape.</p>
<p>Examples::</p>
<p>x = [[0.14883883 0.7772398  0.94865847 0.7225052 ]        [0.23729339 0.6112595  0.66538996 0.5132841 ]        [0.30822644 0.9912457  0.15502319 0.7043658 ]]        <NDArray 3x4 @cpu(0)></p>
<p>out = mx.nd.contrib.arange_like(x, start=0)</p>
<pre><code>[[ 0.  1.  2.  3.]
 [ 4.  5.  6.  7.]
 [ 8.  9. 10. 11.]]
 &lt;NDArray 3x4 @cpu(0)&gt;
</code></pre>

<p>out = mx.nd.contrib.arange_like(x, start=0, axis=-1)</p>
<pre><code>[0. 1. 2. 3.]
&lt;NDArray 4 @cpu(0)&gt;
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input</li>
<li><code>start::double, optional, default=0</code>: Start of interval. The interval includes this value. The default start value is 0.</li>
<li><code>step::double, optional, default=1</code>: Spacing between values.</li>
<li><code>repeat::int, optional, default='1'</code>: The repeating time of all elements. E.g repeat=3, the element a will be repeated three times –&gt; a, a, a.</li>
<li><code>ctx::string, optional, default=''</code>: Context of output, in format <a href="n">cpu|gpu|cpu_pinned</a>.Only used for imperative calls.</li>
<li><code>axis::int or None, optional, default='None'</code>: Arange elements according to the size of a certain axis of input array. The negative numbers are interpreted counting from the backward. If not provided, will arange elements according to the input shape.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L381' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npx_batch_dot-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npx_batch_dot-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npx_batch_dot</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npx_batch_dot(lhs, rhs, transpose_a, transpose_b, forward_stype)
</code></pre>

<p><em>npx</em>batch<em>dot is an alias of batch</em>dot.</p>
<p>Batchwise dot product.</p>
<p>$batch_dot$ is used to compute dot product of $x$ and $y$ when $x$ and $y$ are data in batch, namely N-D (N &gt;= 3) arrays in shape of <code>(B0, ..., B_i, :, :)</code>.</p>
<p>For example, given $x$ with shape <code>(B_0, ..., B_i, N, M)</code> and $y$ with shape <code>(B_0, ..., B_i, M, K)</code>, the result array will have shape <code>(B_0, ..., B_i, N, K)</code>, which is computed by::</p>
<p>batch<em>dot(x,y)[b</em>0, ..., b<em>i, :, :] = dot(x[b</em>0, ..., b<em>i, :, :], y[b</em>0, ..., b_i, :, :])</p>
<p>Defined in src/operator/tensor/dot.cc:L127</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: The first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: The second input</li>
<li><code>transpose_a::boolean, optional, default=0</code>: If true then transpose the first input before dot.</li>
<li><code>transpose_b::boolean, optional, default=0</code>: If true then transpose the second input before dot.</li>
<li><code>forward_stype::{None, 'csr', 'default', 'row_sparse'},optional, default='None'</code>: The desired storage type of the forward output given by user, if thecombination of input storage types and this hint does not matchany implemented ones, the dot operator will perform fallback operationand still produce an output of the desired storage type.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L370' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npx_batch_flatten-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npx_batch_flatten-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npx_batch_flatten</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npx_batch_flatten(data)
</code></pre>

<p><em>npx</em>batch_flatten is an alias of Flatten.</p>
<p>Flattens the input array into a 2-D array by collapsing the higher dimensions. .. note:: <code>Flatten</code> is deprecated. Use <code>flatten</code> instead. For an input array with shape $(d1, d2, ..., dk)$, <code>flatten</code> operation reshapes the input array into an output array of shape $(d1, d2<em>...</em>dk)$. Note that the behavior of this function is different from numpy.ndarray.flatten, which behaves similar to mxnet.ndarray.reshape((-1,)). Example::     x = [[         [1,2,3],         [4,5,6],         [7,8,9]     ],     [    [1,2,3],         [4,5,6],         [7,8,9]     ]],     flatten(x) = [[ 1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9.],        [ 1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9.]]</p>
<p>Defined in src/operator/tensor/matrix_op.cc:L250</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L369' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npx_batch_norm-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npx_batch_norm-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npx_batch_norm</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npx_batch_norm(data, gamma, beta, moving_mean, moving_var, eps, momentum, fix_gamma, use_global_stats, output_mean_var, axis, cudnn_off, min_calib_range, max_calib_range)
</code></pre>

<p><em>npx</em>batch_norm is an alias of BatchNorm.</p>
<p>Batch normalization.</p>
<p>Normalizes a data batch by mean and variance, and applies a scale $gamma$ as well as offset $beta$.</p>
<p>Assume the input has more than one dimension and we normalize along axis 1. We first compute the mean and variance along this axis:</p>
<p>.. math::</p>
<p>data_mean[i] = mean(data[:,i,:,...]) \
  data_var[i] = var(data[:,i,:,...])</p>
<p>Then compute the normalized output, which has the same shape as input, as following:</p>
<p>.. math::</p>
<p>out[:,i,:,...] = \frac{data[:,i,:,...] - data_mean[i]}{\sqrt{data_var[i]+\epsilon}} * gamma[i] + beta[i]</p>
<p>Both <em>mean</em> and <em>var</em> returns a scalar by treating the input as a vector.</p>
<p>Assume the input has size <em>k</em> on axis 1, then both $gamma$ and $beta$ have shape <em>(k,)</em>. If $output_mean_var$ is set to be true, then outputs both $data_mean$ and the inverse of $data_var$, which are needed for the backward pass. Note that gradient of these two outputs are blocked.</p>
<p>Besides the inputs and the outputs, this operator accepts two auxiliary states, $moving_mean$ and $moving_var$, which are <em>k</em>-length vectors. They are global statistics for the whole dataset, which are updated by::</p>
<p>moving<em>mean = moving</em>mean * momentum + data<em>mean * (1 - momentum)   moving</em>var = moving<em>var * momentum + data</em>var * (1 - momentum)</p>
<p>If $use_global_stats$ is set to be true, then $moving_mean$ and $moving_var$ are used instead of $data_mean$ and $data_var$ to compute the output. It is often used during inference.</p>
<p>The parameter $axis$ specifies which axis of the input shape denotes the 'channel' (separately normalized groups).  The default is 1.  Specifying -1 sets the channel axis to be the last item in the input shape.</p>
<p>Both $gamma$ and $beta$ are learnable parameters. But if $fix_gamma$ is true, then set $gamma$ to 1 and its gradient to 0.</p>
<p>.. Note::   When $fix_gamma$ is set to True, no sparse support is provided. If $fix_gamma is$ set to False,   the sparse tensors will fallback.</p>
<p>Defined in src/operator/nn/batch_norm.cc:L545</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data to batch normalization</li>
<li><code>gamma::NDArray-or-SymbolicNode</code>: gamma array</li>
<li><code>beta::NDArray-or-SymbolicNode</code>: beta array</li>
<li><code>moving_mean::NDArray-or-SymbolicNode</code>: running mean of input</li>
<li><code>moving_var::NDArray-or-SymbolicNode</code>: running variance of input</li>
<li><code>eps::double, optional, default=0.0010000000474974513</code>: Epsilon to prevent div 0. Must be no less than CUDNN<em>BN</em>MIN_EPSILON defined in cudnn.h when using cudnn (usually 1e-5)</li>
<li><code>momentum::float, optional, default=0.899999976</code>: Momentum for moving average</li>
<li><code>fix_gamma::boolean, optional, default=1</code>: Fix gamma while training</li>
<li><code>use_global_stats::boolean, optional, default=0</code>: Whether use global moving statistics instead of local batch-norm. This will force change batch-norm into a scale shift operator.</li>
<li><code>output_mean_var::boolean, optional, default=0</code>: Output the mean and inverse std</li>
<li><code>axis::int, optional, default='1'</code>: Specify which shape axis the channel is specified</li>
<li><code>cudnn_off::boolean, optional, default=0</code>: Do not select CUDNN operator, if available</li>
<li><code>min_calib_range::float or None, optional, default=None</code>: The minimum scalar value in the form of float32 obtained through calibration. If present, it will be used to by quantized batch norm op to calculate primitive scale.Note: this calib_range is to calib bn output.</li>
<li><code>max_calib_range::float or None, optional, default=None</code>: The maximum scalar value in the form of float32 obtained through calibration. If present, it will be used to by quantized batch norm op to calculate primitive scale.Note: this calib_range is to calib bn output.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L426' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npx_broadcast_like-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npx_broadcast_like-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npx_broadcast_like</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npx_broadcast_like(lhs, rhs, lhs_axes, rhs_axes)
</code></pre>

<p><em>npx</em>broadcast<em>like is an alias of broadcast</em>like.</p>
<p>Broadcasts lhs to have the same shape as rhs.</p>
<p>Broadcasting is a mechanism that allows NDArrays to perform arithmetic operations with arrays of different shapes efficiently without creating multiple copies of arrays. Also see, <code>Broadcasting &lt;https://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&gt;</code>_ for more explanation.</p>
<p>Broadcasting is allowed on axes with size 1, such as from <code>(2,1,3,1)</code> to <code>(2,8,3,9)</code>. Elements will be duplicated on the broadcasted axes.</p>
<p>For example::</p>
<p>broadcast_like([[1,2,3]], [[5,6,7],[7,8,9]]) = [[ 1.,  2.,  3.],                                                    [ 1.,  2.,  3.]])</p>
<p>broadcast<em>like([9], [1,2,3,4,5], lhs</em>axes=(0,), rhs_axes=(-1,)) = [9,9,9,9,9]</p>
<p>Defined in src/operator/tensor/broadcast<em>reduce</em>op_value.cc:L171</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: First input.</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: Second input.</li>
<li><code>lhs_axes::Shape or None, optional, default=None</code>: Axes to perform broadcast on in the first input array</li>
<li><code>rhs_axes::Shape or None, optional, default=None</code>: Axes to copy from the second input array</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L373' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npx_cast-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npx_cast-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npx_cast</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npx_cast(data, dtype)
</code></pre>

<p><em>npx</em>cast is an alias of Cast.</p>
<p>Casts all elements of the input to a new type.</p>
<p>.. note:: $Cast$ is deprecated. Use $cast$ instead.</p>
<p>Example::</p>
<p>cast([0.9, 1.3], dtype='int32') = [0, 1]    cast([1e20, 11.1], dtype='float16') = [inf, 11.09375]    cast([300, 11.1, 10.9, -1, -3], dtype='uint8') = [44, 11, 10, 255, 253]</p>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_basic.cc:L664</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input.</li>
<li><code>dtype::{'bfloat16', 'bool', 'float16', 'float32', 'float64', 'int32', 'int64', 'int8', 'uint8'}, required</code>: Output data type.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L363' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npx_constraint_check-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npx_constraint_check-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npx_constraint_check</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npx_constraint_check(input, msg)
</code></pre>

<p>This operator will check if all the elements in a boolean tensor is true. If not, ValueError exception will be raised in the backend with given error message. In order to evaluate this operator, one should multiply the origin tensor by the return value of this operator to force this operator become part of the computation graph, otherwise the check would not be working under symoblic mode.</p>
<p>Example:</p>
<p>loc = np.zeros((2,2)) scale = np.array(#some<em>value) constraint = (scale &gt; 0) np.random.normal(loc, scale * npx.constraint</em>check(constraint, 'Scale should be larger than zero'))</p>
<p>If elements in the scale tensor are all bigger than zero, npx.constraint_check would return <code>np.array(True)</code>, which will not change the value of <code>scale</code> when multiplied by. If some of the elements in the scale tensor violate the constraint, i.e. there exists <code>False</code> in the boolean tensor <code>constraint</code>, a <code>ValueError</code> exception with given message 'Scale should be larger than zero' would be raised.</p>
<p>Defined in src/operator/numpy/np<em>constraint</em>check.cc:L79</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>input::NDArray-or-SymbolicNode</code>: Input boolean array</li>
<li><code>msg::string, optional, default='Constraint violated.'</code>: Error message raised when constraint violated</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L370' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npx_convolution-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npx_convolution-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npx_convolution</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npx_convolution(data, weight, bias, kernel, stride, dilate, pad, num_filter, num_group, workspace, no_bias, cudnn_tune, cudnn_off, layout)
</code></pre>

<p><em>npx</em>convolution is an alias of Convolution.</p>
<p>Compute <em>N</em>-D convolution on <em>(N+2)</em>-D input.</p>
<p>In the 2-D convolution, given input data with shape <em>(batch_size, channel, height, width)</em>, the output is computed by</p>
<p>.. math::</p>
<p>out[n,i,:,:] = bias[i] + \sum_{j=0}^{channel} data[n,j,:,:] \star    weight[i,j,:,:]</p>
<p>where :math:<code>\star</code> is the 2-D cross-correlation operator.</p>
<p>For general 2-D convolution, the shapes are</p>
<ul>
<li><strong>data</strong>: <em>(batch_size, channel, height, width)</em></li>
<li><strong>weight</strong>: <em>(num_filter, channel, kernel[0], kernel[1])</em></li>
<li><strong>bias</strong>: <em>(num_filter,)</em></li>
<li><strong>out</strong>: <em>(batch</em>size, num<em>filter, out</em>height, out<em>width)</em>.</li>
</ul>
<p>Define::</p>
<p>f(x,k,p,s,d) = floor((x+2<em>p-d</em>(k-1)-1)/s)+1</p>
<p>then we have::</p>
<p>out<em>height=f(height, kernel[0], pad[0], stride[0], dilate[0])   out</em>width=f(width, kernel[1], pad[1], stride[1], dilate[1])</p>
<p>If $no_bias$ is set to be true, then the $bias$ term is ignored.</p>
<p>The default data $layout$ is <em>NCHW</em>, namely <em>(batch_size, channel, height, width)</em>. We can choose other layouts such as <em>NWC</em>.</p>
<p>If $num_group$ is larger than 1, denoted by <em>g</em>, then split the input $data$ evenly into <em>g</em> parts along the channel axis, and also evenly split $weight$ along the first dimension. Next compute the convolution on the <em>i</em>-th part of the data with the <em>i</em>-th weight part. The output is obtained by concatenating all the <em>g</em> results.</p>
<p>1-D convolution does not have <em>height</em> dimension but only <em>width</em> in space.</p>
<ul>
<li><strong>data</strong>: <em>(batch_size, channel, width)</em></li>
<li><strong>weight</strong>: <em>(num_filter, channel, kernel[0])</em></li>
<li><strong>bias</strong>: <em>(num_filter,)</em></li>
<li><strong>out</strong>: <em>(batch</em>size, num<em>filter, out_width)</em>.</li>
</ul>
<p>3-D convolution adds an additional <em>depth</em> dimension besides <em>height</em> and <em>width</em>. The shapes are</p>
<ul>
<li><strong>data</strong>: <em>(batch_size, channel, depth, height, width)</em></li>
<li><strong>weight</strong>: <em>(num_filter, channel, kernel[0], kernel[1], kernel[2])</em></li>
<li><strong>bias</strong>: <em>(num_filter,)</em></li>
<li><strong>out</strong>: <em>(batch</em>size, num<em>filter, out</em>depth, out<em>height, out_width)</em>.</li>
</ul>
<p>Both $weight$ and $bias$ are learnable parameters.</p>
<p>There are other options to tune the performance.</p>
<ul>
<li>
<p><strong>cudnn_tune</strong>: enable this option leads to higher startup time but may give faster speed. Options are</p>
<ul>
<li><strong>off</strong>: no tuning</li>
<li><strong>limited_workspace</strong>:run test and pick the fastest algorithm that doesn't exceed workspace limit.</li>
<li><strong>fastest</strong>: pick the fastest algorithm and ignore workspace limit.</li>
<li><strong>None</strong> (default): the behavior is determined by environment variable $MXNET_CUDNN_AUTOTUNE_DEFAULT$. 0 for off, 1 for limited workspace (default), 2 for fastest.</li>
<li><strong>workspace</strong>: A large number leads to more (GPU) memory usage but may improve the performance.</li>
</ul>
</li>
</ul>
<p>Defined in src/operator/nn/convolution.cc:L469</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data to the ConvolutionOp.</li>
<li><code>weight::NDArray-or-SymbolicNode</code>: Weight matrix.</li>
<li><code>bias::NDArray-or-SymbolicNode</code>: Bias parameter.</li>
<li><code>kernel::Shape(tuple), required</code>: Convolution kernel size: (w,), (h, w) or (d, h, w)</li>
<li><code>stride::Shape(tuple), optional, default=[]</code>: Convolution stride: (w,), (h, w) or (d, h, w). Defaults to 1 for each dimension.</li>
<li><code>dilate::Shape(tuple), optional, default=[]</code>: Convolution dilate: (w,), (h, w) or (d, h, w). Defaults to 1 for each dimension.</li>
<li><code>pad::Shape(tuple), optional, default=[]</code>: Zero pad for convolution: (w,), (h, w) or (d, h, w). Defaults to no padding.</li>
<li><code>num_filter::int (non-negative), required</code>: Convolution filter(channel) number</li>
<li><code>num_group::int (non-negative), optional, default=1</code>: Number of group partitions.</li>
<li><code>workspace::long (non-negative), optional, default=1024</code>: Maximum temporary workspace allowed (MB) in convolution.This parameter has two usages. When CUDNN is not used, it determines the effective batch size of the convolution kernel. When CUDNN is used, it controls the maximum temporary storage used for tuning the best CUDNN kernel when <code>limited_workspace</code> strategy is used.</li>
<li><code>no_bias::boolean, optional, default=0</code>: Whether to disable bias parameter.</li>
<li><code>cudnn_tune::{None, 'fastest', 'limited_workspace', 'off'},optional, default='None'</code>: Whether to pick convolution algo by running performance test.</li>
<li><code>cudnn_off::boolean, optional, default=0</code>: Turn off cudnn for this layer.</li>
<li><code>layout::{None, 'NCDHW', 'NCHW', 'NCW', 'NDHWC', 'NHWC'},optional, default='None'</code>: Set layout for input, output and weight. Empty for   default layout: NCW for 1d, NCHW for 2d and NCDHW for 3d.NHWC and NDHWC are only supported on GPU.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L450' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npx_deconvolution-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npx_deconvolution-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npx_deconvolution</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npx_deconvolution(data, weight, bias, kernel, stride, dilate, pad, adj, target_shape, num_filter, num_group, workspace, no_bias, cudnn_tune, cudnn_off, layout)
</code></pre>

<p><em>npx</em>deconvolution is an alias of Deconvolution.</p>
<p>Computes 1D or 2D transposed convolution (aka fractionally strided convolution) of the input tensor. This operation can be seen as the gradient of Convolution operation with respect to its input. Convolution usually reduces the size of the input. Transposed convolution works the other way, going from a smaller input to a larger output while preserving the connectivity pattern.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input tensor to the deconvolution operation.</li>
<li><code>weight::NDArray-or-SymbolicNode</code>: Weights representing the kernel.</li>
<li><code>bias::NDArray-or-SymbolicNode</code>: Bias added to the result after the deconvolution operation.</li>
<li><code>kernel::Shape(tuple), required</code>: Deconvolution kernel size: (w,), (h, w) or (d, h, w). This is same as the kernel size used for the corresponding convolution</li>
<li><code>stride::Shape(tuple), optional, default=[]</code>: The stride used for the corresponding convolution: (w,), (h, w) or (d, h, w). Defaults to 1 for each dimension.</li>
<li><code>dilate::Shape(tuple), optional, default=[]</code>: Dilation factor for each dimension of the input: (w,), (h, w) or (d, h, w). Defaults to 1 for each dimension.</li>
<li><code>pad::Shape(tuple), optional, default=[]</code>: The amount of implicit zero padding added during convolution for each dimension of the input: (w,), (h, w) or (d, h, w). $(kernel-1)/2$ is usually a good choice. If <code>target_shape</code> is set, <code>pad</code> will be ignored and a padding that will generate the target shape will be used. Defaults to no padding.</li>
<li><code>adj::Shape(tuple), optional, default=[]</code>: Adjustment for output shape: (w,), (h, w) or (d, h, w). If <code>target_shape</code> is set, <code>adj</code> will be ignored and computed accordingly.</li>
<li><code>target_shape::Shape(tuple), optional, default=[]</code>: Shape of the output tensor: (w,), (h, w) or (d, h, w).</li>
<li><code>num_filter::int (non-negative), required</code>: Number of output filters.</li>
<li><code>num_group::int (non-negative), optional, default=1</code>: Number of groups partition.</li>
<li><code>workspace::long (non-negative), optional, default=512</code>: Maximum temporary workspace allowed (MB) in deconvolution.This parameter has two usages. When CUDNN is not used, it determines the effective batch size of the deconvolution kernel. When CUDNN is used, it controls the maximum temporary storage used for tuning the best CUDNN kernel when <code>limited_workspace</code> strategy is used.</li>
<li><code>no_bias::boolean, optional, default=1</code>: Whether to disable bias parameter.</li>
<li><code>cudnn_tune::{None, 'fastest', 'limited_workspace', 'off'},optional, default='None'</code>: Whether to pick convolution algorithm by running performance test.</li>
<li><code>cudnn_off::boolean, optional, default=0</code>: Turn off cudnn for this layer.</li>
<li><code>layout::{None, 'NCDHW', 'NCHW', 'NCW', 'NDHWC', 'NHWC'},optional, default='None'</code>: Set layout for input, output and weight. Empty for default layout, NCW for 1d, NCHW for 2d and NCDHW for 3d.NHWC and NDHWC are only supported on GPU.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L379' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npx_dropout-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npx_dropout-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npx_dropout</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npx_dropout(data, p, mode, axes, cudnn_off)
</code></pre>

<p><em>npx</em>dropout is an alias of Dropout.</p>
<p>Applies dropout operation to input array.</p>
<ul>
<li>During training, each element of the input is set to zero with probability p. The whole array is rescaled by :math:<code>1/(1-p)</code> to keep the expected sum of the input unchanged.</li>
<li>During testing, this operator does not change the input if mode is 'training'. If mode is 'always', the same computaion as during training will be applied.</li>
</ul>
<p>Example::</p>
<p>random.seed(998)   input<em>array = array([[3., 0.5,  -0.5,  2., 7.],                       [2., -0.4,   7.,  3., 0.2]])   a = symbol.Variable('a')   dropout = symbol.Dropout(a, p = 0.2)   executor = dropout.simple</em>bind(a = input_array.shape)</p>
<p><strong>If training</strong></p>
<p>executor.forward(is<em>train = True, a = input</em>array)   executor.outputs   [[ 3.75   0.625 -0.     2.5    8.75 ]    [ 2.5   -0.5    8.75   3.75   0.   ]]</p>
<p><strong>If testing</strong></p>
<p>executor.forward(is<em>train = False, a = input</em>array)   executor.outputs   [[ 3.     0.5   -0.5    2.     7.   ]    [ 2.    -0.4    7.     3.     0.2  ]]</p>
<p>Defined in src/operator/nn/dropout.cc:L96</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input array to which dropout will be applied.</li>
<li><code>p::float, optional, default=0.5</code>: Fraction of the input that gets dropped out during training time.</li>
<li><code>mode::{'always', 'training'},optional, default='training'</code>: Whether to only turn on dropout during training or to also turn on for inference.</li>
<li><code>axes::Shape(tuple), optional, default=[]</code>: Axes for variational dropout kernel.</li>
<li><code>cudnn_off::boolean or None, optional, default=0</code>: Whether to turn off cudnn in dropout operator. This option is ignored if axes is specified.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L388' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npx_embedding-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npx_embedding-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npx_embedding</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npx_embedding(data, weight, input_dim, output_dim, dtype, sparse_grad)
</code></pre>

<p><em>npx</em>embedding is an alias of Embedding.</p>
<p>Maps integer indices to vector representations (embeddings).</p>
<p>This operator maps words to real-valued vectors in a high-dimensional space, called word embeddings. These embeddings can capture semantic and syntactic properties of the words. For example, it has been noted that in the learned embedding spaces, similar words tend to be close to each other and dissimilar words far apart.</p>
<p>For an input array of shape (d1, ..., dK), the shape of an output array is (d1, ..., dK, output<em>dim). All the input values should be integers in the range [0, input</em>dim).</p>
<p>If the input<em>dim is ip0 and output</em>dim is op0, then shape of the embedding weight matrix must be (ip0, op0).</p>
<p>When "sparse<em>grad" is False, if any index mentioned is too large, it is replaced by the index that addresses the last vector in an embedding matrix. When "sparse</em>grad" is True, an error will be raised if invalid indices are found.</p>
<p>Examples::</p>
<p>input<em>dim = 4   output</em>dim = 5</p>
<p>// Each row in weight matrix y represents a word. So, y = (w0,w1,w2,w3)   y = [[  0.,   1.,   2.,   3.,   4.],        [  5.,   6.,   7.,   8.,   9.],        [ 10.,  11.,  12.,  13.,  14.],        [ 15.,  16.,  17.,  18.,  19.]]</p>
<p>// Input array x represents n-grams(2-gram). So, x = [(w1,w3), (w0,w2)]   x = [[ 1.,  3.],        [ 0.,  2.]]</p>
<p>// Mapped input x to its vector representation y.   Embedding(x, y, 4, 5) = [[[  5.,   6.,   7.,   8.,   9.],                             [ 15.,  16.,  17.,  18.,  19.]],</p>
<pre><code>                       [[  0.,   1.,   2.,   3.,   4.],
                        [ 10.,  11.,  12.,  13.,  14.]]]
</code></pre>

<p>The storage type of weight can be either row_sparse or default.</p>
<p>.. Note::</p>
<pre><code>If &quot;sparse_grad&quot; is set to True, the storage type of gradient w.r.t weights will be
&quot;row_sparse&quot;. Only a subset of optimizers support sparse gradients, including SGD, AdaGrad
and Adam. Note that by default lazy updates is turned on, which may perform differently
from standard updates. For more details, please check the Optimization API at:
https://mxnet.incubator.apache.org/api/python/optimization/optimization.html
</code></pre>

<p>Defined in src/operator/tensor/indexing_op.cc:L603</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array to the embedding operator.</li>
<li><code>weight::NDArray-or-SymbolicNode</code>: The embedding weight matrix.</li>
<li><code>input_dim::int, required</code>: Vocabulary size of the input indices.</li>
<li><code>output_dim::int, required</code>: Dimension of the embedding vectors.</li>
<li><code>dtype::{'bfloat16', 'float16', 'float32', 'float64', 'int32', 'int64', 'int8', 'uint8'},optional, default='float32'</code>: Data type of weight.</li>
<li><code>sparse_grad::boolean, optional, default=0</code>: Compute row sparse gradient in the backward calculation. If set to True, the grad's storage type is row_sparse.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L412' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npx_erf-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npx_erf-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npx_erf</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npx_erf(data)
</code></pre>

<p><em>npx</em>erf is an alias of erf.</p>
<p>Returns element-wise gauss error function of the input.</p>
<p>Example::</p>
<p>erf([0, -1., 10.]) = [0., -0.8427, 1.]</p>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_basic.cc:L886</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L357' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npx_erfinv-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npx_erfinv-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npx_erfinv</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npx_erfinv(data)
</code></pre>

<p><em>npx</em>erfinv is an alias of erfinv.</p>
<p>Returns element-wise inverse gauss error function of the input.</p>
<p>Example::</p>
<p>erfinv([0, 0.5., -1.]) = [0., 0.4769, -inf]</p>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_basic.cc:L908</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L357' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npx_fully_connected-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npx_fully_connected-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npx_fully_connected</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npx_fully_connected(data, weight, bias, num_hidden, no_bias, flatten)
</code></pre>

<p><em>npx</em>fully_connected is an alias of FullyConnected.</p>
<p>Applies a linear transformation: :math:<code>Y = XW^T + b</code>.</p>
<p>If $flatten$ is set to be true, then the shapes are:</p>
<ul>
<li><strong>data</strong>: <code>(batch_size, x1, x2, ..., xn)</code></li>
<li><strong>weight</strong>: <code>(num_hidden, x1 * x2 * ... * xn)</code></li>
<li><strong>bias</strong>: <code>(num_hidden,)</code></li>
<li><strong>out</strong>: <code>(batch_size, num_hidden)</code></li>
</ul>
<p>If $flatten$ is set to be false, then the shapes are:</p>
<ul>
<li><strong>data</strong>: <code>(x1, x2, ..., xn, input_dim)</code></li>
<li><strong>weight</strong>: <code>(num_hidden, input_dim)</code></li>
<li><strong>bias</strong>: <code>(num_hidden,)</code></li>
<li><strong>out</strong>: <code>(x1, x2, ..., xn, num_hidden)</code></li>
</ul>
<p>The learnable parameters include both $weight$ and $bias$.</p>
<p>If $no_bias$ is set to be true, then the $bias$ term is ignored.</p>
<p>.. Note::</p>
<pre><code>The sparse support for FullyConnected is limited to forward evaluation with `row_sparse`
weight and bias, where the length of `weight.indices` and `bias.indices` must be equal
to `num_hidden`. This could be useful for model inference with `row_sparse` weights
trained with importance sampling or noise contrastive estimation.

To compute linear transformation with 'csr' sparse data, sparse.dot is recommended instead
of sparse.FullyConnected.
</code></pre>

<p>Defined in src/operator/nn/fully_connected.cc:L287</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data.</li>
<li><code>weight::NDArray-or-SymbolicNode</code>: Weight matrix.</li>
<li><code>bias::NDArray-or-SymbolicNode</code>: Bias parameter.</li>
<li><code>num_hidden::int, required</code>: Number of hidden nodes of the output.</li>
<li><code>no_bias::boolean, optional, default=0</code>: Whether to disable bias parameter.</li>
<li><code>flatten::boolean, optional, default=1</code>: Whether to collapse all but the first axis of the input data tensor.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L391' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npx_gamma-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npx_gamma-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npx_gamma</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npx_gamma(data)
</code></pre>

<p><em>npx</em>gamma is an alias of gamma.</p>
<p>Returns the gamma function (extension of the factorial function 
to the reals), computed element-wise on the input array.</p>
<p>The storage type of $gamma$ output is always dense</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L354' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npx_gammaln-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npx_gammaln-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npx_gammaln</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npx_gammaln(data)
</code></pre>

<p><em>npx</em>gammaln is an alias of gammaln.</p>
<p>Returns element-wise log of the absolute value of the gamma function 
of the input.</p>
<p>The storage type of $gammaln$ output is always dense</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L354' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npx_gather_nd-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npx_gather_nd-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npx_gather_nd</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npx_gather_nd(data, indices)
</code></pre>

<p><em>npx</em>gather<em>nd is an alias of gather</em>nd.</p>
<p>Gather elements or slices from <code>data</code> and store to a tensor whose shape is defined by <code>indices</code>.</p>
<p>Given <code>data</code> with shape <code>(X_0, X_1, ..., X_{N-1})</code> and indices with shape <code>(M, Y_0, ..., Y_{K-1})</code>, the output will have shape <code>(Y_0, ..., Y_{K-1}, X_M, ..., X_{N-1})</code>, where <code>M &lt;= N</code>. If <code>M == N</code>, output shape will simply be <code>(Y_0, ..., Y_{K-1})</code>.</p>
<p>The elements in output is defined as follows::</p>
<p>output[y<em K-1="K-1">0, ..., y</em>, x<em N-1="N-1">M, ..., x</em>] = data[indices[0, y<em K-1="K-1">0, ..., y</em>],                                                       ...,                                                       indices[M-1, y<em K-1="K-1">0, ..., y</em>],                                                       x<em N-1="N-1">M, ..., x</em>]</p>
<p>Examples::</p>
<p>data = [[0, 1], [2, 3]]   indices = [[1, 1, 0], [0, 1, 0]]   gather_nd(data, indices) = [2, 3, 0]</p>
<p>data = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]   indices = [[0, 1], [1, 0]]   gather_nd(data, indices) = [[3, 4], [5, 6]]</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: data</li>
<li><code>indices::NDArray-or-SymbolicNode</code>: indices</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L375' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npx_layer_norm-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npx_layer_norm-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npx_layer_norm</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npx_layer_norm(data, gamma, beta, axis, eps, output_mean_var)
</code></pre>

<p><em>npx</em>layer_norm is an alias of LayerNorm.</p>
<p>Layer normalization.</p>
<p>Normalizes the channels of the input tensor by mean and variance, and applies a scale $gamma$ as well as offset $beta$.</p>
<p>Assume the input has more than one dimension and we normalize along axis 1. We first compute the mean and variance along this axis and then  compute the normalized output, which has the same shape as input, as following:</p>
<p>.. math::</p>
<p>out = \frac{data - mean(data, axis)}{\sqrt{var(data, axis) + \epsilon}} * gamma + beta</p>
<p>Both $gamma$ and $beta$ are learnable parameters.</p>
<p>Unlike BatchNorm and InstanceNorm,  the <em>mean</em> and <em>var</em> are computed along the channel dimension.</p>
<p>Assume the input has size <em>k</em> on axis 1, then both $gamma$ and $beta$ have shape <em>(k,)</em>. If $output_mean_var$ is set to be true, then outputs both $data_mean$ and $data_std$. Note that no gradient will be passed through these two outputs.</p>
<p>The parameter $axis$ specifies which axis of the input shape denotes the 'channel' (separately normalized groups).  The default is -1, which sets the channel axis to be the last item in the input shape.</p>
<p>Defined in src/operator/nn/layer_norm.cc:L158</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data to layer normalization</li>
<li><code>gamma::NDArray-or-SymbolicNode</code>: gamma array</li>
<li><code>beta::NDArray-or-SymbolicNode</code>: beta array</li>
<li><code>axis::int, optional, default='-1'</code>: The axis to perform layer normalization. Usually, this should be be axis of the channel dimension. Negative values means indexing from right to left.</li>
<li><code>eps::float, optional, default=9.99999975e-06</code>: An <code>epsilon</code> parameter to prevent division by 0.</li>
<li><code>output_mean_var::boolean, optional, default=0</code>: Output the mean and std calculated along the given axis.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L386' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npx_leaky_relu-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npx_leaky_relu-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npx_leaky_relu</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npx_leaky_relu(data, gamma, act_type, slope, lower_bound, upper_bound)
</code></pre>

<p><em>npx</em>leaky_relu is an alias of LeakyReLU.</p>
<p>Applies Leaky rectified linear unit activation element-wise to the input.</p>
<p>Leaky ReLUs attempt to fix the "dying ReLU" problem by allowing a small <code>slope</code> when the input is negative and has a slope of one when input is positive.</p>
<p>The following modified ReLU Activation functions are supported:</p>
<ul>
<li><em>elu</em>: Exponential Linear Unit. <code>y = x &gt; 0 ? x : slope * (exp(x)-1)</code></li>
<li><em>selu</em>: Scaled Exponential Linear Unit. <code>y = lambda * (x &gt; 0 ? x : alpha * (exp(x) - 1))</code> where <em>lambda = 1.0507009873554804934193349852946</em> and <em>alpha = 1.6732632423543772848170429916717</em>.</li>
<li><em>leaky</em>: Leaky ReLU. <code>y = x &gt; 0 ? x : slope * x</code></li>
<li><em>prelu</em>: Parametric ReLU. This is same as <em>leaky</em> except that <code>slope</code> is learnt during training.</li>
<li><em>rrelu</em>: Randomized ReLU. same as <em>leaky</em> but the <code>slope</code> is uniformly and randomly chosen from <em>[lower</em>bound, upper<em>bound)</em> for training, while fixed to be <em>(lower</em>bound+upper<em>bound)/2</em> for inference.</li>
</ul>
<p>Defined in src/operator/leaky_relu.cc:L161</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data to activation function.</li>
<li><code>gamma::NDArray-or-SymbolicNode</code>: Input data to activation function.</li>
<li><code>act_type::{'elu', 'gelu', 'leaky', 'prelu', 'rrelu', 'selu'},optional, default='leaky'</code>: Activation function to be applied.</li>
<li><code>slope::float, optional, default=0.25</code>: Init slope for the activation. (For leaky and elu only)</li>
<li><code>lower_bound::float, optional, default=0.125</code>: Lower bound of random slope. (For rrelu only)</li>
<li><code>upper_bound::float, optional, default=0.333999991</code>: Upper bound of random slope. (For rrelu only)</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L377' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npx_log_softmax-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npx_log_softmax-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npx_log_softmax</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npx_log_softmax(data, axis, temperature, dtype, use_length)
</code></pre>

<p><em>npx</em>log<em>softmax is an alias of log</em>softmax.</p>
<p>Computes the log softmax of the input. This is equivalent to computing softmax followed by log.</p>
<p>Examples::</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = mx.nd.array([1, 2, .1]) mx.nd.log_softmax(x).asnumpy()</p>
</blockquote>
</blockquote>
</blockquote>
<p>array([-1.41702998, -0.41702995, -2.31702995], dtype=float32)</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = mx.nd.array( [[1, 2, .1],[.1, 2, 1]] ) mx.nd.log_softmax(x, axis=0).asnumpy()</p>
</blockquote>
</blockquote>
</blockquote>
<p>array([[-0.34115392, -0.69314718, -1.24115396],          [-1.24115396, -0.69314718, -0.34115392]], dtype=float32)</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>axis::int, optional, default='-1'</code>: The axis along which to compute softmax.</li>
<li><code>temperature::double or None, optional, default=None</code>: Temperature parameter in softmax</li>
<li><code>dtype::{None, 'float16', 'float32', 'float64'},optional, default='None'</code>: DType of the output in case this can't be inferred. Defaults to the same as input's dtype if not defined (dtype=None).</li>
<li><code>use_length::boolean or None, optional, default=0</code>: Whether to use the length input as a mask over the data input.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L372' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npx_multibox_detection-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npx_multibox_detection-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npx_multibox_detection</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npx_multibox_detection(cls_prob, loc_pred, anchor, clip, threshold, background_id, nms_threshold, force_suppress, variances, nms_topk)
</code></pre>

<p><em>npx</em>multibox<em>detection is an alias of _contrib</em>MultiBoxDetection.</p>
<p>Convert multibox detection predictions.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>cls_prob::NDArray-or-SymbolicNode</code>: Class probabilities.</li>
<li><code>loc_pred::NDArray-or-SymbolicNode</code>: Location regression predictions.</li>
<li><code>anchor::NDArray-or-SymbolicNode</code>: Multibox prior anchor boxes</li>
<li><code>clip::boolean, optional, default=1</code>: Clip out-of-boundary boxes.</li>
<li><code>threshold::float, optional, default=0.00999999978</code>: Threshold to be a positive prediction.</li>
<li><code>background_id::int, optional, default='0'</code>: Background id.</li>
<li><code>nms_threshold::float, optional, default=0.5</code>: Non-maximum suppression threshold.</li>
<li><code>force_suppress::boolean, optional, default=0</code>: Suppress all detections regardless of class_id.</li>
<li><code>variances::tuple of &lt;float&gt;, optional, default=[0.1,0.1,0.2,0.2]</code>: Variances to be decoded from box regression output.</li>
<li><code>nms_topk::int, optional, default='-1'</code>: Keep maximum top k detections before nms, -1 for no limit.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L367' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npx_multibox_prior-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npx_multibox_prior-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npx_multibox_prior</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npx_multibox_prior(data, sizes, ratios, clip, steps, offsets)
</code></pre>

<p><em>npx</em>multibox<em>prior is an alias of _contrib</em>MultiBoxPrior.</p>
<p>Generate prior(anchor) boxes from data, sizes and ratios.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data.</li>
<li><code>sizes::tuple of &lt;float&gt;, optional, default=[1]</code>: List of sizes of generated MultiBoxPriores.</li>
<li><code>ratios::tuple of &lt;float&gt;, optional, default=[1]</code>: List of aspect ratios of generated MultiBoxPriores.</li>
<li><code>clip::boolean, optional, default=0</code>: Whether to clip out-of-boundary boxes.</li>
<li><code>steps::tuple of &lt;float&gt;, optional, default=[-1,-1]</code>: Priorbox step across y and x, -1 for auto calculation.</li>
<li><code>offsets::tuple of &lt;float&gt;, optional, default=[0.5,0.5]</code>: Priorbox center offsets, y and x respectively</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L359' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npx_multibox_target-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npx_multibox_target-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npx_multibox_target</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npx_multibox_target(anchor, label, cls_pred, overlap_threshold, ignore_label, negative_mining_ratio, negative_mining_thresh, minimum_negative_samples, variances)
</code></pre>

<p><em>npx</em>multibox<em>target is an alias of _contrib</em>MultiBoxTarget.</p>
<p>Compute Multibox training targets</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>anchor::NDArray-or-SymbolicNode</code>: Generated anchor boxes.</li>
<li><code>label::NDArray-or-SymbolicNode</code>: Object detection labels.</li>
<li><code>cls_pred::NDArray-or-SymbolicNode</code>: Class predictions.</li>
<li><code>overlap_threshold::float, optional, default=0.5</code>: Anchor-GT overlap threshold to be regarded as a positive match.</li>
<li><code>ignore_label::float, optional, default=-1</code>: Label for ignored anchors.</li>
<li><code>negative_mining_ratio::float, optional, default=-1</code>: Max negative to positive samples ratio, use -1 to disable mining</li>
<li><code>negative_mining_thresh::float, optional, default=0.5</code>: Threshold used for negative mining.</li>
<li><code>minimum_negative_samples::int, optional, default='0'</code>: Minimum number of negative samples.</li>
<li><code>variances::tuple of &lt;float&gt;, optional, default=[0.1,0.1,0.2,0.2]</code>: Variances to be encoded in box regression target.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L365' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npx_nonzero-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npx_nonzero-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npx_nonzero</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npx_nonzero(x)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>x::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L347' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npx_one_hot-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npx_one_hot-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npx_one_hot</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npx_one_hot(indices, depth, on_value, off_value, dtype)
</code></pre>

<p><em>npx</em>one<em>hot is an alias of one</em>hot.</p>
<p>Returns a one-hot array.</p>
<p>The locations represented by <code>indices</code> take value <code>on_value</code>, while all other locations take value <code>off_value</code>.</p>
<p><code>one_hot</code> operation with <code>indices</code> of shape $(i0, i1)$ and <code>depth</code>  of $d$ would result in an output array of shape $(i0, i1, d)$ with::</p>
<p>output[i,j,:] = off<em>value   output[i,j,indices[i,j]] = on</em>value</p>
<p>Examples::</p>
<p>one_hot([1,0,2,0], 3) = [[ 0.  1.  0.]                            [ 1.  0.  0.]                            [ 0.  0.  1.]                            [ 1.  0.  0.]]</p>
<p>one<em>hot([1,0,2,0], 3, on</em>value=8, off_value=1,           dtype='int32') = [[1 8 1]                             [8 1 1]                             [1 1 8]                             [8 1 1]]</p>
<p>one_hot([[1,0],[1,0],[2,0]], 3) = [[[ 0.  1.  0.]                                       [ 1.  0.  0.]]</p>
<pre><code>                                 [[ 0.  1.  0.]
                                  [ 1.  0.  0.]]

                                 [[ 0.  0.  1.]
                                  [ 1.  0.  0.]]]
</code></pre>

<p>Defined in src/operator/tensor/indexing_op.cc:L888</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>indices::NDArray-or-SymbolicNode</code>: array of locations where to set on_value</li>
<li><code>depth::int, required</code>: Depth of the one hot dimension.</li>
<li><code>on_value::double, optional, default=1</code>: The value assigned to the locations represented by indices.</li>
<li><code>off_value::double, optional, default=0</code>: The value assigned to the locations not represented by indices.</li>
<li><code>dtype::{'bfloat16', 'float16', 'float32', 'float64', 'int32', 'int64', 'int8', 'uint8'},optional, default='float32'</code>: DType of the output</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L391' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npx_pick-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npx_pick-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npx_pick</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npx_pick(data, index, axis, keepdims, mode)
</code></pre>

<p><em>npx</em>pick is an alias of pick.</p>
<p>Picks elements from an input array according to the input indices along the given axis.</p>
<p>Given an input array of shape $(d0, d1)$ and indices of shape $(i0,)$, the result will be an output array of shape $(i0,)$ with::</p>
<p>output[i] = input[i, indices[i]]</p>
<p>By default, if any index mentioned is too large, it is replaced by the index that addresses the last element along an axis (the <code>clip</code> mode).</p>
<p>This function supports n-dimensional input and (n-1)-dimensional indices arrays.</p>
<p>Examples::</p>
<p>x = [[ 1.,  2.],        [ 3.,  4.],        [ 5.,  6.]]</p>
<p>// picks elements with specified indices along axis 0   pick(x, y=[0,1], 0) = [ 1.,  4.]</p>
<p>// picks elements with specified indices along axis 1   pick(x, y=[0,1,0], 1) = [ 1.,  4.,  5.]</p>
<p>// picks elements with specified indices along axis 1 using 'wrap' mode   // to place indicies that would normally be out of bounds   pick(x, y=[2,-1,-2], 1, mode='wrap') = [ 1.,  4.,  5.]</p>
<p>y = [[ 1.],        [ 0.],        [ 2.]]</p>
<p>// picks elements with specified indices along axis 1 and dims are maintained   pick(x, y, 1, keepdims=True) = [[ 2.],                                  [ 3.],                                  [ 6.]]</p>
<p>Defined in src/operator/tensor/broadcast<em>reduce</em>op_index.cc:L151</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array</li>
<li><code>index::NDArray-or-SymbolicNode</code>: The index array</li>
<li><code>axis::int or None, optional, default='-1'</code>: int or None. The axis to picking the elements. Negative values means indexing from right to left. If is <code>None</code>, the elements in the index w.r.t the flattened input will be picked.</li>
<li><code>keepdims::boolean, optional, default=0</code>: If true, the axis where we pick the elements is left in the result as dimension with size one.</li>
<li><code>mode::{'clip', 'wrap'},optional, default='clip'</code>: Specify how out-of-bound indices behave. Default is "clip". "clip" means clip to the range. So, if all indices mentioned are too large, they are replaced by the index that addresses the last element along an axis.  "wrap" means to wrap around.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L396' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npx_pooling-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npx_pooling-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npx_pooling</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npx_pooling(data, kernel, pool_type, global_pool, cudnn_off, pooling_convention, stride, pad, p_value, count_include_pad, layout)
</code></pre>

<p><em>npx</em>pooling is an alias of Pooling.</p>
<p>Performs pooling on the input.</p>
<p>The shapes for 1-D pooling are</p>
<ul>
<li><strong>data</strong> and <strong>out</strong>: <em>(batch_size, channel, width)</em> (NCW layout) or <em>(batch_size, width, channel)</em> (NWC layout),</li>
</ul>
<p>The shapes for 2-D pooling are</p>
<ul>
<li>
<p><strong>data</strong> and <strong>out</strong>: <em>(batch_size, channel, height, width)</em> (NCHW layout) or <em>(batch_size, height, width, channel)</em> (NHWC layout),</p>
<p>out<em>height = f(height, kernel[0], pad[0], stride[0])   out</em>width = f(width, kernel[1], pad[1], stride[1])</p>
</li>
</ul>
<p>The definition of <em>f</em> depends on $pooling_convention$, which has two options:</p>
<ul>
<li>
<p><strong>valid</strong> (default)::</p>
<p>f(x, k, p, s) = floor((x+2*p-k)/s)+1
  * <strong>full</strong>, which is compatible with Caffe::</p>
<p>f(x, k, p, s) = ceil((x+2*p-k)/s)+1</p>
</li>
</ul>
<p>When $global_pool$ is set to be true, then global pooling is performed. It will reset $kernel=(height, width)$ and set the appropiate padding to 0.</p>
<p>Three pooling options are supported by $pool_type$:</p>
<ul>
<li><strong>avg</strong>: average pooling</li>
<li><strong>max</strong>: max pooling</li>
<li><strong>sum</strong>: sum pooling</li>
<li><strong>lp</strong>: Lp pooling</li>
</ul>
<p>For 3-D pooling, an additional <em>depth</em> dimension is added before <em>height</em>. Namely the input data and output will have shape <em>(batch_size, channel, depth, height, width)</em> (NCDHW layout) or <em>(batch_size, depth, height, width, channel)</em> (NDHWC layout).</p>
<p>Notes on Lp pooling:</p>
<p>Lp pooling was first introduced by this paper: https://arxiv.org/pdf/1204.3968.pdf. L-1 pooling is simply sum pooling, while L-inf pooling is simply max pooling. We can see that Lp pooling stands between those two, in practice the most common value for p is 2.</p>
<p>For each window $X$, the mathematical expression for Lp pooling is:</p>
<p>:math:<code>f(X) = \sqrt[p]{\sum_{x}^{X} x^p}</code></p>
<p>Defined in src/operator/nn/pooling.cc:L416</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data to the pooling operator.</li>
<li><code>kernel::Shape(tuple), optional, default=[]</code>: Pooling kernel size: (y, x) or (d, y, x)</li>
<li><code>pool_type::{'avg', 'lp', 'max', 'sum'},optional, default='max'</code>: Pooling type to be applied.</li>
<li><code>global_pool::boolean, optional, default=0</code>: Ignore kernel size, do global pooling based on current input feature map.</li>
<li><code>cudnn_off::boolean, optional, default=0</code>: Turn off cudnn pooling and use MXNet pooling operator.</li>
<li><code>pooling_convention::{'full', 'same', 'valid'},optional, default='valid'</code>: Pooling convention to be applied.</li>
<li><code>stride::Shape(tuple), optional, default=[]</code>: Stride: for pooling (y, x) or (d, y, x). Defaults to 1 for each dimension.</li>
<li><code>pad::Shape(tuple), optional, default=[]</code>: Pad for pooling: (y, x) or (d, y, x). Defaults to no padding.</li>
<li><code>p_value::int or None, optional, default='None'</code>: Value of p for Lp pooling, can be 1 or 2, required for Lp Pooling.</li>
<li><code>count_include_pad::boolean or None, optional, default=None</code>: Only used for AvgPool, specify whether to count padding elements for averagecalculation. For example, with a 5<em>5 kernel on a 3</em>3 corner of a image,the sum of the 9 valid elements will be divided by 25 if this is set to true,or it will be divided by 9 if this is set to false. Defaults to true.</li>
<li><code>layout::{None, 'NCDHW', 'NCHW', 'NCW', 'NDHWC', 'NHWC', 'NWC'},optional, default='None'</code>: Set layout for input and output. Empty for   default layout: NCW for 1d, NCHW for 2d and NCDHW for 3d.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L421' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npx_relu-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npx_relu-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npx_relu</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npx_relu(data)
</code></pre>

<p>Computes rectified linear activation. .. math::    max(features, 0)</p>
<p>Defined in src/operator/numpy/np<em>elemwise</em>unary<em>op</em>basic.cc:L34</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L352' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npx_reshape-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npx_reshape-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npx_reshape</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npx_reshape(a, newshape, reverse, order)
</code></pre>

<p>Defined in src/operator/numpy/np<em>matrix</em>op.cc:L382</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>a::NDArray-or-SymbolicNode</code>: Array to be reshaped.</li>
<li><code>newshape::Shape(tuple), required</code>: The new shape should be compatible with the original shape. If an integer, then the result will be a 1-D array of that length. One shape dimension can be -1. In this case, the value is inferred from the length of the array and remaining dimensions. -2 to -6 are used for data manipulation. -2 copy this dimension from the input to the output shape. -3 will skip current dimension if and only if the current dim size is one. -4 copy all remain of the input dimensions to the output shape. -5 use the product of two consecutive dimensions of the input shape as the output. -6 split one dimension of the input into two dimensions passed subsequent to -6 in the new shape.</li>
<li><code>reverse::boolean, optional, default=0</code>: If true then the special values are inferred from right to left</li>
<li><code>order::string, optional, default='C'</code>: Read the elements of a using this index order, and place the elements into the reshaped array using this index order. 'C' means to read/write the elements using C-like index order, with the last axis index changing fastest, back to the first axis index changing slowest. Note that currently only C-like order is supported</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L355' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npx_reshape_like-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npx_reshape_like-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npx_reshape_like</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npx_reshape_like(lhs, rhs, lhs_begin, lhs_end, rhs_begin, rhs_end)
</code></pre>

<p><em>npx</em>reshape<em>like is an alias of reshape</em>like.</p>
<p>Reshape some or all dimensions of <code>lhs</code> to have the same shape as some or all dimensions of <code>rhs</code>.</p>
<p>Returns a <strong>view</strong> of the <code>lhs</code> array with a new shape without altering any data.</p>
<p>Example::</p>
<p>x = [1, 2, 3, 4, 5, 6]   y = [[0, -4], [3, 2], [2, 2]]   reshape_like(x, y) = [[1, 2], [3, 4], [5, 6]]</p>
<p>More precise control over how dimensions are inherited is achieved by specifying 
slices over the <code>lhs</code> and <code>rhs</code> array dimensions. Only the sliced <code>lhs</code> dimensions 
are reshaped to the <code>rhs</code> sliced dimensions, with the non-sliced <code>lhs</code> dimensions staying the same.</p>
<p>Examples::</p>
<ul>
<li>lhs shape = (30,7), rhs shape = (15,2,4), lhs<em>begin=0, lhs</em>end=1, rhs<em>begin=0, rhs</em>end=2, output shape = (15,2,7)</li>
<li>lhs shape = (3, 5), rhs shape = (1,15,4), lhs<em>begin=0, lhs</em>end=2, rhs<em>begin=1, rhs</em>end=2, output shape = (15)</li>
</ul>
<p>Negative indices are supported, and <code>None</code> can be used for either <code>lhs_end</code> or <code>rhs_end</code> to indicate the end of the range.</p>
<p>Example::</p>
<ul>
<li>lhs shape = (30, 12), rhs shape = (4, 2, 2, 3), lhs<em>begin=-1, lhs</em>end=None, rhs<em>begin=1, rhs</em>end=None, output shape = (30, 2, 2, 3)</li>
</ul>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_basic.cc:L511</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: First input.</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: Second input.</li>
<li><code>lhs_begin::int or None, optional, default='None'</code>: Defaults to 0. The beginning index along which the lhs dimensions are to be reshaped. Supports negative indices.</li>
<li><code>lhs_end::int or None, optional, default='None'</code>: Defaults to None. The ending index along which the lhs dimensions are to be used for reshaping. Supports negative indices.</li>
<li><code>rhs_begin::int or None, optional, default='None'</code>: Defaults to 0. The beginning index along which the rhs dimensions are to be used for reshaping. Supports negative indices.</li>
<li><code>rhs_end::int or None, optional, default='None'</code>: Defaults to None. The ending index along which the rhs dimensions are to be used for reshaping. Supports negative indices.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L386' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npx_rnn-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npx_rnn-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npx_rnn</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npx_rnn(data, parameters, state, state_cell, sequence_length, state_size, num_layers, bidirectional, mode, p, state_outputs, projection_size, lstm_state_clip_min, lstm_state_clip_max, lstm_state_clip_nan, use_sequence_length)
</code></pre>

<p><em>npx</em>rnn is an alias of RNN.</p>
<p>Applies recurrent layers to input data. Currently, vanilla RNN, LSTM and GRU are implemented, with both multi-layer and bidirectional support.</p>
<p>When the input data is of type float32 and the environment variables MXNET<em>CUDA</em>ALLOW<em>TENSOR</em>CORE and MXNET<em>CUDA</em>TENSOR<em>OP</em>MATH<em>ALLOW</em>CONVERSION are set to 1, this operator will try to use pseudo-float16 precision (float32 math with float16 I/O) precision in order to use Tensor Cores on suitable NVIDIA GPUs. This can sometimes give significant speedups.</p>
<p><strong>Vanilla RNN</strong></p>
<p>Applies a single-gate recurrent layer to input X. Two kinds of activation function are supported: ReLU and Tanh.</p>
<p>With ReLU activation function:</p>
<p>.. math::     h<em ih="ih">t = relu(W</em> * x<em ih="ih">t + b</em>  +  W<em _t-1_="(t-1)">{hh} * h</em> + b_{hh})</p>
<p>With Tanh activtion function:</p>
<p>.. math::     h<em ih="ih">t = \tanh(W</em> * x<em ih="ih">t + b</em>  +  W<em _t-1_="(t-1)">{hh} * h</em> + b_{hh})</p>
<p>Reference paper: Finding structure in time - Elman, 1988. https://crl.ucsd.edu/~elman/Papers/fsit.pdf</p>
<p><strong>LSTM</strong></p>
<p>Long Short-Term Memory - Hochreiter, 1997. http://www.bioinf.jku.at/publications/older/2604.pdf</p>
<p>.. math::   <script type="math/tex; mode=display">\begin{array}{ll}             i*t = \mathrm{sigmoid}(W*{ii} x*t + b*{ii} + W*{hi} h*{(t-1)} + b*{hi}) \
            f*t = \mathrm{sigmoid}(W*{if} x*t + b*{if} + W*{hf} h*{(t-1)} + b*{hf}) \
            g*t = \tanh(W*{ig} x*t + b*{ig} + W*{hc} h*{(t-1)} + b*{hg}) \
            o*t = \mathrm{sigmoid}(W*{io} x*t + b*{io} + W*{ho} h*{(t-1)} + b*{ho}) \
            c*t = f*t * c*{(t-1)} + i*t * g*t \
            h*t = o*t * \tanh(c*t)             \end{array}</script>
</p>
<p>With the projection size being set, LSTM could use the projection feature to reduce the parameters size and give some speedups without significant damage to the accuracy.</p>
<p>Long Short-Term Memory Based Recurrent Neural Network Architectures for Large Vocabulary Speech Recognition - Sak et al. 2014. https://arxiv.org/abs/1402.1128</p>
<p>.. math::   <script type="math/tex; mode=display">\begin{array}{ll}             i*t = \mathrm{sigmoid}(W*{ii} x*t + b*{ii} + W*{ri} r*{(t-1)} + b*{ri}) \
            f*t = \mathrm{sigmoid}(W*{if} x*t + b*{if} + W*{rf} r*{(t-1)} + b*{rf}) \
            g*t = \tanh(W*{ig} x*t + b*{ig} + W*{rc} r*{(t-1)} + b*{rg}) \
            o*t = \mathrm{sigmoid}(W*{io} x*t + b*{o} + W*{ro} r*{(t-1)} + b*{ro}) \
            c*t = f*t * c*{(t-1)} + i*t * g*t \
            h*t = o*t * \tanh(c*t)             r*t = W*{hr} h_t             \end{array}</script>
</p>
<p><strong>GRU</strong></p>
<p>Gated Recurrent Unit - Cho et al. 2014. http://arxiv.org/abs/1406.1078</p>
<p>The definition of GRU here is slightly different from paper but compatible with CUDNN.</p>
<p>.. math::   <script type="math/tex; mode=display">\begin{array}{ll}             r*t = \mathrm{sigmoid}(W*{ir} x*t + b*{ir} + W*{hr} h*{(t-1)} + b*{hr}) \
            z*t = \mathrm{sigmoid}(W*{iz} x*t + b*{iz} + W*{hz} h*{(t-1)} + b*{hz}) \
            n*t = \tanh(W*{in} x*t + b*{in} + r*t * (W*{hn} h*{(t-1)}+ b*{hn})) \
            h*t = (1 - z*t) * n*t + z*t * h_{(t-1)} \
            \end{array}</script>
</p>
<p>Defined in src/operator/rnn.cc:L368</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data to RNN</li>
<li><code>parameters::NDArray-or-SymbolicNode</code>: Vector of all RNN trainable parameters concatenated</li>
<li><code>state::NDArray-or-SymbolicNode</code>: initial hidden state of the RNN</li>
<li><code>state_cell::NDArray-or-SymbolicNode</code>: initial cell state for LSTM networks (only for LSTM)</li>
<li><code>sequence_length::NDArray-or-SymbolicNode</code>: Vector of valid sequence lengths for each element in batch. (Only used if use<em>sequence</em>length kwarg is True)</li>
<li><code>state_size::int (non-negative), required</code>: size of the state for each layer</li>
<li><code>num_layers::int (non-negative), required</code>: number of stacked layers</li>
<li><code>bidirectional::boolean, optional, default=0</code>: whether to use bidirectional recurrent layers</li>
<li><code>mode::{'gru', 'lstm', 'rnn_relu', 'rnn_tanh'}, required</code>: the type of RNN to compute</li>
<li><code>p::float, optional, default=0</code>: drop rate of the dropout on the outputs of each RNN layer, except the last layer.</li>
<li><code>state_outputs::boolean, optional, default=0</code>: Whether to have the states as symbol outputs.</li>
<li><code>projection_size::int or None, optional, default='None'</code>: size of project size</li>
<li><code>lstm_state_clip_min::double or None, optional, default=None</code>: Minimum clip value of LSTM states. This option must be used together with lstm<em>state</em>clip_max.</li>
<li><code>lstm_state_clip_max::double or None, optional, default=None</code>: Maximum clip value of LSTM states. This option must be used together with lstm<em>state</em>clip_min.</li>
<li><code>lstm_state_clip_nan::boolean, optional, default=0</code>: Whether to stop NaN from propagating in state by clipping it to min/max. If clipping range is not specified, this option is ignored.</li>
<li><code>use_sequence_length::boolean, optional, default=0</code>: If set to true, this layer takes in an extra input parameter <code>sequence_length</code> to specify variable length sequence</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L451' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npx_roi_pooling-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npx_roi_pooling-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npx_roi_pooling</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npx_roi_pooling(data, rois, pooled_size, spatial_scale)
</code></pre>

<p><em>npx</em>roi_pooling is an alias of ROIPooling.</p>
<p>Performs region of interest(ROI) pooling on the input array.</p>
<p>ROI pooling is a variant of a max pooling layer, in which the output size is fixed and region of interest is a parameter. Its purpose is to perform max pooling on the inputs of non-uniform sizes to obtain fixed-size feature maps. ROI pooling is a neural-net layer mostly used in training a <code>Fast R-CNN</code> network for object detection.</p>
<p>This operator takes a 4D feature map as an input array and region proposals as <code>rois</code>, then it pools over sub-regions of input and produces a fixed-sized output array regardless of the ROI size.</p>
<p>To crop the feature map accordingly, you can resize the bounding box coordinates by changing the parameters <code>rois</code> and <code>spatial_scale</code>.</p>
<p>The cropped feature maps are pooled by standard max pooling operation to a fixed size output indicated by a <code>pooled_size</code> parameter. batch_size will change to the number of region bounding boxes after <code>ROIPooling</code>.</p>
<p>The size of each region of interest doesn't have to be perfectly divisible by the number of pooling sections(<code>pooled_size</code>).</p>
<p>Example::</p>
<p>x = [[[[  0.,   1.,   2.,   3.,   4.,   5.],          [  6.,   7.,   8.,   9.,  10.,  11.],          [ 12.,  13.,  14.,  15.,  16.,  17.],          [ 18.,  19.,  20.,  21.,  22.,  23.],          [ 24.,  25.,  26.,  27.,  28.,  29.],          [ 30.,  31.,  32.,  33.,  34.,  35.],          [ 36.,  37.,  38.,  39.,  40.,  41.],          [ 42.,  43.,  44.,  45.,  46.,  47.]]]]</p>
<p>// region of interest i.e. bounding box coordinates.   y = [[0,0,0,4,4]]</p>
<p>// returns array of shape (2,2) according to the given roi with max pooling.   ROIPooling(x, y, (2,2), 1.0) = [[[[ 14.,  16.],                                     [ 26.,  28.]]]]</p>
<p>// region of interest is changed due to the change in <code>spacial_scale</code> parameter.   ROIPooling(x, y, (2,2), 0.7) = [[[[  7.,   9.],                                     [ 19.,  21.]]]]</p>
<p>Defined in src/operator/roi_pooling.cc:L225</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array to the pooling operator,  a 4D Feature maps</li>
<li><code>rois::NDArray-or-SymbolicNode</code>: Bounding box coordinates, a 2D array of [[batch*index, x1, y1, x2, y2]], where (x1, y1) and (x2, y2) are top left and bottom right corners of designated region of interest. <code>batch*index</code> indicates the index of corresponding image in the input array</li>
<li><code>pooled_size::Shape(tuple), required</code>: ROI pooling output shape (h,w)</li>
<li><code>spatial_scale::float, required</code>: Ratio of input feature map height (or w) to raw image height (or w). Equals the reciprocal of total stride in convolutional layers</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L400' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npx_sequence_mask-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npx_sequence_mask-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npx_sequence_mask</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npx_sequence_mask(data, sequence_length, use_sequence_length, value, axis)
</code></pre>

<p><em>npx</em>sequence_mask is an alias of SequenceMask.</p>
<p>Sets all elements outside the sequence to a constant value.</p>
<p>This function takes an n-dimensional input array of the form [max<em>sequence</em>length, batch<em>size, other</em>feature_dims] and returns an array of the same shape.</p>
<p>Parameter <code>sequence_length</code> is used to handle variable-length sequences. <code>sequence_length</code> should be an input array of positive ints of dimension [batch*size]. To use this parameter, set <code>use*sequence_length</code>to<code>True</code>, otherwise each example in the batch is assumed to have the max sequence length and this operator works as the<code>identity</code> operator.</p>
<p>Example::</p>
<p>x = [[[  1.,   2.,   3.],          [  4.,   5.,   6.]],</p>
<pre><code>    [[  7.,   8.,   9.],
     [ 10.,  11.,  12.]],

    [[ 13.,  14.,   15.],
     [ 16.,  17.,   18.]]]
</code></pre>

<p>// Batch 1    B1 = [[  1.,   2.,   3.],          [  7.,   8.,   9.],          [ 13.,  14.,  15.]]</p>
<p>// Batch 2    B2 = [[  4.,   5.,   6.],          [ 10.,  11.,  12.],          [ 16.,  17.,  18.]]</p>
<p>// works as identity operator when sequence_length parameter is not used    SequenceMask(x) = [[[  1.,   2.,   3.],                        [  4.,   5.,   6.]],</p>
<pre><code>                  [[  7.,   8.,   9.],
                   [ 10.,  11.,  12.]],

                  [[ 13.,  14.,   15.],
                   [ 16.,  17.,   18.]]]
</code></pre>

<p>// sequence<em>length [1,1] means 1 of each batch will be kept    // and other rows are masked with default mask value = 0    SequenceMask(x, sequence</em>length=[1,1], use<em>sequence</em>length=True) =                 [[[  1.,   2.,   3.],                   [  4.,   5.,   6.]],</p>
<pre><code>             [[  0.,   0.,   0.],
              [  0.,   0.,   0.]],

             [[  0.,   0.,   0.],
              [  0.,   0.,   0.]]]
</code></pre>

<p>// sequence<em>length [2,3] means 2 of batch B1 and 3 of batch B2 will be kept    // and other rows are masked with value = 1    SequenceMask(x, sequence</em>length=[2,3], use<em>sequence</em>length=True, value=1) =                 [[[  1.,   2.,   3.],                   [  4.,   5.,   6.]],</p>
<pre><code>             [[  7.,   8.,   9.],
              [  10.,  11.,  12.]],

             [[   1.,   1.,   1.],
              [  16.,  17.,  18.]]]
</code></pre>

<p>Defined in src/operator/sequence_mask.cc:L186</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: n-dimensional input array of the form [max<em>sequence</em>length, batch<em>size, other</em>feature_dims] where n&gt;2</li>
<li><code>sequence_length::NDArray-or-SymbolicNode</code>: vector of sequence lengths of the form [batch_size]</li>
<li><code>use_sequence_length::boolean, optional, default=0</code>: If set to true, this layer takes in an extra input parameter <code>sequence_length</code> to specify variable length sequence</li>
<li><code>value::float, optional, default=0</code>: The value to be used as a mask.</li>
<li><code>axis::int, optional, default='0'</code>: The sequence axis. Only values of 0 and 1 are currently supported.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L425' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npx_shape_array-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npx_shape_array-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npx_shape_array</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npx_shape_array(data)
</code></pre>

<p><em>npx</em>shape<em>array is an alias of shape</em>array.</p>
<p>Returns a 1D int64 array containing the shape of data.</p>
<p>Example::</p>
<p>shape_array([[1,2,3,4], [5,6,7,8]]) = [2,4]</p>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_basic.cc:L573</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input Array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L357' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npx_sigmoid-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npx_sigmoid-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npx_sigmoid</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npx_sigmoid(data)
</code></pre>

<p>Computes sigmoid of x element-wise. .. math::    y = 1 / (1 + exp(-x))</p>
<p>Defined in src/operator/numpy/np<em>elemwise</em>unary<em>op</em>basic.cc:L42</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L352' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npx_slice-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npx_slice-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npx_slice</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npx_slice(data, begin, end, step)
</code></pre>

<p><em>npx</em>slice is an alias of slice.</p>
<p>Slices a region of the array. .. note:: $crop$ is deprecated. Use $slice$ instead. This function returns a sliced array between the indices given by <code>begin</code> and <code>end</code> with the corresponding <code>step</code>. For an input array of $shape=(d_0, d_1, ..., d_n-1)$, slice operation with $begin=(b_0, b_1...b_m-1)$, $end=(e_0, e_1, ..., e_m-1)$, and $step=(s_0, s_1, ..., s_m-1)$, where m &lt;= n, results in an array with the shape $(|e_0-b_0|/|s_0|, ..., |e_m-1-b_m-1|/|s_m-1|, d_m, ..., d_n-1)$. The resulting array's <em>k</em>-th dimension contains elements from the <em>k</em>-th dimension of the input array starting from index $b_k$ (inclusive) with step $s_k$ until reaching $e_k$ (exclusive). If the <em>k</em>-th elements are <code>None</code> in the sequence of <code>begin</code>, <code>end</code>, and <code>step</code>, the following rule will be used to set default values. If <code>s_k</code> is <code>None</code>, set <code>s_k=1</code>. If <code>s_k &gt; 0</code>, set <code>b_k=0</code>, <code>e_k=d_k</code>; else, set <code>b_k=d_k-1</code>, <code>e_k=-1</code>. The storage type of $slice$ output depends on storage types of inputs</p>
<ul>
<li>slice(csr) = csr</li>
<li>otherwise, $slice$ generates output with default storage</li>
</ul>
<p>.. note:: When input data storage type is csr, it only supports    step=(), or step=(None,), or step=(1,) to generate a csr output.    For other step parameter values, it falls back to slicing    a dense tensor. Example::   x = [[  1.,   2.,   3.,   4.],        [  5.,   6.,   7.,   8.],        [  9.,  10.,  11.,  12.]]   slice(x, begin=(0,1), end=(2,4)) = [[ 2.,  3.,  4.],                                      [ 6.,  7.,  8.]]   slice(x, begin=(None, 0), end=(None, 3), step=(-1, 2)) = [[9., 11.],                                                             [5.,  7.],                                                             [1.,  3.]]</p>
<p>Defined in src/operator/tensor/matrix_op.cc:L482</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Source input</li>
<li><code>begin::Shape(tuple), required</code>: starting indices for the slice operation, supports negative indices.</li>
<li><code>end::Shape(tuple), required</code>: ending indices for the slice operation, supports negative indices.</li>
<li><code>step::Shape(tuple), optional, default=[]</code>: step for the slice operation, supports negative values.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L390' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npx_smooth_l1-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npx_smooth_l1-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npx_smooth_l1</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npx_smooth_l1(data, scalar)
</code></pre>

<p><em>npx</em>smooth<em>l1 is an alias of smooth</em>l1.</p>
<p>Calculate Smooth L1 Loss(lhs, scalar) by summing</p>
<p>.. math::</p>
<pre><code>f(x) =
\begin{cases}
(\sigma x)^2/2,&amp; \text{if }x &lt; 1/\sigma^2\\
|x|-0.5/\sigma^2,&amp; \text{otherwise}
\end{cases}
</code></pre>

<p>where :math:<code>x</code> is an element of the tensor <em>lhs</em> and :math:<code>\sigma</code> is the scalar.</p>
<p>Example::</p>
<p>smooth<em>l1([1, 2, 3, 4]) = [0.5, 1.5, 2.5, 3.5]   smooth</em>l1([1, 2, 3, 4], scalar=1) = [0.5, 1.5, 2.5, 3.5]</p>
<p>Defined in src/operator/tensor/elemwise<em>binary</em>scalar<em>op</em>extended.cc:L108</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L370' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npx_softmax-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npx_softmax-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npx_softmax</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npx_softmax(data, length, axis, temperature, dtype, use_length)
</code></pre>

<p><em>npx</em>softmax is an alias of softmax.</p>
<p>Applies the softmax function.</p>
<p>The resulting array contains elements in the range (0,1) and the elements along the given axis sum up to 1.</p>
<p>.. math::    softmax(\mathbf{z/t})<em>j = \frac{e^{z</em>j/t}}{\sum<em>{k=1}^K e^{z</em>k/t}}</p>
<p>for :math:<code>j = 1, ..., K</code></p>
<p>t is the temperature parameter in softmax function. By default, t equals 1.0</p>
<p>Example::</p>
<p>x = [[ 1.  1.  1.]        [ 1.  1.  1.]]</p>
<p>softmax(x,axis=0) = [[ 0.5  0.5  0.5]                        [ 0.5  0.5  0.5]]</p>
<p>softmax(x,axis=1) = [[ 0.33333334,  0.33333334,  0.33333334],                        [ 0.33333334,  0.33333334,  0.33333334]]</p>
<p>Defined in src/operator/nn/softmax.cc:L134</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>length::NDArray-or-SymbolicNode</code>: The length array.</li>
<li><code>axis::int, optional, default='-1'</code>: The axis along which to compute softmax.</li>
<li><code>temperature::double or None, optional, default=None</code>: Temperature parameter in softmax</li>
<li><code>dtype::{None, 'float16', 'float32', 'float64'},optional, default='None'</code>: DType of the output in case this can't be inferred. Defaults to the same as input's dtype if not defined (dtype=None).</li>
<li><code>use_length::boolean or None, optional, default=0</code>: Whether to use the length input as a mask over the data input.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L383' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._npx_topk-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._npx_topk-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._npx_topk</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_npx_topk(data, axis, k, ret_typ, is_ascend, dtype)
</code></pre>

<p><em>npx</em>topk is an alias of topk.</p>
<p>Returns the indices of the top <em>k</em> elements in an input array along the given  axis (by default).  If ret<em>type is set to 'value' returns the value of top </em>k<em> elements (instead of indices).  In case of ret</em>type = 'both', both value and index would be returned.  The returned elements will be sorted.</p>
<p>Examples::</p>
<p>x = [[ 0.3,  0.2,  0.4],        [ 0.1,  0.3,  0.2]]</p>
<p>// returns an index of the largest element on last axis   topk(x) = [[ 2.],              [ 1.]]</p>
<p>// returns the value of top-2 largest elements on last axis   topk(x, ret_typ='value', k=2) = [[ 0.4,  0.3],                                    [ 0.3,  0.2]]</p>
<p>// returns the value of top-2 smallest elements on last axis   topk(x, ret<em>typ='value', k=2, is</em>ascend=1) = [[ 0.2 ,  0.3],                                                [ 0.1 ,  0.2]]</p>
<p>// returns the value of top-2 largest elements on axis 0   topk(x, axis=0, ret_typ='value', k=2) = [[ 0.3,  0.3,  0.4],                                            [ 0.1,  0.2,  0.2]]</p>
<p>// flattens and then returns list of both values and indices   topk(x, ret_typ='both', k=2) = [[[ 0.4,  0.3], [ 0.3,  0.2]] ,  [[ 2.,  0.], [ 1.,  2.]]]</p>
<p>Defined in src/operator/tensor/ordering_op.cc:L68</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array</li>
<li><code>axis::int or None, optional, default='-1'</code>: Axis along which to choose the top k indices. If not given, the flattened array is used. Default is -1.</li>
<li><code>k::int, optional, default='1'</code>: Number of top elements to select, should be always smaller than or equal to the element number in the given axis. A global sort is performed if set k &lt; 1.</li>
<li><code>ret_typ::{'both', 'indices', 'mask', 'value'},optional, default='indices'</code>: The return type.</li>
</ul>
<p>"value" means to return the top k values, "indices" means to return the indices of the top k values, "mask" means to return a mask array containing 0 and 1. 1 means the top k values. "both" means to return a list of both values and indices of top k elements.</p>
<ul>
<li><code>is_ascend::boolean, optional, default=0</code>: Whether to choose k largest or k smallest elements. Top K largest elements will be chosen if set to false.</li>
<li><code>dtype::{'float16', 'float32', 'float64', 'int32', 'int64', 'uint8'},optional, default='float32'</code>: DType of the output indices when ret_typ is "indices" or "both". An error will be raised if the selected data type cannot precisely represent the indices.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L392' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._onehot_encode-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._onehot_encode-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._onehot_encode</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_onehot_encode(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray</code>: Left operand to the function.</li>
<li><code>rhs::NDArray</code>: Right operand to the function.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._ones-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._ones-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._ones</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_ones(shape, ctx, dtype)
</code></pre>

<p>fill target with ones</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>shape::Shape(tuple), optional, default=[]</code>: The shape of the output</li>
<li><code>ctx::string, optional, default=''</code>: Context of output, in format <a href="n">cpu|gpu|cpu_pinned</a>.Only used for imperative calls.</li>
<li><code>dtype::{'bfloat16', 'bool', 'float16', 'float32', 'float64', 'int32', 'int64', 'int8', 'uint8'},optional, default='float32'</code>: Target data type.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._plus-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._plus-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._plus</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_plus(lhs, rhs)
</code></pre>

<p><em>plus is an alias of elemwise</em>add.</p>
<p>Adds arguments element-wise.</p>
<p>The storage type of $elemwise_add$ output depends on storage types of inputs</p>
<ul>
<li>elemwise<em>add(row</em>sparse, row<em>sparse) = row</em>sparse</li>
<li>elemwise_add(csr, csr) = csr</li>
<li>elemwise_add(default, csr) = default</li>
<li>elemwise_add(csr, default) = default</li>
<li>elemwise_add(default, rsp) = default</li>
<li>elemwise_add(rsp, default) = default</li>
<li>otherwise, $elemwise_add$ generates output with default storage</li>
</ul>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L363' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._plus_scalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._plus_scalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._plus_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_plus_scalar(data, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._power-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._power-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._power</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_power(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._power_scalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._power_scalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._power_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_power_scalar(data, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._random_exponential-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._random_exponential-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._random_exponential</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_random_exponential(lam, shape, ctx, dtype)
</code></pre>

<p>Draw random samples from an exponential distribution.</p>
<p>Samples are distributed according to an exponential distribution parametrized by <em>lambda</em> (rate).</p>
<p>Example::</p>
<p>exponential(lam=4, shape=(2,2)) = [[ 0.0097189 ,  0.08999364],                                       [ 0.04146638,  0.31715935]]</p>
<p>Defined in src/operator/random/sample_op.cc:L137</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lam::float, optional, default=1</code>: Lambda parameter (rate) of the exponential distribution.</li>
<li><code>shape::Shape(tuple), optional, default=None</code>: Shape of the output.</li>
<li><code>ctx::string, optional, default=''</code>: Context of output, in format <a href="n">cpu|gpu|cpu_pinned</a>. Only used for imperative calls.</li>
<li><code>dtype::{'None', 'float16', 'float32', 'float64'},optional, default='None'</code>: DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L363' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._random_exponential_like-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._random_exponential_like-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._random_exponential_like</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_random_exponential_like(lam, data)
</code></pre>

<p>Draw random samples from an exponential distribution according to the input array shape.</p>
<p>Samples are distributed according to an exponential distribution parametrized by <em>lambda</em> (rate).</p>
<p>Example::</p>
<p>exponential(lam=4, data=ones(2,2)) = [[ 0.0097189 ,  0.08999364],                                          [ 0.04146638,  0.31715935]]</p>
<p>Defined in src/operator/random/sample_op.cc:L243</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lam::float, optional, default=1</code>: Lambda parameter (rate) of the exponential distribution.</li>
<li><code>data::NDArray-or-SymbolicNode</code>: The input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L359' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._random_gamma-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._random_gamma-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._random_gamma</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_random_gamma(alpha, beta, shape, ctx, dtype)
</code></pre>

<p>Draw random samples from a gamma distribution.</p>
<p>Samples are distributed according to a gamma distribution parametrized by <em>alpha</em> (shape) and <em>beta</em> (scale).</p>
<p>Example::</p>
<p>gamma(alpha=9, beta=0.5, shape=(2,2)) = [[ 7.10486984,  3.37695289],                                             [ 3.91697288,  3.65933681]]</p>
<p>Defined in src/operator/random/sample_op.cc:L125</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>alpha::float, optional, default=1</code>: Alpha parameter (shape) of the gamma distribution.</li>
<li><code>beta::float, optional, default=1</code>: Beta parameter (scale) of the gamma distribution.</li>
<li><code>shape::Shape(tuple), optional, default=None</code>: Shape of the output.</li>
<li><code>ctx::string, optional, default=''</code>: Context of output, in format <a href="n">cpu|gpu|cpu_pinned</a>. Only used for imperative calls.</li>
<li><code>dtype::{'None', 'float16', 'float32', 'float64'},optional, default='None'</code>: DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L365' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._random_gamma_like-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._random_gamma_like-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._random_gamma_like</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_random_gamma_like(alpha, beta, data)
</code></pre>

<p>Draw random samples from a gamma distribution according to the input array shape.</p>
<p>Samples are distributed according to a gamma distribution parametrized by <em>alpha</em> (shape) and <em>beta</em> (scale).</p>
<p>Example::</p>
<p>gamma(alpha=9, beta=0.5, data=ones(2,2)) = [[ 7.10486984,  3.37695289],                                                [ 3.91697288,  3.65933681]]</p>
<p>Defined in src/operator/random/sample_op.cc:L232</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>alpha::float, optional, default=1</code>: Alpha parameter (shape) of the gamma distribution.</li>
<li><code>beta::float, optional, default=1</code>: Beta parameter (scale) of the gamma distribution.</li>
<li><code>data::NDArray-or-SymbolicNode</code>: The input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L361' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._random_generalized_negative_binomial-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._random_generalized_negative_binomial-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._random_generalized_negative_binomial</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_random_generalized_negative_binomial(mu, alpha, shape, ctx, dtype)
</code></pre>

<p>Draw random samples from a generalized negative binomial distribution.</p>
<p>Samples are distributed according to a generalized negative binomial distribution parametrized by <em>mu</em> (mean) and <em>alpha</em> (dispersion). <em>alpha</em> is defined as <em>1/k</em> where <em>k</em> is the failure limit of the number of unsuccessful experiments (generalized to real numbers). Samples will always be returned as a floating point data type.</p>
<p>Example::</p>
<p>generalized<em>negative</em>binomial(mu=2.0, alpha=0.3, shape=(2,2)) = [[ 2.,  1.],                                                                     [ 6.,  4.]]</p>
<p>Defined in src/operator/random/sample_op.cc:L179</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>mu::float, optional, default=1</code>: Mean of the negative binomial distribution.</li>
<li><code>alpha::float, optional, default=1</code>: Alpha (dispersion) parameter of the negative binomial distribution.</li>
<li><code>shape::Shape(tuple), optional, default=None</code>: Shape of the output.</li>
<li><code>ctx::string, optional, default=''</code>: Context of output, in format <a href="n">cpu|gpu|cpu_pinned</a>. Only used for imperative calls.</li>
<li><code>dtype::{'None', 'float16', 'float32', 'float64'},optional, default='None'</code>: DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L368' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._random_generalized_negative_binomial_like-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._random_generalized_negative_binomial_like-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._random_generalized_negative_binomial_like</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_random_generalized_negative_binomial_like(mu, alpha, data)
</code></pre>

<p>Draw random samples from a generalized negative binomial distribution according to the input array shape.</p>
<p>Samples are distributed according to a generalized negative binomial distribution parametrized by <em>mu</em> (mean) and <em>alpha</em> (dispersion). <em>alpha</em> is defined as <em>1/k</em> where <em>k</em> is the failure limit of the number of unsuccessful experiments (generalized to real numbers). Samples will always be returned as a floating point data type.</p>
<p>Example::</p>
<p>generalized<em>negative</em>binomial(mu=2.0, alpha=0.3, data=ones(2,2)) = [[ 2.,  1.],                                                                        [ 6.,  4.]]</p>
<p>Defined in src/operator/random/sample_op.cc:L284</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>mu::float, optional, default=1</code>: Mean of the negative binomial distribution.</li>
<li><code>alpha::float, optional, default=1</code>: Alpha (dispersion) parameter of the negative binomial distribution.</li>
<li><code>data::NDArray-or-SymbolicNode</code>: The input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L365' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._random_negative_binomial-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._random_negative_binomial-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._random_negative_binomial</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_random_negative_binomial(k, p, shape, ctx, dtype)
</code></pre>

<p>Draw random samples from a negative binomial distribution.</p>
<p>Samples are distributed according to a negative binomial distribution parametrized by <em>k</em> (limit of unsuccessful experiments) and <em>p</em> (failure probability in each experiment). Samples will always be returned as a floating point data type.</p>
<p>Example::</p>
<p>negative_binomial(k=3, p=0.4, shape=(2,2)) = [[ 4.,  7.],                                                  [ 2.,  5.]]</p>
<p>Defined in src/operator/random/sample_op.cc:L164</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>k::int, optional, default='1'</code>: Limit of unsuccessful experiments.</li>
<li><code>p::float, optional, default=1</code>: Failure probability in each experiment.</li>
<li><code>shape::Shape(tuple), optional, default=None</code>: Shape of the output.</li>
<li><code>ctx::string, optional, default=''</code>: Context of output, in format <a href="n">cpu|gpu|cpu_pinned</a>. Only used for imperative calls.</li>
<li><code>dtype::{'None', 'float16', 'float32', 'float64'},optional, default='None'</code>: DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L367' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._random_negative_binomial_like-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._random_negative_binomial_like-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._random_negative_binomial_like</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_random_negative_binomial_like(k, p, data)
</code></pre>

<p>Draw random samples from a negative binomial distribution according to the input array shape.</p>
<p>Samples are distributed according to a negative binomial distribution parametrized by <em>k</em> (limit of unsuccessful experiments) and <em>p</em> (failure probability in each experiment). Samples will always be returned as a floating point data type.</p>
<p>Example::</p>
<p>negative_binomial(k=3, p=0.4, data=ones(2,2)) = [[ 4.,  7.],                                                     [ 2.,  5.]]</p>
<p>Defined in src/operator/random/sample_op.cc:L268</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>k::int, optional, default='1'</code>: Limit of unsuccessful experiments.</li>
<li><code>p::float, optional, default=1</code>: Failure probability in each experiment.</li>
<li><code>data::NDArray-or-SymbolicNode</code>: The input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L363' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._random_normal-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._random_normal-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._random_normal</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_random_normal(loc, scale, shape, ctx, dtype)
</code></pre>

<p>Draw random samples from a normal (Gaussian) distribution.</p>
<p>.. note:: The existing alias $normal$ is deprecated.</p>
<p>Samples are distributed according to a normal distribution parametrized by <em>loc</em> (mean) and <em>scale</em> (standard deviation).</p>
<p>Example::</p>
<p>normal(loc=0, scale=1, shape=(2,2)) = [[ 1.89171135, -1.16881478],                                           [-1.23474145,  1.55807114]]</p>
<p>Defined in src/operator/random/sample_op.cc:L113</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>loc::float, optional, default=0</code>: Mean of the distribution.</li>
<li><code>scale::float, optional, default=1</code>: Standard deviation of the distribution.</li>
<li><code>shape::Shape(tuple), optional, default=None</code>: Shape of the output.</li>
<li><code>ctx::string, optional, default=''</code>: Context of output, in format <a href="n">cpu|gpu|cpu_pinned</a>. Only used for imperative calls.</li>
<li><code>dtype::{'None', 'float16', 'float32', 'float64'},optional, default='None'</code>: DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L368' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._random_normal_like-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._random_normal_like-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._random_normal_like</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_random_normal_like(loc, scale, data)
</code></pre>

<p>Draw random samples from a normal (Gaussian) distribution according to the input array shape.</p>
<p>Samples are distributed according to a normal distribution parametrized by <em>loc</em> (mean) and <em>scale</em> (standard deviation).</p>
<p>Example::</p>
<p>normal(loc=0, scale=1, data=ones(2,2)) = [[ 1.89171135, -1.16881478],                                              [-1.23474145,  1.55807114]]</p>
<p>Defined in src/operator/random/sample_op.cc:L221</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>loc::float, optional, default=0</code>: Mean of the distribution.</li>
<li><code>scale::float, optional, default=1</code>: Standard deviation of the distribution.</li>
<li><code>data::NDArray-or-SymbolicNode</code>: The input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L362' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._random_pdf_dirichlet-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._random_pdf_dirichlet-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._random_pdf_dirichlet</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_random_pdf_dirichlet(sample, alpha, is_log)
</code></pre>

<p>Computes the value of the PDF of <em>sample</em> of Dirichlet distributions with parameter <em>alpha</em>.</p>
<p>The shape of <em>alpha</em> must match the leftmost subshape of <em>sample</em>.  That is, <em>sample</em> can have the same shape as <em>alpha</em>, in which case the output contains one density per distribution, or <em>sample</em> can be a tensor of tensors with that shape, in which case the output is a tensor of densities such that the densities at index <em>i</em> in the output are given by the samples at index <em>i</em> in <em>sample</em> parameterized by the value of <em>alpha</em> at index <em>i</em>.</p>
<p>Examples::</p>
<pre><code>random_pdf_dirichlet(sample=[[1,2],[2,3],[3,4]], alpha=[2.5, 2.5]) =
    [38.413498, 199.60245, 564.56085]

sample = [[[1, 2, 3], [10, 20, 30], [100, 200, 300]],
          [[0.1, 0.2, 0.3], [0.01, 0.02, 0.03], [0.001, 0.002, 0.003]]]

random_pdf_dirichlet(sample=sample, alpha=[0.1, 0.4, 0.9]) =
    [[2.3257459e-02, 5.8420084e-04, 1.4674458e-05],
     [9.2589635e-01, 3.6860607e+01, 1.4674468e+03]]
</code></pre>

<p>Defined in src/operator/random/pdf_op.cc:L316</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>sample::NDArray-or-SymbolicNode</code>: Samples from the distributions.</li>
<li><code>alpha::NDArray-or-SymbolicNode</code>: Concentration parameters of the distributions.</li>
<li><code>is_log::boolean, optional, default=0</code>: If set, compute the density of the log-probability instead of the probability.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L374' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._random_pdf_exponential-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._random_pdf_exponential-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._random_pdf_exponential</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_random_pdf_exponential(sample, lam, is_log)
</code></pre>

<p>Computes the value of the PDF of <em>sample</em> of exponential distributions with parameters <em>lam</em> (rate).</p>
<p>The shape of <em>lam</em> must match the leftmost subshape of <em>sample</em>.  That is, <em>sample</em> can have the same shape as <em>lam</em>, in which case the output contains one density per distribution, or <em>sample</em> can be a tensor of tensors with that shape, in which case the output is a tensor of densities such that the densities at index <em>i</em> in the output are given by the samples at index <em>i</em> in <em>sample</em> parameterized by the value of <em>lam</em> at index <em>i</em>.</p>
<p>Examples::</p>
<p>random<em>pdf</em>exponential(sample=[[1, 2, 3]], lam=[1]) =       [[0.36787945, 0.13533528, 0.04978707]]</p>
<p>sample = [[1,2,3],             [1,2,3],             [1,2,3]]</p>
<p>random<em>pdf</em>exponential(sample=sample, lam=[1,0.5,0.25]) =       [[0.36787945, 0.13533528, 0.04978707],        [0.30326533, 0.18393973, 0.11156508],        [0.1947002,  0.15163267, 0.11809164]]</p>
<p>Defined in src/operator/random/pdf_op.cc:L305</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>sample::NDArray-or-SymbolicNode</code>: Samples from the distributions.</li>
<li><code>lam::NDArray-or-SymbolicNode</code>: Lambda (rate) parameters of the distributions.</li>
<li><code>is_log::boolean, optional, default=0</code>: If set, compute the density of the log-probability instead of the probability.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L376' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._random_pdf_gamma-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._random_pdf_gamma-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._random_pdf_gamma</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_random_pdf_gamma(sample, alpha, is_log, beta)
</code></pre>

<p>Computes the value of the PDF of <em>sample</em> of gamma distributions with parameters <em>alpha</em> (shape) and <em>beta</em> (rate).</p>
<p><em>alpha</em> and <em>beta</em> must have the same shape, which must match the leftmost subshape of <em>sample</em>.  That is, <em>sample</em> can have the same shape as <em>alpha</em> and <em>beta</em>, in which case the output contains one density per distribution, or <em>sample</em> can be a tensor of tensors with that shape, in which case the output is a tensor of densities such that the densities at index <em>i</em> in the output are given by the samples at index <em>i</em> in <em>sample</em> parameterized by the values of <em>alpha</em> and <em>beta</em> at index <em>i</em>.</p>
<p>Examples::</p>
<p>random<em>pdf</em>gamma(sample=[[1,2,3,4,5]], alpha=[5], beta=[1]) =       [[0.01532831, 0.09022352, 0.16803136, 0.19536681, 0.17546739]]</p>
<p>sample = [[1, 2, 3, 4, 5],             [2, 3, 4, 5, 6],             [3, 4, 5, 6, 7]]</p>
<p>random<em>pdf</em>gamma(sample=sample, alpha=[5,6,7], beta=[1,1,1]) =       [[0.01532831, 0.09022352, 0.16803136, 0.19536681, 0.17546739],        [0.03608941, 0.10081882, 0.15629345, 0.17546739, 0.16062315],        [0.05040941, 0.10419563, 0.14622283, 0.16062315, 0.14900276]]</p>
<p>Defined in src/operator/random/pdf_op.cc:L303</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>sample::NDArray-or-SymbolicNode</code>: Samples from the distributions.</li>
<li><code>alpha::NDArray-or-SymbolicNode</code>: Alpha (shape) parameters of the distributions.</li>
<li><code>is_log::boolean, optional, default=0</code>: If set, compute the density of the log-probability instead of the probability.</li>
<li><code>beta::NDArray-or-SymbolicNode</code>: Beta (scale) parameters of the distributions.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L378' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._random_pdf_generalized_negative_binomial-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._random_pdf_generalized_negative_binomial-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._random_pdf_generalized_negative_binomial</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_random_pdf_generalized_negative_binomial(sample, mu, is_log, alpha)
</code></pre>

<p>Computes the value of the PDF of <em>sample</em> of generalized negative binomial distributions with parameters <em>mu</em> (mean) and <em>alpha</em> (dispersion).  This can be understood as a reparameterization of the negative binomial, where <em>k</em> = <em>1 / alpha</em> and <em>p</em> = <em>1 / (mu * alpha + 1)</em>.</p>
<p><em>mu</em> and <em>alpha</em> must have the same shape, which must match the leftmost subshape of <em>sample</em>.  That is, <em>sample</em> can have the same shape as <em>mu</em> and <em>alpha</em>, in which case the output contains one density per distribution, or <em>sample</em> can be a tensor of tensors with that shape, in which case the output is a tensor of densities such that the densities at index <em>i</em> in the output are given by the samples at index <em>i</em> in <em>sample</em> parameterized by the values of <em>mu</em> and <em>alpha</em> at index <em>i</em>.</p>
<p>Examples::</p>
<pre><code>random_pdf_generalized_negative_binomial(sample=[[1, 2, 3, 4]], alpha=[1], mu=[1]) =
    [[0.25, 0.125, 0.0625, 0.03125]]

sample = [[1,2,3,4],
          [1,2,3,4]]
random_pdf_generalized_negative_binomial(sample=sample, alpha=[1, 0.6666], mu=[1, 1.5]) =
    [[0.25,       0.125,      0.0625,     0.03125   ],
     [0.26517063, 0.16573331, 0.09667706, 0.05437994]]
</code></pre>

<p>Defined in src/operator/random/pdf_op.cc:L314</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>sample::NDArray-or-SymbolicNode</code>: Samples from the distributions.</li>
<li><code>mu::NDArray-or-SymbolicNode</code>: Means of the distributions.</li>
<li><code>is_log::boolean, optional, default=0</code>: If set, compute the density of the log-probability instead of the probability.</li>
<li><code>alpha::NDArray-or-SymbolicNode</code>: Alpha (dispersion) parameters of the distributions.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L377' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._random_pdf_negative_binomial-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._random_pdf_negative_binomial-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._random_pdf_negative_binomial</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_random_pdf_negative_binomial(sample, k, is_log, p)
</code></pre>

<p>Computes the value of the PDF of samples of negative binomial distributions with parameters <em>k</em> (failure limit) and <em>p</em> (failure probability).</p>
<p><em>k</em> and <em>p</em> must have the same shape, which must match the leftmost subshape of <em>sample</em>.  That is, <em>sample</em> can have the same shape as <em>k</em> and <em>p</em>, in which case the output contains one density per distribution, or <em>sample</em> can be a tensor of tensors with that shape, in which case the output is a tensor of densities such that the densities at index <em>i</em> in the output are given by the samples at index <em>i</em> in <em>sample</em> parameterized by the values of <em>k</em> and <em>p</em> at index <em>i</em>.</p>
<p>Examples::</p>
<pre><code>random_pdf_negative_binomial(sample=[[1,2,3,4]], k=[1], p=a[0.5]) =
    [[0.25, 0.125, 0.0625, 0.03125]]

# Note that k may be real-valued
sample = [[1,2,3,4],
          [1,2,3,4]]
random_pdf_negative_binomial(sample=sample, k=[1, 1.5], p=[0.5, 0.5]) =
    [[0.25,       0.125,      0.0625,     0.03125   ],
     [0.26516506, 0.16572815, 0.09667476, 0.05437956]]
</code></pre>

<p>Defined in src/operator/random/pdf_op.cc:L310</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>sample::NDArray-or-SymbolicNode</code>: Samples from the distributions.</li>
<li><code>k::NDArray-or-SymbolicNode</code>: Limits of unsuccessful experiments.</li>
<li><code>is_log::boolean, optional, default=0</code>: If set, compute the density of the log-probability instead of the probability.</li>
<li><code>p::NDArray-or-SymbolicNode</code>: Failure probabilities in each experiment.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L376' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._random_pdf_normal-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._random_pdf_normal-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._random_pdf_normal</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_random_pdf_normal(sample, mu, is_log, sigma)
</code></pre>

<p>Computes the value of the PDF of <em>sample</em> of normal distributions with parameters <em>mu</em> (mean) and <em>sigma</em> (standard deviation).</p>
<p><em>mu</em> and <em>sigma</em> must have the same shape, which must match the leftmost subshape of <em>sample</em>.  That is, <em>sample</em> can have the same shape as <em>mu</em> and <em>sigma</em>, in which case the output contains one density per distribution, or <em>sample</em> can be a tensor of tensors with that shape, in which case the output is a tensor of densities such that the densities at index <em>i</em> in the output are given by the samples at index <em>i</em> in <em>sample</em> parameterized by the values of <em>mu</em> and <em>sigma</em> at index <em>i</em>.</p>
<p>Examples::</p>
<pre><code>sample = [[-2, -1, 0, 1, 2]]
random_pdf_normal(sample=sample, mu=[0], sigma=[1]) =
    [[0.05399097, 0.24197073, 0.3989423, 0.24197073, 0.05399097]]

random_pdf_normal(sample=sample*2, mu=[0,0], sigma=[1,2]) =
    [[0.05399097, 0.24197073, 0.3989423,  0.24197073, 0.05399097],
     [0.12098537, 0.17603266, 0.19947115, 0.17603266, 0.12098537]]
</code></pre>

<p>Defined in src/operator/random/pdf_op.cc:L300</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>sample::NDArray-or-SymbolicNode</code>: Samples from the distributions.</li>
<li><code>mu::NDArray-or-SymbolicNode</code>: Means of the distributions.</li>
<li><code>is_log::boolean, optional, default=0</code>: If set, compute the density of the log-probability instead of the probability.</li>
<li><code>sigma::NDArray-or-SymbolicNode</code>: Standard deviations of the distributions.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L374' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._random_pdf_poisson-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._random_pdf_poisson-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._random_pdf_poisson</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_random_pdf_poisson(sample, lam, is_log)
</code></pre>

<p>Computes the value of the PDF of <em>sample</em> of Poisson distributions with parameters <em>lam</em> (rate).</p>
<p>The shape of <em>lam</em> must match the leftmost subshape of <em>sample</em>.  That is, <em>sample</em> can have the same shape as <em>lam</em>, in which case the output contains one density per distribution, or <em>sample</em> can be a tensor of tensors with that shape, in which case the output is a tensor of densities such that the densities at index <em>i</em> in the output are given by the samples at index <em>i</em> in <em>sample</em> parameterized by the value of <em>lam</em> at index <em>i</em>.</p>
<p>Examples::</p>
<pre><code>random_pdf_poisson(sample=[[0,1,2,3]], lam=[1]) =
    [[0.36787945, 0.36787945, 0.18393973, 0.06131324]]

sample = [[0,1,2,3],
          [0,1,2,3],
          [0,1,2,3]]

random_pdf_poisson(sample=sample, lam=[1,2,3]) =
    [[0.36787945, 0.36787945, 0.18393973, 0.06131324],
     [0.13533528, 0.27067056, 0.27067056, 0.18044704],
     [0.04978707, 0.14936121, 0.22404182, 0.22404182]]
</code></pre>

<p>Defined in src/operator/random/pdf_op.cc:L307</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>sample::NDArray-or-SymbolicNode</code>: Samples from the distributions.</li>
<li><code>lam::NDArray-or-SymbolicNode</code>: Lambda (rate) parameters of the distributions.</li>
<li><code>is_log::boolean, optional, default=0</code>: If set, compute the density of the log-probability instead of the probability.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L376' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._random_pdf_uniform-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._random_pdf_uniform-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._random_pdf_uniform</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_random_pdf_uniform(sample, low, is_log, high)
</code></pre>

<p>Computes the value of the PDF of <em>sample</em> of uniform distributions on the intervals given by <em>[low,high)</em>.</p>
<p><em>low</em> and <em>high</em> must have the same shape, which must match the leftmost subshape of <em>sample</em>.  That is, <em>sample</em> can have the same shape as <em>low</em> and <em>high</em>, in which case the output contains one density per distribution, or <em>sample</em> can be a tensor of tensors with that shape, in which case the output is a tensor of densities such that the densities at index <em>i</em> in the output are given by the samples at index <em>i</em> in <em>sample</em> parameterized by the values of <em>low</em> and <em>high</em> at index <em>i</em>.</p>
<p>Examples::</p>
<pre><code>random_pdf_uniform(sample=[[1,2,3,4]], low=[0], high=[10]) = [0.1, 0.1, 0.1, 0.1]

sample = [[[1, 2, 3],
           [1, 2, 3]],
          [[1, 2, 3],
           [1, 2, 3]]]
low  = [[0, 0],
        [0, 0]]
high = [[ 5, 10],
        [15, 20]]
random_pdf_uniform(sample=sample, low=low, high=high) =
    [[[0.2,        0.2,        0.2    ],
      [0.1,        0.1,        0.1    ]],
     [[0.06667,    0.06667,    0.06667],
      [0.05,       0.05,       0.05   ]]]
</code></pre>

<p>Defined in src/operator/random/pdf_op.cc:L298</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>sample::NDArray-or-SymbolicNode</code>: Samples from the distributions.</li>
<li><code>low::NDArray-or-SymbolicNode</code>: Lower bounds of the distributions.</li>
<li><code>is_log::boolean, optional, default=0</code>: If set, compute the density of the log-probability instead of the probability.</li>
<li><code>high::NDArray-or-SymbolicNode</code>: Upper bounds of the distributions.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L383' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._random_poisson-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._random_poisson-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._random_poisson</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_random_poisson(lam, shape, ctx, dtype)
</code></pre>

<p>Draw random samples from a Poisson distribution.</p>
<p>Samples are distributed according to a Poisson distribution parametrized by <em>lambda</em> (rate). Samples will always be returned as a floating point data type.</p>
<p>Example::</p>
<p>poisson(lam=4, shape=(2,2)) = [[ 5.,  2.],                                   [ 4.,  6.]]</p>
<p>Defined in src/operator/random/sample_op.cc:L150</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lam::float, optional, default=1</code>: Lambda parameter (rate) of the Poisson distribution.</li>
<li><code>shape::Shape(tuple), optional, default=None</code>: Shape of the output.</li>
<li><code>ctx::string, optional, default=''</code>: Context of output, in format <a href="n">cpu|gpu|cpu_pinned</a>. Only used for imperative calls.</li>
<li><code>dtype::{'None', 'float16', 'float32', 'float64'},optional, default='None'</code>: DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L364' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._random_poisson_like-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._random_poisson_like-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._random_poisson_like</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_random_poisson_like(lam, data)
</code></pre>

<p>Draw random samples from a Poisson distribution according to the input array shape.</p>
<p>Samples are distributed according to a Poisson distribution parametrized by <em>lambda</em> (rate). Samples will always be returned as a floating point data type.</p>
<p>Example::</p>
<p>poisson(lam=4, data=ones(2,2)) = [[ 5.,  2.],                                      [ 4.,  6.]]</p>
<p>Defined in src/operator/random/sample_op.cc:L255</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lam::float, optional, default=1</code>: Lambda parameter (rate) of the Poisson distribution.</li>
<li><code>data::NDArray-or-SymbolicNode</code>: The input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L360' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._random_randint-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._random_randint-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._random_randint</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_random_randint(low, high, shape, ctx, dtype)
</code></pre>

<p>Draw random samples from a discrete uniform distribution.</p>
<p>Samples are uniformly distributed over the half-open interval <em>[low, high)</em> (includes <em>low</em>, but excludes <em>high</em>).</p>
<p>Example::</p>
<p>randint(low=0, high=5, shape=(2,2)) = [[ 0,  2],                                           [ 3,  1]]</p>
<p>Defined in src/operator/random/sample_op.cc:L194</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>low::long, required</code>: Lower bound of the distribution.</li>
<li><code>high::long, required</code>: Upper bound of the distribution.</li>
<li><code>shape::Shape(tuple), optional, default=None</code>: Shape of the output.</li>
<li><code>ctx::string, optional, default=''</code>: Context of output, in format <a href="n">cpu|gpu|cpu_pinned</a>. Only used for imperative calls.</li>
<li><code>dtype::{'None', 'int32', 'int64'},optional, default='None'</code>: DType of the output in case this can't be inferred. Defaults to int32 if not defined (dtype=None).</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L367' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._random_uniform-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._random_uniform-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._random_uniform</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_random_uniform(low, high, shape, ctx, dtype)
</code></pre>

<p>Draw random samples from a uniform distribution.</p>
<p>.. note:: The existing alias $uniform$ is deprecated.</p>
<p>Samples are uniformly distributed over the half-open interval <em>[low, high)</em> (includes <em>low</em>, but excludes <em>high</em>).</p>
<p>Example::</p>
<p>uniform(low=0, high=1, shape=(2,2)) = [[ 0.60276335,  0.85794562],                                           [ 0.54488319,  0.84725171]]</p>
<p>Defined in src/operator/random/sample_op.cc:L96</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>low::float, optional, default=0</code>: Lower bound of the distribution.</li>
<li><code>high::float, optional, default=1</code>: Upper bound of the distribution.</li>
<li><code>shape::Shape(tuple), optional, default=None</code>: Shape of the output.</li>
<li><code>ctx::string, optional, default=''</code>: Context of output, in format <a href="n">cpu|gpu|cpu_pinned</a>. Only used for imperative calls.</li>
<li><code>dtype::{'None', 'float16', 'float32', 'float64'},optional, default='None'</code>: DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L369' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._random_uniform_like-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._random_uniform_like-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._random_uniform_like</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_random_uniform_like(low, high, data)
</code></pre>

<p>Draw random samples from a uniform distribution according to the input array shape.</p>
<p>Samples are uniformly distributed over the half-open interval <em>[low, high)</em> (includes <em>low</em>, but excludes <em>high</em>).</p>
<p>Example::</p>
<p>uniform(low=0, high=1, data=ones(2,2)) = [[ 0.60276335,  0.85794562],                                              [ 0.54488319,  0.84725171]]</p>
<p>Defined in src/operator/random/sample_op.cc:L209</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>low::float, optional, default=0</code>: Lower bound of the distribution.</li>
<li><code>high::float, optional, default=1</code>: Upper bound of the distribution.</li>
<li><code>data::NDArray-or-SymbolicNode</code>: The input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L363' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._ravel_multi_index-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._ravel_multi_index-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._ravel_multi_index</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_ravel_multi_index(data, shape)
</code></pre>

<p>Converts a batch of index arrays into an array of flat indices. The operator follows numpy conventions so a single multi index is given by a column of the input matrix. The leading dimension may be left unspecified by using -1 as placeholder.  </p>
<p>Examples::</p>
<p>A = [[3,6,6],[4,5,1]]    ravel(A, shape=(7,6)) = [22,41,37]    ravel(A, shape=(-1,6)) = [22,41,37]</p>
<p>Defined in src/operator/tensor/ravel.cc:L42</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Batch of multi-indices</li>
<li><code>shape::Shape(tuple), optional, default=None</code>: Shape of the array into which the multi-indices apply.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L359' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._rdiv_scalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._rdiv_scalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._rdiv_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_rdiv_scalar(data, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._rminus_scalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._rminus_scalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._rminus_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_rminus_scalar(data, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._rmod_scalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._rmod_scalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._rmod_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_rmod_scalar(data, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._rnn_param_concat-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._rnn_param_concat-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._rnn_param_concat</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_rnn_param_concat(data, num_args, dim)
</code></pre>

<p><strong>Note</strong>: <em>rnn</em>param<em>concat takes variable number of positional inputs. So instead of calling as _rnn</em>param<em>concat([x, y, z], num</em>args=3), one should call via <em>rnn</em>param<em>concat(x, y, z), and num</em>args will be determined automatically.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode[]</code>: List of arrays to concatenate</li>
<li><code>num_args::int, required</code>: Number of inputs to be concated.</li>
<li><code>dim::int, optional, default='1'</code>: the dimension to be concated.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L353' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._rpower_scalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._rpower_scalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._rpower_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_rpower_scalar(data, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sample_exponential-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._sample_exponential-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._sample_exponential</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_sample_exponential(lam, shape, dtype)
</code></pre>

<p>Concurrent sampling from multiple exponential distributions with parameters lambda (rate).</p>
<p>The parameters of the distributions are provided as an input array. Let <em>[s]</em> be the shape of the input array, <em>n</em> be the dimension of <em>[s]</em>, <em>[t]</em> be the shape specified as the parameter of the operator, and <em>m</em> be the dimension of <em>[t]</em>. Then the output will be a <em>(n+m)</em>-dimensional array with shape <em>[s]x[t]</em>.</p>
<p>For any valid <em>n</em>-dimensional index <em>i</em> with respect to the input array, <em>output[i]</em> will be an <em>m</em>-dimensional array that holds randomly drawn samples from the distribution which is parameterized by the input value at index <em>i</em>. If the shape parameter of the operator is not set, then one sample will be drawn per distribution and the output array has the same shape as the input array.</p>
<p>Examples::</p>
<p>lam = [ 1.0, 8.5 ]</p>
<p>// Draw a single sample for each distribution    sample_exponential(lam) = [ 0.51837951,  0.09994757]</p>
<p>// Draw a vector containing two samples for each distribution    sample_exponential(lam, shape=(2)) = [[ 0.51837951,  0.19866663],                                          [ 0.09994757,  0.50447971]]</p>
<p>Defined in src/operator/random/multisample_op.cc:L284</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lam::NDArray-or-SymbolicNode</code>: Lambda (rate) parameters of the distributions.</li>
<li><code>shape::Shape(tuple), optional, default=[]</code>: Shape to be sampled from each random distribution.</li>
<li><code>dtype::{'None', 'float16', 'float32', 'float64'},optional, default='None'</code>: DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L377' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sample_gamma-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._sample_gamma-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._sample_gamma</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_sample_gamma(alpha, shape, dtype, beta)
</code></pre>

<p>Concurrent sampling from multiple gamma distributions with parameters <em>alpha</em> (shape) and <em>beta</em> (scale).</p>
<p>The parameters of the distributions are provided as input arrays. Let <em>[s]</em> be the shape of the input arrays, <em>n</em> be the dimension of <em>[s]</em>, <em>[t]</em> be the shape specified as the parameter of the operator, and <em>m</em> be the dimension of <em>[t]</em>. Then the output will be a <em>(n+m)</em>-dimensional array with shape <em>[s]x[t]</em>.</p>
<p>For any valid <em>n</em>-dimensional index <em>i</em> with respect to the input arrays, <em>output[i]</em> will be an <em>m</em>-dimensional array that holds randomly drawn samples from the distribution which is parameterized by the input values at index <em>i</em>. If the shape parameter of the operator is not set, then one sample will be drawn per distribution and the output array has the same shape as the input arrays.</p>
<p>Examples::</p>
<p>alpha = [ 0.0, 2.5 ]    beta = [ 1.0, 0.7 ]</p>
<p>// Draw a single sample for each distribution    sample_gamma(alpha, beta) = [ 0.        ,  2.25797319]</p>
<p>// Draw a vector containing two samples for each distribution    sample_gamma(alpha, beta, shape=(2)) = [[ 0.        ,  0.        ],                                            [ 2.25797319,  1.70734084]]</p>
<p>Defined in src/operator/random/multisample_op.cc:L282</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>alpha::NDArray-or-SymbolicNode</code>: Alpha (shape) parameters of the distributions.</li>
<li><code>shape::Shape(tuple), optional, default=[]</code>: Shape to be sampled from each random distribution.</li>
<li><code>dtype::{'None', 'float16', 'float32', 'float64'},optional, default='None'</code>: DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).</li>
<li><code>beta::NDArray-or-SymbolicNode</code>: Beta (scale) parameters of the distributions.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L380' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sample_generalized_negative_binomial-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._sample_generalized_negative_binomial-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._sample_generalized_negative_binomial</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_sample_generalized_negative_binomial(mu, shape, dtype, alpha)
</code></pre>

<p>Concurrent sampling from multiple generalized negative binomial distributions with parameters <em>mu</em> (mean) and <em>alpha</em> (dispersion).</p>
<p>The parameters of the distributions are provided as input arrays. Let <em>[s]</em> be the shape of the input arrays, <em>n</em> be the dimension of <em>[s]</em>, <em>[t]</em> be the shape specified as the parameter of the operator, and <em>m</em> be the dimension of <em>[t]</em>. Then the output will be a <em>(n+m)</em>-dimensional array with shape <em>[s]x[t]</em>.</p>
<p>For any valid <em>n</em>-dimensional index <em>i</em> with respect to the input arrays, <em>output[i]</em> will be an <em>m</em>-dimensional array that holds randomly drawn samples from the distribution which is parameterized by the input values at index <em>i</em>. If the shape parameter of the operator is not set, then one sample will be drawn per distribution and the output array has the same shape as the input arrays.</p>
<p>Samples will always be returned as a floating point data type.</p>
<p>Examples::</p>
<p>mu = [ 2.0, 2.5 ]    alpha = [ 1.0, 0.1 ]</p>
<p>// Draw a single sample for each distribution    sample<em>generalized</em>negative_binomial(mu, alpha) = [ 0.,  3.]</p>
<p>// Draw a vector containing two samples for each distribution    sample<em>generalized</em>negative_binomial(mu, alpha, shape=(2)) = [[ 0.,  3.],                                                                  [ 3.,  1.]]</p>
<p>Defined in src/operator/random/multisample_op.cc:L293</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>mu::NDArray-or-SymbolicNode</code>: Means of the distributions.</li>
<li><code>shape::Shape(tuple), optional, default=[]</code>: Shape to be sampled from each random distribution.</li>
<li><code>dtype::{'None', 'float16', 'float32', 'float64'},optional, default='None'</code>: DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).</li>
<li><code>alpha::NDArray-or-SymbolicNode</code>: Alpha (dispersion) parameters of the distributions.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L382' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sample_multinomial-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._sample_multinomial-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._sample_multinomial</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_sample_multinomial(data, shape, get_prob, dtype)
</code></pre>

<p>Concurrent sampling from multiple multinomial distributions.</p>
<p><em>data</em> is an <em>n</em> dimensional array whose last dimension has length <em>k</em>, where <em>k</em> is the number of possible outcomes of each multinomial distribution. This operator will draw <em>shape</em> samples from each distribution. If shape is empty one sample will be drawn from each distribution.</p>
<p>If <em>get_prob</em> is true, a second array containing log likelihood of the drawn samples will also be returned. This is usually used for reinforcement learning where you can provide reward as head gradient for this array to estimate gradient.</p>
<p>Note that the input distribution must be normalized, i.e. <em>data</em> must sum to 1 along its last axis.</p>
<p>Examples::</p>
<p>probs = [[0, 0.1, 0.2, 0.3, 0.4], [0.4, 0.3, 0.2, 0.1, 0]]</p>
<p>// Draw a single sample for each distribution    sample_multinomial(probs) = [3, 0]</p>
<p>// Draw a vector containing two samples for each distribution    sample_multinomial(probs, shape=(2)) = [[4, 2],                                            [0, 0]]</p>
<p>// requests log likelihood    sample<em>multinomial(probs, get</em>prob=True) = [2, 1], [0.2, 0.3]</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Distribution probabilities. Must sum to one on the last axis.</li>
<li><code>shape::Shape(tuple), optional, default=[]</code>: Shape to be sampled from each random distribution.</li>
<li><code>get_prob::boolean, optional, default=0</code>: Whether to also return the log probability of sampled result. This is usually used for differentiating through stochastic variables, e.g. in reinforcement learning.</li>
<li><code>dtype::{'float16', 'float32', 'float64', 'int32', 'uint8'},optional, default='int32'</code>: DType of the output in case this can't be inferred.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L381' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sample_negative_binomial-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._sample_negative_binomial-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._sample_negative_binomial</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_sample_negative_binomial(k, shape, dtype, p)
</code></pre>

<p>Concurrent sampling from multiple negative binomial distributions with parameters <em>k</em> (failure limit) and <em>p</em> (failure probability).</p>
<p>The parameters of the distributions are provided as input arrays. Let <em>[s]</em> be the shape of the input arrays, <em>n</em> be the dimension of <em>[s]</em>, <em>[t]</em> be the shape specified as the parameter of the operator, and <em>m</em> be the dimension of <em>[t]</em>. Then the output will be a <em>(n+m)</em>-dimensional array with shape <em>[s]x[t]</em>.</p>
<p>For any valid <em>n</em>-dimensional index <em>i</em> with respect to the input arrays, <em>output[i]</em> will be an <em>m</em>-dimensional array that holds randomly drawn samples from the distribution which is parameterized by the input values at index <em>i</em>. If the shape parameter of the operator is not set, then one sample will be drawn per distribution and the output array has the same shape as the input arrays.</p>
<p>Samples will always be returned as a floating point data type.</p>
<p>Examples::</p>
<p>k = [ 20, 49 ]    p = [ 0.4 , 0.77 ]</p>
<p>// Draw a single sample for each distribution    sample<em>negative</em>binomial(k, p) = [ 15.,  16.]</p>
<p>// Draw a vector containing two samples for each distribution    sample<em>negative</em>binomial(k, p, shape=(2)) = [[ 15.,  50.],                                                 [ 16.,  12.]]</p>
<p>Defined in src/operator/random/multisample_op.cc:L289</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>k::NDArray-or-SymbolicNode</code>: Limits of unsuccessful experiments.</li>
<li><code>shape::Shape(tuple), optional, default=[]</code>: Shape to be sampled from each random distribution.</li>
<li><code>dtype::{'None', 'float16', 'float32', 'float64'},optional, default='None'</code>: DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).</li>
<li><code>p::NDArray-or-SymbolicNode</code>: Failure probabilities in each experiment.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L382' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sample_normal-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._sample_normal-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._sample_normal</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_sample_normal(mu, shape, dtype, sigma)
</code></pre>

<p>Concurrent sampling from multiple normal distributions with parameters <em>mu</em> (mean) and <em>sigma</em> (standard deviation).</p>
<p>The parameters of the distributions are provided as input arrays. Let <em>[s]</em> be the shape of the input arrays, <em>n</em> be the dimension of <em>[s]</em>, <em>[t]</em> be the shape specified as the parameter of the operator, and <em>m</em> be the dimension of <em>[t]</em>. Then the output will be a <em>(n+m)</em>-dimensional array with shape <em>[s]x[t]</em>.</p>
<p>For any valid <em>n</em>-dimensional index <em>i</em> with respect to the input arrays, <em>output[i]</em> will be an <em>m</em>-dimensional array that holds randomly drawn samples from the distribution which is parameterized by the input values at index <em>i</em>. If the shape parameter of the operator is not set, then one sample will be drawn per distribution and the output array has the same shape as the input arrays.</p>
<p>Examples::</p>
<p>mu = [ 0.0, 2.5 ]    sigma = [ 1.0, 3.7 ]</p>
<p>// Draw a single sample for each distribution    sample_normal(mu, sigma) = [-0.56410581,  0.95934606]</p>
<p>// Draw a vector containing two samples for each distribution    sample_normal(mu, sigma, shape=(2)) = [[-0.56410581,  0.2928229 ],                                           [ 0.95934606,  4.48287058]]</p>
<p>Defined in src/operator/random/multisample_op.cc:L279</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>mu::NDArray-or-SymbolicNode</code>: Means of the distributions.</li>
<li><code>shape::Shape(tuple), optional, default=[]</code>: Shape to be sampled from each random distribution.</li>
<li><code>dtype::{'None', 'float16', 'float32', 'float64'},optional, default='None'</code>: DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).</li>
<li><code>sigma::NDArray-or-SymbolicNode</code>: Standard deviations of the distributions.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L380' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sample_poisson-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._sample_poisson-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._sample_poisson</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_sample_poisson(lam, shape, dtype)
</code></pre>

<p>Concurrent sampling from multiple Poisson distributions with parameters lambda (rate).</p>
<p>The parameters of the distributions are provided as an input array. Let <em>[s]</em> be the shape of the input array, <em>n</em> be the dimension of <em>[s]</em>, <em>[t]</em> be the shape specified as the parameter of the operator, and <em>m</em> be the dimension of <em>[t]</em>. Then the output will be a <em>(n+m)</em>-dimensional array with shape <em>[s]x[t]</em>.</p>
<p>For any valid <em>n</em>-dimensional index <em>i</em> with respect to the input array, <em>output[i]</em> will be an <em>m</em>-dimensional array that holds randomly drawn samples from the distribution which is parameterized by the input value at index <em>i</em>. If the shape parameter of the operator is not set, then one sample will be drawn per distribution and the output array has the same shape as the input array.</p>
<p>Samples will always be returned as a floating point data type.</p>
<p>Examples::</p>
<p>lam = [ 1.0, 8.5 ]</p>
<p>// Draw a single sample for each distribution    sample_poisson(lam) = [  0.,  13.]</p>
<p>// Draw a vector containing two samples for each distribution    sample_poisson(lam, shape=(2)) = [[  0.,   4.],                                      [ 13.,   8.]]</p>
<p>Defined in src/operator/random/multisample_op.cc:L286</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lam::NDArray-or-SymbolicNode</code>: Lambda (rate) parameters of the distributions.</li>
<li><code>shape::Shape(tuple), optional, default=[]</code>: Shape to be sampled from each random distribution.</li>
<li><code>dtype::{'None', 'float16', 'float32', 'float64'},optional, default='None'</code>: DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L379' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sample_uniform-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._sample_uniform-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._sample_uniform</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_sample_uniform(low, shape, dtype, high)
</code></pre>

<p>Concurrent sampling from multiple uniform distributions on the intervals given by <em>[low,high)</em>.</p>
<p>The parameters of the distributions are provided as input arrays. Let <em>[s]</em> be the shape of the input arrays, <em>n</em> be the dimension of <em>[s]</em>, <em>[t]</em> be the shape specified as the parameter of the operator, and <em>m</em> be the dimension of <em>[t]</em>. Then the output will be a <em>(n+m)</em>-dimensional array with shape <em>[s]x[t]</em>.</p>
<p>For any valid <em>n</em>-dimensional index <em>i</em> with respect to the input arrays, <em>output[i]</em> will be an <em>m</em>-dimensional array that holds randomly drawn samples from the distribution which is parameterized by the input values at index <em>i</em>. If the shape parameter of the operator is not set, then one sample will be drawn per distribution and the output array has the same shape as the input arrays.</p>
<p>Examples::</p>
<p>low = [ 0.0, 2.5 ]    high = [ 1.0, 3.7 ]</p>
<p>// Draw a single sample for each distribution    sample_uniform(low, high) = [ 0.40451524,  3.18687344]</p>
<p>// Draw a vector containing two samples for each distribution    sample_uniform(low, high, shape=(2)) = [[ 0.40451524,  0.18017688],                                            [ 3.18687344,  3.68352246]]</p>
<p>Defined in src/operator/random/multisample_op.cc:L277</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>low::NDArray-or-SymbolicNode</code>: Lower bounds of the distributions.</li>
<li><code>shape::Shape(tuple), optional, default=[]</code>: Shape to be sampled from each random distribution.</li>
<li><code>dtype::{'None', 'float16', 'float32', 'float64'},optional, default='None'</code>: DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).</li>
<li><code>high::NDArray-or-SymbolicNode</code>: Upper bounds of the distributions.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L380' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sample_unique_zipfian-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._sample_unique_zipfian-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._sample_unique_zipfian</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_sample_unique_zipfian(range_max, shape)
</code></pre>

<p>Draw random samples from an an approximately log-uniform or Zipfian distribution without replacement.</p>
<p>This operation takes a 2-D shape <code>(batch_size, num_sampled)</code>, and randomly generates <em>num_sampled</em> samples from the range of integers [0, range_max) for each instance in the batch.</p>
<p>The elements in each instance are drawn without replacement from the base distribution. The base distribution for this operator is an approximately log-uniform or Zipfian distribution:</p>
<p>P(class) = (log(class + 2) - log(class + 1)) / log(range_max + 1)</p>
<p>Additionaly, it also returns the number of trials used to obtain <code>num_sampled</code> samples for each instance in the batch.</p>
<p>Example::</p>
<p>samples, trials = <em>sample</em>unique_zipfian(750000, shape=(4, 8192))    unique(samples[0]) = 8192    unique(samples[3]) = 8192    trials[0] = 16435</p>
<p>Defined in src/operator/random/unique<em>sample</em>op.cc:L66</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>range_max::int, required</code>: The number of possible classes.</li>
<li><code>shape::Shape(tuple), optional, default=None</code>: 2-D shape of the output, where shape[0] is the batch size, and shape[1] is the number of candidates to sample for each batch.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L373' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._scatter_elemwise_div-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._scatter_elemwise_div-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._scatter_elemwise_div</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_scatter_elemwise_div(lhs, rhs)
</code></pre>

<p>Divides arguments element-wise.  If the left-hand-side input is 'row_sparse', then only the values which exist in the left-hand sparse array are computed.  The 'missing' values are ignored.</p>
<p>The storage type of $_scatter_elemwise_div$ output depends on storage types of inputs</p>
<ul>
<li><em>scatter</em>elemwise<em>div(row</em>sparse, row<em>sparse) = row</em>sparse</li>
<li><em>scatter</em>elemwise<em>div(row</em>sparse, dense) = row_sparse</li>
<li><em>scatter</em>elemwise<em>div(row</em>sparse, csr) = row_sparse</li>
<li>otherwise, $_scatter_elemwise_div$ behaves exactly like elemwise_div and generates output</li>
</ul>
<p>with default storage</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L361' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._scatter_minus_scalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._scatter_minus_scalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._scatter_minus_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_scatter_minus_scalar(data, scalar)
</code></pre>

<p>Subtracts a scalar to a tensor element-wise.  If the left-hand-side input is 'row_sparse' or 'csr', then only the values which exist in the left-hand sparse array are computed. The 'missing' values are ignored.</p>
<p>The storage type of $_scatter_minus_scalar$ output depends on storage types of inputs</p>
<ul>
<li><em>scatter</em>minus<em>scalar(row</em>sparse, scalar) = row_sparse</li>
<li><em>scatter</em>minus_scalar(csr, scalar) = csr</li>
<li>otherwise, $_scatter_minus_scalar$ behaves exactly like <em>minus</em>scalar and generates output</li>
</ul>
<p>with default storage</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L360' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._scatter_plus_scalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._scatter_plus_scalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._scatter_plus_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_scatter_plus_scalar(data, scalar)
</code></pre>

<p>Adds a scalar to a tensor element-wise.  If the left-hand-side input is 'row_sparse' or 'csr', then only the values which exist in the left-hand sparse array are computed. The 'missing' values are ignored.</p>
<p>The storage type of $_scatter_plus_scalar$ output depends on storage types of inputs</p>
<ul>
<li><em>scatter</em>plus<em>scalar(row</em>sparse, scalar) = row_sparse</li>
<li><em>scatter</em>plus_scalar(csr, scalar) = csr</li>
<li>otherwise, $_scatter_plus_scalar$ behaves exactly like <em>plus</em>scalar and generates output</li>
</ul>
<p>with default storage</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L360' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._scatter_set_nd-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._scatter_set_nd-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._scatter_set_nd</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_scatter_set_nd(lhs, rhs, indices, shape)
</code></pre>

<p>This operator has the same functionality as scatter_nd except that it does not reset the elements not indexed by the input index <code>NDArray</code> in the input data <code>NDArray</code>. output should be explicitly given and be the same as lhs.</p>
<p>.. note:: This operator is for internal use only.</p>
<p>Examples::</p>
<p>data = [2, 3, 0]   indices = [[1, 1, 0], [0, 1, 0]]   out = [[1, 1], [1, 1]]   <em>scatter</em>set_nd(lhs=out, rhs=data, indices=indices, out=out)   out = [[0, 1], [2, 3]]</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: value to assign</li>
<li><code>indices::NDArray-or-SymbolicNode</code>: indices</li>
<li><code>shape::Shape(tuple), required</code>: Shape of output.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L368' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._shuffle-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._shuffle-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._shuffle</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_shuffle(data)
</code></pre>

<p>Randomly shuffle the elements.</p>
<p>This shuffles the array along the first axis. The order of the elements in each subarray does not change. For example, if a 2D array is given, the order of the rows randomly changes, but the order of the elements in each row does not change.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Data to be shuffled.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L353' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._slice_assign-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._slice_assign-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._slice_assign</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_slice_assign(lhs, rhs, begin, end, step)
</code></pre>

<p>Assign the rhs to a cropped subset of lhs.</p>
<p><strong>Requirements</strong></p>
<ul>
<li>output should be explicitly given and be the same as lhs.</li>
<li>lhs and rhs are of the same data type, and on the same device.</li>
</ul>
<p>From:src/operator/tensor/matrix_op.cc:515</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: Source input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: value to assign</li>
<li><code>begin::Shape(tuple), required</code>: starting indices for the slice operation, supports negative indices.</li>
<li><code>end::Shape(tuple), required</code>: ending indices for the slice operation, supports negative indices.</li>
<li><code>step::Shape(tuple), optional, default=[]</code>: step for the slice operation, supports negative values.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L363' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._slice_assign_scalar-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._slice_assign_scalar-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._slice_assign_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_slice_assign_scalar(data, scalar, begin, end, step)
</code></pre>

<p>(Assign the scalar to a cropped subset of the input.</p>
<p><strong>Requirements</strong></p>
<ul>
<li>output should be explicitly given and be the same as input</li>
</ul>
<p>)</p>
<p>From:src/operator/tensor/matrix_op.cc:541</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Source input</li>
<li><code>scalar::double, optional, default=0</code>: The scalar value for assignment.</li>
<li><code>begin::Shape(tuple), required</code>: starting indices for the slice operation, supports negative indices.</li>
<li><code>end::Shape(tuple), required</code>: ending indices for the slice operation, supports negative indices.</li>
<li><code>step::Shape(tuple), optional, default=[]</code>: step for the slice operation, supports negative values.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L362' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_ElementWiseSum-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._sparse_ElementWiseSum-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_ElementWiseSum</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_sparse_ElementWiseSum(args)
</code></pre>

<p><em>sparse</em>ElementWiseSum is an alias of add_n.</p>
<p><strong>Note</strong>: <em>sparse</em>ElementWiseSum takes variable number of positional inputs. So instead of calling as <em>sparse</em>ElementWiseSum([x, y, z], num<em>args=3), one should call via _sparse</em>ElementWiseSum(x, y, z), and num_args will be determined automatically.</p>
<p>Adds all input arguments element-wise.</p>
<p>.. math::    add_n(a<em>1, a</em>2, ..., a<em>n) = a</em>1 + a<em>2 + ... + a</em>n</p>
<p>$add_n$ is potentially more efficient than calling $add$ by <code>n</code> times.</p>
<p>The storage type of $add_n$ output depends on storage types of inputs</p>
<ul>
<li>add<em>n(row</em>sparse, row<em>sparse, ..) = row</em>sparse</li>
<li>add_n(default, csr, default) = default</li>
<li>add_n(any input combinations longer than 4 (&gt;4) with at least one default type) = default</li>
<li>otherwise, $add_n$ falls all inputs back to default storage and generates default storage</li>
</ul>
<p>Defined in src/operator/tensor/elemwise_sum.cc:L155</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>args::NDArray-or-SymbolicNode[]</code>: Positional input arguments</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L367' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_Embedding-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._sparse_Embedding-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_Embedding</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_sparse_Embedding(data, weight, input_dim, output_dim, dtype, sparse_grad)
</code></pre>

<p><em>sparse</em>Embedding is an alias of Embedding.</p>
<p>Maps integer indices to vector representations (embeddings).</p>
<p>This operator maps words to real-valued vectors in a high-dimensional space, called word embeddings. These embeddings can capture semantic and syntactic properties of the words. For example, it has been noted that in the learned embedding spaces, similar words tend to be close to each other and dissimilar words far apart.</p>
<p>For an input array of shape (d1, ..., dK), the shape of an output array is (d1, ..., dK, output<em>dim). All the input values should be integers in the range [0, input</em>dim).</p>
<p>If the input<em>dim is ip0 and output</em>dim is op0, then shape of the embedding weight matrix must be (ip0, op0).</p>
<p>When "sparse<em>grad" is False, if any index mentioned is too large, it is replaced by the index that addresses the last vector in an embedding matrix. When "sparse</em>grad" is True, an error will be raised if invalid indices are found.</p>
<p>Examples::</p>
<p>input<em>dim = 4   output</em>dim = 5</p>
<p>// Each row in weight matrix y represents a word. So, y = (w0,w1,w2,w3)   y = [[  0.,   1.,   2.,   3.,   4.],        [  5.,   6.,   7.,   8.,   9.],        [ 10.,  11.,  12.,  13.,  14.],        [ 15.,  16.,  17.,  18.,  19.]]</p>
<p>// Input array x represents n-grams(2-gram). So, x = [(w1,w3), (w0,w2)]   x = [[ 1.,  3.],        [ 0.,  2.]]</p>
<p>// Mapped input x to its vector representation y.   Embedding(x, y, 4, 5) = [[[  5.,   6.,   7.,   8.,   9.],                             [ 15.,  16.,  17.,  18.,  19.]],</p>
<pre><code>                       [[  0.,   1.,   2.,   3.,   4.],
                        [ 10.,  11.,  12.,  13.,  14.]]]
</code></pre>

<p>The storage type of weight can be either row_sparse or default.</p>
<p>.. Note::</p>
<pre><code>If &quot;sparse_grad&quot; is set to True, the storage type of gradient w.r.t weights will be
&quot;row_sparse&quot;. Only a subset of optimizers support sparse gradients, including SGD, AdaGrad
and Adam. Note that by default lazy updates is turned on, which may perform differently
from standard updates. For more details, please check the Optimization API at:
https://mxnet.incubator.apache.org/api/python/optimization/optimization.html
</code></pre>

<p>Defined in src/operator/tensor/indexing_op.cc:L603</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array to the embedding operator.</li>
<li><code>weight::NDArray-or-SymbolicNode</code>: The embedding weight matrix.</li>
<li><code>input_dim::int, required</code>: Vocabulary size of the input indices.</li>
<li><code>output_dim::int, required</code>: Dimension of the embedding vectors.</li>
<li><code>dtype::{'bfloat16', 'float16', 'float32', 'float64', 'int32', 'int64', 'int8', 'uint8'},optional, default='float32'</code>: Data type of weight.</li>
<li><code>sparse_grad::boolean, optional, default=0</code>: Compute row sparse gradient in the backward calculation. If set to True, the grad's storage type is row_sparse.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L412' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_FullyConnected-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._sparse_FullyConnected-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_FullyConnected</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_sparse_FullyConnected(data, weight, bias, num_hidden, no_bias, flatten)
</code></pre>

<p><em>sparse</em>FullyConnected is an alias of FullyConnected.</p>
<p>Applies a linear transformation: :math:<code>Y = XW^T + b</code>.</p>
<p>If $flatten$ is set to be true, then the shapes are:</p>
<ul>
<li><strong>data</strong>: <code>(batch_size, x1, x2, ..., xn)</code></li>
<li><strong>weight</strong>: <code>(num_hidden, x1 * x2 * ... * xn)</code></li>
<li><strong>bias</strong>: <code>(num_hidden,)</code></li>
<li><strong>out</strong>: <code>(batch_size, num_hidden)</code></li>
</ul>
<p>If $flatten$ is set to be false, then the shapes are:</p>
<ul>
<li><strong>data</strong>: <code>(x1, x2, ..., xn, input_dim)</code></li>
<li><strong>weight</strong>: <code>(num_hidden, input_dim)</code></li>
<li><strong>bias</strong>: <code>(num_hidden,)</code></li>
<li><strong>out</strong>: <code>(x1, x2, ..., xn, num_hidden)</code></li>
</ul>
<p>The learnable parameters include both $weight$ and $bias$.</p>
<p>If $no_bias$ is set to be true, then the $bias$ term is ignored.</p>
<p>.. Note::</p>
<pre><code>The sparse support for FullyConnected is limited to forward evaluation with `row_sparse`
weight and bias, where the length of `weight.indices` and `bias.indices` must be equal
to `num_hidden`. This could be useful for model inference with `row_sparse` weights
trained with importance sampling or noise contrastive estimation.

To compute linear transformation with 'csr' sparse data, sparse.dot is recommended instead
of sparse.FullyConnected.
</code></pre>

<p>Defined in src/operator/nn/fully_connected.cc:L287</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data.</li>
<li><code>weight::NDArray-or-SymbolicNode</code>: Weight matrix.</li>
<li><code>bias::NDArray-or-SymbolicNode</code>: Bias parameter.</li>
<li><code>num_hidden::int, required</code>: Number of hidden nodes of the output.</li>
<li><code>no_bias::boolean, optional, default=0</code>: Whether to disable bias parameter.</li>
<li><code>flatten::boolean, optional, default=1</code>: Whether to collapse all but the first axis of the input data tensor.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L391' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_LinearRegressionOutput-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._sparse_LinearRegressionOutput-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_LinearRegressionOutput</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_sparse_LinearRegressionOutput(data, label, grad_scale)
</code></pre>

<p><em>sparse</em>LinearRegressionOutput is an alias of LinearRegressionOutput.</p>
<p>Computes and optimizes for squared loss during backward propagation. Just outputs $data$ during forward propagation.</p>
<p>If :math:<code>\hat{y}_i</code> is the predicted value of the i-th sample, and :math:<code>y_i</code> is the corresponding target value, then the squared loss estimated over :math:<code>n</code> samples is defined as</p>
<p>:math:<code>\text{SquaredLoss}(\textbf{Y}, \hat{\textbf{Y}} ) = \frac{1}{n} \sum_{i=0}^{n-1} \lVert  \textbf{y}_i - \hat{\textbf{y}}_i  \rVert_2</code></p>
<p>.. note::    Use the LinearRegressionOutput as the final output layer of a net.</p>
<p>The storage type of $label$ can be $default$ or $csr$</p>
<ul>
<li>LinearRegressionOutput(default, default) = default</li>
<li>LinearRegressionOutput(default, csr) = default</li>
</ul>
<p>By default, gradients of this loss function are scaled by factor <code>1/m</code>, where m is the number of regression outputs of a training example. The parameter <code>grad_scale</code> can be used to change this scale to <code>grad_scale/m</code>.</p>
<p>Defined in src/operator/regression_output.cc:L92</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data to the function.</li>
<li><code>label::NDArray-or-SymbolicNode</code>: Input label to the function.</li>
<li><code>grad_scale::float, optional, default=1</code>: Scale the gradient by a float factor</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L374' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_LogisticRegressionOutput-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._sparse_LogisticRegressionOutput-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_LogisticRegressionOutput</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_sparse_LogisticRegressionOutput(data, label, grad_scale)
</code></pre>

<p><em>sparse</em>LogisticRegressionOutput is an alias of LogisticRegressionOutput.</p>
<p>Applies a logistic function to the input.</p>
<p>The logistic function, also known as the sigmoid function, is computed as :math:<code>\frac{1}{1+exp(-\textbf{x})}</code>.</p>
<p>Commonly, the sigmoid is used to squash the real-valued output of a linear model :math:<code>wTx+b</code> into the [0,1] range so that it can be interpreted as a probability. It is suitable for binary classification or probability prediction tasks.</p>
<p>.. note::    Use the LogisticRegressionOutput as the final output layer of a net.</p>
<p>The storage type of $label$ can be $default$ or $csr$</p>
<ul>
<li>LogisticRegressionOutput(default, default) = default</li>
<li>LogisticRegressionOutput(default, csr) = default</li>
</ul>
<p>The loss function used is the Binary Cross Entropy Loss:</p>
<p>:math:<code>-{(y\log(p) + (1 - y)\log(1 - p))}</code></p>
<p>Where <code>y</code> is the ground truth probability of positive outcome for a given example, and <code>p</code> the probability predicted by the model. By default, gradients of this loss function are scaled by factor <code>1/m</code>, where m is the number of regression outputs of a training example. The parameter <code>grad_scale</code> can be used to change this scale to <code>grad_scale/m</code>.</p>
<p>Defined in src/operator/regression_output.cc:L152</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data to the function.</li>
<li><code>label::NDArray-or-SymbolicNode</code>: Input label to the function.</li>
<li><code>grad_scale::float, optional, default=1</code>: Scale the gradient by a float factor</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L379' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_MAERegressionOutput-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._sparse_MAERegressionOutput-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_MAERegressionOutput</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_sparse_MAERegressionOutput(data, label, grad_scale)
</code></pre>

<p><em>sparse</em>MAERegressionOutput is an alias of MAERegressionOutput.</p>
<p>Computes mean absolute error of the input.</p>
<p>MAE is a risk metric corresponding to the expected value of the absolute error.</p>
<p>If :math:<code>\hat{y}_i</code> is the predicted value of the i-th sample, and :math:<code>y_i</code> is the corresponding target value, then the mean absolute error (MAE) estimated over :math:<code>n</code> samples is defined as</p>
<p>:math:<code>\text{MAE}(\textbf{Y}, \hat{\textbf{Y}} ) = \frac{1}{n} \sum_{i=0}^{n-1} \lVert \textbf{y}_i - \hat{\textbf{y}}_i \rVert_1</code></p>
<p>.. note::    Use the MAERegressionOutput as the final output layer of a net.</p>
<p>The storage type of $label$ can be $default$ or $csr$</p>
<ul>
<li>MAERegressionOutput(default, default) = default</li>
<li>MAERegressionOutput(default, csr) = default</li>
</ul>
<p>By default, gradients of this loss function are scaled by factor <code>1/m</code>, where m is the number of regression outputs of a training example. The parameter <code>grad_scale</code> can be used to change this scale to <code>grad_scale/m</code>.</p>
<p>Defined in src/operator/regression_output.cc:L120</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data to the function.</li>
<li><code>label::NDArray-or-SymbolicNode</code>: Input label to the function.</li>
<li><code>grad_scale::float, optional, default=1</code>: Scale the gradient by a float factor</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L375' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse__contrib_round_ste-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._sparse__contrib_round_ste-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse__contrib_round_ste</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_sparse__contrib_round_ste(data)
</code></pre>

<p><em>sparse__contrib</em>round<em>ste is an alias of _contrib</em>round_ste.</p>
<p>Straight-through-estimator of <code>round()</code>.</p>
<p>In forward pass, returns element-wise rounded value to the nearest integer of the input (same as <code>round()</code>).</p>
<p>In backward pass, returns gradients of $1$ everywhere (instead of $0$ everywhere as in <code>round()</code>): :math:<code>\frac{d}{dx}{round\_ste(x)} = 1</code> vs. :math:<code>\frac{d}{dx}{round(x)} = 0</code>. This is useful for quantized training.</p>
<p>Reference: Estimating or Propagating Gradients Through Stochastic Neurons for Conditional Computation.</p>
<p>Example::   x = round_ste([-1.5, 1.5, -1.9, 1.9, 2.7])   x.backward()   x = [-2.,  2., -2.,  2.,  3.]   x.grad() = [1.,  1., 1.,  1.,  1.]</p>
<p>The storage type of $round_ste$ output depends upon the input storage type:</p>
<ul>
<li>round_ste(default) = default</li>
<li>round<em>ste(row</em>sparse) = row_sparse</li>
<li>round_ste(csr) = csr</li>
</ul>
<p>Defined in src/operator/contrib/stes_op.cc:L55</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L371' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse__contrib_sign_ste-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._sparse__contrib_sign_ste-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse__contrib_sign_ste</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_sparse__contrib_sign_ste(data)
</code></pre>

<p><em>sparse__contrib</em>sign<em>ste is an alias of _contrib</em>sign_ste.</p>
<p>Straight-through-estimator of <code>sign()</code>.</p>
<p>In forward pass, returns element-wise sign of the input (same as <code>sign()</code>).</p>
<p>In backward pass, returns gradients of $1$ everywhere (instead of $0$ everywhere as in $sign()$): :math:<code>\frac{d}{dx}{sign\_ste(x)} = 1</code> vs. :math:<code>\frac{d}{dx}{sign(x)} = 0</code>. This is useful for quantized training.</p>
<p>Reference: Estimating or Propagating Gradients Through Stochastic Neurons for Conditional Computation.</p>
<p>Example::   x = sign_ste([-2, 0, 3])   x.backward()   x = [-1.,  0., 1.]   x.grad() = [1.,  1., 1.]</p>
<p>The storage type of $sign_ste$ output depends upon the input storage type:</p>
<ul>
<li>round_ste(default) = default</li>
<li>round<em>ste(row</em>sparse) = row_sparse</li>
<li>round_ste(csr) = csr</li>
</ul>
<p>Defined in src/operator/contrib/stes_op.cc:L80</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L371' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_abs-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._sparse_abs-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_abs</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_sparse_abs(data)
</code></pre>

<p><em>sparse</em>abs is an alias of abs.</p>
<p>Returns element-wise absolute value of the input.</p>
<p>Example::</p>
<p>abs([-2, 0, 3]) = [2, 0, 3]</p>
<p>The storage type of $abs$ output depends upon the input storage type:</p>
<ul>
<li>abs(default) = default</li>
<li>abs(row<em>sparse) = row</em>sparse</li>
<li>abs(csr) = csr</li>
</ul>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_basic.cc:L720</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L363' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_adagrad_update-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._sparse_adagrad_update-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_adagrad_update</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_sparse_adagrad_update(weight, grad, history, lr, epsilon, wd, rescale_grad, clip_gradient)
</code></pre>

<p>Update function for AdaGrad optimizer.</p>
<p>Referenced from <em>Adaptive Subgradient Methods for Online Learning and Stochastic Optimization</em>, and available at http://www.jmlr.org/papers/volume12/duchi11a/duchi11a.pdf.</p>
<p>Updates are applied by::</p>
<pre><code>rescaled_grad = clip(grad * rescale_grad, clip_gradient)
history = history + square(rescaled_grad)
w = w - learning_rate * rescaled_grad / sqrt(history + epsilon)
</code></pre>

<p>Note that non-zero values for the weight decay option are not supported.</p>
<p>Defined in src/operator/optimizer_op.cc:L900</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>weight::NDArray-or-SymbolicNode</code>: Weight</li>
<li><code>grad::NDArray-or-SymbolicNode</code>: Gradient</li>
<li><code>history::NDArray-or-SymbolicNode</code>: History</li>
<li><code>lr::float, required</code>: Learning rate</li>
<li><code>epsilon::float, optional, default=1.00000001e-07</code>: epsilon</li>
<li><code>wd::float, optional, default=0</code>: weight decay</li>
<li><code>rescale_grad::float, optional, default=1</code>: Rescale gradient to grad = rescale_grad*grad.</li>
<li><code>clip_gradient::float, optional, default=-1</code>: Clip gradient to the range of [-clip<em>gradient, clip</em>gradient] If clip<em>gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip</em>gradient), -clip_gradient).</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L376' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_adam_update-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._sparse_adam_update-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_adam_update</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_sparse_adam_update(weight, grad, mean, var, lr, beta1, beta2, epsilon, wd, rescale_grad, clip_gradient, lazy_update)
</code></pre>

<p><em>sparse</em>adam<em>update is an alias of adam</em>update.</p>
<p>Update function for Adam optimizer. Adam is seen as a generalization of AdaGrad.</p>
<p>Adam update consists of the following steps, where g represents gradient and m, v are 1st and 2nd order moment estimates (mean and variance).</p>
<p>.. math::</p>
<p>g<em t-1="t-1">t = \nabla J(W</em>)\
 m<em>t = \beta</em>1 m<em>{t-1} + (1 - \beta</em>1) g<em>t\
 v</em>t = \beta<em t-1="t-1">2 v</em> + (1 - \beta<em>2) g</em>t^2\
 W<em t-1="t-1">t = W</em> - \alpha \frac{ m<em>t }{ \sqrt{ v</em>t } + \epsilon }</p>
<p>It updates the weights using::</p>
<p>m = beta1<em>m + (1-beta1)</em>grad  v = beta2<em>v + (1-beta2)</em>(grad**2)  w += - learning_rate * m / (sqrt(v) + epsilon)</p>
<p>However, if grad's storage type is $row_sparse$, $lazy_update$ is True and the storage type of weight is the same as those of m and v, only the row slices whose indices appear in grad.indices are updated (for w, m and v)::</p>
<p>for row in grad.indices:      m[row] = beta1<em>m[row] + (1-beta1)</em>grad[row]      v[row] = beta2<em>v[row] + (1-beta2)</em>(grad[row]**2)      w[row] += - learning_rate * m[row] / (sqrt(v[row]) + epsilon)</p>
<p>Defined in src/operator/optimizer_op.cc:L679</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>weight::NDArray-or-SymbolicNode</code>: Weight</li>
<li><code>grad::NDArray-or-SymbolicNode</code>: Gradient</li>
<li><code>mean::NDArray-or-SymbolicNode</code>: Moving mean</li>
<li><code>var::NDArray-or-SymbolicNode</code>: Moving variance</li>
<li><code>lr::float, required</code>: Learning rate</li>
<li><code>beta1::float, optional, default=0.899999976</code>: The decay rate for the 1st moment estimates.</li>
<li><code>beta2::float, optional, default=0.999000013</code>: The decay rate for the 2nd moment estimates.</li>
<li><code>epsilon::float, optional, default=9.99999994e-09</code>: A small constant for numerical stability.</li>
<li><code>wd::float, optional, default=0</code>: Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</li>
<li><code>rescale_grad::float, optional, default=1</code>: Rescale gradient to grad = rescale_grad*grad.</li>
<li><code>clip_gradient::float, optional, default=-1</code>: Clip gradient to the range of [-clip<em>gradient, clip</em>gradient] If clip<em>gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip</em>gradient), -clip_gradient).</li>
<li><code>lazy_update::boolean, optional, default=1</code>: If true, lazy updates are applied if gradient's stype is row_sparse and all of w, m and v have the same stype</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L401' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_add_n-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._sparse_add_n-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_add_n</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_sparse_add_n(args)
</code></pre>

<p><em>sparse</em>add<em>n is an alias of add</em>n.</p>
<p><strong>Note</strong>: <em>sparse</em>add<em>n takes variable number of positional inputs. So instead of calling as _sparse</em>add<em>n([x, y, z], num</em>args=3), one should call via <em>sparse</em>add<em>n(x, y, z), and num</em>args will be determined automatically.</p>
<p>Adds all input arguments element-wise.</p>
<p>.. math::    add_n(a<em>1, a</em>2, ..., a<em>n) = a</em>1 + a<em>2 + ... + a</em>n</p>
<p>$add_n$ is potentially more efficient than calling $add$ by <code>n</code> times.</p>
<p>The storage type of $add_n$ output depends on storage types of inputs</p>
<ul>
<li>add<em>n(row</em>sparse, row<em>sparse, ..) = row</em>sparse</li>
<li>add_n(default, csr, default) = default</li>
<li>add_n(any input combinations longer than 4 (&gt;4) with at least one default type) = default</li>
<li>otherwise, $add_n$ falls all inputs back to default storage and generates default storage</li>
</ul>
<p>Defined in src/operator/tensor/elemwise_sum.cc:L155</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>args::NDArray-or-SymbolicNode[]</code>: Positional input arguments</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L367' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_arccos-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._sparse_arccos-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_arccos</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_sparse_arccos(data)
</code></pre>

<p><em>sparse</em>arccos is an alias of arccos.</p>
<p>Returns element-wise inverse cosine of the input array.</p>
<p>The input should be in range <code>[-1, 1]</code>. The output is in the closed interval :math:<code>[0, \pi]</code></p>
<p>.. math::    arccos([-1, -.707, 0, .707, 1]) = [\pi, 3\pi/4, \pi/2, \pi/4, 0]</p>
<p>The storage type of $arccos$ output is always dense</p>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_trig.cc:L233</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L361' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_arccosh-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._sparse_arccosh-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_arccosh</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_sparse_arccosh(data)
</code></pre>

<p><em>sparse</em>arccosh is an alias of arccosh.</p>
<p>Returns the element-wise inverse hyperbolic cosine of the input array, 
computed element-wise.</p>
<p>The storage type of $arccosh$ output is always dense</p>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_trig.cc:L535</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L356' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_arcsin-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._sparse_arcsin-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_arcsin</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_sparse_arcsin(data)
</code></pre>

<p><em>sparse</em>arcsin is an alias of arcsin.</p>
<p>Returns element-wise inverse sine of the input array.</p>
<p>The input should be in the range <code>[-1, 1]</code>. The output is in the closed interval of [:math:<code>-\pi/2</code>, :math:<code>\pi/2</code>].</p>
<p>.. math::    arcsin([-1, -.707, 0, .707, 1]) = [-\pi/2, -\pi/4, 0, \pi/4, \pi/2]</p>
<p>The storage type of $arcsin$ output depends upon the input storage type:</p>
<ul>
<li>arcsin(default) = default</li>
<li>arcsin(row<em>sparse) = row</em>sparse</li>
<li>arcsin(csr) = csr</li>
</ul>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_trig.cc:L187</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L365' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_arcsinh-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._sparse_arcsinh-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_arcsinh</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_sparse_arcsinh(data)
</code></pre>

<p><em>sparse</em>arcsinh is an alias of arcsinh.</p>
<p>Returns the element-wise inverse hyperbolic sine of the input array, 
computed element-wise.</p>
<p>The storage type of $arcsinh$ output depends upon the input storage type:</p>
<ul>
<li>arcsinh(default) = default</li>
<li>arcsinh(row<em>sparse) = row</em>sparse</li>
<li>arcsinh(csr) = csr</li>
</ul>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_trig.cc:L494</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L360' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_arctan-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._sparse_arctan-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_arctan</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_sparse_arctan(data)
</code></pre>

<p><em>sparse</em>arctan is an alias of arctan.</p>
<p>Returns element-wise inverse tangent of the input array.</p>
<p>The output is in the closed interval :math:<code>[-\pi/2, \pi/2]</code></p>
<p>.. math::    arctan([-1, 0, 1]) = [-\pi/4, 0, \pi/4]</p>
<p>The storage type of $arctan$ output depends upon the input storage type:</p>
<ul>
<li>arctan(default) = default</li>
<li>arctan(row<em>sparse) = row</em>sparse</li>
<li>arctan(csr) = csr</li>
</ul>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_trig.cc:L282</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L364' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_arctanh-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._sparse_arctanh-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_arctanh</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_sparse_arctanh(data)
</code></pre>

<p><em>sparse</em>arctanh is an alias of arctanh.</p>
<p>Returns the element-wise inverse hyperbolic tangent of the input array, 
computed element-wise.</p>
<p>The storage type of $arctanh$ output depends upon the input storage type:</p>
<ul>
<li>arctanh(default) = default</li>
<li>arctanh(row<em>sparse) = row</em>sparse</li>
<li>arctanh(csr) = csr</li>
</ul>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_trig.cc:L579</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L360' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_broadcast_add-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._sparse_broadcast_add-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_broadcast_add</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_sparse_broadcast_add(lhs, rhs)
</code></pre>

<p><em>sparse</em>broadcast<em>add is an alias of broadcast</em>add.</p>
<p>Returns element-wise sum of the input arrays with broadcasting.</p>
<p><code>broadcast_plus</code> is an alias to the function <code>broadcast_add</code>.</p>
<p>Example::</p>
<p>x = [[ 1.,  1.,  1.],         [ 1.,  1.,  1.]]</p>
<p>y = [[ 0.],         [ 1.]]</p>
<p>broadcast_add(x, y) = [[ 1.,  1.,  1.],                           [ 2.,  2.,  2.]]</p>
<p>broadcast_plus(x, y) = [[ 1.,  1.,  1.],                            [ 2.,  2.,  2.]]</p>
<p>Supported sparse operations:</p>
<p>broadcast<em>add(csr, dense(1D)) = dense    broadcast</em>add(dense(1D), csr) = dense</p>
<p>Defined in src/operator/tensor/elemwise<em>binary</em>broadcast<em>op</em>basic.cc:L58</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: First input to the function</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: Second input to the function</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L376' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_broadcast_div-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._sparse_broadcast_div-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_broadcast_div</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_sparse_broadcast_div(lhs, rhs)
</code></pre>

<p><em>sparse</em>broadcast<em>div is an alias of broadcast</em>div.</p>
<p>Returns element-wise division of the input arrays with broadcasting.</p>
<p>Example::</p>
<p>x = [[ 6.,  6.,  6.],         [ 6.,  6.,  6.]]</p>
<p>y = [[ 2.],         [ 3.]]</p>
<p>broadcast_div(x, y) = [[ 3.,  3.,  3.],                           [ 2.,  2.,  2.]]</p>
<p>Supported sparse operations:</p>
<p>broadcast_div(csr, dense(1D)) = csr</p>
<p>Defined in src/operator/tensor/elemwise<em>binary</em>broadcast<em>op</em>basic.cc:L187</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: First input to the function</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: Second input to the function</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L370' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_broadcast_minus-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._sparse_broadcast_minus-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_broadcast_minus</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_sparse_broadcast_minus(lhs, rhs)
</code></pre>

<p><em>sparse</em>broadcast<em>minus is an alias of broadcast</em>sub.</p>
<p>Returns element-wise difference of the input arrays with broadcasting.</p>
<p><code>broadcast_minus</code> is an alias to the function <code>broadcast_sub</code>.</p>
<p>Example::</p>
<p>x = [[ 1.,  1.,  1.],         [ 1.,  1.,  1.]]</p>
<p>y = [[ 0.],         [ 1.]]</p>
<p>broadcast_sub(x, y) = [[ 1.,  1.,  1.],                           [ 0.,  0.,  0.]]</p>
<p>broadcast_minus(x, y) = [[ 1.,  1.,  1.],                             [ 0.,  0.,  0.]]</p>
<p>Supported sparse operations:</p>
<p>broadcast<em>sub/minus(csr, dense(1D)) = dense    broadcast</em>sub/minus(dense(1D), csr) = dense</p>
<p>Defined in src/operator/tensor/elemwise<em>binary</em>broadcast<em>op</em>basic.cc:L106</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: First input to the function</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: Second input to the function</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L376' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_broadcast_mul-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._sparse_broadcast_mul-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_broadcast_mul</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_sparse_broadcast_mul(lhs, rhs)
</code></pre>

<p><em>sparse</em>broadcast<em>mul is an alias of broadcast</em>mul.</p>
<p>Returns element-wise product of the input arrays with broadcasting.</p>
<p>Example::</p>
<p>x = [[ 1.,  1.,  1.],         [ 1.,  1.,  1.]]</p>
<p>y = [[ 0.],         [ 1.]]</p>
<p>broadcast_mul(x, y) = [[ 0.,  0.,  0.],                           [ 1.,  1.,  1.]]</p>
<p>Supported sparse operations:</p>
<p>broadcast_mul(csr, dense(1D)) = csr</p>
<p>Defined in src/operator/tensor/elemwise<em>binary</em>broadcast<em>op</em>basic.cc:L146</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: First input to the function</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: Second input to the function</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L370' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_broadcast_plus-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._sparse_broadcast_plus-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_broadcast_plus</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_sparse_broadcast_plus(lhs, rhs)
</code></pre>

<p><em>sparse</em>broadcast<em>plus is an alias of broadcast</em>add.</p>
<p>Returns element-wise sum of the input arrays with broadcasting.</p>
<p><code>broadcast_plus</code> is an alias to the function <code>broadcast_add</code>.</p>
<p>Example::</p>
<p>x = [[ 1.,  1.,  1.],         [ 1.,  1.,  1.]]</p>
<p>y = [[ 0.],         [ 1.]]</p>
<p>broadcast_add(x, y) = [[ 1.,  1.,  1.],                           [ 2.,  2.,  2.]]</p>
<p>broadcast_plus(x, y) = [[ 1.,  1.,  1.],                            [ 2.,  2.,  2.]]</p>
<p>Supported sparse operations:</p>
<p>broadcast<em>add(csr, dense(1D)) = dense    broadcast</em>add(dense(1D), csr) = dense</p>
<p>Defined in src/operator/tensor/elemwise<em>binary</em>broadcast<em>op</em>basic.cc:L58</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: First input to the function</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: Second input to the function</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L376' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_broadcast_sub-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._sparse_broadcast_sub-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_broadcast_sub</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_sparse_broadcast_sub(lhs, rhs)
</code></pre>

<p><em>sparse</em>broadcast<em>sub is an alias of broadcast</em>sub.</p>
<p>Returns element-wise difference of the input arrays with broadcasting.</p>
<p><code>broadcast_minus</code> is an alias to the function <code>broadcast_sub</code>.</p>
<p>Example::</p>
<p>x = [[ 1.,  1.,  1.],         [ 1.,  1.,  1.]]</p>
<p>y = [[ 0.],         [ 1.]]</p>
<p>broadcast_sub(x, y) = [[ 1.,  1.,  1.],                           [ 0.,  0.,  0.]]</p>
<p>broadcast_minus(x, y) = [[ 1.,  1.,  1.],                             [ 0.,  0.,  0.]]</p>
<p>Supported sparse operations:</p>
<p>broadcast<em>sub/minus(csr, dense(1D)) = dense    broadcast</em>sub/minus(dense(1D), csr) = dense</p>
<p>Defined in src/operator/tensor/elemwise<em>binary</em>broadcast<em>op</em>basic.cc:L106</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: First input to the function</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: Second input to the function</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L376' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_cast_storage-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._sparse_cast_storage-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_cast_storage</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_sparse_cast_storage(data, stype)
</code></pre>

<p><em>sparse</em>cast<em>storage is an alias of cast</em>storage.</p>
<p>Casts tensor storage type to the new type.</p>
<p>When an NDArray with default storage type is cast to csr or row_sparse storage, the result is compact, which means:</p>
<ul>
<li>for csr, zero values will not be retained</li>
<li>for row_sparse, row slices of all zeros will not be retained</li>
</ul>
<p>The storage type of $cast_storage$ output depends on stype parameter:</p>
<ul>
<li>cast_storage(csr, 'default') = default</li>
<li>cast<em>storage(row</em>sparse, 'default') = default</li>
<li>cast_storage(default, 'csr') = csr</li>
<li>cast<em>storage(default, 'row</em>sparse') = row_sparse</li>
<li>cast_storage(csr, 'csr') = csr</li>
<li>cast<em>storage(row</em>sparse, 'row<em>sparse') = row</em>sparse</li>
</ul>
<p>Example::</p>
<pre><code>dense = [[ 0.,  1.,  0.],
         [ 2.,  0.,  3.],
         [ 0.,  0.,  0.],
         [ 0.,  0.,  0.]]

# cast to row_sparse storage type
rsp = cast_storage(dense, 'row_sparse')
rsp.indices = [0, 1]
rsp.values = [[ 0.,  1.,  0.],
              [ 2.,  0.,  3.]]

# cast to csr storage type
csr = cast_storage(dense, 'csr')
csr.indices = [1, 0, 2]
csr.values = [ 1.,  2.,  3.]
csr.indptr = [0, 1, 3, 3, 3]
</code></pre>

<p>Defined in src/operator/tensor/cast_storage.cc:L71</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input.</li>
<li><code>stype::{'csr', 'default', 'row_sparse'}, required</code>: Output storage type.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L389' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_cbrt-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._sparse_cbrt-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_cbrt</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_sparse_cbrt(data)
</code></pre>

<p><em>sparse</em>cbrt is an alias of cbrt.</p>
<p>Returns element-wise cube-root value of the input.</p>
<p>.. math::    cbrt(x) = \sqrt[3]{x}</p>
<p>Example::</p>
<p>cbrt([1, 8, -125]) = [1, 2, -5]</p>
<p>The storage type of $cbrt$ output depends upon the input storage type:</p>
<ul>
<li>cbrt(default) = default</li>
<li>cbrt(row<em>sparse) = row</em>sparse</li>
<li>cbrt(csr) = csr</li>
</ul>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_pow.cc:L270</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L366' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_ceil-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._sparse_ceil-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_ceil</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_sparse_ceil(data)
</code></pre>

<p><em>sparse</em>ceil is an alias of ceil.</p>
<p>Returns element-wise ceiling of the input.</p>
<p>The ceil of the scalar x is the smallest integer i, such that i &gt;= x.</p>
<p>Example::</p>
<p>ceil([-2.1, -1.9, 1.5, 1.9, 2.1]) = [-2., -1.,  2.,  2.,  3.]</p>
<p>The storage type of $ceil$ output depends upon the input storage type:</p>
<ul>
<li>ceil(default) = default</li>
<li>ceil(row<em>sparse) = row</em>sparse</li>
<li>ceil(csr) = csr</li>
</ul>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_basic.cc:L817</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L365' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_clip-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._sparse_clip-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_clip</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_sparse_clip(data, a_min, a_max)
</code></pre>

<p><em>sparse</em>clip is an alias of clip.</p>
<p>Clips (limits) the values in an array. Given an interval, values outside the interval are clipped to the interval edges. Clipping $x$ between <code>a_min</code> and <code>a_max</code> would be:: .. math::    clip(x, a<em>min, a</em>max) = \max(\min(x, a<em>max), a</em>min)) Example::     x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]     clip(x,1,8) = [ 1.,  1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  8.] The storage type of $clip$ output depends on storage types of inputs and the a<em>min, a</em>max 
parameter values:</p>
<ul>
<li>clip(default) = default</li>
<li>clip(row<em>sparse, a</em>min &lt;= 0, a<em>max &gt;= 0) = row</em>sparse</li>
<li>clip(csr, a<em>min &lt;= 0, a</em>max &gt;= 0) = csr</li>
<li>clip(row<em>sparse, a</em>min &lt; 0, a_max &lt; 0) = default</li>
<li>clip(row<em>sparse, a</em>min &gt; 0, a_max &gt; 0) = default</li>
<li>clip(csr, a<em>min &lt; 0, a</em>max &lt; 0) = csr</li>
<li>clip(csr, a<em>min &gt; 0, a</em>max &gt; 0) = csr</li>
</ul>
<p>Defined in src/operator/tensor/matrix_op.cc:L677</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input array.</li>
<li><code>a_min::float, required</code>: Minimum value</li>
<li><code>a_max::float, required</code>: Maximum value</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L372' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_concat-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._sparse_concat-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_concat</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_sparse_concat(data, num_args, dim)
</code></pre>

<p><em>sparse</em>concat is an alias of Concat.</p>
<p><strong>Note</strong>: <em>sparse</em>concat takes variable number of positional inputs. So instead of calling as <em>sparse</em>concat([x, y, z], num<em>args=3), one should call via _sparse</em>concat(x, y, z), and num_args will be determined automatically.</p>
<p>Joins input arrays along a given axis.</p>
<p>.. note:: <code>Concat</code> is deprecated. Use <code>concat</code> instead.</p>
<p>The dimensions of the input arrays should be the same except the axis along which they will be concatenated. The dimension of the output array along the concatenated axis will be equal to the sum of the corresponding dimensions of the input arrays.</p>
<p>The storage type of $concat$ output depends on storage types of inputs</p>
<ul>
<li>concat(csr, csr, ..., csr, dim=0) = csr</li>
<li>otherwise, $concat$ generates output with default storage</li>
</ul>
<p>Example::</p>
<p>x = [[1,1],[2,2]]    y = [[3,3],[4,4],[5,5]]    z = [[6,6], [7,7],[8,8]]</p>
<p>concat(x,y,z,dim=0) = [[ 1.,  1.],                           [ 2.,  2.],                           [ 3.,  3.],                           [ 4.,  4.],                           [ 5.,  5.],                           [ 6.,  6.],                           [ 7.,  7.],                           [ 8.,  8.]]</p>
<p>Note that you cannot concat x,y,z along dimension 1 since dimension    0 is not the same for all the input arrays.</p>
<p>concat(y,z,dim=1) = [[ 3.,  3.,  6.,  6.],                          [ 4.,  4.,  7.,  7.],                          [ 5.,  5.,  8.,  8.]]</p>
<p>Defined in src/operator/nn/concat.cc:L385</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode[]</code>: List of arrays to concatenate</li>
<li><code>num_args::int, required</code>: Number of inputs to be concated.</li>
<li><code>dim::int, optional, default='1'</code>: the dimension to be concated.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L393' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_cos-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._sparse_cos-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_cos</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_sparse_cos(data)
</code></pre>

<p><em>sparse</em>cos is an alias of cos.</p>
<p>Computes the element-wise cosine of the input array.</p>
<p>The input should be in radians (:math:<code>2\pi</code> rad equals 360 degrees).</p>
<p>.. math::    cos([0, \pi/4, \pi/2]) = [1, 0.707, 0]</p>
<p>The storage type of $cos$ output is always dense</p>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_trig.cc:L90</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L360' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_cosh-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._sparse_cosh-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_cosh</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_sparse_cosh(data)
</code></pre>

<p><em>sparse</em>cosh is an alias of cosh.</p>
<p>Returns the hyperbolic cosine  of the input array, computed element-wise.</p>
<p>.. math::    cosh(x) = 0.5\times(exp(x) + exp(-x))</p>
<p>The storage type of $cosh$ output is always dense</p>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_trig.cc:L409</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L358' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_degrees-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._sparse_degrees-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_degrees</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_sparse_degrees(data)
</code></pre>

<p><em>sparse</em>degrees is an alias of degrees.</p>
<p>Converts each element of the input array from radians to degrees.</p>
<p>.. math::    degrees([0, \pi/2, \pi, 3\pi/2, 2\pi]) = [0, 90, 180, 270, 360]</p>
<p>The storage type of $degrees$ output depends upon the input storage type:</p>
<ul>
<li>degrees(default) = default</li>
<li>degrees(row<em>sparse) = row</em>sparse</li>
<li>degrees(csr) = csr</li>
</ul>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_trig.cc:L332</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L362' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_dot-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._sparse_dot-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_dot</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_sparse_dot(lhs, rhs, transpose_a, transpose_b, forward_stype)
</code></pre>

<p><em>sparse</em>dot is an alias of dot.</p>
<p>Dot product of two arrays.</p>
<p>$dot$'s behavior depends on the input array dimensions:</p>
<ul>
<li>1-D arrays: inner product of vectors</li>
<li>2-D arrays: matrix multiplication</li>
<li>
<p>N-D arrays: a sum product over the last axis of the first input and the first axis of the second input</p>
<p>For example, given 3-D $x$ with shape <code>(n,m,k)</code> and $y$ with shape <code>(k,r,s)</code>, the result array will have shape <code>(n,m,r,s)</code>. It is computed by::</p>
<p>dot(x,y)[i,j,a,b] = sum(x[i,j,:]*y[:,a,b])</p>
<p>Example::</p>
<p>x = reshape([0,1,2,3,4,5,6,7], shape=(2,2,2))   y = reshape([7,6,5,4,3,2,1,0], shape=(2,2,2))   dot(x,y)[0,0,1,1] = 0   sum(x[0,0,:]*y[:,1,1]) = 0</p>
</li>
</ul>
<p>The storage type of $dot$ output depends on storage types of inputs, transpose option and forward_stype option for output storage type. Implemented sparse operations include:</p>
<ul>
<li>dot(default, default, transpose<em>a=True/False, transpose</em>b=True/False) = default</li>
<li>dot(csr, default, transpose_a=True) = default</li>
<li>dot(csr, default, transpose<em>a=True) = row</em>sparse</li>
<li>dot(csr, default) = default</li>
<li>dot(csr, row_sparse) = default</li>
<li>dot(default, csr) = csr (CPU only)</li>
<li>dot(default, csr, forward_stype='default') = default</li>
<li>dot(default, csr, transpose<em>b=True, forward</em>stype='default') = default</li>
</ul>
<p>If the combination of input storage types and forward_stype does not match any of the above patterns, $dot$ will fallback and generate output with default storage.</p>
<p>.. Note::</p>
<pre><code>If the storage type of the lhs is &quot;csr&quot;, the storage type of gradient w.r.t rhs will be
&quot;row_sparse&quot;. Only a subset of optimizers support sparse gradients, including SGD, AdaGrad
and Adam. Note that by default lazy updates is turned on, which may perform differently
from standard updates. For more details, please check the Optimization API at:
https://mxnet.incubator.apache.org/api/python/optimization/optimization.html
</code></pre>

<p>Defined in src/operator/tensor/dot.cc:L77</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: The first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: The second input</li>
<li><code>transpose_a::boolean, optional, default=0</code>: If true then transpose the first input before dot.</li>
<li><code>transpose_b::boolean, optional, default=0</code>: If true then transpose the second input before dot.</li>
<li><code>forward_stype::{None, 'csr', 'default', 'row_sparse'},optional, default='None'</code>: The desired storage type of the forward output given by user, if thecombination of input storage types and this hint does not matchany implemented ones, the dot operator will perform fallback operationand still produce an output of the desired storage type.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L403' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_elemwise_add-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._sparse_elemwise_add-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_elemwise_add</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_sparse_elemwise_add(lhs, rhs)
</code></pre>

<p><em>sparse</em>elemwise<em>add is an alias of elemwise</em>add.</p>
<p>Adds arguments element-wise.</p>
<p>The storage type of $elemwise_add$ output depends on storage types of inputs</p>
<ul>
<li>elemwise<em>add(row</em>sparse, row<em>sparse) = row</em>sparse</li>
<li>elemwise_add(csr, csr) = csr</li>
<li>elemwise_add(default, csr) = default</li>
<li>elemwise_add(csr, default) = default</li>
<li>elemwise_add(default, rsp) = default</li>
<li>elemwise_add(rsp, default) = default</li>
<li>otherwise, $elemwise_add$ generates output with default storage</li>
</ul>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L363' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_elemwise_div-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._sparse_elemwise_div-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_elemwise_div</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_sparse_elemwise_div(lhs, rhs)
</code></pre>

<p><em>sparse</em>elemwise<em>div is an alias of elemwise</em>div.</p>
<p>Divides arguments element-wise.</p>
<p>The storage type of $elemwise_div$ output is always dense</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L355' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_elemwise_mul-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._sparse_elemwise_mul-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_elemwise_mul</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_sparse_elemwise_mul(lhs, rhs)
</code></pre>

<p><em>sparse</em>elemwise<em>mul is an alias of elemwise</em>mul.</p>
<p>Multiplies arguments element-wise.</p>
<p>The storage type of $elemwise_mul$ output depends on storage types of inputs</p>
<ul>
<li>elemwise_mul(default, default) = default</li>
<li>elemwise<em>mul(row</em>sparse, row<em>sparse) = row</em>sparse</li>
<li>elemwise<em>mul(default, row</em>sparse) = row_sparse</li>
<li>elemwise<em>mul(row</em>sparse, default) = row_sparse</li>
<li>elemwise_mul(csr, csr) = csr</li>
<li>otherwise, $elemwise_mul$ generates output with default storage</li>
</ul>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L362' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_elemwise_sub-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._sparse_elemwise_sub-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_elemwise_sub</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_sparse_elemwise_sub(lhs, rhs)
</code></pre>

<p><em>sparse</em>elemwise<em>sub is an alias of elemwise</em>sub.</p>
<p>Subtracts arguments element-wise.</p>
<p>The storage type of $elemwise_sub$ output depends on storage types of inputs</p>
<ul>
<li>elemwise<em>sub(row</em>sparse, row<em>sparse) = row</em>sparse</li>
<li>elemwise_sub(csr, csr) = csr</li>
<li>elemwise_sub(default, csr) = default</li>
<li>elemwise_sub(csr, default) = default</li>
<li>elemwise_sub(default, rsp) = default</li>
<li>elemwise_sub(rsp, default) = default</li>
<li>otherwise, $elemwise_sub$ generates output with default storage</li>
</ul>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L363' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_exp-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._sparse_exp-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_exp</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_sparse_exp(data)
</code></pre>

<p><em>sparse</em>exp is an alias of exp.</p>
<p>Returns element-wise exponential value of the input.</p>
<p>.. math::    exp(x) = e^x \approx 2.718^x</p>
<p>Example::</p>
<p>exp([0, 1, 2]) = [1., 2.71828175, 7.38905621]</p>
<p>The storage type of $exp$ output is always dense</p>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_logexp.cc:L64</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L362' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_expm1-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._sparse_expm1-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_expm1</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_sparse_expm1(data)
</code></pre>

<p><em>sparse</em>expm1 is an alias of expm1.</p>
<p>Returns $exp(x) - 1$ computed element-wise on the input.</p>
<p>This function provides greater precision than $exp(x) - 1$ for small values of $x$.</p>
<p>The storage type of $expm1$ output depends upon the input storage type:</p>
<ul>
<li>expm1(default) = default</li>
<li>expm1(row<em>sparse) = row</em>sparse</li>
<li>expm1(csr) = csr</li>
</ul>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_logexp.cc:L244</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L361' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_fix-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._sparse_fix-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_fix</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_sparse_fix(data)
</code></pre>

<p><em>sparse</em>fix is an alias of fix.</p>
<p>Returns element-wise rounded value to the nearest 
integer towards zero of the input.</p>
<p>Example::</p>
<p>fix([-2.1, -1.9, 1.9, 2.1]) = [-2., -1.,  1., 2.]</p>
<p>The storage type of $fix$ output depends upon the input storage type:</p>
<ul>
<li>fix(default) = default</li>
<li>fix(row<em>sparse) = row</em>sparse</li>
<li>fix(csr) = csr</li>
</ul>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_basic.cc:L874</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L364' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_floor-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._sparse_floor-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_floor</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_sparse_floor(data)
</code></pre>

<p><em>sparse</em>floor is an alias of floor.</p>
<p>Returns element-wise floor of the input.</p>
<p>The floor of the scalar x is the largest integer i, such that i &lt;= x.</p>
<p>Example::</p>
<p>floor([-2.1, -1.9, 1.5, 1.9, 2.1]) = [-3., -2.,  1.,  1.,  2.]</p>
<p>The storage type of $floor$ output depends upon the input storage type:</p>
<ul>
<li>floor(default) = default</li>
<li>floor(row<em>sparse) = row</em>sparse</li>
<li>floor(csr) = csr</li>
</ul>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_basic.cc:L836</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L365' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_ftrl_update-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._sparse_ftrl_update-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_ftrl_update</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_sparse_ftrl_update(weight, grad, z, n, lr, lamda1, beta, wd, rescale_grad, clip_gradient)
</code></pre>

<p><em>sparse</em>ftrl<em>update is an alias of ftrl</em>update.</p>
<p>Update function for Ftrl optimizer. Referenced from <em>Ad Click Prediction: a View from the Trenches</em>, available at http://dl.acm.org/citation.cfm?id=2488200.</p>
<p>It updates the weights using::</p>
<p>rescaled<em>grad = clip(grad * rescale</em>grad, clip<em>gradient)  z += rescaled</em>grad - (sqrt(n + rescaled<em>grad<strong>2) - sqrt(n)) * weight / learning<em>rate  n += rescaled</em>grad</strong>2  w = (sign(z) * lamda1 - z) / ((beta + sqrt(n)) / learning</em>rate + wd) * (abs(z) &gt; lamda1)</p>
<p>If w, z and n are all of $row_sparse$ storage type, only the row slices whose indices appear in grad.indices are updated (for w, z and n)::</p>
<p>for row in grad.indices:      rescaled<em>grad[row] = clip(grad[row] * rescale</em>grad, clip<em>gradient)      z[row] += rescaled</em>grad[row] - (sqrt(n[row] + rescaled<em>grad[row]<strong>2) - sqrt(n[row])) * weight[row] / learning<em>rate      n[row] += rescaled</em>grad[row]</strong>2      w[row] = (sign(z[row]) * lamda1 - z[row]) / ((beta + sqrt(n[row])) / learning</em>rate + wd) * (abs(z[row]) &gt; lamda1)</p>
<p>Defined in src/operator/optimizer_op.cc:L867</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>weight::NDArray-or-SymbolicNode</code>: Weight</li>
<li><code>grad::NDArray-or-SymbolicNode</code>: Gradient</li>
<li><code>z::NDArray-or-SymbolicNode</code>: z</li>
<li><code>n::NDArray-or-SymbolicNode</code>: Square of grad</li>
<li><code>lr::float, required</code>: Learning rate</li>
<li><code>lamda1::float, optional, default=0.00999999978</code>: The L1 regularization coefficient.</li>
<li><code>beta::float, optional, default=1</code>: Per-Coordinate Learning Rate beta.</li>
<li><code>wd::float, optional, default=0</code>: Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</li>
<li><code>rescale_grad::float, optional, default=1</code>: Rescale gradient to grad = rescale_grad*grad.</li>
<li><code>clip_gradient::float, optional, default=-1</code>: Clip gradient to the range of [-clip<em>gradient, clip</em>gradient] If clip<em>gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip</em>gradient), -clip_gradient).</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L389' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_gamma-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._sparse_gamma-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_gamma</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_sparse_gamma(data)
</code></pre>

<p><em>sparse</em>gamma is an alias of gamma.</p>
<p>Returns the gamma function (extension of the factorial function 
to the reals), computed element-wise on the input array.</p>
<p>The storage type of $gamma$ output is always dense</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L354' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_gammaln-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._sparse_gammaln-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_gammaln</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_sparse_gammaln(data)
</code></pre>

<p><em>sparse</em>gammaln is an alias of gammaln.</p>
<p>Returns element-wise log of the absolute value of the gamma function 
of the input.</p>
<p>The storage type of $gammaln$ output is always dense</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L354' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_log-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._sparse_log-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_log</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_sparse_log(data)
</code></pre>

<p><em>sparse</em>log is an alias of log.</p>
<p>Returns element-wise Natural logarithmic value of the input.</p>
<p>The natural logarithm is logarithm in base <em>e</em>, so that $log(exp(x)) = x$</p>
<p>The storage type of $log$ output is always dense</p>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_logexp.cc:L77</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L357' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_log10-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._sparse_log10-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_log10</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_sparse_log10(data)
</code></pre>

<p><em>sparse</em>log10 is an alias of log10.</p>
<p>Returns element-wise Base-10 logarithmic value of the input.</p>
<p>$10**log10(x) = x$</p>
<p>The storage type of $log10$ output is always dense</p>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_logexp.cc:L94</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L357' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_log1p-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._sparse_log1p-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_log1p</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_sparse_log1p(data)
</code></pre>

<p><em>sparse</em>log1p is an alias of log1p.</p>
<p>Returns element-wise $log(1 + x)$ value of the input.</p>
<p>This function is more accurate than $log(1 + x)$  for small $x$ so that :math:<code>1+x\approx 1</code></p>
<p>The storage type of $log1p$ output depends upon the input storage type:</p>
<ul>
<li>log1p(default) = default</li>
<li>log1p(row<em>sparse) = row</em>sparse</li>
<li>log1p(csr) = csr</li>
</ul>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_logexp.cc:L199</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L362' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_log2-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._sparse_log2-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_log2</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_sparse_log2(data)
</code></pre>

<p><em>sparse</em>log2 is an alias of log2.</p>
<p>Returns element-wise Base-2 logarithmic value of the input.</p>
<p>$2**log2(x) = x$</p>
<p>The storage type of $log2$ output is always dense</p>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_logexp.cc:L106</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L357' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_make_loss-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._sparse_make_loss-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_make_loss</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_sparse_make_loss(data)
</code></pre>

<p><em>sparse</em>make<em>loss is an alias of make</em>loss.</p>
<p>Make your own loss function in network construction.</p>
<p>This operator accepts a customized loss function symbol as a terminal loss and the symbol should be an operator with no backward dependency. The output of this function is the gradient of loss with respect to the input data.</p>
<p>For example, if you are a making a cross entropy loss function. Assume $out$ is the predicted output and $label$ is the true label, then the cross entropy can be defined as::</p>
<p>cross<em>entropy = label * log(out) + (1 - label) * log(1 - out)   loss = make</em>loss(cross_entropy)</p>
<p>We will need to use $make_loss$ when we are creating our own loss function or we want to combine multiple loss functions. Also we may want to stop some variables' gradients from backpropagation. See more detail in $BlockGrad$ or $stop_gradient$.</p>
<p>The storage type of $make_loss$ output depends upon the input storage type:</p>
<ul>
<li>make_loss(default) = default</li>
<li>make<em>loss(row</em>sparse) = row_sparse</li>
</ul>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_basic.cc:L358</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L372' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_mean-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._sparse_mean-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_mean</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_sparse_mean(data, axis, keepdims, exclude)
</code></pre>

<p><em>sparse</em>mean is an alias of mean.</p>
<p>Computes the mean of array elements over given axes.</p>
<p>Defined in src/operator/tensor/./broadcast<em>reduce</em>op.h:L84</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input</li>
<li>
<p><code>axis::Shape or None, optional, default=None</code>: The axis or axes along which to perform the reduction.</p>
<p><code>``
The default,</code>axis=()<code>, will compute over all elements into a
scalar array with shape</code>(1,)`.</p>
<p>If <code>axis</code> is int, a reduction is performed on a particular axis.</p>
<p>If <code>axis</code> is a tuple of ints, a reduction is performed on all the axes
specified in the tuple.</p>
<p>If <code>exclude</code> is true, reduction will be performed on the axes that are
NOT in axis instead.</p>
<p>Negative values means indexing from right to left.
<code>``
  *</code>keepdims::boolean, optional, default=0<code>: If this is set to</code>True<code>, the reduced axes are left in the result as dimension with size one.
  *</code>exclude::boolean, optional, default=0<code>: Whether to perform reduction on axis that are NOT in axis instead.
  *</code>name::Symbol<code>: The name of the</code>SymbolicNode<code>. (e.g.</code>:my_symbol<code>), optional.
  *</code>attrs::Dict{Symbol,String}<code>: The attributes associated with this</code>SymbolicNode`.</p>
</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L370' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_negative-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._sparse_negative-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_negative</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_sparse_negative(data)
</code></pre>

<p><em>sparse</em>negative is an alias of negative.</p>
<p>Numerical negative of the argument, element-wise.</p>
<p>The storage type of $negative$ output depends upon the input storage type:</p>
<ul>
<li>negative(default) = default</li>
<li>negative(row<em>sparse) = row</em>sparse</li>
<li>negative(csr) = csr</li>
</ul>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L357' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_norm-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._sparse_norm-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_norm</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_sparse_norm(data, ord, axis, out_dtype, keepdims)
</code></pre>

<p><em>sparse</em>norm is an alias of norm.</p>
<p>Computes the norm on an NDArray.</p>
<p>This operator computes the norm on an NDArray with the specified axis, depending on the value of the ord parameter. By default, it computes the L2 norm on the entire array. Currently only ord=2 supports sparse ndarrays.</p>
<p>Examples::</p>
<p>x = [[[1, 2],         [3, 4]],        [[2, 2],         [5, 6]]]</p>
<p>norm(x, ord=2, axis=1) = [[3.1622777 4.472136 ]                             [5.3851647 6.3245554]]</p>
<p>norm(x, ord=1, axis=1) = [[4., 6.],                             [7., 8.]]</p>
<p>rsp = x.cast<em>storage('row</em>sparse')</p>
<p>norm(rsp) = [5.47722578]</p>
<p>csr = x.cast_storage('csr')</p>
<p>norm(csr) = [5.47722578]</p>
<p>Defined in src/operator/tensor/broadcast<em>reduce</em>norm_value.cc:L89</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input</li>
<li><code>ord::int, optional, default='2'</code>: Order of the norm. Currently ord=1 and ord=2 is supported.</li>
<li><code>axis::Shape or None, optional, default=None</code>: The axis or axes along which to perform the reduction.     The default, <code>axis=()</code>, will compute over all elements into a     scalar array with shape <code>(1,)</code>.     If <code>axis</code> is int, a reduction is performed on a particular axis.     If <code>axis</code> is a 2-tuple, it specifies the axes that hold 2-D matrices,     and the matrix norms of these matrices are computed.</li>
<li><code>out_dtype::{None, 'float16', 'float32', 'float64', 'int32', 'int64', 'int8'},optional, default='None'</code>: The data type of the output.</li>
<li><code>keepdims::boolean, optional, default=0</code>: If this is set to <code>True</code>, the reduced axis is left in the result as dimension with size one.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L391' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_radians-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._sparse_radians-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_radians</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_sparse_radians(data)
</code></pre>

<p><em>sparse</em>radians is an alias of radians.</p>
<p>Converts each element of the input array from degrees to radians.</p>
<p>.. math::    radians([0, 90, 180, 270, 360]) = [0, \pi/2, \pi, 3\pi/2, 2\pi]</p>
<p>The storage type of $radians$ output depends upon the input storage type:</p>
<ul>
<li>radians(default) = default</li>
<li>radians(row<em>sparse) = row</em>sparse</li>
<li>radians(csr) = csr</li>
</ul>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_trig.cc:L351</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L362' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_relu-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._sparse_relu-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_relu</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_sparse_relu(data)
</code></pre>

<p><em>sparse</em>relu is an alias of relu.</p>
<p>Computes rectified linear activation.</p>
<p>.. math::    max(features, 0)</p>
<p>The storage type of $relu$ output depends upon the input storage type:</p>
<ul>
<li>relu(default) = default</li>
<li>relu(row<em>sparse) = row</em>sparse</li>
<li>relu(csr) = csr</li>
</ul>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_basic.cc:L85</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L362' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_retain-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._sparse_retain-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_retain</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_sparse_retain(data, indices)
</code></pre>

<p>Pick rows specified by user input index array from a row sparse matrix and save them in the output sparse matrix.</p>
<p>Example::</p>
<p>data = [[1, 2], [3, 4], [5, 6]]   indices = [0, 1, 3]   shape = (4, 2)   rsp<em>in = row</em>sparse<em>array(data, indices)   to</em>retain = [0, 3]   rsp<em>out = retain(rsp</em>in, to<em>retain)   rsp</em>out.data = [[1, 2], [5, 6]]   rsp_out.indices = [0, 3]</p>
<p>The storage type of $retain$ output depends on storage types of inputs</p>
<ul>
<li>retain(row<em>sparse, default) = row</em>sparse</li>
<li>otherwise, $retain$ is not supported</li>
</ul>
<p>Defined in src/operator/tensor/sparse_retain.cc:L53</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array for sparse_retain operator.</li>
<li><code>indices::NDArray-or-SymbolicNode</code>: The index array of rows ids that will be retained.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L370' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_rint-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._sparse_rint-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_rint</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_sparse_rint(data)
</code></pre>

<p><em>sparse</em>rint is an alias of rint.</p>
<p>Returns element-wise rounded value to the nearest integer of the input.</p>
<p>.. note::</p>
<ul>
<li>For input $n.5$ $rint$ returns $n$ while $round$ returns $n+1$.</li>
<li>For input $-n.5$ both $rint$ and $round$ returns $-n-1$.</li>
</ul>
<p>Example::</p>
<p>rint([-1.5, 1.5, -1.9, 1.9, 2.1]) = [-2.,  1., -2.,  2.,  2.]</p>
<p>The storage type of $rint$ output depends upon the input storage type:</p>
<ul>
<li>rint(default) = default</li>
<li>rint(row<em>sparse) = row</em>sparse</li>
<li>rint(csr) = csr</li>
</ul>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_basic.cc:L798</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L367' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_round-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._sparse_round-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_round</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_sparse_round(data)
</code></pre>

<p><em>sparse</em>round is an alias of round.</p>
<p>Returns element-wise rounded value to the nearest integer of the input.</p>
<p>Example::</p>
<p>round([-1.5, 1.5, -1.9, 1.9, 2.1]) = [-2.,  2., -2.,  2.,  2.]</p>
<p>The storage type of $round$ output depends upon the input storage type:</p>
<ul>
<li>round(default) = default</li>
<li>round(row<em>sparse) = row</em>sparse</li>
<li>round(csr) = csr</li>
</ul>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_basic.cc:L777</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L363' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_rsqrt-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._sparse_rsqrt-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_rsqrt</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_sparse_rsqrt(data)
</code></pre>

<p><em>sparse</em>rsqrt is an alias of rsqrt.</p>
<p>Returns element-wise inverse square-root value of the input.</p>
<p>.. math::    rsqrt(x) = 1/\sqrt{x}</p>
<p>Example::</p>
<p>rsqrt([4,9,16]) = [0.5, 0.33333334, 0.25]</p>
<p>The storage type of $rsqrt$ output is always dense</p>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_pow.cc:L221</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L362' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_sgd_mom_update-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._sparse_sgd_mom_update-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_sgd_mom_update</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_sparse_sgd_mom_update(weight, grad, mom, lr, momentum, wd, rescale_grad, clip_gradient, lazy_update)
</code></pre>

<p><em>sparse</em>sgd<em>mom</em>update is an alias of sgd<em>mom</em>update.</p>
<p>Momentum update function for Stochastic Gradient Descent (SGD) optimizer.</p>
<p>Momentum update has better convergence rates on neural networks. Mathematically it looks like below:</p>
<p>.. math::</p>
<p>v<em>1 = \alpha * \nabla J(W</em>0)\
  v<em t-1="t-1">t = \gamma v</em> - \alpha * \nabla J(W<em>{t-1})\
  W</em>t = W<em>{t-1} + v</em>t</p>
<p>It updates the weights using::</p>
<p>v = momentum * v - learning_rate * gradient   weight += v</p>
<p>Where the parameter $momentum$ is the decay rate of momentum estimates at each epoch.</p>
<p>However, if grad's storage type is $row_sparse$, $lazy_update$ is True and weight's storage type is the same as momentum's storage type, only the row slices whose indices appear in grad.indices are updated (for both weight and momentum)::</p>
<p>for row in gradient.indices:       v[row] = momentum[row] * v[row] - learning_rate * gradient[row]       weight[row] += v[row]</p>
<p>Defined in src/operator/optimizer_op.cc:L556</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>weight::NDArray-or-SymbolicNode</code>: Weight</li>
<li><code>grad::NDArray-or-SymbolicNode</code>: Gradient</li>
<li><code>mom::NDArray-or-SymbolicNode</code>: Momentum</li>
<li><code>lr::float, required</code>: Learning rate</li>
<li><code>momentum::float, optional, default=0</code>: The decay rate of momentum estimates at each epoch.</li>
<li><code>wd::float, optional, default=0</code>: Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</li>
<li><code>rescale_grad::float, optional, default=1</code>: Rescale gradient to grad = rescale_grad*grad.</li>
<li><code>clip_gradient::float, optional, default=-1</code>: Clip gradient to the range of [-clip<em>gradient, clip</em>gradient] If clip<em>gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip</em>gradient), -clip_gradient).</li>
<li><code>lazy_update::boolean, optional, default=1</code>: If true, lazy updates are applied if gradient's stype is row_sparse and both weight and momentum have the same stype</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L393' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_sgd_update-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._sparse_sgd_update-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_sgd_update</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_sparse_sgd_update(weight, grad, lr, wd, rescale_grad, clip_gradient, lazy_update)
</code></pre>

<p><em>sparse</em>sgd<em>update is an alias of sgd</em>update.</p>
<p>Update function for Stochastic Gradient Descent (SGD) optimizer.</p>
<p>It updates the weights using::</p>
<p>weight = weight - learning_rate * (gradient + wd * weight)</p>
<p>However, if gradient is of $row_sparse$ storage type and $lazy_update$ is True, only the row slices whose indices appear in grad.indices are updated::</p>
<p>for row in gradient.indices:      weight[row] = weight[row] - learning_rate * (gradient[row] + wd * weight[row])</p>
<p>Defined in src/operator/optimizer_op.cc:L515</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>weight::NDArray-or-SymbolicNode</code>: Weight</li>
<li><code>grad::NDArray-or-SymbolicNode</code>: Gradient</li>
<li><code>lr::float, required</code>: Learning rate</li>
<li><code>wd::float, optional, default=0</code>: Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</li>
<li><code>rescale_grad::float, optional, default=1</code>: Rescale gradient to grad = rescale_grad*grad.</li>
<li><code>clip_gradient::float, optional, default=-1</code>: Clip gradient to the range of [-clip<em>gradient, clip</em>gradient] If clip<em>gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip</em>gradient), -clip_gradient).</li>
<li><code>lazy_update::boolean, optional, default=1</code>: If true, lazy updates are applied if gradient's stype is row_sparse.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L375' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_sigmoid-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._sparse_sigmoid-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_sigmoid</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_sparse_sigmoid(data)
</code></pre>

<p><em>sparse</em>sigmoid is an alias of sigmoid.</p>
<p>Computes sigmoid of x element-wise.</p>
<p>.. math::    y = 1 / (1 + exp(-x))</p>
<p>The storage type of $sigmoid$ output is always dense</p>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_basic.cc:L119</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L358' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_sign-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._sparse_sign-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_sign</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_sparse_sign(data)
</code></pre>

<p><em>sparse</em>sign is an alias of sign.</p>
<p>Returns element-wise sign of the input.</p>
<p>Example::</p>
<p>sign([-2, 0, 3]) = [-1, 0, 1]</p>
<p>The storage type of $sign$ output depends upon the input storage type:</p>
<ul>
<li>sign(default) = default</li>
<li>sign(row<em>sparse) = row</em>sparse</li>
<li>sign(csr) = csr</li>
</ul>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_basic.cc:L758</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L363' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_sin-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._sparse_sin-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_sin</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_sparse_sin(data)
</code></pre>

<p><em>sparse</em>sin is an alias of sin.</p>
<p>Computes the element-wise sine of the input array.</p>
<p>The input should be in radians (:math:<code>2\pi</code> rad equals 360 degrees).</p>
<p>.. math::    sin([0, \pi/4, \pi/2]) = [0, 0.707, 1]</p>
<p>The storage type of $sin$ output depends upon the input storage type:</p>
<ul>
<li>sin(default) = default</li>
<li>sin(row<em>sparse) = row</em>sparse</li>
<li>sin(csr) = csr</li>
</ul>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_trig.cc:L47</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L364' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_sinh-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._sparse_sinh-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_sinh</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_sparse_sinh(data)
</code></pre>

<p><em>sparse</em>sinh is an alias of sinh.</p>
<p>Returns the hyperbolic sine of the input array, computed element-wise.</p>
<p>.. math::    sinh(x) = 0.5\times(exp(x) - exp(-x))</p>
<p>The storage type of $sinh$ output depends upon the input storage type:</p>
<ul>
<li>sinh(default) = default</li>
<li>sinh(row<em>sparse) = row</em>sparse</li>
<li>sinh(csr) = csr</li>
</ul>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_trig.cc:L371</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L362' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_slice-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._sparse_slice-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_slice</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_sparse_slice(data, begin, end, step)
</code></pre>

<p><em>sparse</em>slice is an alias of slice.</p>
<p>Slices a region of the array. .. note:: $crop$ is deprecated. Use $slice$ instead. This function returns a sliced array between the indices given by <code>begin</code> and <code>end</code> with the corresponding <code>step</code>. For an input array of $shape=(d_0, d_1, ..., d_n-1)$, slice operation with $begin=(b_0, b_1...b_m-1)$, $end=(e_0, e_1, ..., e_m-1)$, and $step=(s_0, s_1, ..., s_m-1)$, where m &lt;= n, results in an array with the shape $(|e_0-b_0|/|s_0|, ..., |e_m-1-b_m-1|/|s_m-1|, d_m, ..., d_n-1)$. The resulting array's <em>k</em>-th dimension contains elements from the <em>k</em>-th dimension of the input array starting from index $b_k$ (inclusive) with step $s_k$ until reaching $e_k$ (exclusive). If the <em>k</em>-th elements are <code>None</code> in the sequence of <code>begin</code>, <code>end</code>, and <code>step</code>, the following rule will be used to set default values. If <code>s_k</code> is <code>None</code>, set <code>s_k=1</code>. If <code>s_k &gt; 0</code>, set <code>b_k=0</code>, <code>e_k=d_k</code>; else, set <code>b_k=d_k-1</code>, <code>e_k=-1</code>. The storage type of $slice$ output depends on storage types of inputs</p>
<ul>
<li>slice(csr) = csr</li>
<li>otherwise, $slice$ generates output with default storage</li>
</ul>
<p>.. note:: When input data storage type is csr, it only supports    step=(), or step=(None,), or step=(1,) to generate a csr output.    For other step parameter values, it falls back to slicing    a dense tensor. Example::   x = [[  1.,   2.,   3.,   4.],        [  5.,   6.,   7.,   8.],        [  9.,  10.,  11.,  12.]]   slice(x, begin=(0,1), end=(2,4)) = [[ 2.,  3.,  4.],                                      [ 6.,  7.,  8.]]   slice(x, begin=(None, 0), end=(None, 3), step=(-1, 2)) = [[9., 11.],                                                             [5.,  7.],                                                             [1.,  3.]]</p>
<p>Defined in src/operator/tensor/matrix_op.cc:L482</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Source input</li>
<li><code>begin::Shape(tuple), required</code>: starting indices for the slice operation, supports negative indices.</li>
<li><code>end::Shape(tuple), required</code>: ending indices for the slice operation, supports negative indices.</li>
<li><code>step::Shape(tuple), optional, default=[]</code>: step for the slice operation, supports negative values.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L390' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_sqrt-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._sparse_sqrt-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_sqrt</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_sparse_sqrt(data)
</code></pre>

<p><em>sparse</em>sqrt is an alias of sqrt.</p>
<p>Returns element-wise square-root value of the input.</p>
<p>.. math::    \textrm{sqrt}(x) = \sqrt{x}</p>
<p>Example::</p>
<p>sqrt([4, 9, 16]) = [2, 3, 4]</p>
<p>The storage type of $sqrt$ output depends upon the input storage type:</p>
<ul>
<li>sqrt(default) = default</li>
<li>sqrt(row<em>sparse) = row</em>sparse</li>
<li>sqrt(csr) = csr</li>
</ul>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_pow.cc:L170</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L366' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_square-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._sparse_square-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_square</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_sparse_square(data)
</code></pre>

<p><em>sparse</em>square is an alias of square.</p>
<p>Returns element-wise squared value of the input.</p>
<p>.. math::    square(x) = x^2</p>
<p>Example::</p>
<p>square([2, 3, 4]) = [4, 9, 16]</p>
<p>The storage type of $square$ output depends upon the input storage type:</p>
<ul>
<li>square(default) = default</li>
<li>square(row<em>sparse) = row</em>sparse</li>
<li>square(csr) = csr</li>
</ul>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_pow.cc:L119</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L366' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_stop_gradient-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._sparse_stop_gradient-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_stop_gradient</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_sparse_stop_gradient(data)
</code></pre>

<p><em>sparse</em>stop_gradient is an alias of BlockGrad.</p>
<p>Stops gradient computation.</p>
<p>Stops the accumulated gradient of the inputs from flowing through this operator in the backward direction. In other words, this operator prevents the contribution of its inputs to be taken into account for computing gradients.</p>
<p>Example::</p>
<p>v1 = [1, 2]   v2 = [0, 1]   a = Variable('a')   b = Variable('b')   b<em>stop</em>grad = stop<em>gradient(3 * b)   loss = MakeLoss(b</em>stop_grad + a)</p>
<p>executor = loss.simple<em>bind(ctx=cpu(), a=(1,2), b=(1,2))   executor.forward(is</em>train=True, a=v1, b=v2)   executor.outputs   [ 1.  5.]</p>
<p>executor.backward()   executor.grad_arrays   [ 0.  0.]   [ 1.  1.]</p>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_basic.cc:L325</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L376' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_sum-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._sparse_sum-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_sum</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_sparse_sum(data, axis, keepdims, exclude)
</code></pre>

<p><em>sparse</em>sum is an alias of sum.</p>
<p>Computes the sum of array elements over given axes.</p>
<p>.. Note::</p>
<p><code>sum</code> and <code>sum_axis</code> are equivalent.   For ndarray of csr storage type summation along axis 0 and axis 1 is supported.   Setting keepdims or exclude to True will cause a fallback to dense operator.</p>
<p>Example::</p>
<p>data = [[[1, 2], [2, 3], [1, 3]],           [[1, 4], [4, 3], [5, 2]],           [[7, 1], [7, 2], [7, 3]]]</p>
<p>sum(data, axis=1)   [[  4.   8.]    [ 10.   9.]    [ 21.   6.]]</p>
<p>sum(data, axis=[1,2])   [ 12.  19.  27.]</p>
<p>data = [[1, 2, 0],           [3, 0, 1],           [4, 1, 0]]</p>
<p>csr = cast_storage(data, 'csr')</p>
<p>sum(csr, axis=0)   [ 8.  3.  1.]</p>
<p>sum(csr, axis=1)   [ 3.  4.  5.]</p>
<p>Defined in src/operator/tensor/broadcast<em>reduce</em>sum_value.cc:L67</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input</li>
<li>
<p><code>axis::Shape or None, optional, default=None</code>: The axis or axes along which to perform the reduction.</p>
<p><code>``
The default,</code>axis=()<code>, will compute over all elements into a
scalar array with shape</code>(1,)`.</p>
<p>If <code>axis</code> is int, a reduction is performed on a particular axis.</p>
<p>If <code>axis</code> is a tuple of ints, a reduction is performed on all the axes
specified in the tuple.</p>
<p>If <code>exclude</code> is true, reduction will be performed on the axes that are
NOT in axis instead.</p>
<p>Negative values means indexing from right to left.
<code>``
  *</code>keepdims::boolean, optional, default=0<code>: If this is set to</code>True<code>, the reduced axes are left in the result as dimension with size one.
  *</code>exclude::boolean, optional, default=0<code>: Whether to perform reduction on axis that are NOT in axis instead.
  *</code>name::Symbol<code>: The name of the</code>SymbolicNode<code>. (e.g.</code>:my_symbol<code>), optional.
  *</code>attrs::Dict{Symbol,String}<code>: The attributes associated with this</code>SymbolicNode`.</p>
</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L404' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_tan-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._sparse_tan-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_tan</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_sparse_tan(data)
</code></pre>

<p><em>sparse</em>tan is an alias of tan.</p>
<p>Computes the element-wise tangent of the input array.</p>
<p>The input should be in radians (:math:<code>2\pi</code> rad equals 360 degrees).</p>
<p>.. math::    tan([0, \pi/4, \pi/2]) = [0, 1, -inf]</p>
<p>The storage type of $tan$ output depends upon the input storage type:</p>
<ul>
<li>tan(default) = default</li>
<li>tan(row<em>sparse) = row</em>sparse</li>
<li>tan(csr) = csr</li>
</ul>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_trig.cc:L140</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L364' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_tanh-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._sparse_tanh-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_tanh</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_sparse_tanh(data)
</code></pre>

<p><em>sparse</em>tanh is an alias of tanh.</p>
<p>Returns the hyperbolic tangent of the input array, computed element-wise.</p>
<p>.. math::    tanh(x) = sinh(x) / cosh(x)</p>
<p>The storage type of $tanh$ output depends upon the input storage type:</p>
<ul>
<li>tanh(default) = default</li>
<li>tanh(row<em>sparse) = row</em>sparse</li>
<li>tanh(csr) = csr</li>
</ul>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_trig.cc:L451</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L362' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_trunc-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._sparse_trunc-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_trunc</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_sparse_trunc(data)
</code></pre>

<p><em>sparse</em>trunc is an alias of trunc.</p>
<p>Return the element-wise truncated value of the input.</p>
<p>The truncated value of the scalar x is the nearest integer i which is closer to zero than x is. In short, the fractional part of the signed number x is discarded.</p>
<p>Example::</p>
<p>trunc([-2.1, -1.9, 1.5, 1.9, 2.1]) = [-2., -1.,  1.,  1.,  2.]</p>
<p>The storage type of $trunc$ output depends upon the input storage type:</p>
<ul>
<li>trunc(default) = default</li>
<li>trunc(row<em>sparse) = row</em>sparse</li>
<li>trunc(csr) = csr</li>
</ul>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_basic.cc:L856</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L366' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_where-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._sparse_where-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_where</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_sparse_where(condition, x, y)
</code></pre>

<p><em>sparse</em>where is an alias of where.</p>
<p>Return the elements, either from x or y, depending on the condition.</p>
<p>Given three ndarrays, condition, x, and y, return an ndarray with the elements from x or y, depending on the elements from condition are true or false. x and y must have the same shape. If condition has the same shape as x, each element in the output array is from x if the corresponding element in the condition is true, and from y if false.</p>
<p>If condition does not have the same shape as x, it must be a 1D array whose size is the same as x's first dimension size. Each row of the output array is from x's row if the corresponding element from condition is true, and from y's row if false.</p>
<p>Note that all non-zero values are interpreted as $True$ in condition.</p>
<p>Examples::</p>
<p>x = [[1, 2], [3, 4]]   y = [[5, 6], [7, 8]]   cond = [[0, 1], [-1, 0]]</p>
<p>where(cond, x, y) = [[5, 2], [3, 8]]</p>
<p>csr<em>cond = cast</em>storage(cond, 'csr')</p>
<p>where(csr_cond, x, y) = [[5, 2], [3, 8]]</p>
<p>Defined in src/operator/tensor/control<em>flow</em>op.cc:L57</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>condition::NDArray-or-SymbolicNode</code>: condition array</li>
<li><code>x::NDArray-or-SymbolicNode</code>:</li>
<li><code>y::NDArray-or-SymbolicNode</code>:</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L380' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_zeros_like-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._sparse_zeros_like-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_zeros_like</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_sparse_zeros_like(data)
</code></pre>

<p><em>sparse</em>zeros<em>like is an alias of zeros</em>like.</p>
<p>Return an array of zeros with the same shape, type and storage type as the input array.</p>
<p>The storage type of $zeros_like$ output depends on the storage type of the input</p>
<ul>
<li>zeros<em>like(row</em>sparse) = row_sparse</li>
<li>zeros_like(csr) = csr</li>
<li>zeros_like(default) = default</li>
</ul>
<p>Examples::</p>
<p>x = [[ 1.,  1.,  1.],        [ 1.,  1.,  1.]]</p>
<p>zeros_like(x) = [[ 0.,  0.,  0.],                    [ 0.,  0.,  0.]]</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L366' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._split_v2-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._split_v2-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._split_v2</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_split_v2(data, indices, axis, squeeze_axis, sections)
</code></pre>

<p>Splits an array along a particular axis into multiple sub-arrays. Example::    x  = [[[ 1.]           [ 2.]]          [[ 3.]           [ 4.]]          [[ 5.]           [ 6.]]]    x.shape = (3, 2, 1)    y = split<em>v2(x, axis=1, indices</em>or<em>sections=2) // a list of 2 arrays with shape (3, 1, 1)    y = [[[ 1.]]         [[ 3.]]         [[ 5.]]]        [[[ 2.]]         [[ 4.]]         [[ 6.]]]    y[0].shape = (3, 1, 1)    z = split</em>v2(x, axis=0, indices<em>or</em>sections=3) // a list of 3 arrays with shape (1, 2, 1)    z = [[[ 1.]          [ 2.]]]        [[[ 3.]          [ 4.]]]        [[[ 5.]          [ 6.]]]    z[0].shape = (1, 2, 1)    w = split<em>v2(x, axis=0, indices</em>or<em>sections=(1,)) // a list of 2 arrays with shape [(1, 2, 1), (2, 2, 1)]    w = [[[ 1.]          [ 2.]]]        [[[3.]          [4.]]         [[5.]          [6.]]]   w[0].shape = (1, 2, 1)   w[1].shape = (2, 2, 1) <code>squeeze*axis=True</code>removes the axis with length 1 from the shapes of the output arrays. <strong>Note</strong> that setting<code>squeeze*axis</code>to<code>1</code>removes axis with length 1 only along the<code>axis</code>which it is split. Also<code>squeeze*axis</code>can be set to true only if<code>input.shape[axis] == indices_or_sections</code>. Example::    z = split</em>v2(x, axis=0, indices<em>or</em>sections=3, squeeze*axis=1) // a list of 3 arrays with shape (2, 1)    z = [[ 1.]         [ 2.]]        [[ 3.]         [ 4.]]        [[ 5.]         [ 6.]]    z[0].shape = (2, 1)</p>
<p>Defined in src/operator/tensor/matrix_op.cc:L1088</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input</li>
<li><code>indices::Shape(tuple), required</code>: Indices of splits. The elements should denote the boundaries of at which split is performed along the <code>axis</code>.</li>
<li><code>axis::int, optional, default='1'</code>: Axis along which to split.</li>
<li><code>squeeze_axis::boolean, optional, default=0</code>: If true, Removes the axis with length 1 from the shapes of the output arrays. <strong>Note</strong> that setting <code>squeeze_axis</code> to $true$ removes axis with length 1 only along the <code>axis</code> which it is split. Also <code>squeeze_axis</code> can be set to $true$ only if $input.shape[axis] == num_outputs$.</li>
<li><code>sections::int, optional, default='0'</code>: Number of sections if equally splitted. Default to 0 which means split by indices.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L404' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._split_v2_backward-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._split_v2_backward-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._split_v2_backward</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_split_v2_backward()
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L346' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._square_sum-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._square_sum-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._square_sum</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_square_sum(data, axis, keepdims, exclude)
</code></pre>

<p>Computes the square sum of array elements over a given axis for row-sparse matrix. This is a temporary solution for fusing ops square and sum together for row-sparse matrix to save memory for storing gradients. It will become deprecated once the functionality of fusing operators is finished in the future.</p>
<p>Example::</p>
<p>dns = mx.nd.array([[0, 0], [1, 2], [0, 0], [3, 4], [0, 0]])   rsp = dns.tostype('row<em>sparse')   sum = mx.nd.</em>internal.<em>square</em>sum(rsp, axis=1)   sum = [0, 5, 0, 25, 0]</p>
<p>Defined in src/operator/tensor/square_sum.cc:L63</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input</li>
<li>
<p><code>axis::Shape or None, optional, default=None</code>: The axis or axes along which to perform the reduction.</p>
<p><code>``
The default,</code>axis=()<code>, will compute over all elements into a
scalar array with shape</code>(1,)`.</p>
<p>If <code>axis</code> is int, a reduction is performed on a particular axis.</p>
<p>If <code>axis</code> is a tuple of ints, a reduction is performed on all the axes
specified in the tuple.</p>
<p>If <code>exclude</code> is true, reduction will be performed on the axes that are
NOT in axis instead.</p>
<p>Negative values means indexing from right to left.
<code>``
  *</code>keepdims::boolean, optional, default=0<code>: If this is set to</code>True<code>, the reduced axes are left in the result as dimension with size one.
  *</code>exclude::boolean, optional, default=0<code>: Whether to perform reduction on axis that are NOT in axis instead.
  *</code>name::Symbol<code>: The name of the</code>SymbolicNode<code>. (e.g.</code>:my_symbol<code>), optional.
  *</code>attrs::Dict{Symbol,String}<code>: The attributes associated with this</code>SymbolicNode`.</p>
</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L380' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._unravel_index-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._unravel_index-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._unravel_index</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_unravel_index(data, shape)
</code></pre>

<p>Converts an array of flat indices into a batch of index arrays. The operator follows numpy conventions so a single multi index is given by a column of the output matrix. The leading dimension may be left unspecified by using -1 as placeholder.  </p>
<p>Examples::</p>
<p>A = [22,41,37]    unravel(A, shape=(7,6)) = [[3,6,6],[4,5,1]]    unravel(A, shape=(-1,6)) = [[3,6,6],[4,5,1]]</p>
<p>Defined in src/operator/tensor/ravel.cc:L68</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Array of flat indices</li>
<li><code>shape::Shape(tuple), optional, default=None</code>: Shape of the array into which the multi-indices apply.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L359' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._while_loop-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._while_loop-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._while_loop</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_while_loop(cond, func, data, num_args, num_outputs, num_out_data, max_iterations, cond_input_locs, func_input_locs, func_var_locs)
</code></pre>

<p><strong>Note</strong>: <em>while</em>loop takes variable number of positional inputs. So instead of calling as <em>while</em>loop([x, y, z], num<em>args=3), one should call via _while</em>loop(x, y, z), and num_args will be determined automatically.</p>
<p>Run a while loop over with user-defined condition and computation</p>
<p>From:src/operator/control_flow.cc:1151</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>cond::SymbolicNode</code>: Input graph for the loop condition.</li>
<li><code>func::SymbolicNode</code>: Input graph for the loop body.</li>
<li><code>data::NDArray-or-SymbolicNode[]</code>: The input arrays that include data arrays and states.</li>
<li><code>num_args::int, required</code>: Number of input arguments, including cond and func as two symbol inputs.</li>
<li><code>num_outputs::int, required</code>: The number of outputs of the subgraph.</li>
<li><code>num_out_data::int, required</code>: The number of outputs from the function body.</li>
<li><code>max_iterations::int, required</code>: Maximum number of iterations.</li>
<li><code>cond_input_locs::tuple of &lt;long&gt;, required</code>: The locations of cond's inputs in the given inputs.</li>
<li><code>func_input_locs::tuple of &lt;long&gt;, required</code>: The locations of func's inputs in the given inputs.</li>
<li><code>func_var_locs::tuple of &lt;long&gt;, required</code>: The locations of loop_vars among func's inputs.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L369' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._zeros-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._zeros-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._zeros</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_zeros(shape, ctx, dtype)
</code></pre>

<p>fill target with zeros</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>shape::Shape(tuple), optional, default=[]</code>: The shape of the output</li>
<li><code>ctx::string, optional, default=''</code>: Context of output, in format <a href="n">cpu|gpu|cpu_pinned</a>.Only used for imperative calls.</li>
<li><code>dtype::{'bfloat16', 'bool', 'float16', 'float32', 'float64', 'int32', 'int64', 'int8', 'uint8'},optional, default='float32'</code>: Target data type.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._zeros_without_dtype-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx._zeros_without_dtype-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx._zeros_without_dtype</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">_zeros_without_dtype(shape, ctx, dtype)
</code></pre>

<p>fill target with zeros without default dtype</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>shape::Shape(tuple), optional, default=None</code>: The shape of the output</li>
<li><code>ctx::string, optional, default=''</code>: Context of output, in format <a href="n">cpu|gpu|cpu_pinned</a>.Only used for imperative calls.</li>
<li><code>dtype::int, optional, default='-1'</code>: Target data type.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.adam_update-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.adam_update-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.adam_update</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">adam_update(weight, grad, mean, var, lr, beta1, beta2, epsilon, wd, rescale_grad, clip_gradient, lazy_update)
</code></pre>

<p>Update function for Adam optimizer. Adam is seen as a generalization of AdaGrad.</p>
<p>Adam update consists of the following steps, where g represents gradient and m, v are 1st and 2nd order moment estimates (mean and variance).</p>
<p>.. math::</p>
<p>g<em t-1="t-1">t = \nabla J(W</em>)\
 m<em>t = \beta</em>1 m<em>{t-1} + (1 - \beta</em>1) g<em>t\
 v</em>t = \beta<em t-1="t-1">2 v</em> + (1 - \beta<em>2) g</em>t^2\
 W<em t-1="t-1">t = W</em> - \alpha \frac{ m<em>t }{ \sqrt{ v</em>t } + \epsilon }</p>
<p>It updates the weights using::</p>
<p>m = beta1<em>m + (1-beta1)</em>grad  v = beta2<em>v + (1-beta2)</em>(grad**2)  w += - learning_rate * m / (sqrt(v) + epsilon)</p>
<p>However, if grad's storage type is $row_sparse$, $lazy_update$ is True and the storage type of weight is the same as those of m and v, only the row slices whose indices appear in grad.indices are updated (for w, m and v)::</p>
<p>for row in grad.indices:      m[row] = beta1<em>m[row] + (1-beta1)</em>grad[row]      v[row] = beta2<em>v[row] + (1-beta2)</em>(grad[row]**2)      w[row] += - learning_rate * m[row] / (sqrt(v[row]) + epsilon)</p>
<p>Defined in src/operator/optimizer_op.cc:L679</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>weight::NDArray-or-SymbolicNode</code>: Weight</li>
<li><code>grad::NDArray-or-SymbolicNode</code>: Gradient</li>
<li><code>mean::NDArray-or-SymbolicNode</code>: Moving mean</li>
<li><code>var::NDArray-or-SymbolicNode</code>: Moving variance</li>
<li><code>lr::float, required</code>: Learning rate</li>
<li><code>beta1::float, optional, default=0.899999976</code>: The decay rate for the 1st moment estimates.</li>
<li><code>beta2::float, optional, default=0.999000013</code>: The decay rate for the 2nd moment estimates.</li>
<li><code>epsilon::float, optional, default=9.99999994e-09</code>: A small constant for numerical stability.</li>
<li><code>wd::float, optional, default=0</code>: Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</li>
<li><code>rescale_grad::float, optional, default=1</code>: Rescale gradient to grad = rescale_grad*grad.</li>
<li><code>clip_gradient::float, optional, default=-1</code>: Clip gradient to the range of [-clip<em>gradient, clip</em>gradient] If clip<em>gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip</em>gradient), -clip_gradient).</li>
<li><code>lazy_update::boolean, optional, default=1</code>: If true, lazy updates are applied if gradient's stype is row_sparse and all of w, m and v have the same stype</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L399' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.add_n-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.add_n-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.add_n</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">add_n(args)
</code></pre>

<p><strong>Note</strong>: add<em>n takes variable number of positional inputs. So instead of calling as add</em>n([x, y, z], num<em>args=3), one should call via add</em>n(x, y, z), and num_args will be determined automatically.</p>
<p>Adds all input arguments element-wise.</p>
<p>.. math::    add_n(a<em>1, a</em>2, ..., a<em>n) = a</em>1 + a<em>2 + ... + a</em>n</p>
<p>$add_n$ is potentially more efficient than calling $add$ by <code>n</code> times.</p>
<p>The storage type of $add_n$ output depends on storage types of inputs</p>
<ul>
<li>add<em>n(row</em>sparse, row<em>sparse, ..) = row</em>sparse</li>
<li>add_n(default, csr, default) = default</li>
<li>add_n(any input combinations longer than 4 (&gt;4) with at least one default type) = default</li>
<li>otherwise, $add_n$ falls all inputs back to default storage and generates default storage</li>
</ul>
<p>Defined in src/operator/tensor/elemwise_sum.cc:L155</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>args::NDArray-or-SymbolicNode[]</code>: Positional input arguments</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L365' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.all_finite-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.all_finite-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.all_finite</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">all_finite(data, init_output)
</code></pre>

<p>Check if all the float numbers in the array are finite (used for AMP)</p>
<p>Defined in src/operator/contrib/all_finite.cc:L101</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray</code>: Array</li>
<li><code>init_output::boolean, optional, default=1</code>: Initialize output to 1.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L352' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.amp_cast-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.amp_cast-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.amp_cast</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">amp_cast(data, dtype)
</code></pre>

<p>Cast function between low precision float/FP32 used by AMP.</p>
<p>It casts only between low precision float/FP32 and does not do anything for other types.</p>
<p>Defined in src/operator/tensor/amp_cast.cc:L121</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input.</li>
<li><code>dtype::{'bfloat16', 'float16', 'float32', 'float64', 'int32', 'int64', 'int8', 'uint8'}, required</code>: Output data type.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L354' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.amp_multicast-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.amp_multicast-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.amp_multicast</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">amp_multicast(data, num_outputs, cast_narrow)
</code></pre>

<p>Cast function used by AMP, that casts its inputs to the common widest type.</p>
<p>It casts only between low precision float/FP32 and does not do anything for other types.</p>
<p>Defined in src/operator/tensor/amp_cast.cc:L165</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode[]</code>: Weights</li>
<li><code>num_outputs::int, required</code>: Number of input/output pairs to be casted to the widest type.</li>
<li><code>cast_narrow::boolean, optional, default=0</code>: Whether to cast to the narrowest type</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L357' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.argmax_channel-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.argmax_channel-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.argmax_channel</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">argmax_channel(data)
</code></pre>

<p>Returns argmax indices of each channel from the input array.</p>
<p>The result will be an NDArray of shape (num_channel,).</p>
<p>In case of multiple occurrences of the maximum values, the indices corresponding to the first occurrence are returned.</p>
<p>Examples::</p>
<p>x = [[ 0.,  1.,  2.],        [ 3.,  4.,  5.]]</p>
<p>argmax_channel(x) = [ 2.,  2.]</p>
<p>Defined in src/operator/tensor/broadcast<em>reduce</em>op_index.cc:L97</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L363' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.argsort-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.argsort-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.argsort</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">argsort(data, axis, is_ascend, dtype)
</code></pre>

<p>Returns the indices that would sort an input array along the given axis.</p>
<p>This function performs sorting along the given axis and returns an array of indices having same shape as an input array that index data in sorted order.</p>
<p>Examples::</p>
<p>x = [[ 0.3,  0.2,  0.4],        [ 0.1,  0.3,  0.2]]</p>
<p>// sort along axis -1   argsort(x) = [[ 1.,  0.,  2.],                 [ 0.,  2.,  1.]]</p>
<p>// sort along axis 0   argsort(x, axis=0) = [[ 1.,  0.,  1.]                         [ 0.,  1.,  0.]]</p>
<p>// flatten and then sort   argsort(x, axis=None) = [ 3.,  1.,  5.,  0.,  4.,  2.]</p>
<p>Defined in src/operator/tensor/ordering_op.cc:L185</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array</li>
<li><code>axis::int or None, optional, default='-1'</code>: Axis along which to sort the input tensor. If not given, the flattened array is used. Default is -1.</li>
<li><code>is_ascend::boolean, optional, default=1</code>: Whether to sort in ascending or descending order.</li>
<li><code>dtype::{'float16', 'float32', 'float64', 'int32', 'int64', 'uint8'},optional, default='float32'</code>: DType of the output indices. It is only valid when ret_typ is "indices" or "both". An error will be raised if the selected data type cannot precisely represent the indices.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L375' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.batch_dot-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.batch_dot-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.batch_dot</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">batch_dot(lhs, rhs, transpose_a, transpose_b, forward_stype)
</code></pre>

<p>Batchwise dot product.</p>
<p>$batch_dot$ is used to compute dot product of $x$ and $y$ when $x$ and $y$ are data in batch, namely N-D (N &gt;= 3) arrays in shape of <code>(B0, ..., B_i, :, :)</code>.</p>
<p>For example, given $x$ with shape <code>(B_0, ..., B_i, N, M)</code> and $y$ with shape <code>(B_0, ..., B_i, M, K)</code>, the result array will have shape <code>(B_0, ..., B_i, N, K)</code>, which is computed by::</p>
<p>batch<em>dot(x,y)[b</em>0, ..., b<em>i, :, :] = dot(x[b</em>0, ..., b<em>i, :, :], y[b</em>0, ..., b_i, :, :])</p>
<p>Defined in src/operator/tensor/dot.cc:L127</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: The first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: The second input</li>
<li><code>transpose_a::boolean, optional, default=0</code>: If true then transpose the first input before dot.</li>
<li><code>transpose_b::boolean, optional, default=0</code>: If true then transpose the second input before dot.</li>
<li><code>forward_stype::{None, 'csr', 'default', 'row_sparse'},optional, default='None'</code>: The desired storage type of the forward output given by user, if thecombination of input storage types and this hint does not matchany implemented ones, the dot operator will perform fallback operationand still produce an output of the desired storage type.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L368' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.batch_take-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.batch_take-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.batch_take</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">batch_take(a, indices)
</code></pre>

<p>Takes elements from a data batch.</p>
<p>.. note::   <code>batch_take</code> is deprecated. Use <code>pick</code> instead.</p>
<p>Given an input array of shape $(d0, d1)$ and indices of shape $(i0,)$, the result will be an output array of shape $(i0,)$ with::</p>
<p>output[i] = input[i, indices[i]]</p>
<p>Examples::</p>
<p>x = [[ 1.,  2.],        [ 3.,  4.],        [ 5.,  6.]]</p>
<p>// takes elements with specified indices   batch_take(x, [0,1,0]) = [ 1.  4.  5.]</p>
<p>Defined in src/operator/tensor/indexing_op.cc:L841</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>a::NDArray-or-SymbolicNode</code>: The input array</li>
<li><code>indices::NDArray-or-SymbolicNode</code>: The index array</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L370' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.broadcast_add-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.broadcast_add-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.broadcast_add</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">broadcast_add(lhs, rhs)
</code></pre>

<p>Returns element-wise sum of the input arrays with broadcasting.</p>
<p><code>broadcast_plus</code> is an alias to the function <code>broadcast_add</code>.</p>
<p>Example::</p>
<p>x = [[ 1.,  1.,  1.],         [ 1.,  1.,  1.]]</p>
<p>y = [[ 0.],         [ 1.]]</p>
<p>broadcast_add(x, y) = [[ 1.,  1.,  1.],                           [ 2.,  2.,  2.]]</p>
<p>broadcast_plus(x, y) = [[ 1.,  1.,  1.],                            [ 2.,  2.,  2.]]</p>
<p>Supported sparse operations:</p>
<p>broadcast<em>add(csr, dense(1D)) = dense    broadcast</em>add(dense(1D), csr) = dense</p>
<p>Defined in src/operator/tensor/elemwise<em>binary</em>broadcast<em>op</em>basic.cc:L58</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: First input to the function</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: Second input to the function</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L374' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.broadcast_div-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.broadcast_div-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.broadcast_div</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">broadcast_div(lhs, rhs)
</code></pre>

<p>Returns element-wise division of the input arrays with broadcasting.</p>
<p>Example::</p>
<p>x = [[ 6.,  6.,  6.],         [ 6.,  6.,  6.]]</p>
<p>y = [[ 2.],         [ 3.]]</p>
<p>broadcast_div(x, y) = [[ 3.,  3.,  3.],                           [ 2.,  2.,  2.]]</p>
<p>Supported sparse operations:</p>
<p>broadcast_div(csr, dense(1D)) = csr</p>
<p>Defined in src/operator/tensor/elemwise<em>binary</em>broadcast<em>op</em>basic.cc:L187</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: First input to the function</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: Second input to the function</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L368' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.broadcast_equal-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.broadcast_equal-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.broadcast_equal</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">broadcast_equal(lhs, rhs)
</code></pre>

<p>Returns the result of element-wise <strong>equal to</strong> (==) comparison operation with broadcasting.</p>
<p>Example::</p>
<p>x = [[ 1.,  1.,  1.],         [ 1.,  1.,  1.]]</p>
<p>y = [[ 0.],         [ 1.]]</p>
<p>broadcast_equal(x, y) = [[ 0.,  0.,  0.],                             [ 1.,  1.,  1.]]</p>
<p>Defined in src/operator/tensor/elemwise<em>binary</em>broadcast<em>op</em>logic.cc:L46</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: First input to the function</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: Second input to the function</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L364' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.broadcast_greater-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.broadcast_greater-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.broadcast_greater</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">broadcast_greater(lhs, rhs)
</code></pre>

<p>Returns the result of element-wise <strong>greater than</strong> (&gt;) comparison operation with broadcasting.</p>
<p>Example::</p>
<p>x = [[ 1.,  1.,  1.],         [ 1.,  1.,  1.]]</p>
<p>y = [[ 0.],         [ 1.]]</p>
<p>broadcast_greater(x, y) = [[ 1.,  1.,  1.],                               [ 0.,  0.,  0.]]</p>
<p>Defined in src/operator/tensor/elemwise<em>binary</em>broadcast<em>op</em>logic.cc:L82</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: First input to the function</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: Second input to the function</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L364' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.broadcast_greater_equal-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.broadcast_greater_equal-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.broadcast_greater_equal</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">broadcast_greater_equal(lhs, rhs)
</code></pre>

<p>Returns the result of element-wise <strong>greater than or equal to</strong> (&gt;=) comparison operation with broadcasting.</p>
<p>Example::</p>
<p>x = [[ 1.,  1.,  1.],         [ 1.,  1.,  1.]]</p>
<p>y = [[ 0.],         [ 1.]]</p>
<p>broadcast<em>greater</em>equal(x, y) = [[ 1.,  1.,  1.],                                     [ 1.,  1.,  1.]]</p>
<p>Defined in src/operator/tensor/elemwise<em>binary</em>broadcast<em>op</em>logic.cc:L100</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: First input to the function</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: Second input to the function</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L364' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.broadcast_hypot-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.broadcast_hypot-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.broadcast_hypot</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">broadcast_hypot(lhs, rhs)
</code></pre>

<p>Returns the hypotenuse of a right angled triangle, given its "legs" with broadcasting.</p>
<p>It is equivalent to doing :math:<code>sqrt(x_1^2 + x_2^2)</code>.</p>
<p>Example::</p>
<p>x = [[ 3.,  3.,  3.]]</p>
<p>y = [[ 4.],         [ 4.]]</p>
<p>broadcast_hypot(x, y) = [[ 5.,  5.,  5.],                             [ 5.,  5.,  5.]]</p>
<p>z = [[ 0.],         [ 4.]]</p>
<p>broadcast_hypot(x, z) = [[ 3.,  3.,  3.],                             [ 5.,  5.,  5.]]</p>
<p>Defined in src/operator/tensor/elemwise<em>binary</em>broadcast<em>op</em>extended.cc:L158</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: First input to the function</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: Second input to the function</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L372' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.broadcast_lesser-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.broadcast_lesser-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.broadcast_lesser</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">broadcast_lesser(lhs, rhs)
</code></pre>

<p>Returns the result of element-wise <strong>lesser than</strong> (&lt;) comparison operation with broadcasting.</p>
<p>Example::</p>
<p>x = [[ 1.,  1.,  1.],         [ 1.,  1.,  1.]]</p>
<p>y = [[ 0.],         [ 1.]]</p>
<p>broadcast_lesser(x, y) = [[ 0.,  0.,  0.],                              [ 0.,  0.,  0.]]</p>
<p>Defined in src/operator/tensor/elemwise<em>binary</em>broadcast<em>op</em>logic.cc:L118</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: First input to the function</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: Second input to the function</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L364' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.broadcast_lesser_equal-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.broadcast_lesser_equal-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.broadcast_lesser_equal</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">broadcast_lesser_equal(lhs, rhs)
</code></pre>

<p>Returns the result of element-wise <strong>lesser than or equal to</strong> (&lt;=) comparison operation with broadcasting.</p>
<p>Example::</p>
<p>x = [[ 1.,  1.,  1.],         [ 1.,  1.,  1.]]</p>
<p>y = [[ 0.],         [ 1.]]</p>
<p>broadcast<em>lesser</em>equal(x, y) = [[ 0.,  0.,  0.],                                    [ 1.,  1.,  1.]]</p>
<p>Defined in src/operator/tensor/elemwise<em>binary</em>broadcast<em>op</em>logic.cc:L136</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: First input to the function</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: Second input to the function</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L364' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.broadcast_like-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.broadcast_like-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.broadcast_like</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">broadcast_like(lhs, rhs, lhs_axes, rhs_axes)
</code></pre>

<p>Broadcasts lhs to have the same shape as rhs.</p>
<p>Broadcasting is a mechanism that allows NDArrays to perform arithmetic operations with arrays of different shapes efficiently without creating multiple copies of arrays. Also see, <code>Broadcasting &lt;https://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&gt;</code>_ for more explanation.</p>
<p>Broadcasting is allowed on axes with size 1, such as from <code>(2,1,3,1)</code> to <code>(2,8,3,9)</code>. Elements will be duplicated on the broadcasted axes.</p>
<p>For example::</p>
<p>broadcast_like([[1,2,3]], [[5,6,7],[7,8,9]]) = [[ 1.,  2.,  3.],                                                    [ 1.,  2.,  3.]])</p>
<p>broadcast<em>like([9], [1,2,3,4,5], lhs</em>axes=(0,), rhs_axes=(-1,)) = [9,9,9,9,9]</p>
<p>Defined in src/operator/tensor/broadcast<em>reduce</em>op_value.cc:L171</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: First input.</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: Second input.</li>
<li><code>lhs_axes::Shape or None, optional, default=None</code>: Axes to perform broadcast on in the first input array</li>
<li><code>rhs_axes::Shape or None, optional, default=None</code>: Axes to copy from the second input array</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L371' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.broadcast_logical_and-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.broadcast_logical_and-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.broadcast_logical_and</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">broadcast_logical_and(lhs, rhs)
</code></pre>

<p>Returns the result of element-wise <strong>logical and</strong> with broadcasting.</p>
<p>Example::</p>
<p>x = [[ 1.,  1.,  1.],         [ 1.,  1.,  1.]]</p>
<p>y = [[ 0.],         [ 1.]]</p>
<p>broadcast<em>logical</em>and(x, y) = [[ 0.,  0.,  0.],                                   [ 1.,  1.,  1.]]</p>
<p>Defined in src/operator/tensor/elemwise<em>binary</em>broadcast<em>op</em>logic.cc:L154</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: First input to the function</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: Second input to the function</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L364' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.broadcast_logical_or-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.broadcast_logical_or-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.broadcast_logical_or</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">broadcast_logical_or(lhs, rhs)
</code></pre>

<p>Returns the result of element-wise <strong>logical or</strong> with broadcasting.</p>
<p>Example::</p>
<p>x = [[ 1.,  1.,  0.],         [ 1.,  1.,  0.]]</p>
<p>y = [[ 1.],         [ 0.]]</p>
<p>broadcast<em>logical</em>or(x, y) = [[ 1.,  1.,  1.],                                  [ 1.,  1.,  0.]]</p>
<p>Defined in src/operator/tensor/elemwise<em>binary</em>broadcast<em>op</em>logic.cc:L172</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: First input to the function</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: Second input to the function</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L364' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.broadcast_logical_xor-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.broadcast_logical_xor-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.broadcast_logical_xor</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">broadcast_logical_xor(lhs, rhs)
</code></pre>

<p>Returns the result of element-wise <strong>logical xor</strong> with broadcasting.</p>
<p>Example::</p>
<p>x = [[ 1.,  1.,  0.],         [ 1.,  1.,  0.]]</p>
<p>y = [[ 1.],         [ 0.]]</p>
<p>broadcast<em>logical</em>xor(x, y) = [[ 0.,  0.,  1.],                                   [ 1.,  1.,  0.]]</p>
<p>Defined in src/operator/tensor/elemwise<em>binary</em>broadcast<em>op</em>logic.cc:L190</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: First input to the function</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: Second input to the function</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L364' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.broadcast_maximum-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.broadcast_maximum-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.broadcast_maximum</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">broadcast_maximum(lhs, rhs)
</code></pre>

<p>Returns element-wise maximum of the input arrays with broadcasting.</p>
<p>This function compares two input arrays and returns a new array having the element-wise maxima.</p>
<p>Example::</p>
<p>x = [[ 1.,  1.,  1.],         [ 1.,  1.,  1.]]</p>
<p>y = [[ 0.],         [ 1.]]</p>
<p>broadcast_maximum(x, y) = [[ 1.,  1.,  1.],                               [ 1.,  1.,  1.]]</p>
<p>Defined in src/operator/tensor/elemwise<em>binary</em>broadcast<em>op</em>extended.cc:L81</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: First input to the function</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: Second input to the function</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L366' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.broadcast_minimum-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.broadcast_minimum-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.broadcast_minimum</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">broadcast_minimum(lhs, rhs)
</code></pre>

<p>Returns element-wise minimum of the input arrays with broadcasting.</p>
<p>This function compares two input arrays and returns a new array having the element-wise minima.</p>
<p>Example::</p>
<p>x = [[ 1.,  1.,  1.],         [ 1.,  1.,  1.]]</p>
<p>y = [[ 0.],         [ 1.]]</p>
<p>broadcast_maximum(x, y) = [[ 0.,  0.,  0.],                               [ 1.,  1.,  1.]]</p>
<p>Defined in src/operator/tensor/elemwise<em>binary</em>broadcast<em>op</em>extended.cc:L117</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: First input to the function</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: Second input to the function</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L366' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.broadcast_minus-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.broadcast_minus-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.broadcast_minus</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">broadcast_minus(lhs, rhs)
</code></pre>

<p>broadcast<em>minus is an alias of broadcast</em>sub.</p>
<p>Returns element-wise difference of the input arrays with broadcasting.</p>
<p><code>broadcast_minus</code> is an alias to the function <code>broadcast_sub</code>.</p>
<p>Example::</p>
<p>x = [[ 1.,  1.,  1.],         [ 1.,  1.,  1.]]</p>
<p>y = [[ 0.],         [ 1.]]</p>
<p>broadcast_sub(x, y) = [[ 1.,  1.,  1.],                           [ 0.,  0.,  0.]]</p>
<p>broadcast_minus(x, y) = [[ 1.,  1.,  1.],                             [ 0.,  0.,  0.]]</p>
<p>Supported sparse operations:</p>
<p>broadcast<em>sub/minus(csr, dense(1D)) = dense    broadcast</em>sub/minus(dense(1D), csr) = dense</p>
<p>Defined in src/operator/tensor/elemwise<em>binary</em>broadcast<em>op</em>basic.cc:L106</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: First input to the function</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: Second input to the function</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L376' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.broadcast_mod-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.broadcast_mod-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.broadcast_mod</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">broadcast_mod(lhs, rhs)
</code></pre>

<p>Returns element-wise modulo of the input arrays with broadcasting.</p>
<p>Example::</p>
<p>x = [[ 8.,  8.,  8.],         [ 8.,  8.,  8.]]</p>
<p>y = [[ 2.],         [ 3.]]</p>
<p>broadcast_mod(x, y) = [[ 0.,  0.,  0.],                           [ 2.,  2.,  2.]]</p>
<p>Defined in src/operator/tensor/elemwise<em>binary</em>broadcast<em>op</em>basic.cc:L222</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: First input to the function</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: Second input to the function</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L364' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.broadcast_mul-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.broadcast_mul-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.broadcast_mul</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">broadcast_mul(lhs, rhs)
</code></pre>

<p>Returns element-wise product of the input arrays with broadcasting.</p>
<p>Example::</p>
<p>x = [[ 1.,  1.,  1.],         [ 1.,  1.,  1.]]</p>
<p>y = [[ 0.],         [ 1.]]</p>
<p>broadcast_mul(x, y) = [[ 0.,  0.,  0.],                           [ 1.,  1.,  1.]]</p>
<p>Supported sparse operations:</p>
<p>broadcast_mul(csr, dense(1D)) = csr</p>
<p>Defined in src/operator/tensor/elemwise<em>binary</em>broadcast<em>op</em>basic.cc:L146</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: First input to the function</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: Second input to the function</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L368' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.broadcast_not_equal-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.broadcast_not_equal-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.broadcast_not_equal</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">broadcast_not_equal(lhs, rhs)
</code></pre>

<p>Returns the result of element-wise <strong>not equal to</strong> (!=) comparison operation with broadcasting.</p>
<p>Example::</p>
<p>x = [[ 1.,  1.,  1.],         [ 1.,  1.,  1.]]</p>
<p>y = [[ 0.],         [ 1.]]</p>
<p>broadcast<em>not</em>equal(x, y) = [[ 1.,  1.,  1.],                                 [ 0.,  0.,  0.]]</p>
<p>Defined in src/operator/tensor/elemwise<em>binary</em>broadcast<em>op</em>logic.cc:L64</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: First input to the function</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: Second input to the function</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L364' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.broadcast_plus-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.broadcast_plus-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.broadcast_plus</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">broadcast_plus(lhs, rhs)
</code></pre>

<p>broadcast<em>plus is an alias of broadcast</em>add.</p>
<p>Returns element-wise sum of the input arrays with broadcasting.</p>
<p><code>broadcast_plus</code> is an alias to the function <code>broadcast_add</code>.</p>
<p>Example::</p>
<p>x = [[ 1.,  1.,  1.],         [ 1.,  1.,  1.]]</p>
<p>y = [[ 0.],         [ 1.]]</p>
<p>broadcast_add(x, y) = [[ 1.,  1.,  1.],                           [ 2.,  2.,  2.]]</p>
<p>broadcast_plus(x, y) = [[ 1.,  1.,  1.],                            [ 2.,  2.,  2.]]</p>
<p>Supported sparse operations:</p>
<p>broadcast<em>add(csr, dense(1D)) = dense    broadcast</em>add(dense(1D), csr) = dense</p>
<p>Defined in src/operator/tensor/elemwise<em>binary</em>broadcast<em>op</em>basic.cc:L58</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: First input to the function</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: Second input to the function</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L376' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.broadcast_power-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.broadcast_power-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.broadcast_power</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">broadcast_power(lhs, rhs)
</code></pre>

<p>Returns result of first array elements raised to powers from second array, element-wise with broadcasting.</p>
<p>Example::</p>
<p>x = [[ 1.,  1.,  1.],         [ 1.,  1.,  1.]]</p>
<p>y = [[ 0.],         [ 1.]]</p>
<p>broadcast_power(x, y) = [[ 2.,  2.,  2.],                             [ 4.,  4.,  4.]]</p>
<p>Defined in src/operator/tensor/elemwise<em>binary</em>broadcast<em>op</em>extended.cc:L45</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: First input to the function</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: Second input to the function</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L364' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.broadcast_sub-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.broadcast_sub-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.broadcast_sub</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">broadcast_sub(lhs, rhs)
</code></pre>

<p>Returns element-wise difference of the input arrays with broadcasting.</p>
<p><code>broadcast_minus</code> is an alias to the function <code>broadcast_sub</code>.</p>
<p>Example::</p>
<p>x = [[ 1.,  1.,  1.],         [ 1.,  1.,  1.]]</p>
<p>y = [[ 0.],         [ 1.]]</p>
<p>broadcast_sub(x, y) = [[ 1.,  1.,  1.],                           [ 0.,  0.,  0.]]</p>
<p>broadcast_minus(x, y) = [[ 1.,  1.,  1.],                             [ 0.,  0.,  0.]]</p>
<p>Supported sparse operations:</p>
<p>broadcast<em>sub/minus(csr, dense(1D)) = dense    broadcast</em>sub/minus(dense(1D), csr) = dense</p>
<p>Defined in src/operator/tensor/elemwise<em>binary</em>broadcast<em>op</em>basic.cc:L106</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: First input to the function</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: Second input to the function</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L374' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.cast-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.cast-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.cast</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">cast(data, dtype)
</code></pre>

<p>cast is an alias of Cast.</p>
<p>Casts all elements of the input to a new type.</p>
<p>.. note:: $Cast$ is deprecated. Use $cast$ instead.</p>
<p>Example::</p>
<p>cast([0.9, 1.3], dtype='int32') = [0, 1]    cast([1e20, 11.1], dtype='float16') = [inf, 11.09375]    cast([300, 11.1, 10.9, -1, -3], dtype='uint8') = [44, 11, 10, 255, 253]</p>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_basic.cc:L664</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input.</li>
<li><code>dtype::{'bfloat16', 'bool', 'float16', 'float32', 'float64', 'int32', 'int64', 'int8', 'uint8'}, required</code>: Output data type.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L363' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.cast_storage-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.cast_storage-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.cast_storage</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">cast_storage(data, stype)
</code></pre>

<p>Casts tensor storage type to the new type.</p>
<p>When an NDArray with default storage type is cast to csr or row_sparse storage, the result is compact, which means:</p>
<ul>
<li>for csr, zero values will not be retained</li>
<li>for row_sparse, row slices of all zeros will not be retained</li>
</ul>
<p>The storage type of $cast_storage$ output depends on stype parameter:</p>
<ul>
<li>cast_storage(csr, 'default') = default</li>
<li>cast<em>storage(row</em>sparse, 'default') = default</li>
<li>cast_storage(default, 'csr') = csr</li>
<li>cast<em>storage(default, 'row</em>sparse') = row_sparse</li>
<li>cast_storage(csr, 'csr') = csr</li>
<li>cast<em>storage(row</em>sparse, 'row<em>sparse') = row</em>sparse</li>
</ul>
<p>Example::</p>
<pre><code>dense = [[ 0.,  1.,  0.],
         [ 2.,  0.,  3.],
         [ 0.,  0.,  0.],
         [ 0.,  0.,  0.]]

# cast to row_sparse storage type
rsp = cast_storage(dense, 'row_sparse')
rsp.indices = [0, 1]
rsp.values = [[ 0.,  1.,  0.],
              [ 2.,  0.,  3.]]

# cast to csr storage type
csr = cast_storage(dense, 'csr')
csr.indices = [1, 0, 2]
csr.values = [ 1.,  2.,  3.]
csr.indptr = [0, 1, 3, 3, 3]
</code></pre>

<p>Defined in src/operator/tensor/cast_storage.cc:L71</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input.</li>
<li><code>stype::{'csr', 'default', 'row_sparse'}, required</code>: Output storage type.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L387' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.choose_element_0index-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.choose_element_0index-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.choose_element_0index</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">choose_element_0index(data, index, axis, keepdims, mode)
</code></pre>

<p>choose<em>element</em>0index is an alias of pick.</p>
<p>Picks elements from an input array according to the input indices along the given axis.</p>
<p>Given an input array of shape $(d0, d1)$ and indices of shape $(i0,)$, the result will be an output array of shape $(i0,)$ with::</p>
<p>output[i] = input[i, indices[i]]</p>
<p>By default, if any index mentioned is too large, it is replaced by the index that addresses the last element along an axis (the <code>clip</code> mode).</p>
<p>This function supports n-dimensional input and (n-1)-dimensional indices arrays.</p>
<p>Examples::</p>
<p>x = [[ 1.,  2.],        [ 3.,  4.],        [ 5.,  6.]]</p>
<p>// picks elements with specified indices along axis 0   pick(x, y=[0,1], 0) = [ 1.,  4.]</p>
<p>// picks elements with specified indices along axis 1   pick(x, y=[0,1,0], 1) = [ 1.,  4.,  5.]</p>
<p>// picks elements with specified indices along axis 1 using 'wrap' mode   // to place indicies that would normally be out of bounds   pick(x, y=[2,-1,-2], 1, mode='wrap') = [ 1.,  4.,  5.]</p>
<p>y = [[ 1.],        [ 0.],        [ 2.]]</p>
<p>// picks elements with specified indices along axis 1 and dims are maintained   pick(x, y, 1, keepdims=True) = [[ 2.],                                  [ 3.],                                  [ 6.]]</p>
<p>Defined in src/operator/tensor/broadcast<em>reduce</em>op_index.cc:L151</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array</li>
<li><code>index::NDArray-or-SymbolicNode</code>: The index array</li>
<li><code>axis::int or None, optional, default='-1'</code>: int or None. The axis to picking the elements. Negative values means indexing from right to left. If is <code>None</code>, the elements in the index w.r.t the flattened input will be picked.</li>
<li><code>keepdims::boolean, optional, default=0</code>: If true, the axis where we pick the elements is left in the result as dimension with size one.</li>
<li><code>mode::{'clip', 'wrap'},optional, default='clip'</code>: Specify how out-of-bound indices behave. Default is "clip". "clip" means clip to the range. So, if all indices mentioned are too large, they are replaced by the index that addresses the last element along an axis.  "wrap" means to wrap around.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L396' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.col2im-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.col2im-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.col2im</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">col2im(data, output_size, kernel, stride, dilate, pad)
</code></pre>

<p>Combining the output column matrix of im2col back to image array.</p>
<p>Like :class:<code>~mxnet.ndarray.im2col</code>, this operator is also used in the vanilla convolution implementation. Despite the name, col2im is not the reverse operation of im2col. Since there may be overlaps between neighbouring sliding blocks, the column elements cannot be directly put back into image. Instead, they are accumulated (i.e., summed) in the input image just like the gradient computation, so col2im is the gradient of im2col and vice versa.</p>
<p>Using the notation in im2col, given an input column array of shape :math:<code>(N, C \times  \prod(\text{kernel}), W)</code>, this operator accumulates the column elements into output array of shape :math:<code>(N, C, \text{output_size}[0], \text{output_size}[1], \dots)</code>. Only 1-D, 2-D and 3-D of spatial dimension is supported in this operator.</p>
<p>Defined in src/operator/nn/im2col.cc:L182</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input array to combine sliding blocks.</li>
<li><code>output_size::Shape(tuple), required</code>: The spatial dimension of image array: (w,), (h, w) or (d, h, w).</li>
<li><code>kernel::Shape(tuple), required</code>: Sliding kernel size: (w,), (h, w) or (d, h, w).</li>
<li><code>stride::Shape(tuple), optional, default=[]</code>: The stride between adjacent sliding blocks in spatial dimension: (w,), (h, w) or (d, h, w). Defaults to 1 for each dimension.</li>
<li><code>dilate::Shape(tuple), optional, default=[]</code>: The spacing between adjacent kernel points: (w,), (h, w) or (d, h, w). Defaults to 1 for each dimension.</li>
<li><code>pad::Shape(tuple), optional, default=[]</code>: The zero-value padding size on both sides of spatial dimension: (w,), (h, w) or (d, h, w). Defaults to no padding.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L372' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.concat-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.concat-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.concat</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">concat(data, num_args, dim)
</code></pre>

<p>concat is an alias of Concat.</p>
<p><strong>Note</strong>: concat takes variable number of positional inputs. So instead of calling as concat([x, y, z], num<em>args=3), one should call via concat(x, y, z), and num</em>args will be determined automatically.</p>
<p>Joins input arrays along a given axis.</p>
<p>.. note:: <code>Concat</code> is deprecated. Use <code>concat</code> instead.</p>
<p>The dimensions of the input arrays should be the same except the axis along which they will be concatenated. The dimension of the output array along the concatenated axis will be equal to the sum of the corresponding dimensions of the input arrays.</p>
<p>The storage type of $concat$ output depends on storage types of inputs</p>
<ul>
<li>concat(csr, csr, ..., csr, dim=0) = csr</li>
<li>otherwise, $concat$ generates output with default storage</li>
</ul>
<p>Example::</p>
<p>x = [[1,1],[2,2]]    y = [[3,3],[4,4],[5,5]]    z = [[6,6], [7,7],[8,8]]</p>
<p>concat(x,y,z,dim=0) = [[ 1.,  1.],                           [ 2.,  2.],                           [ 3.,  3.],                           [ 4.,  4.],                           [ 5.,  5.],                           [ 6.,  6.],                           [ 7.,  7.],                           [ 8.,  8.]]</p>
<p>Note that you cannot concat x,y,z along dimension 1 since dimension    0 is not the same for all the input arrays.</p>
<p>concat(y,z,dim=1) = [[ 3.,  3.,  6.,  6.],                          [ 4.,  4.,  7.,  7.],                          [ 5.,  5.,  8.,  8.]]</p>
<p>Defined in src/operator/nn/concat.cc:L385</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode[]</code>: List of arrays to concatenate</li>
<li><code>num_args::int, required</code>: Number of inputs to be concated.</li>
<li><code>dim::int, optional, default='1'</code>: the dimension to be concated.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L393' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.crop-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.crop-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.crop</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">crop(data, begin, end, step)
</code></pre>

<p>crop is an alias of slice.</p>
<p>Slices a region of the array. .. note:: $crop$ is deprecated. Use $slice$ instead. This function returns a sliced array between the indices given by <code>begin</code> and <code>end</code> with the corresponding <code>step</code>. For an input array of $shape=(d_0, d_1, ..., d_n-1)$, slice operation with $begin=(b_0, b_1...b_m-1)$, $end=(e_0, e_1, ..., e_m-1)$, and $step=(s_0, s_1, ..., s_m-1)$, where m &lt;= n, results in an array with the shape $(|e_0-b_0|/|s_0|, ..., |e_m-1-b_m-1|/|s_m-1|, d_m, ..., d_n-1)$. The resulting array's <em>k</em>-th dimension contains elements from the <em>k</em>-th dimension of the input array starting from index $b_k$ (inclusive) with step $s_k$ until reaching $e_k$ (exclusive). If the <em>k</em>-th elements are <code>None</code> in the sequence of <code>begin</code>, <code>end</code>, and <code>step</code>, the following rule will be used to set default values. If <code>s_k</code> is <code>None</code>, set <code>s_k=1</code>. If <code>s_k &gt; 0</code>, set <code>b_k=0</code>, <code>e_k=d_k</code>; else, set <code>b_k=d_k-1</code>, <code>e_k=-1</code>. The storage type of $slice$ output depends on storage types of inputs</p>
<ul>
<li>slice(csr) = csr</li>
<li>otherwise, $slice$ generates output with default storage</li>
</ul>
<p>.. note:: When input data storage type is csr, it only supports    step=(), or step=(None,), or step=(1,) to generate a csr output.    For other step parameter values, it falls back to slicing    a dense tensor. Example::   x = [[  1.,   2.,   3.,   4.],        [  5.,   6.,   7.,   8.],        [  9.,  10.,  11.,  12.]]   slice(x, begin=(0,1), end=(2,4)) = [[ 2.,  3.,  4.],                                      [ 6.,  7.,  8.]]   slice(x, begin=(None, 0), end=(None, 3), step=(-1, 2)) = [[9., 11.],                                                             [5.,  7.],                                                             [1.,  3.]]</p>
<p>Defined in src/operator/tensor/matrix_op.cc:L482</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Source input</li>
<li><code>begin::Shape(tuple), required</code>: starting indices for the slice operation, supports negative indices.</li>
<li><code>end::Shape(tuple), required</code>: ending indices for the slice operation, supports negative indices.</li>
<li><code>step::Shape(tuple), optional, default=[]</code>: step for the slice operation, supports negative values.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L390' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.ctc_loss-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.ctc_loss-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.ctc_loss</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">ctc_loss(data, label, data_lengths, label_lengths, use_data_lengths, use_label_lengths, blank_label)
</code></pre>

<p>ctc_loss is an alias of CTCLoss.</p>
<p>Connectionist Temporal Classification Loss.</p>
<p>.. note:: The existing alias $contrib_CTCLoss$ is deprecated.</p>
<p>The shapes of the inputs and outputs:</p>
<ul>
<li><strong>data</strong>: <code>(sequence_length, batch_size, alphabet_size)</code></li>
<li><strong>label</strong>: <code>(batch_size, label_sequence_length)</code></li>
<li><strong>out</strong>: <code>(batch_size)</code></li>
</ul>
<p>The <code>data</code> tensor consists of sequences of activation vectors (without applying softmax), with i-th channel in the last dimension corresponding to i-th label for i between 0 and alphabet*size-1 (i.e always 0-indexed). Alphabet size should include one additional value reserved for blank label. When <code>blank*label</code>is<code>"first"</code>, the<code>0</code>-th channel is be reserved for activation of blank label, or otherwise if it is "last",<code>(alphabet_size-1)</code>-th channel should be reserved for blank label.</p>
<p>$label$ is an index matrix of integers. When <code>blank_label</code> is $"first"$, the value 0 is then reserved for blank label, and should not be passed in this matrix. Otherwise, when <code>blank_label</code> is $"last"$, the value <code>(alphabet_size-1)</code> is reserved for blank label.</p>
<p>If a sequence of labels is shorter than <em>label</em>sequence<em>length</em>, use the special padding value at the end of the sequence to conform it to the correct length. The padding value is <code>0</code> when <code>blank_label</code> is $"first"$, and <code>-1</code> otherwise.</p>
<p>For example, suppose the vocabulary is <code>[a, b, c]</code>, and in one batch we have three sequences 'ba', 'cbb', and 'abac'. When <code>blank_label</code> is $"first"$, we can index the labels as <code>{'a': 1, 'b': 2, 'c': 3}</code>, and we reserve the 0-th channel for blank label in data tensor. The resulting <code>label</code> tensor should be padded to be::</p>
<p>[[2, 1, 0, 0], [3, 2, 2, 0], [1, 2, 1, 3]]</p>
<p>When <code>blank_label</code> is $"last"$, we can index the labels as <code>{'a': 0, 'b': 1, 'c': 2}</code>, and we reserve the channel index 3 for blank label in data tensor. The resulting <code>label</code> tensor should be padded to be::</p>
<p>[[1, 0, -1, -1], [2, 1, 1, -1], [0, 1, 0, 2]]</p>
<p>$out$ is a list of CTC loss values, one per example in the batch.</p>
<p>See <em>Connectionist Temporal Classification: Labelling Unsegmented Sequence Data with Recurrent Neural Networks</em>, A. Graves <em>et al</em>. for more information on the definition and the algorithm.</p>
<p>Defined in src/operator/nn/ctc_loss.cc:L100</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input ndarray</li>
<li><code>label::NDArray-or-SymbolicNode</code>: Ground-truth labels for the loss.</li>
<li><code>data_lengths::NDArray-or-SymbolicNode</code>: Lengths of data for each of the samples. Only required when use<em>data</em>lengths is true.</li>
<li><code>label_lengths::NDArray-or-SymbolicNode</code>: Lengths of labels for each of the samples. Only required when use<em>label</em>lengths is true.</li>
<li><code>use_data_lengths::boolean, optional, default=0</code>: Whether the data lenghts are decided by <code>data_lengths</code>. If false, the lengths are equal to the max sequence length.</li>
<li><code>use_label_lengths::boolean, optional, default=0</code>: Whether the label lenghts are decided by <code>label_lengths</code>, or derived from <code>padding_mask</code>. If false, the lengths are derived from the first occurrence of the value of <code>padding_mask</code>. The value of <code>padding_mask</code> is $0$ when first CTC label is reserved for blank, and $-1$ when last label is reserved for blank. See <code>blank_label</code>.</li>
<li><code>blank_label::{'first', 'last'},optional, default='first'</code>: Set the label that is reserved for blank label.If "first", 0-th label is reserved, and label values for tokens in the vocabulary are between $1$ and $alphabet_size-1$, and the padding mask is $-1$. If "last", last label value $alphabet_size-1$ is reserved for blank label instead, and label values for tokens in the vocabulary are between $0$ and $alphabet_size-2$, and the padding mask is $0$.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L408' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.degrees-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.degrees-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.degrees</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">degrees(data)
</code></pre>

<p>Converts each element of the input array from radians to degrees.</p>
<p>.. math::    degrees([0, \pi/2, \pi, 3\pi/2, 2\pi]) = [0, 90, 180, 270, 360]</p>
<p>The storage type of $degrees$ output depends upon the input storage type:</p>
<ul>
<li>degrees(default) = default</li>
<li>degrees(row<em>sparse) = row</em>sparse</li>
<li>degrees(csr) = csr</li>
</ul>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_trig.cc:L332</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L360' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.depth_to_space-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.depth_to_space-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.depth_to_space</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">depth_to_space(data, block_size)
</code></pre>

<p>Rearranges(permutes) data from depth into blocks of spatial data. Similar to ONNX DepthToSpace operator: https://github.com/onnx/onnx/blob/master/docs/Operators.md#DepthToSpace. The output is a new tensor where the values from depth dimension are moved in spatial blocks to height and width dimension. The reverse of this operation is $space_to_depth$. .. math::     <script type="math/tex; mode=display">\begin{gather*}     x \prime = reshape(x, [N, block_size, block_size, C / (block_size ^ 2), H * block_size, W * block_size]) \
    x \prime \prime = transpose(x \prime, [0, 3, 4, 1, 5, 2]) \
    y = reshape(x \prime \prime, [N, C / (block_size ^ 2), H * block_size, W * block_size])     \end{gather*}</script> where :math:<code>x</code> is an input tensor with default layout as :math:<code>[N, C, H, W]</code>: [batch, channels, height, width] and :math:<code>y</code> is the output tensor of layout :math:<code>[N, C / (block\_size ^ 2), H * block\_size, W * block\_size]</code> Example::   x = [[[[0, 1, 2],          [3, 4, 5]],         [[6, 7, 8],          [9, 10, 11]],         [[12, 13, 14],          [15, 16, 17]],         [[18, 19, 20],          [21, 22, 23]]]]   depth<em>to</em>space(x, 2) = [[[[0, 6, 1, 7, 2, 8],                             [12, 18, 13, 19, 14, 20],                             [3, 9, 4, 10, 5, 11],                             [15, 21, 16, 22, 17, 23]]]]</p>
<p>Defined in src/operator/tensor/matrix_op.cc:L972</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input ndarray</li>
<li><code>block_size::int, required</code>: Blocks of [block<em>size. block</em>size] are moved</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L377' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.elemwise_add-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.elemwise_add-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.elemwise_add</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">elemwise_add(lhs, rhs)
</code></pre>

<p>Adds arguments element-wise.</p>
<p>The storage type of $elemwise_add$ output depends on storage types of inputs</p>
<ul>
<li>elemwise<em>add(row</em>sparse, row<em>sparse) = row</em>sparse</li>
<li>elemwise_add(csr, csr) = csr</li>
<li>elemwise_add(default, csr) = default</li>
<li>elemwise_add(csr, default) = default</li>
<li>elemwise_add(default, rsp) = default</li>
<li>elemwise_add(rsp, default) = default</li>
<li>otherwise, $elemwise_add$ generates output with default storage</li>
</ul>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L361' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.elemwise_div-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.elemwise_div-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.elemwise_div</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">elemwise_div(lhs, rhs)
</code></pre>

<p>Divides arguments element-wise.</p>
<p>The storage type of $elemwise_div$ output is always dense</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L353' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.elemwise_mul-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.elemwise_mul-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.elemwise_mul</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">elemwise_mul(lhs, rhs)
</code></pre>

<p>Multiplies arguments element-wise.</p>
<p>The storage type of $elemwise_mul$ output depends on storage types of inputs</p>
<ul>
<li>elemwise_mul(default, default) = default</li>
<li>elemwise<em>mul(row</em>sparse, row<em>sparse) = row</em>sparse</li>
<li>elemwise<em>mul(default, row</em>sparse) = row_sparse</li>
<li>elemwise<em>mul(row</em>sparse, default) = row_sparse</li>
<li>elemwise_mul(csr, csr) = csr</li>
<li>otherwise, $elemwise_mul$ generates output with default storage</li>
</ul>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L360' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.elemwise_sub-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.elemwise_sub-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.elemwise_sub</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">elemwise_sub(lhs, rhs)
</code></pre>

<p>Subtracts arguments element-wise.</p>
<p>The storage type of $elemwise_sub$ output depends on storage types of inputs</p>
<ul>
<li>elemwise<em>sub(row</em>sparse, row<em>sparse) = row</em>sparse</li>
<li>elemwise_sub(csr, csr) = csr</li>
<li>elemwise_sub(default, csr) = default</li>
<li>elemwise_sub(csr, default) = default</li>
<li>elemwise_sub(default, rsp) = default</li>
<li>elemwise_sub(rsp, default) = default</li>
<li>otherwise, $elemwise_sub$ generates output with default storage</li>
</ul>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L361' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.erf-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.erf-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.erf</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">erf(data)
</code></pre>

<p>Returns element-wise gauss error function of the input.</p>
<p>Example::</p>
<p>erf([0, -1., 10.]) = [0., -0.8427, 1.]</p>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_basic.cc:L886</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L355' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.erfinv-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.erfinv-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.erfinv</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">erfinv(data)
</code></pre>

<p>Returns element-wise inverse gauss error function of the input.</p>
<p>Example::</p>
<p>erfinv([0, 0.5., -1.]) = [0., 0.4769, -inf]</p>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_basic.cc:L908</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L355' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.fill_element_0index-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.fill_element_0index-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.fill_element_0index</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">fill_element_0index(lhs, mhs, rhs)
</code></pre>

<p>Fill one element of each line(row for python, column for R/Julia) in lhs according to index indicated by rhs and values indicated by mhs. This function assume rhs uses 0-based index.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray</code>: Left operand to the function.</li>
<li><code>mhs::NDArray</code>: Middle operand to the function.</li>
<li><code>rhs::NDArray</code>: Right operand to the function.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L351' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.fix-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.fix-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.fix</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">fix(data)
</code></pre>

<p>Returns element-wise rounded value to the nearest 
integer towards zero of the input.</p>
<p>Example::</p>
<p>fix([-2.1, -1.9, 1.9, 2.1]) = [-2., -1.,  1., 2.]</p>
<p>The storage type of $fix$ output depends upon the input storage type:</p>
<ul>
<li>fix(default) = default</li>
<li>fix(row<em>sparse) = row</em>sparse</li>
<li>fix(csr) = csr</li>
</ul>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_basic.cc:L874</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L362' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.flatten-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.flatten-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.flatten</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">flatten(data)
</code></pre>

<p>flatten is an alias of Flatten.</p>
<p>Flattens the input array into a 2-D array by collapsing the higher dimensions. .. note:: <code>Flatten</code> is deprecated. Use <code>flatten</code> instead. For an input array with shape $(d1, d2, ..., dk)$, <code>flatten</code> operation reshapes the input array into an output array of shape $(d1, d2<em>...</em>dk)$. Note that the behavior of this function is different from numpy.ndarray.flatten, which behaves similar to mxnet.ndarray.reshape((-1,)). Example::     x = [[         [1,2,3],         [4,5,6],         [7,8,9]     ],     [    [1,2,3],         [4,5,6],         [7,8,9]     ]],     flatten(x) = [[ 1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9.],        [ 1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9.]]</p>
<p>Defined in src/operator/tensor/matrix_op.cc:L250</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L369' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.flip-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.flip-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.flip</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">flip(data, axis)
</code></pre>

<p>flip is an alias of reverse.</p>
<p>Reverses the order of elements along given axis while preserving array shape. Note: reverse and flip are equivalent. We use reverse in the following examples. Examples::   x = [[ 0.,  1.,  2.,  3.,  4.],        [ 5.,  6.,  7.,  8.,  9.]]   reverse(x, axis=0) = [[ 5.,  6.,  7.,  8.,  9.],                         [ 0.,  1.,  2.,  3.,  4.]]   reverse(x, axis=1) = [[ 4.,  3.,  2.,  1.,  0.],                         [ 9.,  8.,  7.,  6.,  5.]]</p>
<p>Defined in src/operator/tensor/matrix_op.cc:L832</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data array</li>
<li><code>axis::Shape(tuple), required</code>: The axis which to reverse elements.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L362' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.ftml_update-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.ftml_update-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.ftml_update</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">ftml_update(weight, grad, d, v, z, lr, beta1, beta2, epsilon, t, wd, rescale_grad, clip_grad)
</code></pre>

<p>The FTML optimizer described in <em>FTML - Follow the Moving Leader in Deep Learning</em>, available at http://proceedings.mlr.press/v70/zheng17a/zheng17a.pdf.</p>
<p>.. math::</p>
<p>g<em t-1="t-1">t = \nabla J(W</em>)\
 v<em>t = \beta</em>2 v<em>{t-1} + (1 - \beta</em>2) g<em>t^2\
 d</em>t = \frac{ 1 - \beta<em>1^t }{ \eta</em>t } (\sqrt{ \frac{ v<em>t }{ 1 - \beta</em>2^t } } + \epsilon)  \sigma<em>t = d</em>t - \beta<em t-1="t-1">1 d</em>  z<em>t = \beta</em>1 z<em>{ t-1 } + (1 - \beta</em>1^t) g<em>t - \sigma</em>t W<em>{t-1}  W</em>t = - \frac{ z<em>t }{ d</em>t }</p>
<p>Defined in src/operator/optimizer_op.cc:L631</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>weight::NDArray-or-SymbolicNode</code>: Weight</li>
<li><code>grad::NDArray-or-SymbolicNode</code>: Gradient</li>
<li><code>d::NDArray-or-SymbolicNode</code>: Internal state $d_t$</li>
<li><code>v::NDArray-or-SymbolicNode</code>: Internal state $v_t$</li>
<li><code>z::NDArray-or-SymbolicNode</code>: Internal state $z_t$</li>
<li><code>lr::float, required</code>: Learning rate.</li>
<li><code>beta1::float, optional, default=0.600000024</code>: Generally close to 0.5.</li>
<li><code>beta2::float, optional, default=0.999000013</code>: Generally close to 1.</li>
<li><code>epsilon::double, optional, default=9.9999999392252903e-09</code>: Epsilon to prevent div 0.</li>
<li><code>t::int, required</code>: Number of update.</li>
<li><code>wd::float, optional, default=0</code>: Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</li>
<li><code>rescale_grad::float, optional, default=1</code>: Rescale gradient to grad = rescale_grad*grad.</li>
<li><code>clip_grad::float, optional, default=-1</code>: Clip gradient to the range of [-clip<em>gradient, clip</em>gradient] If clip<em>gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip</em>gradient), -clip_gradient).</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L386' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.ftrl_update-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.ftrl_update-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.ftrl_update</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">ftrl_update(weight, grad, z, n, lr, lamda1, beta, wd, rescale_grad, clip_gradient)
</code></pre>

<p>Update function for Ftrl optimizer. Referenced from <em>Ad Click Prediction: a View from the Trenches</em>, available at http://dl.acm.org/citation.cfm?id=2488200.</p>
<p>It updates the weights using::</p>
<p>rescaled<em>grad = clip(grad * rescale</em>grad, clip<em>gradient)  z += rescaled</em>grad - (sqrt(n + rescaled<em>grad<strong>2) - sqrt(n)) * weight / learning<em>rate  n += rescaled</em>grad</strong>2  w = (sign(z) * lamda1 - z) / ((beta + sqrt(n)) / learning</em>rate + wd) * (abs(z) &gt; lamda1)</p>
<p>If w, z and n are all of $row_sparse$ storage type, only the row slices whose indices appear in grad.indices are updated (for w, z and n)::</p>
<p>for row in grad.indices:      rescaled<em>grad[row] = clip(grad[row] * rescale</em>grad, clip<em>gradient)      z[row] += rescaled</em>grad[row] - (sqrt(n[row] + rescaled<em>grad[row]<strong>2) - sqrt(n[row])) * weight[row] / learning<em>rate      n[row] += rescaled</em>grad[row]</strong>2      w[row] = (sign(z[row]) * lamda1 - z[row]) / ((beta + sqrt(n[row])) / learning</em>rate + wd) * (abs(z[row]) &gt; lamda1)</p>
<p>Defined in src/operator/optimizer_op.cc:L867</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>weight::NDArray-or-SymbolicNode</code>: Weight</li>
<li><code>grad::NDArray-or-SymbolicNode</code>: Gradient</li>
<li><code>z::NDArray-or-SymbolicNode</code>: z</li>
<li><code>n::NDArray-or-SymbolicNode</code>: Square of grad</li>
<li><code>lr::float, required</code>: Learning rate</li>
<li><code>lamda1::float, optional, default=0.00999999978</code>: The L1 regularization coefficient.</li>
<li><code>beta::float, optional, default=1</code>: Per-Coordinate Learning Rate beta.</li>
<li><code>wd::float, optional, default=0</code>: Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</li>
<li><code>rescale_grad::float, optional, default=1</code>: Rescale gradient to grad = rescale_grad*grad.</li>
<li><code>clip_gradient::float, optional, default=-1</code>: Clip gradient to the range of [-clip<em>gradient, clip</em>gradient] If clip<em>gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip</em>gradient), -clip_gradient).</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L387' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.gamma-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.gamma-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.gamma</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">gamma(data)
</code></pre>

<p>Returns the gamma function (extension of the factorial function 
to the reals), computed element-wise on the input array.</p>
<p>The storage type of $gamma$ output is always dense</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L352' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.gammaln-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.gammaln-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.gammaln</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">gammaln(data)
</code></pre>

<p>Returns element-wise log of the absolute value of the gamma function 
of the input.</p>
<p>The storage type of $gammaln$ output is always dense</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L352' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.gather_nd-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.gather_nd-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.gather_nd</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">gather_nd(data, indices)
</code></pre>

<p>Gather elements or slices from <code>data</code> and store to a tensor whose shape is defined by <code>indices</code>.</p>
<p>Given <code>data</code> with shape <code>(X_0, X_1, ..., X_{N-1})</code> and indices with shape <code>(M, Y_0, ..., Y_{K-1})</code>, the output will have shape <code>(Y_0, ..., Y_{K-1}, X_M, ..., X_{N-1})</code>, where <code>M &lt;= N</code>. If <code>M == N</code>, output shape will simply be <code>(Y_0, ..., Y_{K-1})</code>.</p>
<p>The elements in output is defined as follows::</p>
<p>output[y<em K-1="K-1">0, ..., y</em>, x<em N-1="N-1">M, ..., x</em>] = data[indices[0, y<em K-1="K-1">0, ..., y</em>],                                                       ...,                                                       indices[M-1, y<em K-1="K-1">0, ..., y</em>],                                                       x<em N-1="N-1">M, ..., x</em>]</p>
<p>Examples::</p>
<p>data = [[0, 1], [2, 3]]   indices = [[1, 1, 0], [0, 1, 0]]   gather_nd(data, indices) = [2, 3, 0]</p>
<p>data = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]   indices = [[0, 1], [1, 0]]   gather_nd(data, indices) = [[3, 4], [5, 6]]</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: data</li>
<li><code>indices::NDArray-or-SymbolicNode</code>: indices</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L373' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.get_attr-Tuple{SymbolicNode,Symbol}' href='#MXNet.mx.get_attr-Tuple{SymbolicNode,Symbol}'>#</a>
<strong><code>MXNet.mx.get_attr</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">get_attr(s::SymbolicNode, key::Symbol)
</code></pre>

<p>Get attribute attached to this <code>SymbolicNode</code> belonging to key.</p>
<p>Returns the value belonging to key as a <code>String</code>. If not available, returns <code>missing</code>.</p>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L113-L120' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.get_children-Tuple{SymbolicNode}' href='#MXNet.mx.get_children-Tuple{SymbolicNode}'>#</a>
<strong><code>MXNet.mx.get_children</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">get_children(x::SymbolicNode)
</code></pre>

<p>Gets a new grouped <code>SymbolicNode</code> whose output contains inputs to output nodes of the original symbol.</p>
<pre><code class="julia">julia&gt; x, y = @mx.var x y
(SymbolicNode x, SymbolicNode y)

julia&gt; z = x + y
SymbolicNode _plus0

julia&gt; z |&gt; mx.get_children |&gt; mx.list_outputs
2-element Array{Symbol,1}:
 :x
 :y
</code></pre>

<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L87-L105' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.get_internals-Tuple{SymbolicNode}' href='#MXNet.mx.get_internals-Tuple{SymbolicNode}'>#</a>
<strong><code>MXNet.mx.get_internals</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">get_internals(s::SymbolicNode)
</code></pre>

<p>Get a new grouped <code>SymbolicNode</code> whose output contains all the internal outputs of this <code>SymbolicNode</code>.</p>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L75-L80' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.get_name-Tuple{SymbolicNode}' href='#MXNet.mx.get_name-Tuple{SymbolicNode}'>#</a>
<strong><code>MXNet.mx.get_name</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">get_name(s::SymbolicNode)
</code></pre>

<p>Get the name of the symbol.</p>
<pre><code>julia&gt; x = mx.Variable(:data)
julia&gt; mx.get_name(x)
:data

julia&gt; y = mx.FullyConnected(x, num_hidden = 128)
julia&gt; mx.get_name(y)
:fullyconnected0
</code></pre>

<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L198-L210' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.hard_sigmoid-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.hard_sigmoid-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.hard_sigmoid</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">hard_sigmoid(data, alpha, beta)
</code></pre>

<p>Computes hard sigmoid of x element-wise.</p>
<p>.. math::    y = max(0, min(1, alpha * x + beta))</p>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_basic.cc:L161</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>alpha::float, optional, default=0.200000003</code>: Slope of hard sigmoid</li>
<li><code>beta::float, optional, default=0.5</code>: Bias of hard sigmoid.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L358' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.im2col-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.im2col-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.im2col</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">im2col(data, kernel, stride, dilate, pad)
</code></pre>

<p>Extract sliding blocks from input array.</p>
<p>This operator is used in vanilla convolution implementation to transform the sliding blocks on image to column matrix, then the convolution operation can be computed by matrix multiplication between column and convolution weight. Due to the close relation between im2col and convolution, the concept of <strong>kernel</strong>, <strong>stride</strong>, <strong>dilate</strong> and <strong>pad</strong> in this operator are inherited from convolution operation.</p>
<p>Given the input data of shape :math:<code>(N, C, *)</code>, where :math:<code>N</code> is the batch size, :math:<code>C</code> is the channel size, and :math:<code>*</code> is the arbitrary spatial dimension, the output column array is always with shape :math:<code>(N, C \times \prod(\text{kernel}), W)</code>, where :math:<code>C \times \prod(\text{kernel})</code> is the block size, and :math:<code>W</code> is the block number which is the spatial size of the convolution output with same input parameters. Only 1-D, 2-D and 3-D of spatial dimension is supported in this operator.</p>
<p>Defined in src/operator/nn/im2col.cc:L100</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input array to extract sliding blocks.</li>
<li><code>kernel::Shape(tuple), required</code>: Sliding kernel size: (w,), (h, w) or (d, h, w).</li>
<li><code>stride::Shape(tuple), optional, default=[]</code>: The stride between adjacent sliding blocks in spatial dimension: (w,), (h, w) or (d, h, w). Defaults to 1 for each dimension.</li>
<li><code>dilate::Shape(tuple), optional, default=[]</code>: The spacing between adjacent kernel points: (w,), (h, w) or (d, h, w). Defaults to 1 for each dimension.</li>
<li><code>pad::Shape(tuple), optional, default=[]</code>: The zero-value padding size on both sides of spatial dimension: (w,), (h, w) or (d, h, w). Defaults to no padding.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L372' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.khatri_rao-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.khatri_rao-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.khatri_rao</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">khatri_rao(args)
</code></pre>

<p><strong>Note</strong>: khatri<em>rao takes variable number of positional inputs. So instead of calling as khatri</em>rao([x, y, z], num<em>args=3), one should call via khatri</em>rao(x, y, z), and num_args will be determined automatically.</p>
<p>Computes the Khatri-Rao product of the input matrices.</p>
<p>Given a collection of :math:<code>n</code> input matrices,</p>
<p>.. math::    A<em>1 \in \mathbb{R}^{M</em>1 \times M}, \ldots, A<em>n \in \mathbb{R}^{M</em>n \times N},</p>
<p>the (column-wise) Khatri-Rao product is defined as the matrix,</p>
<p>.. math::    X = A<em>1 \otimes \cdots \otimes A</em>n \in \mathbb{R}^{(M<em>1 \cdots M</em>n) \times N},</p>
<p>where the :math:<code>k</code> th column is equal to the column-wise outer product :math:<code>{A_1}_k \otimes \cdots \otimes {A_n}_k</code> where :math:<code>{A_i}_k</code> is the kth column of the ith matrix.</p>
<p>Example::</p>
<blockquote>
<blockquote>
<blockquote>
<p>A = mx.nd.array([[1, -1],                  [2, -3]]) B = mx.nd.array([[1, 4],                  [2, 5],                  [3, 6]]) C = mx.nd.khatri_rao(A, B) print(C.asnumpy())</p>
</blockquote>
</blockquote>
</blockquote>
<p>[[  1.  -4.]    [  2.  -5.]    [  3.  -6.]    [  2. -12.]    [  4. -15.]    [  6. -18.]]</p>
<p>Defined in src/operator/contrib/krprod.cc:L108</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>args::NDArray-or-SymbolicNode[]</code>: Positional input matrices</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L383' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.lamb_update_phase1-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.lamb_update_phase1-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.lamb_update_phase1</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">lamb_update_phase1(weight, grad, mean, var, beta1, beta2, epsilon, t, bias_correction, wd, rescale_grad, clip_gradient)
</code></pre>

<p>Phase I of lamb update it performs the following operations and returns g:.</p>
<p>Link to paper: https://arxiv.org/pdf/1904.00962.pdf</p>
<p>.. math::     \begin{gather<em>}     grad = grad * rescale</em>grad     if (grad &lt; -clip<em>gradient)     then          grad = -clip</em>gradient     if (grad &gt; clip*gradient)     then          grad = clip_gradient</p>
<pre><code>mean = beta1 * mean + (1 - beta1) * grad;
variance = beta2 * variance + (1. - beta2) * grad ^ 2;

if (bias_correction)
then
     mean_hat = mean / (1. - beta1^t);
     var_hat = var / (1 - beta2^t);
     g = mean_hat / (var_hat^(1/2) + epsilon) + wd * weight;
else
     g = mean / (var_data^(1/2) + epsilon) + wd * weight;
\end{gather*}
</code></pre>

<p>Defined in src/operator/optimizer_op.cc:L944</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>weight::NDArray-or-SymbolicNode</code>: Weight</li>
<li><code>grad::NDArray-or-SymbolicNode</code>: Gradient</li>
<li><code>mean::NDArray-or-SymbolicNode</code>: Moving mean</li>
<li><code>var::NDArray-or-SymbolicNode</code>: Moving variance</li>
<li><code>beta1::float, optional, default=0.899999976</code>: The decay rate for the 1st moment estimates.</li>
<li><code>beta2::float, optional, default=0.999000013</code>: The decay rate for the 2nd moment estimates.</li>
<li><code>epsilon::float, optional, default=9.99999997e-07</code>: A small constant for numerical stability.</li>
<li><code>t::int, required</code>: Index update count.</li>
<li><code>bias_correction::boolean, optional, default=1</code>: Whether to use bias correction.</li>
<li><code>wd::float, required</code>: Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</li>
<li><code>rescale_grad::float, optional, default=1</code>: Rescale gradient to grad = rescale_grad*grad.</li>
<li><code>clip_gradient::float, optional, default=-1</code>: Clip gradient to the range of [-clip<em>gradient, clip</em>gradient] If clip<em>gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip</em>gradient), -clip_gradient).</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L397' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.lamb_update_phase2-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.lamb_update_phase2-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.lamb_update_phase2</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">lamb_update_phase2(weight, g, r1, r2, lr, lower_bound, upper_bound)
</code></pre>

<p>Phase II of lamb update it performs the following operations and updates grad.</p>
<p>Link to paper: https://arxiv.org/pdf/1904.00962.pdf</p>
<p>.. math::     \begin{gather<em>}     if (lower</em>bound &gt;= 0)     then          r1 = max(r1, lower<em>bound)     if (upper</em>bound &gt;= 0)     then          r1 = max(r1, upper*bound)</p>
<pre><code>if (r1 == 0 or r2 == 0)
then
     lr = lr
else
     lr = lr * (r1/r2)
weight = weight - lr * g
\end{gather*}
</code></pre>

<p>Defined in src/operator/optimizer_op.cc:L983</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>weight::NDArray-or-SymbolicNode</code>: Weight</li>
<li><code>g::NDArray-or-SymbolicNode</code>: Output of lamb<em>update</em>phase 1</li>
<li><code>r1::NDArray-or-SymbolicNode</code>: r1</li>
<li><code>r2::NDArray-or-SymbolicNode</code>: r2</li>
<li><code>lr::float, required</code>: Learning rate</li>
<li><code>lower_bound::float, optional, default=-1</code>: Lower limit of norm of weight. If lower_bound &lt;= 0, Lower limit is not set</li>
<li><code>upper_bound::float, optional, default=-1</code>: Upper limit of norm of weight. If upper_bound &lt;= 0, Upper limit is not set</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L382' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.linalg_det-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.linalg_det-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.linalg_det</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">linalg_det(A)
</code></pre>

<p>linalg<em>det is an alias of _linalg</em>det.</p>
<p>Compute the determinant of a matrix. Input is a tensor <em>A</em> of dimension <em>n &gt;= 2</em>.</p>
<p>If <em>n=2</em>, <em>A</em> is a square matrix. We compute:</p>
<p><em>out</em> = <em>det(A)</em></p>
<p>If <em>n&gt;2</em>, <em>det</em> is performed separately on the trailing two dimensions for all inputs (batch mode).</p>
<p>.. note:: The operator supports float32 and float64 data types only. .. note:: There is no gradient backwarded when A is non-invertible (which is           equivalent to det(A) = 0) because zero is rarely hit upon in float           point computation and the Jacobi's formula on determinant gradient           is not computationally efficient when A is non-invertible.</p>
<p>Examples::</p>
<p>Single matrix determinant    A = [[1., 4.], [2., 3.]]    det(A) = [-5.]</p>
<p>Batch matrix determinant    A = [[[1., 4.], [2., 3.]],         [[2., 3.], [1., 4.]]]    det(A) = [-5., 5.]</p>
<p>Defined in src/operator/tensor/la_op.cc:L975</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>A::NDArray-or-SymbolicNode</code>: Tensor of square matrix</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L377' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.linalg_extractdiag-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.linalg_extractdiag-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.linalg_extractdiag</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">linalg_extractdiag(A, offset)
</code></pre>

<p>linalg<em>extractdiag is an alias of _linalg</em>extractdiag.</p>
<p>Extracts the diagonal entries of a square matrix. Input is a tensor <em>A</em> of dimension <em>n &gt;= 2</em>.</p>
<p>If <em>n=2</em>, then <em>A</em> represents a single square matrix which diagonal elements get extracted as a 1-dimensional tensor.</p>
<p>If <em>n&gt;2</em>, then <em>A</em> represents a batch of square matrices on the trailing two dimensions. The extracted diagonals are returned as an <em>n-1</em>-dimensional tensor.</p>
<p>.. note:: The operator supports float32 and float64 data types only.</p>
<p>Examples::</p>
<pre><code>Single matrix diagonal extraction
A = [[1.0, 2.0],
     [3.0, 4.0]]

extractdiag(A) = [1.0, 4.0]

extractdiag(A, 1) = [2.0]

Batch matrix diagonal extraction
A = [[[1.0, 2.0],
      [3.0, 4.0]],
     [[5.0, 6.0],
      [7.0, 8.0]]]

extractdiag(A) = [[1.0, 4.0],
                  [5.0, 8.0]]
</code></pre>

<p>Defined in src/operator/tensor/la_op.cc:L495</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>A::NDArray-or-SymbolicNode</code>: Tensor of square matrices</li>
<li><code>offset::int, optional, default='0'</code>: Offset of the diagonal versus the main diagonal. 0 corresponds to the main diagonal, a negative/positive value to diagonals below/above the main diagonal.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L380' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.linalg_extracttrian-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.linalg_extracttrian-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.linalg_extracttrian</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">linalg_extracttrian(A, offset, lower)
</code></pre>

<p>linalg<em>extracttrian is an alias of _linalg</em>extracttrian.</p>
<p>Extracts a triangular sub-matrix from a square matrix. Input is a tensor <em>A</em> of dimension <em>n &gt;= 2</em>.</p>
<p>If <em>n=2</em>, then <em>A</em> represents a single square matrix from which a triangular sub-matrix is extracted as a 1-dimensional tensor.</p>
<p>If <em>n&gt;2</em>, then <em>A</em> represents a batch of square matrices on the trailing two dimensions. The extracted triangular sub-matrices are returned as an <em>n-1</em>-dimensional tensor.</p>
<p>The <em>offset</em> and <em>lower</em> parameters determine the triangle to be extracted:</p>
<ul>
<li>When <em>offset = 0</em> either the lower or upper triangle with respect to the main diagonal is extracted depending on the value of parameter <em>lower</em>.</li>
<li>When <em>offset = k &gt; 0</em> the upper triangle with respect to the k-th diagonal above the main diagonal is extracted.</li>
<li>When <em>offset = k &lt; 0</em> the lower triangle with respect to the k-th diagonal below the main diagonal is extracted.</li>
</ul>
<p>.. note:: The operator supports float32 and float64 data types only.</p>
<p>Examples::</p>
<pre><code>Single triagonal extraction
A = [[1.0, 2.0],
     [3.0, 4.0]]

extracttrian(A) = [1.0, 3.0, 4.0]
extracttrian(A, lower=False) = [1.0, 2.0, 4.0]
extracttrian(A, 1) = [2.0]
extracttrian(A, -1) = [3.0]

Batch triagonal extraction
A = [[[1.0, 2.0],
      [3.0, 4.0]],
     [[5.0, 6.0],
      [7.0, 8.0]]]

extracttrian(A) = [[1.0, 3.0, 4.0],
                   [5.0, 7.0, 8.0]]
</code></pre>

<p>Defined in src/operator/tensor/la_op.cc:L605</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>A::NDArray-or-SymbolicNode</code>: Tensor of square matrices</li>
<li><code>offset::int, optional, default='0'</code>: Offset of the diagonal versus the main diagonal. 0 corresponds to the main diagonal, a negative/positive value to diagonals below/above the main diagonal.</li>
<li><code>lower::boolean, optional, default=1</code>: Refer to the lower triangular matrix if lower=true, refer to the upper otherwise. Only relevant when offset=0</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L389' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.linalg_gelqf-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.linalg_gelqf-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.linalg_gelqf</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">linalg_gelqf(A)
</code></pre>

<p>linalg<em>gelqf is an alias of _linalg</em>gelqf.</p>
<p>LQ factorization for general matrix. Input is a tensor <em>A</em> of dimension <em>n &gt;= 2</em>.</p>
<p>If <em>n=2</em>, we compute the LQ factorization (LAPACK <em>gelqf</em>, followed by <em>orglq</em>). <em>A</em> must have shape <em>(x, y)</em> with <em>x &lt;= y</em>, and must have full rank <em>=x</em>. The LQ factorization consists of <em>L</em> with shape <em>(x, x)</em> and <em>Q</em> with shape <em>(x, y)</em>, so that:</p>
<p><em>A</em> = <em>L</em> * <em>Q</em></p>
<p>Here, <em>L</em> is lower triangular (upper triangle equal to zero) with nonzero diagonal, and <em>Q</em> is row-orthonormal, meaning that</p>
<p><em>Q</em> * <em>Q</em>\ :sup:<code>T</code></p>
<p>is equal to the identity matrix of shape <em>(x, x)</em>.</p>
<p>If <em>n&gt;2</em>, <em>gelqf</em> is performed separately on the trailing two dimensions for all inputs (batch mode).</p>
<p>.. note:: The operator supports float32 and float64 data types only.</p>
<p>Examples::</p>
<p>Single LQ factorization    A = [[1., 2., 3.], [4., 5., 6.]]    Q, L = gelqf(A)    Q = [[-0.26726124, -0.53452248, -0.80178373],         [0.87287156, 0.21821789, -0.43643578]]    L = [[-3.74165739, 0.],         [-8.55235974, 1.96396101]]</p>
<p>Batch LQ factorization    A = [[[1., 2., 3.], [4., 5., 6.]],         [[7., 8., 9.], [10., 11., 12.]]]    Q, L = gelqf(A)    Q = [[[-0.26726124, -0.53452248, -0.80178373],          [0.87287156, 0.21821789, -0.43643578]],         [[-0.50257071, -0.57436653, -0.64616234],          [0.7620735, 0.05862104, -0.64483142]]]    L = [[[-3.74165739, 0.],          [-8.55235974, 1.96396101]],         [[-13.92838828, 0.],          [-19.09768702, 0.52758934]]]</p>
<p>Defined in src/operator/tensor/la_op.cc:L798</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>A::NDArray-or-SymbolicNode</code>: Tensor of input matrices to be factorized</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L395' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.linalg_gemm-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.linalg_gemm-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.linalg_gemm</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">linalg_gemm(A, B, C, transpose_a, transpose_b, alpha, beta, axis)
</code></pre>

<p>linalg<em>gemm is an alias of _linalg</em>gemm.</p>
<p>Performs general matrix multiplication and accumulation. Input are tensors <em>A</em>, <em>B</em>, <em>C</em>, each of dimension <em>n &gt;= 2</em> and having the same shape on the leading <em>n-2</em> dimensions.</p>
<p>If <em>n=2</em>, the BLAS3 function <em>gemm</em> is performed:</p>
<p><em>out</em> = <em>alpha</em> * <em>op</em>\ (<em>A</em>) * <em>op</em>\ (<em>B</em>) + <em>beta</em> * <em>C</em></p>
<p>Here, <em>alpha</em> and <em>beta</em> are scalar parameters, and <em>op()</em> is either the identity or matrix transposition (depending on <em>transpose_a</em>, <em>transpose_b</em>).</p>
<p>If <em>n&gt;2</em>, <em>gemm</em> is performed separately for a batch of matrices. The column indices of the matrices are given by the last dimensions of the tensors, the row indices by the axis specified with the <em>axis</em> parameter. By default, the trailing two dimensions will be used for matrix encoding.</p>
<p>For a non-default axis parameter, the operation performed is equivalent to a series of swapaxes/gemm/swapaxes calls. For example let <em>A</em>, <em>B</em>, <em>C</em> be 5 dimensional tensors. Then gemm(<em>A</em>, <em>B</em>, <em>C</em>, axis=1) is equivalent to the following without the overhead of the additional swapaxis operations::</p>
<pre><code>A1 = swapaxes(A, dim1=1, dim2=3)
B1 = swapaxes(B, dim1=1, dim2=3)
C = swapaxes(C, dim1=1, dim2=3)
C = gemm(A1, B1, C)
C = swapaxis(C, dim1=1, dim2=3)
</code></pre>

<p>When the input data is of type float32 and the environment variables MXNET<em>CUDA</em>ALLOW<em>TENSOR</em>CORE and MXNET<em>CUDA</em>TENSOR<em>OP</em>MATH<em>ALLOW</em>CONVERSION are set to 1, this operator will try to use pseudo-float16 precision (float32 math with float16 I/O) precision in order to use Tensor Cores on suitable NVIDIA GPUs. This can sometimes give significant speedups.</p>
<p>.. note:: The operator supports float32 and float64 data types only.</p>
<p>Examples::</p>
<p>Single matrix multiply-add    A = [[1.0, 1.0], [1.0, 1.0]]    B = [[1.0, 1.0], [1.0, 1.0], [1.0, 1.0]]    C = [[1.0, 1.0, 1.0], [1.0, 1.0, 1.0]]    gemm(A, B, C, transpose_b=True, alpha=2.0, beta=10.0)            = [[14.0, 14.0, 14.0], [14.0, 14.0, 14.0]]</p>
<p>Batch matrix multiply-add    A = [[[1.0, 1.0]], [[0.1, 0.1]]]    B = [[[1.0, 1.0]], [[0.1, 0.1]]]    C = [[[10.0]], [[0.01]]]    gemm(A, B, C, transpose_b=True, alpha=2.0 , beta=10.0)            = [[[104.0]], [[0.14]]]</p>
<p>Defined in src/operator/tensor/la_op.cc:L89</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>A::NDArray-or-SymbolicNode</code>: Tensor of input matrices</li>
<li><code>B::NDArray-or-SymbolicNode</code>: Tensor of input matrices</li>
<li><code>C::NDArray-or-SymbolicNode</code>: Tensor of input matrices</li>
<li><code>transpose_a::boolean, optional, default=0</code>: Multiply with transposed of first input (A).</li>
<li><code>transpose_b::boolean, optional, default=0</code>: Multiply with transposed of second input (B).</li>
<li><code>alpha::double, optional, default=1</code>: Scalar factor multiplied with A*B.</li>
<li><code>beta::double, optional, default=1</code>: Scalar factor multiplied with C.</li>
<li><code>axis::int, optional, default='-2'</code>: Axis corresponding to the matrix rows.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L412' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.linalg_gemm2-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.linalg_gemm2-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.linalg_gemm2</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">linalg_gemm2(A, B, transpose_a, transpose_b, alpha, axis)
</code></pre>

<p>linalg<em>gemm2 is an alias of _linalg</em>gemm2.</p>
<p>Performs general matrix multiplication. Input are tensors <em>A</em>, <em>B</em>, each of dimension <em>n &gt;= 2</em> and having the same shape on the leading <em>n-2</em> dimensions.</p>
<p>If <em>n=2</em>, the BLAS3 function <em>gemm</em> is performed:</p>
<p><em>out</em> = <em>alpha</em> * <em>op</em>\ (<em>A</em>) * <em>op</em>\ (<em>B</em>)</p>
<p>Here <em>alpha</em> is a scalar parameter and <em>op()</em> is either the identity or the matrix transposition (depending on <em>transpose_a</em>, <em>transpose_b</em>).</p>
<p>If <em>n&gt;2</em>, <em>gemm</em> is performed separately for a batch of matrices. The column indices of the matrices are given by the last dimensions of the tensors, the row indices by the axis specified with the <em>axis</em> parameter. By default, the trailing two dimensions will be used for matrix encoding.</p>
<p>For a non-default axis parameter, the operation performed is equivalent to a series of swapaxes/gemm/swapaxes calls. For example let <em>A</em>, <em>B</em> be 5 dimensional tensors. Then gemm(<em>A</em>, <em>B</em>, axis=1) is equivalent to the following without the overhead of the additional swapaxis operations::</p>
<pre><code>A1 = swapaxes(A, dim1=1, dim2=3)
B1 = swapaxes(B, dim1=1, dim2=3)
C = gemm2(A1, B1)
C = swapaxis(C, dim1=1, dim2=3)
</code></pre>

<p>When the input data is of type float32 and the environment variables MXNET<em>CUDA</em>ALLOW<em>TENSOR</em>CORE and MXNET<em>CUDA</em>TENSOR<em>OP</em>MATH<em>ALLOW</em>CONVERSION are set to 1, this operator will try to use pseudo-float16 precision (float32 math with float16 I/O) precision in order to use Tensor Cores on suitable NVIDIA GPUs. This can sometimes give significant speedups.</p>
<p>.. note:: The operator supports float32 and float64 data types only.</p>
<p>Examples::</p>
<p>Single matrix multiply    A = [[1.0, 1.0], [1.0, 1.0]]    B = [[1.0, 1.0], [1.0, 1.0], [1.0, 1.0]]    gemm2(A, B, transpose_b=True, alpha=2.0)             = [[4.0, 4.0, 4.0], [4.0, 4.0, 4.0]]</p>
<p>Batch matrix multiply    A = [[[1.0, 1.0]], [[0.1, 0.1]]]    B = [[[1.0, 1.0]], [[0.1, 0.1]]]    gemm2(A, B, transpose_b=True, alpha=2.0)            = [[[4.0]], [[0.04 ]]]</p>
<p>Defined in src/operator/tensor/la_op.cc:L163</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>A::NDArray-or-SymbolicNode</code>: Tensor of input matrices</li>
<li><code>B::NDArray-or-SymbolicNode</code>: Tensor of input matrices</li>
<li><code>transpose_a::boolean, optional, default=0</code>: Multiply with transposed of first input (A).</li>
<li><code>transpose_b::boolean, optional, default=0</code>: Multiply with transposed of second input (B).</li>
<li><code>alpha::double, optional, default=1</code>: Scalar factor multiplied with A*B.</li>
<li><code>axis::int, optional, default='-2'</code>: Axis corresponding to the matrix row indices.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L405' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.linalg_inverse-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.linalg_inverse-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.linalg_inverse</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">linalg_inverse(A)
</code></pre>

<p>linalg<em>inverse is an alias of _linalg</em>inverse.</p>
<p>Compute the inverse of a matrix. Input is a tensor <em>A</em> of dimension <em>n &gt;= 2</em>.</p>
<p>If <em>n=2</em>, <em>A</em> is a square matrix. We compute:</p>
<p><em>out</em> = <em>A</em>\ :sup:<code>-1</code></p>
<p>If <em>n&gt;2</em>, <em>inverse</em> is performed separately on the trailing two dimensions for all inputs (batch mode).</p>
<p>.. note:: The operator supports float32 and float64 data types only.</p>
<p>Examples::</p>
<p>Single matrix inverse    A = [[1., 4.], [2., 3.]]    inverse(A) = [[-0.6, 0.8], [0.4, -0.2]]</p>
<p>Batch matrix inverse    A = [[[1., 4.], [2., 3.]],         [[1., 3.], [2., 4.]]]    inverse(A) = [[[-0.6, 0.8], [0.4, -0.2]],                  [[-2., 1.5], [1., -0.5]]]</p>
<p>Defined in src/operator/tensor/la_op.cc:L920</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>A::NDArray-or-SymbolicNode</code>: Tensor of square matrix</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L374' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.linalg_makediag-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.linalg_makediag-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.linalg_makediag</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">linalg_makediag(A, offset)
</code></pre>

<p>linalg<em>makediag is an alias of _linalg</em>makediag.</p>
<p>Constructs a square matrix with the input as diagonal. Input is a tensor <em>A</em> of dimension <em>n &gt;= 1</em>.</p>
<p>If <em>n=1</em>, then <em>A</em> represents the diagonal entries of a single square matrix. This matrix will be returned as a 2-dimensional tensor. If <em>n&gt;1</em>, then <em>A</em> represents a batch of diagonals of square matrices. The batch of diagonal matrices will be returned as an <em>n+1</em>-dimensional tensor.</p>
<p>.. note:: The operator supports float32 and float64 data types only.</p>
<p>Examples::</p>
<pre><code>Single diagonal matrix construction
A = [1.0, 2.0]

makediag(A)    = [[1.0, 0.0],
                  [0.0, 2.0]]

makediag(A, 1) = [[0.0, 1.0, 0.0],
                  [0.0, 0.0, 2.0],
                  [0.0, 0.0, 0.0]]

Batch diagonal matrix construction
A = [[1.0, 2.0],
     [3.0, 4.0]]

makediag(A) = [[[1.0, 0.0],
                [0.0, 2.0]],
               [[3.0, 0.0],
                [0.0, 4.0]]]
</code></pre>

<p>Defined in src/operator/tensor/la_op.cc:L547</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>A::NDArray-or-SymbolicNode</code>: Tensor of diagonal entries</li>
<li><code>offset::int, optional, default='0'</code>: Offset of the diagonal versus the main diagonal. 0 corresponds to the main diagonal, a negative/positive value to diagonals below/above the main diagonal.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L381' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.linalg_maketrian-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.linalg_maketrian-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.linalg_maketrian</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">linalg_maketrian(A, offset, lower)
</code></pre>

<p>linalg<em>maketrian is an alias of _linalg</em>maketrian.</p>
<p>Constructs a square matrix with the input representing a specific triangular sub-matrix. This is basically the inverse of <em>linalg.extracttrian</em>. Input is a tensor <em>A</em> of dimension <em>n &gt;= 1</em>.</p>
<p>If <em>n=1</em>, then <em>A</em> represents the entries of a triangular matrix which is lower triangular if <em>offset&lt;0</em> or <em>offset=0</em>, <em>lower=true</em>. The resulting matrix is derived by first constructing the square matrix with the entries outside the triangle set to zero and then adding <em>offset</em>-times an additional  diagonal with zero entries to the square matrix. </p>
<p>If <em>n&gt;1</em>, then <em>A</em> represents a batch of triangular sub-matrices. The batch of corresponding square matrices is returned as an <em>n+1</em>-dimensional tensor.</p>
<p>.. note:: The operator supports float32 and float64 data types only.</p>
<p>Examples::</p>
<pre><code>Single  matrix construction
A = [1.0, 2.0, 3.0]

maketrian(A)              = [[1.0, 0.0],
                             [2.0, 3.0]]

maketrian(A, lower=false) = [[1.0, 2.0],
                             [0.0, 3.0]]

maketrian(A, offset=1)    = [[0.0, 1.0, 2.0],
                             [0.0, 0.0, 3.0],
                             [0.0, 0.0, 0.0]]
maketrian(A, offset=-1)   = [[0.0, 0.0, 0.0],
                             [1.0, 0.0, 0.0],
                             [2.0, 3.0, 0.0]]

Batch matrix construction
A = [[1.0, 2.0, 3.0],
     [4.0, 5.0, 6.0]]

maketrian(A)           = [[[1.0, 0.0],
                           [2.0, 3.0]],
                          [[4.0, 0.0],
                           [5.0, 6.0]]]

maketrian(A, offset=1) = [[[0.0, 1.0, 2.0],
                           [0.0, 0.0, 3.0],
                           [0.0, 0.0, 0.0]],
                          [[0.0, 4.0, 5.0],
                           [0.0, 0.0, 6.0],
                           [0.0, 0.0, 0.0]]]
</code></pre>

<p>Defined in src/operator/tensor/la_op.cc:L673</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>A::NDArray-or-SymbolicNode</code>: Tensor of triangular matrices stored as vectors</li>
<li><code>offset::int, optional, default='0'</code>: Offset of the diagonal versus the main diagonal. 0 corresponds to the main diagonal, a negative/positive value to diagonals below/above the main diagonal.</li>
<li><code>lower::boolean, optional, default=1</code>: Refer to the lower triangular matrix if lower=true, refer to the upper otherwise. Only relevant when offset=0</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L399' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.linalg_potrf-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.linalg_potrf-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.linalg_potrf</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">linalg_potrf(A)
</code></pre>

<p>linalg<em>potrf is an alias of _linalg</em>potrf.</p>
<p>Performs Cholesky factorization of a symmetric positive-definite matrix. Input is a tensor <em>A</em> of dimension <em>n &gt;= 2</em>.</p>
<p>If <em>n=2</em>, the Cholesky factor <em>B</em> of the symmetric, positive definite matrix <em>A</em> is computed. <em>B</em> is triangular (entries of upper or lower triangle are all zero), has positive diagonal entries, and:</p>
<p><em>A</em> = <em>B</em> * <em>B</em>\ :sup:<code>T</code>  if <em>lower</em> = <em>true</em>   <em>A</em> = <em>B</em>\ :sup:<code>T</code> * <em>B</em>  if <em>lower</em> = <em>false</em></p>
<p>If <em>n&gt;2</em>, <em>potrf</em> is performed separately on the trailing two dimensions for all inputs (batch mode).</p>
<p>.. note:: The operator supports float32 and float64 data types only.</p>
<p>Examples::</p>
<p>Single matrix factorization    A = [[4.0, 1.0], [1.0, 4.25]]    potrf(A) = [[2.0, 0], [0.5, 2.0]]</p>
<p>Batch matrix factorization    A = [[[4.0, 1.0], [1.0, 4.25]], [[16.0, 4.0], [4.0, 17.0]]]    potrf(A) = [[[2.0, 0], [0.5, 2.0]], [[4.0, 0], [1.0, 4.0]]]</p>
<p>Defined in src/operator/tensor/la_op.cc:L214</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>A::NDArray-or-SymbolicNode</code>: Tensor of input matrices to be decomposed</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L375' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.linalg_potri-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.linalg_potri-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.linalg_potri</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">linalg_potri(A)
</code></pre>

<p>linalg<em>potri is an alias of _linalg</em>potri.</p>
<p>Performs matrix inversion from a Cholesky factorization. Input is a tensor <em>A</em> of dimension <em>n &gt;= 2</em>.</p>
<p>If <em>n=2</em>, <em>A</em> is a triangular matrix (entries of upper or lower triangle are all zero) with positive diagonal. We compute:</p>
<p><em>out</em> = <em>A</em>\ :sup:<code>-T</code> * <em>A</em>\ :sup:<code>-1</code> if <em>lower</em> = <em>true</em>   <em>out</em> = <em>A</em>\ :sup:<code>-1</code> * <em>A</em>\ :sup:<code>-T</code> if <em>lower</em> = <em>false</em></p>
<p>In other words, if <em>A</em> is the Cholesky factor of a symmetric positive definite matrix <em>B</em> (obtained by <em>potrf</em>), then</p>
<p><em>out</em> = <em>B</em>\ :sup:<code>-1</code></p>
<p>If <em>n&gt;2</em>, <em>potri</em> is performed separately on the trailing two dimensions for all inputs (batch mode).</p>
<p>.. note:: The operator supports float32 and float64 data types only.</p>
<p>.. note:: Use this operator only if you are certain you need the inverse of <em>B</em>, and           cannot use the Cholesky factor <em>A</em> (<em>potrf</em>), together with backsubstitution           (<em>trsm</em>). The latter is numerically much safer, and also cheaper.</p>
<p>Examples::</p>
<p>Single matrix inverse    A = [[2.0, 0], [0.5, 2.0]]    potri(A) = [[0.26563, -0.0625], [-0.0625, 0.25]]</p>
<p>Batch matrix inverse    A = [[[2.0, 0], [0.5, 2.0]], [[4.0, 0], [1.0, 4.0]]]    potri(A) = [[[0.26563, -0.0625], [-0.0625, 0.25]],                [[0.06641, -0.01562], [-0.01562, 0,0625]]]</p>
<p>Defined in src/operator/tensor/la_op.cc:L275</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>A::NDArray-or-SymbolicNode</code>: Tensor of lower triangular matrices</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L384' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.linalg_slogdet-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.linalg_slogdet-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.linalg_slogdet</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">linalg_slogdet(A)
</code></pre>

<p>linalg<em>slogdet is an alias of _linalg</em>slogdet.</p>
<p>Compute the sign and log of the determinant of a matrix. Input is a tensor <em>A</em> of dimension <em>n &gt;= 2</em>.</p>
<p>If <em>n=2</em>, <em>A</em> is a square matrix. We compute:</p>
<p><em>sign</em> = <em>sign(det(A))</em>   <em>logabsdet</em> = <em>log(abs(det(A)))</em></p>
<p>If <em>n&gt;2</em>, <em>slogdet</em> is performed separately on the trailing two dimensions for all inputs (batch mode).</p>
<p>.. note:: The operator supports float32 and float64 data types only. .. note:: The gradient is not properly defined on sign, so the gradient of           it is not backwarded. .. note:: No gradient is backwarded when A is non-invertible. Please see           the docs of operator det for detail.</p>
<p>Examples::</p>
<p>Single matrix signed log determinant    A = [[2., 3.], [1., 4.]]    sign, logabsdet = slogdet(A)    sign = [1.]    logabsdet = [1.609438]</p>
<p>Batch matrix signed log determinant    A = [[[2., 3.], [1., 4.]],         [[1., 2.], [2., 4.]],         [[1., 2.], [4., 3.]]]    sign, logabsdet = slogdet(A)    sign = [1., 0., -1.]    logabsdet = [1.609438, -inf, 1.609438]</p>
<p>Defined in src/operator/tensor/la_op.cc:L1034</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>A::NDArray-or-SymbolicNode</code>: Tensor of square matrix</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L383' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.linalg_sumlogdiag-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.linalg_sumlogdiag-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.linalg_sumlogdiag</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">linalg_sumlogdiag(A)
</code></pre>

<p>linalg<em>sumlogdiag is an alias of _linalg</em>sumlogdiag.</p>
<p>Computes the sum of the logarithms of the diagonal elements of a square matrix. Input is a tensor <em>A</em> of dimension <em>n &gt;= 2</em>.</p>
<p>If <em>n=2</em>, <em>A</em> must be square with positive diagonal entries. We sum the natural logarithms of the diagonal elements, the result has shape (1,).</p>
<p>If <em>n&gt;2</em>, <em>sumlogdiag</em> is performed separately on the trailing two dimensions for all inputs (batch mode).</p>
<p>.. note:: The operator supports float32 and float64 data types only.</p>
<p>Examples::</p>
<p>Single matrix reduction    A = [[1.0, 1.0], [1.0, 7.0]]    sumlogdiag(A) = [1.9459]</p>
<p>Batch matrix reduction    A = [[[1.0, 1.0], [1.0, 7.0]], [[3.0, 0], [0, 17.0]]]    sumlogdiag(A) = [1.9459, 3.9318]</p>
<p>Defined in src/operator/tensor/la_op.cc:L445</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>A::NDArray-or-SymbolicNode</code>: Tensor of square matrices</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L371' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.linalg_syrk-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.linalg_syrk-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.linalg_syrk</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">linalg_syrk(A, transpose, alpha)
</code></pre>

<p>linalg<em>syrk is an alias of _linalg</em>syrk.</p>
<p>Multiplication of matrix with its transpose. Input is a tensor <em>A</em> of dimension <em>n &gt;= 2</em>.</p>
<p>If <em>n=2</em>, the operator performs the BLAS3 function <em>syrk</em>:</p>
<p><em>out</em> = <em>alpha</em> * <em>A</em> * <em>A</em>\ :sup:<code>T</code></p>
<p>if <em>transpose=False</em>, or</p>
<p><em>out</em> = <em>alpha</em> * <em>A</em>\ :sup:<code>T</code> \ * <em>A</em></p>
<p>if <em>transpose=True</em>.</p>
<p>If <em>n&gt;2</em>, <em>syrk</em> is performed separately on the trailing two dimensions for all inputs (batch mode).</p>
<p>.. note:: The operator supports float32 and float64 data types only.</p>
<p>Examples::</p>
<p>Single matrix multiply    A = [[1., 2., 3.], [4., 5., 6.]]    syrk(A, alpha=1., transpose=False)             = [[14., 32.],                [32., 77.]]    syrk(A, alpha=1., transpose=True)             = [[17., 22., 27.],                [22., 29., 36.],                [27., 36., 45.]]</p>
<p>Batch matrix multiply    A = [[[1., 1.]], [[0.1, 0.1]]]    syrk(A, alpha=2., transpose=False) = [[[4.]], [[0.04]]]</p>
<p>Defined in src/operator/tensor/la_op.cc:L730</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>A::NDArray-or-SymbolicNode</code>: Tensor of input matrices</li>
<li><code>transpose::boolean, optional, default=0</code>: Use transpose of input matrix.</li>
<li><code>alpha::double, optional, default=1</code>: Scalar factor to be applied to the result.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L388' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.linalg_trmm-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.linalg_trmm-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.linalg_trmm</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">linalg_trmm(A, B, transpose, rightside, lower, alpha)
</code></pre>

<p>linalg<em>trmm is an alias of _linalg</em>trmm.</p>
<p>Performs multiplication with a lower triangular matrix. Input are tensors <em>A</em>, <em>B</em>, each of dimension <em>n &gt;= 2</em> and having the same shape on the leading <em>n-2</em> dimensions.</p>
<p>If <em>n=2</em>, <em>A</em> must be triangular. The operator performs the BLAS3 function <em>trmm</em>:</p>
<p><em>out</em> = <em>alpha</em> * <em>op</em>\ (<em>A</em>) * <em>B</em></p>
<p>if <em>rightside=False</em>, or</p>
<p><em>out</em> = <em>alpha</em> * <em>B</em> * <em>op</em>\ (<em>A</em>)</p>
<p>if <em>rightside=True</em>. Here, <em>alpha</em> is a scalar parameter, and <em>op()</em> is either the identity or the matrix transposition (depending on <em>transpose</em>).</p>
<p>If <em>n&gt;2</em>, <em>trmm</em> is performed separately on the trailing two dimensions for all inputs (batch mode).</p>
<p>.. note:: The operator supports float32 and float64 data types only.</p>
<p>Examples::</p>
<p>Single triangular matrix multiply    A = [[1.0, 0], [1.0, 1.0]]    B = [[1.0, 1.0, 1.0], [1.0, 1.0, 1.0]]    trmm(A, B, alpha=2.0) = [[2.0, 2.0, 2.0], [4.0, 4.0, 4.0]]</p>
<p>Batch triangular matrix multiply    A = [[[1.0, 0], [1.0, 1.0]], [[1.0, 0], [1.0, 1.0]]]    B = [[[1.0, 1.0, 1.0], [1.0, 1.0, 1.0]], [[0.5, 0.5, 0.5], [0.5, 0.5, 0.5]]]    trmm(A, B, alpha=2.0) = [[[2.0, 2.0, 2.0], [4.0, 4.0, 4.0]],                             [[1.0, 1.0, 1.0], [2.0, 2.0, 2.0]]]</p>
<p>Defined in src/operator/tensor/la_op.cc:L333</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>A::NDArray-or-SymbolicNode</code>: Tensor of lower triangular matrices</li>
<li><code>B::NDArray-or-SymbolicNode</code>: Tensor of matrices</li>
<li><code>transpose::boolean, optional, default=0</code>: Use transposed of the triangular matrix</li>
<li><code>rightside::boolean, optional, default=0</code>: Multiply triangular matrix from the right to non-triangular one.</li>
<li><code>lower::boolean, optional, default=1</code>: True if the triangular matrix is lower triangular, false if it is upper triangular.</li>
<li><code>alpha::double, optional, default=1</code>: Scalar factor to be applied to the result.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L394' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.linalg_trsm-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.linalg_trsm-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.linalg_trsm</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">linalg_trsm(A, B, transpose, rightside, lower, alpha)
</code></pre>

<p>linalg<em>trsm is an alias of _linalg</em>trsm.</p>
<p>Solves matrix equation involving a lower triangular matrix. Input are tensors <em>A</em>, <em>B</em>, each of dimension <em>n &gt;= 2</em> and having the same shape on the leading <em>n-2</em> dimensions.</p>
<p>If <em>n=2</em>, <em>A</em> must be triangular. The operator performs the BLAS3 function <em>trsm</em>, solving for <em>out</em> in:</p>
<p><em>op</em>\ (<em>A</em>) * <em>out</em> = <em>alpha</em> * <em>B</em></p>
<p>if <em>rightside=False</em>, or</p>
<p><em>out</em> * <em>op</em>\ (<em>A</em>) = <em>alpha</em> * <em>B</em></p>
<p>if <em>rightside=True</em>. Here, <em>alpha</em> is a scalar parameter, and <em>op()</em> is either the identity or the matrix transposition (depending on <em>transpose</em>).</p>
<p>If <em>n&gt;2</em>, <em>trsm</em> is performed separately on the trailing two dimensions for all inputs (batch mode).</p>
<p>.. note:: The operator supports float32 and float64 data types only.</p>
<p>Examples::</p>
<p>Single matrix solve    A = [[1.0, 0], [1.0, 1.0]]    B = [[2.0, 2.0, 2.0], [4.0, 4.0, 4.0]]    trsm(A, B, alpha=0.5) = [[1.0, 1.0, 1.0], [1.0, 1.0, 1.0]]</p>
<p>Batch matrix solve    A = [[[1.0, 0], [1.0, 1.0]], [[1.0, 0], [1.0, 1.0]]]    B = [[[2.0, 2.0, 2.0], [4.0, 4.0, 4.0]],         [[4.0, 4.0, 4.0], [8.0, 8.0, 8.0]]]    trsm(A, B, alpha=0.5) = [[[1.0, 1.0, 1.0], [1.0, 1.0, 1.0]],                             [[2.0, 2.0, 2.0], [2.0, 2.0, 2.0]]]</p>
<p>Defined in src/operator/tensor/la_op.cc:L396</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>A::NDArray-or-SymbolicNode</code>: Tensor of lower triangular matrices</li>
<li><code>B::NDArray-or-SymbolicNode</code>: Tensor of matrices</li>
<li><code>transpose::boolean, optional, default=0</code>: Use transposed of the triangular matrix</li>
<li><code>rightside::boolean, optional, default=0</code>: Multiply triangular matrix from the right to non-triangular one.</li>
<li><code>lower::boolean, optional, default=1</code>: True if the triangular matrix is lower triangular, false if it is upper triangular.</li>
<li><code>alpha::double, optional, default=1</code>: Scalar factor to be applied to the result.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L395' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.list_all_attr-Tuple{SymbolicNode}' href='#MXNet.mx.list_all_attr-Tuple{SymbolicNode}'>#</a>
<strong><code>MXNet.mx.list_all_attr</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">list_all_attr(s::SymbolicNode)
</code></pre>

<p>Get all attributes from the symbol graph.</p>
<p>Returns a dictionary of attributes.</p>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L157-L163' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.list_arguments-Tuple{SymbolicNode}' href='#MXNet.mx.list_arguments-Tuple{SymbolicNode}'>#</a>
<strong><code>MXNet.mx.list_arguments</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">list_arguments(s::SymbolicNode)
</code></pre>

<p>List all the arguments of this node. The argument for a node contains both the inputs and parameters. For example, a <code>FullyConnected</code> node will have both data and weights in its arguments. A composed node (e.g. a MLP) will list all the arguments for intermediate nodes.</p>
<p>Returns a list of symbols indicating the names of the arguments.</p>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L37-L46' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.list_attr-Tuple{SymbolicNode}' href='#MXNet.mx.list_attr-Tuple{SymbolicNode}'>#</a>
<strong><code>MXNet.mx.list_attr</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">list_attr(s::SymbolicNode)
</code></pre>

<p>Get all attributes from a symbol.</p>
<p>Returns a dictionary of attributes.</p>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L134-L140' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.list_auxiliary_states-Tuple{SymbolicNode}' href='#MXNet.mx.list_auxiliary_states-Tuple{SymbolicNode}'>#</a>
<strong><code>MXNet.mx.list_auxiliary_states</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">list_auxiliary_states(s::SymbolicNode)
</code></pre>

<p>List all auxiliary states in the symbool.</p>
<p>Auxiliary states are special states of symbols that do not corresponds to an argument, and do not have gradient. But still be useful for the specific operations. A common example of auxiliary state is the moving<em>mean and moving</em>variance in BatchNorm. Most operators do not have Auxiliary states.</p>
<p>Returns a list of symbols indicating the names of the auxiliary states.</p>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L59-L71' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.list_outputs-Tuple{SymbolicNode}' href='#MXNet.mx.list_outputs-Tuple{SymbolicNode}'>#</a>
<strong><code>MXNet.mx.list_outputs</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">list_outputs(s::SymbolicNode)
</code></pre>

<p>List all the outputs of this node.</p>
<p>Returns a list of symbols indicating the names of the outputs.</p>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L49-L55' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.logical_not-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.logical_not-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.logical_not</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">logical_not(data)
</code></pre>

<p>Returns the result of logical NOT (!) function</p>
<p>Example:   logical_not([-2., 0., 1.]) = [0., 1., 0.]</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L352' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.make_loss-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.make_loss-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.make_loss</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">make_loss(data)
</code></pre>

<p>Make your own loss function in network construction.</p>
<p>This operator accepts a customized loss function symbol as a terminal loss and the symbol should be an operator with no backward dependency. The output of this function is the gradient of loss with respect to the input data.</p>
<p>For example, if you are a making a cross entropy loss function. Assume $out$ is the predicted output and $label$ is the true label, then the cross entropy can be defined as::</p>
<p>cross<em>entropy = label * log(out) + (1 - label) * log(1 - out)   loss = make</em>loss(cross_entropy)</p>
<p>We will need to use $make_loss$ when we are creating our own loss function or we want to combine multiple loss functions. Also we may want to stop some variables' gradients from backpropagation. See more detail in $BlockGrad$ or $stop_gradient$.</p>
<p>The storage type of $make_loss$ output depends upon the input storage type:</p>
<ul>
<li>make_loss(default) = default</li>
<li>make<em>loss(row</em>sparse) = row_sparse</li>
</ul>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_basic.cc:L358</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L370' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.max_axis-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.max_axis-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.max_axis</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">max_axis(data, axis, keepdims, exclude)
</code></pre>

<p>max_axis is an alias of max.</p>
<p>Computes the max of array elements over given axes.</p>
<p>Defined in src/operator/tensor/./broadcast<em>reduce</em>op.h:L32</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input</li>
<li>
<p><code>axis::Shape or None, optional, default=None</code>: The axis or axes along which to perform the reduction.</p>
<p><code>``
The default,</code>axis=()<code>, will compute over all elements into a
scalar array with shape</code>(1,)`.</p>
<p>If <code>axis</code> is int, a reduction is performed on a particular axis.</p>
<p>If <code>axis</code> is a tuple of ints, a reduction is performed on all the axes
specified in the tuple.</p>
<p>If <code>exclude</code> is true, reduction will be performed on the axes that are
NOT in axis instead.</p>
<p>Negative values means indexing from right to left.
<code>``
  *</code>keepdims::boolean, optional, default=0<code>: If this is set to</code>True<code>, the reduced axes are left in the result as dimension with size one.
  *</code>exclude::boolean, optional, default=0<code>: Whether to perform reduction on axis that are NOT in axis instead.
  *</code>name::Symbol<code>: The name of the</code>SymbolicNode<code>. (e.g.</code>:my_symbol<code>), optional.
  *</code>attrs::Dict{Symbol,String}<code>: The attributes associated with this</code>SymbolicNode`.</p>
</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L370' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.min_axis-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.min_axis-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.min_axis</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">min_axis(data, axis, keepdims, exclude)
</code></pre>

<p>min_axis is an alias of min.</p>
<p>Computes the min of array elements over given axes.</p>
<p>Defined in src/operator/tensor/./broadcast<em>reduce</em>op.h:L47</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input</li>
<li>
<p><code>axis::Shape or None, optional, default=None</code>: The axis or axes along which to perform the reduction.</p>
<p><code>``
The default,</code>axis=()<code>, will compute over all elements into a
scalar array with shape</code>(1,)`.</p>
<p>If <code>axis</code> is int, a reduction is performed on a particular axis.</p>
<p>If <code>axis</code> is a tuple of ints, a reduction is performed on all the axes
specified in the tuple.</p>
<p>If <code>exclude</code> is true, reduction will be performed on the axes that are
NOT in axis instead.</p>
<p>Negative values means indexing from right to left.
<code>``
  *</code>keepdims::boolean, optional, default=0<code>: If this is set to</code>True<code>, the reduced axes are left in the result as dimension with size one.
  *</code>exclude::boolean, optional, default=0<code>: Whether to perform reduction on axis that are NOT in axis instead.
  *</code>name::Symbol<code>: The name of the</code>SymbolicNode<code>. (e.g.</code>:my_symbol<code>), optional.
  *</code>attrs::Dict{Symbol,String}<code>: The attributes associated with this</code>SymbolicNode`.</p>
</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L370' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.moments-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.moments-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.moments</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">moments(data, axes, keepdims)
</code></pre>

<p>Calculate the mean and variance of <code>data</code>.</p>
<p>The mean and variance are calculated by aggregating the contents of data across axes. If x is 1-D and axes = [0] this is just the mean and variance of a vector.</p>
<p>Example:</p>
<pre><code> x = [[1, 2, 3], [4, 5, 6]]
 mean, var = moments(data=x, axes=[0])
 mean = [2.5, 3.5, 4.5]
 var = [2.25, 2.25, 2.25]
 mean, var = moments(data=x, axes=[1])
 mean = [2.0, 5.0]
 var = [0.66666667, 0.66666667]
 mean, var = moments(data=x, axis=[0, 1])
 mean = [3.5]
 var = [2.9166667]
</code></pre>

<p>Defined in src/operator/nn/moments.cc:L54</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input ndarray</li>
<li><code>axes::Shape or None, optional, default=None</code>: Array of ints. Axes along which to compute mean and variance.</li>
<li><code>keepdims::boolean, optional, default=0</code>: produce moments with the same dimensionality as the input.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L372' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.mp_lamb_update_phase1-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.mp_lamb_update_phase1-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.mp_lamb_update_phase1</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">mp_lamb_update_phase1(weight, grad, mean, var, weight32, beta1, beta2, epsilon, t, bias_correction, wd, rescale_grad, clip_gradient)
</code></pre>

<p>Mixed Precision version of Phase I of lamb update  it performs the following operations and returns g:.</p>
<pre><code>      Link to paper: https://arxiv.org/pdf/1904.00962.pdf

      .. math::
          \begin{gather*}
          grad32 = grad(float16) * rescale_grad
          if (grad &lt; -clip_gradient)
          then
               grad = -clip_gradient
          if (grad &gt; clip_gradient)
          then
               grad = clip_gradient

          mean = beta1 * mean + (1 - beta1) * grad;
          variance = beta2 * variance + (1. - beta2) * grad ^ 2;

          if (bias_correction)
          then
               mean_hat = mean / (1. - beta1^t);
               var_hat = var / (1 - beta2^t);
               g = mean_hat / (var_hat^(1/2) + epsilon) + wd * weight32;
          else
               g = mean / (var_data^(1/2) + epsilon) + wd * weight32;
          \end{gather*}
</code></pre>

<p>Defined in src/operator/optimizer_op.cc:L1024</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>weight::NDArray-or-SymbolicNode</code>: Weight</li>
<li><code>grad::NDArray-or-SymbolicNode</code>: Gradient</li>
<li><code>mean::NDArray-or-SymbolicNode</code>: Moving mean</li>
<li><code>var::NDArray-or-SymbolicNode</code>: Moving variance</li>
<li><code>weight32::NDArray-or-SymbolicNode</code>: Weight32</li>
<li><code>beta1::float, optional, default=0.899999976</code>: The decay rate for the 1st moment estimates.</li>
<li><code>beta2::float, optional, default=0.999000013</code>: The decay rate for the 2nd moment estimates.</li>
<li><code>epsilon::float, optional, default=9.99999997e-07</code>: A small constant for numerical stability.</li>
<li><code>t::int, required</code>: Index update count.</li>
<li><code>bias_correction::boolean, optional, default=1</code>: Whether to use bias correction.</li>
<li><code>wd::float, required</code>: Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</li>
<li><code>rescale_grad::float, optional, default=1</code>: Rescale gradient to grad = rescale_grad*grad.</li>
<li><code>clip_gradient::float, optional, default=-1</code>: Clip gradient to the range of [-clip<em>gradient, clip</em>gradient] If clip<em>gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip</em>gradient), -clip_gradient).</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L400' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.mp_lamb_update_phase2-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.mp_lamb_update_phase2-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.mp_lamb_update_phase2</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">mp_lamb_update_phase2(weight, g, r1, r2, weight32, lr, lower_bound, upper_bound)
</code></pre>

<p>Mixed Precision version Phase II of lamb update  it performs the following operations and updates grad.</p>
<pre><code>      Link to paper: https://arxiv.org/pdf/1904.00962.pdf

      .. math::
          \begin{gather*}
          if (lower_bound &gt;= 0)
          then
               r1 = max(r1, lower_bound)
          if (upper_bound &gt;= 0)
          then
               r1 = max(r1, upper_bound)

          if (r1 == 0 or r2 == 0)
          then
               lr = lr
          else
               lr = lr * (r1/r2)
          weight32 = weight32 - lr * g
          weight(float16) = weight32
          \end{gather*}
</code></pre>

<p>Defined in src/operator/optimizer_op.cc:L1066</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>weight::NDArray-or-SymbolicNode</code>: Weight</li>
<li><code>g::NDArray-or-SymbolicNode</code>: Output of mp<em>lamb</em>update_phase 1</li>
<li><code>r1::NDArray-or-SymbolicNode</code>: r1</li>
<li><code>r2::NDArray-or-SymbolicNode</code>: r2</li>
<li><code>weight32::NDArray-or-SymbolicNode</code>: Weight32</li>
<li><code>lr::float, required</code>: Learning rate</li>
<li><code>lower_bound::float, optional, default=-1</code>: Lower limit of norm of weight. If lower_bound &lt;= 0, Lower limit is not set</li>
<li><code>upper_bound::float, optional, default=-1</code>: Upper limit of norm of weight. If upper_bound &lt;= 0, Upper limit is not set</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L386' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.mp_nag_mom_update-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.mp_nag_mom_update-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.mp_nag_mom_update</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">mp_nag_mom_update(weight, grad, mom, weight32, lr, momentum, wd, rescale_grad, clip_gradient)
</code></pre>

<p>Update function for multi-precision Nesterov Accelerated Gradient( NAG) optimizer.</p>
<p>Defined in src/operator/optimizer_op.cc:L736</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>weight::NDArray-or-SymbolicNode</code>: Weight</li>
<li><code>grad::NDArray-or-SymbolicNode</code>: Gradient</li>
<li><code>mom::NDArray-or-SymbolicNode</code>: Momentum</li>
<li><code>weight32::NDArray-or-SymbolicNode</code>: Weight32</li>
<li><code>lr::float, required</code>: Learning rate</li>
<li><code>momentum::float, optional, default=0</code>: The decay rate of momentum estimates at each epoch.</li>
<li><code>wd::float, optional, default=0</code>: Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</li>
<li><code>rescale_grad::float, optional, default=1</code>: Rescale gradient to grad = rescale_grad*grad.</li>
<li><code>clip_gradient::float, optional, default=-1</code>: Clip gradient to the range of [-clip<em>gradient, clip</em>gradient] If clip<em>gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip</em>gradient), -clip_gradient).</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L366' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.mp_sgd_mom_update-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.mp_sgd_mom_update-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.mp_sgd_mom_update</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">mp_sgd_mom_update(weight, grad, mom, weight32, lr, momentum, wd, rescale_grad, clip_gradient, lazy_update)
</code></pre>

<p>Updater function for multi-precision sgd optimizer</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>weight::NDArray-or-SymbolicNode</code>: Weight</li>
<li><code>grad::NDArray-or-SymbolicNode</code>: Gradient</li>
<li><code>mom::NDArray-or-SymbolicNode</code>: Momentum</li>
<li><code>weight32::NDArray-or-SymbolicNode</code>: Weight32</li>
<li><code>lr::float, required</code>: Learning rate</li>
<li><code>momentum::float, optional, default=0</code>: The decay rate of momentum estimates at each epoch.</li>
<li><code>wd::float, optional, default=0</code>: Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</li>
<li><code>rescale_grad::float, optional, default=1</code>: Rescale gradient to grad = rescale_grad*grad.</li>
<li><code>clip_gradient::float, optional, default=-1</code>: Clip gradient to the range of [-clip<em>gradient, clip</em>gradient] If clip<em>gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip</em>gradient), -clip_gradient).</li>
<li><code>lazy_update::boolean, optional, default=1</code>: If true, lazy updates are applied if gradient's stype is row_sparse and both weight and momentum have the same stype</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L365' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.mp_sgd_update-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.mp_sgd_update-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.mp_sgd_update</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">mp_sgd_update(weight, grad, weight32, lr, wd, rescale_grad, clip_gradient, lazy_update)
</code></pre>

<p>Updater function for multi-precision sgd optimizer</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>weight::NDArray-or-SymbolicNode</code>: Weight</li>
<li><code>grad::NDArray-or-SymbolicNode</code>: gradient</li>
<li><code>weight32::NDArray-or-SymbolicNode</code>: Weight32</li>
<li><code>lr::float, required</code>: Learning rate</li>
<li><code>wd::float, optional, default=0</code>: Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</li>
<li><code>rescale_grad::float, optional, default=1</code>: Rescale gradient to grad = rescale_grad*grad.</li>
<li><code>clip_gradient::float, optional, default=-1</code>: Clip gradient to the range of [-clip<em>gradient, clip</em>gradient] If clip<em>gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip</em>gradient), -clip_gradient).</li>
<li><code>lazy_update::boolean, optional, default=1</code>: If true, lazy updates are applied if gradient's stype is row_sparse.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L361' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.multi_all_finite-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.multi_all_finite-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.multi_all_finite</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">multi_all_finite(data, num_arrays, init_output)
</code></pre>

<p>Check if all the float numbers in all the arrays are finite (used for AMP)</p>
<p>Defined in src/operator/contrib/all_finite.cc:L133</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode[]</code>: Arrays</li>
<li><code>num_arrays::int, optional, default='1'</code>: Number of arrays.</li>
<li><code>init_output::boolean, optional, default=1</code>: Initialize output to 1.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L354' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.multi_lars-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.multi_lars-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.multi_lars</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">multi_lars(lrs, weights_sum_sq, grads_sum_sq, wds, eta, eps, rescale_grad)
</code></pre>

<p>Compute the LARS coefficients of multiple weights and grads from their sums of square"</p>
<p>Defined in src/operator/contrib/multi_lars.cc:L37</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lrs::NDArray-or-SymbolicNode</code>: Learning rates to scale by LARS coefficient</li>
<li><code>weights_sum_sq::NDArray-or-SymbolicNode</code>: sum of square of weights arrays</li>
<li><code>grads_sum_sq::NDArray-or-SymbolicNode</code>: sum of square of gradients arrays</li>
<li><code>wds::NDArray-or-SymbolicNode</code>: weight decays</li>
<li><code>eta::float, required</code>: LARS eta</li>
<li><code>eps::float, required</code>: LARS eps</li>
<li><code>rescale_grad::float, optional, default=1</code>: Gradient rescaling factor</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L362' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.multi_mp_sgd_mom_update-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.multi_mp_sgd_mom_update-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.multi_mp_sgd_mom_update</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">multi_mp_sgd_mom_update(data, lrs, wds, momentum, rescale_grad, clip_gradient, num_weights)
</code></pre>

<p>Momentum update function for multi-precision Stochastic Gradient Descent (SGD) optimizer.</p>
<p>Momentum update has better convergence rates on neural networks. Mathematically it looks like below:</p>
<p>.. math::</p>
<p>v<em>1 = \alpha * \nabla J(W</em>0)\
  v<em t-1="t-1">t = \gamma v</em> - \alpha * \nabla J(W<em>{t-1})\
  W</em>t = W<em>{t-1} + v</em>t</p>
<p>It updates the weights using::</p>
<p>v = momentum * v - learning_rate * gradient   weight += v</p>
<p>Where the parameter $momentum$ is the decay rate of momentum estimates at each epoch.</p>
<p>Defined in src/operator/optimizer_op.cc:L463</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode[]</code>: Weights</li>
<li><code>lrs::tuple of &lt;float&gt;, required</code>: Learning rates.</li>
<li><code>wds::tuple of &lt;float&gt;, required</code>: Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</li>
<li><code>momentum::float, optional, default=0</code>: The decay rate of momentum estimates at each epoch.</li>
<li><code>rescale_grad::float, optional, default=1</code>: Rescale gradient to grad = rescale_grad*grad.</li>
<li><code>clip_gradient::float, optional, default=-1</code>: Clip gradient to the range of [-clip<em>gradient, clip</em>gradient] If clip<em>gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip</em>gradient), -clip_gradient).</li>
<li><code>num_weights::int, optional, default='1'</code>: Number of updated weights.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L379' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.multi_mp_sgd_update-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.multi_mp_sgd_update-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.multi_mp_sgd_update</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">multi_mp_sgd_update(data, lrs, wds, rescale_grad, clip_gradient, num_weights)
</code></pre>

<p>Update function for multi-precision Stochastic Gradient Descent (SDG) optimizer.</p>
<p>It updates the weights using::</p>
<p>weight = weight - learning_rate * (gradient + wd * weight)</p>
<p>Defined in src/operator/optimizer_op.cc:L408</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode[]</code>: Weights</li>
<li><code>lrs::tuple of &lt;float&gt;, required</code>: Learning rates.</li>
<li><code>wds::tuple of &lt;float&gt;, required</code>: Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</li>
<li><code>rescale_grad::float, optional, default=1</code>: Rescale gradient to grad = rescale_grad*grad.</li>
<li><code>clip_gradient::float, optional, default=-1</code>: Clip gradient to the range of [-clip<em>gradient, clip</em>gradient] If clip<em>gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip</em>gradient), -clip_gradient).</li>
<li><code>num_weights::int, optional, default='1'</code>: Number of updated weights.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L365' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.multi_sgd_mom_update-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.multi_sgd_mom_update-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.multi_sgd_mom_update</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">multi_sgd_mom_update(data, lrs, wds, momentum, rescale_grad, clip_gradient, num_weights)
</code></pre>

<p>Momentum update function for Stochastic Gradient Descent (SGD) optimizer.</p>
<p>Momentum update has better convergence rates on neural networks. Mathematically it looks like below:</p>
<p>.. math::</p>
<p>v<em>1 = \alpha * \nabla J(W</em>0)\
  v<em t-1="t-1">t = \gamma v</em> - \alpha * \nabla J(W<em>{t-1})\
  W</em>t = W<em>{t-1} + v</em>t</p>
<p>It updates the weights using::</p>
<p>v = momentum * v - learning_rate * gradient   weight += v</p>
<p>Where the parameter $momentum$ is the decay rate of momentum estimates at each epoch.</p>
<p>Defined in src/operator/optimizer_op.cc:L365</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode[]</code>: Weights, gradients and momentum</li>
<li><code>lrs::tuple of &lt;float&gt;, required</code>: Learning rates.</li>
<li><code>wds::tuple of &lt;float&gt;, required</code>: Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</li>
<li><code>momentum::float, optional, default=0</code>: The decay rate of momentum estimates at each epoch.</li>
<li><code>rescale_grad::float, optional, default=1</code>: Rescale gradient to grad = rescale_grad*grad.</li>
<li><code>clip_gradient::float, optional, default=-1</code>: Clip gradient to the range of [-clip<em>gradient, clip</em>gradient] If clip<em>gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip</em>gradient), -clip_gradient).</li>
<li><code>num_weights::int, optional, default='1'</code>: Number of updated weights.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L379' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.multi_sgd_update-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.multi_sgd_update-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.multi_sgd_update</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">multi_sgd_update(data, lrs, wds, rescale_grad, clip_gradient, num_weights)
</code></pre>

<p>Update function for Stochastic Gradient Descent (SDG) optimizer.</p>
<p>It updates the weights using::</p>
<p>weight = weight - learning_rate * (gradient + wd * weight)</p>
<p>Defined in src/operator/optimizer_op.cc:L320</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode[]</code>: Weights</li>
<li><code>lrs::tuple of &lt;float&gt;, required</code>: Learning rates.</li>
<li><code>wds::tuple of &lt;float&gt;, required</code>: Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</li>
<li><code>rescale_grad::float, optional, default=1</code>: Rescale gradient to grad = rescale_grad*grad.</li>
<li><code>clip_gradient::float, optional, default=-1</code>: Clip gradient to the range of [-clip<em>gradient, clip</em>gradient] If clip<em>gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip</em>gradient), -clip_gradient).</li>
<li><code>num_weights::int, optional, default='1'</code>: Number of updated weights.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L365' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.multi_sum_sq-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.multi_sum_sq-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.multi_sum_sq</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">multi_sum_sq(data, num_arrays)
</code></pre>

<p>Compute the sums of squares of multiple arrays</p>
<p>Defined in src/operator/contrib/multi<em>sum</em>sq.cc:L36</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode[]</code>: Arrays</li>
<li><code>num_arrays::int, required</code>: number of input arrays.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L352' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.nag_mom_update-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.nag_mom_update-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.nag_mom_update</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">nag_mom_update(weight, grad, mom, lr, momentum, wd, rescale_grad, clip_gradient)
</code></pre>

<p>Update function for Nesterov Accelerated Gradient( NAG) optimizer. It updates the weights using the following formula,</p>
<p>.. math::   v<em t-1="t-1">t = \gamma v</em> + \eta * \nabla J(W<em t-1="t-1">{t-1} - \gamma v</em>)\
  W<em t-1="t-1">t = W</em> - v_t</p>
<p>Where  :math:<code>\eta</code> is the learning rate of the optimizer :math:<code>\gamma</code> is the decay rate of the momentum estimate :math:<code>\v_t</code> is the update vector at time step <code>t</code> :math:<code>\W_t</code> is the weight vector at time step <code>t</code></p>
<p>Defined in src/operator/optimizer_op.cc:L717</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>weight::NDArray-or-SymbolicNode</code>: Weight</li>
<li><code>grad::NDArray-or-SymbolicNode</code>: Gradient</li>
<li><code>mom::NDArray-or-SymbolicNode</code>: Momentum</li>
<li><code>lr::float, required</code>: Learning rate</li>
<li><code>momentum::float, optional, default=0</code>: The decay rate of momentum estimates at each epoch.</li>
<li><code>wd::float, optional, default=0</code>: Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</li>
<li><code>rescale_grad::float, optional, default=1</code>: Rescale gradient to grad = rescale_grad*grad.</li>
<li><code>clip_gradient::float, optional, default=-1</code>: Clip gradient to the range of [-clip<em>gradient, clip</em>gradient] If clip<em>gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip</em>gradient), -clip_gradient).</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L376' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.nanprod-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.nanprod-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.nanprod</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">nanprod(data, axis, keepdims, exclude)
</code></pre>

<p>Computes the product of array elements over given axes treating Not a Numbers ($NaN$) as one.</p>
<p>Defined in src/operator/tensor/broadcast<em>reduce</em>prod_value.cc:L47</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input</li>
<li>
<p><code>axis::Shape or None, optional, default=None</code>: The axis or axes along which to perform the reduction.</p>
<p><code>``
The default,</code>axis=()<code>, will compute over all elements into a
scalar array with shape</code>(1,)`.</p>
<p>If <code>axis</code> is int, a reduction is performed on a particular axis.</p>
<p>If <code>axis</code> is a tuple of ints, a reduction is performed on all the axes
specified in the tuple.</p>
<p>If <code>exclude</code> is true, reduction will be performed on the axes that are
NOT in axis instead.</p>
<p>Negative values means indexing from right to left.
<code>``
  *</code>keepdims::boolean, optional, default=0<code>: If this is set to</code>True<code>, the reduced axes are left in the result as dimension with size one.
  *</code>exclude::boolean, optional, default=0<code>: Whether to perform reduction on axis that are NOT in axis instead.
  *</code>name::Symbol<code>: The name of the</code>SymbolicNode<code>. (e.g.</code>:my_symbol<code>), optional.
  *</code>attrs::Dict{Symbol,String}<code>: The attributes associated with this</code>SymbolicNode`.</p>
</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L370' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.nansum-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.nansum-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.nansum</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">nansum(data, axis, keepdims, exclude)
</code></pre>

<p>Computes the sum of array elements over given axes treating Not a Numbers ($NaN$) as zero.</p>
<p>Defined in src/operator/tensor/broadcast<em>reduce</em>sum_value.cc:L102</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input</li>
<li>
<p><code>axis::Shape or None, optional, default=None</code>: The axis or axes along which to perform the reduction.</p>
<p><code>``
The default,</code>axis=()<code>, will compute over all elements into a
scalar array with shape</code>(1,)`.</p>
<p>If <code>axis</code> is int, a reduction is performed on a particular axis.</p>
<p>If <code>axis</code> is a tuple of ints, a reduction is performed on all the axes
specified in the tuple.</p>
<p>If <code>exclude</code> is true, reduction will be performed on the axes that are
NOT in axis instead.</p>
<p>Negative values means indexing from right to left.
<code>``
  *</code>keepdims::boolean, optional, default=0<code>: If this is set to</code>True<code>, the reduced axes are left in the result as dimension with size one.
  *</code>exclude::boolean, optional, default=0<code>: Whether to perform reduction on axis that are NOT in axis instead.
  *</code>name::Symbol<code>: The name of the</code>SymbolicNode<code>. (e.g.</code>:my_symbol<code>), optional.
  *</code>attrs::Dict{Symbol,String}<code>: The attributes associated with this</code>SymbolicNode`.</p>
</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L370' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.negative-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.negative-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.negative</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">negative(data)
</code></pre>

<p>Numerical negative of the argument, element-wise.</p>
<p>The storage type of $negative$ output depends upon the input storage type:</p>
<ul>
<li>negative(default) = default</li>
<li>negative(row<em>sparse) = row</em>sparse</li>
<li>negative(csr) = csr</li>
</ul>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L355' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.normal-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.normal-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.normal</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">normal(loc, scale, shape, ctx, dtype)
</code></pre>

<p>normal is an alias of <em>random</em>normal.</p>
<p>Draw random samples from a normal (Gaussian) distribution.</p>
<p>.. note:: The existing alias $normal$ is deprecated.</p>
<p>Samples are distributed according to a normal distribution parametrized by <em>loc</em> (mean) and <em>scale</em> (standard deviation).</p>
<p>Example::</p>
<p>normal(loc=0, scale=1, shape=(2,2)) = [[ 1.89171135, -1.16881478],                                           [-1.23474145,  1.55807114]]</p>
<p>Defined in src/operator/random/sample_op.cc:L113</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>loc::float, optional, default=0</code>: Mean of the distribution.</li>
<li><code>scale::float, optional, default=1</code>: Standard deviation of the distribution.</li>
<li><code>shape::Shape(tuple), optional, default=None</code>: Shape of the output.</li>
<li><code>ctx::string, optional, default=''</code>: Context of output, in format <a href="n">cpu|gpu|cpu_pinned</a>. Only used for imperative calls.</li>
<li><code>dtype::{'None', 'float16', 'float32', 'float64'},optional, default='None'</code>: DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L370' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.one_hot-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.one_hot-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.one_hot</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">one_hot(indices, depth, on_value, off_value, dtype)
</code></pre>

<p>Returns a one-hot array.</p>
<p>The locations represented by <code>indices</code> take value <code>on_value</code>, while all other locations take value <code>off_value</code>.</p>
<p><code>one_hot</code> operation with <code>indices</code> of shape $(i0, i1)$ and <code>depth</code>  of $d$ would result in an output array of shape $(i0, i1, d)$ with::</p>
<p>output[i,j,:] = off<em>value   output[i,j,indices[i,j]] = on</em>value</p>
<p>Examples::</p>
<p>one_hot([1,0,2,0], 3) = [[ 0.  1.  0.]                            [ 1.  0.  0.]                            [ 0.  0.  1.]                            [ 1.  0.  0.]]</p>
<p>one<em>hot([1,0,2,0], 3, on</em>value=8, off_value=1,           dtype='int32') = [[1 8 1]                             [8 1 1]                             [1 1 8]                             [8 1 1]]</p>
<p>one_hot([[1,0],[1,0],[2,0]], 3) = [[[ 0.  1.  0.]                                       [ 1.  0.  0.]]</p>
<pre><code>                                 [[ 0.  1.  0.]
                                  [ 1.  0.  0.]]

                                 [[ 0.  0.  1.]
                                  [ 1.  0.  0.]]]
</code></pre>

<p>Defined in src/operator/tensor/indexing_op.cc:L888</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>indices::NDArray-or-SymbolicNode</code>: array of locations where to set on_value</li>
<li><code>depth::int, required</code>: Depth of the one hot dimension.</li>
<li><code>on_value::double, optional, default=1</code>: The value assigned to the locations represented by indices.</li>
<li><code>off_value::double, optional, default=0</code>: The value assigned to the locations not represented by indices.</li>
<li><code>dtype::{'bfloat16', 'float16', 'float32', 'float64', 'int32', 'int64', 'int8', 'uint8'},optional, default='float32'</code>: DType of the output</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L389' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.ones_like-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.ones_like-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.ones_like</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">ones_like(data)
</code></pre>

<p>Return an array of ones with the same shape and type as the input array.</p>
<p>Examples::</p>
<p>x = [[ 0.,  0.,  0.],        [ 0.,  0.,  0.]]</p>
<p>ones_like(x) = [[ 1.,  1.,  1.],                   [ 1.,  1.,  1.]]</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L358' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.pad-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.pad-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.pad</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">pad(data, mode, pad_width, constant_value)
</code></pre>

<p>pad is an alias of Pad.</p>
<p>Pads an input array with a constant or edge values of the array.</p>
<p>.. note:: <code>Pad</code> is deprecated. Use <code>pad</code> instead.</p>
<p>.. note:: Current implementation only supports 4D and 5D input arrays with padding applied    only on axes 1, 2 and 3. Expects axes 4 and 5 in <code>pad_width</code> to be zero.</p>
<p>This operation pads an input array with either a <code>constant_value</code> or edge values along each axis of the input array. The amount of padding is specified by <code>pad_width</code>.</p>
<p><code>pad_width</code> is a tuple of integer padding widths for each axis of the format $(before_1, after_1, ... , before_N, after_N)$. The <code>pad_width</code> should be of length $2*N$ where $N$ is the number of dimensions of the array.</p>
<p>For dimension $N$ of the input array, $before_N$ and $after_N$ indicates how many values to add before and after the elements of the array along dimension $N$. The widths of the higher two dimensions $before_1$, $after_1$, $before_2$, $after_2$ must be 0.</p>
<p>Example::</p>
<p>x = [[[[  1.   2.   3.]           [  4.   5.   6.]]</p>
<pre><code>     [[  7.   8.   9.]
      [ 10.  11.  12.]]]


    [[[ 11.  12.  13.]
      [ 14.  15.  16.]]

     [[ 17.  18.  19.]
      [ 20.  21.  22.]]]]
</code></pre>

<p>pad(x,mode="edge", pad_width=(0,0,0,0,1,1,1,1)) =</p>
<pre><code>     [[[[  1.   1.   2.   3.   3.]
        [  1.   1.   2.   3.   3.]
        [  4.   4.   5.   6.   6.]
        [  4.   4.   5.   6.   6.]]

       [[  7.   7.   8.   9.   9.]
        [  7.   7.   8.   9.   9.]
        [ 10.  10.  11.  12.  12.]
        [ 10.  10.  11.  12.  12.]]]


      [[[ 11.  11.  12.  13.  13.]
        [ 11.  11.  12.  13.  13.]
        [ 14.  14.  15.  16.  16.]
        [ 14.  14.  15.  16.  16.]]

       [[ 17.  17.  18.  19.  19.]
        [ 17.  17.  18.  19.  19.]
        [ 20.  20.  21.  22.  22.]
        [ 20.  20.  21.  22.  22.]]]]
</code></pre>

<p>pad(x, mode="constant", constant<em>value=0, pad</em>width=(0,0,0,0,1,1,1,1)) =</p>
<pre><code>     [[[[  0.   0.   0.   0.   0.]
        [  0.   1.   2.   3.   0.]
        [  0.   4.   5.   6.   0.]
        [  0.   0.   0.   0.   0.]]

       [[  0.   0.   0.   0.   0.]
        [  0.   7.   8.   9.   0.]
        [  0.  10.  11.  12.   0.]
        [  0.   0.   0.   0.   0.]]]


      [[[  0.   0.   0.   0.   0.]
        [  0.  11.  12.  13.   0.]
        [  0.  14.  15.  16.   0.]
        [  0.   0.   0.   0.   0.]]

       [[  0.   0.   0.   0.   0.]
        [  0.  17.  18.  19.   0.]
        [  0.  20.  21.  22.   0.]
        [  0.   0.   0.   0.   0.]]]]
</code></pre>

<p>Defined in src/operator/pad.cc:L766</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: An n-dimensional input array.</li>
<li><code>mode::{'constant', 'edge', 'reflect'}, required</code>: Padding type to use. "constant" pads with <code>constant_value</code> "edge" pads using the edge values of the input array "reflect" pads by reflecting values with respect to the edges.</li>
<li><code>pad_width::Shape(tuple), required</code>: Widths of the padding regions applied to the edges of each axis. It is a tuple of integer padding widths for each axis of the format $(before_1, after_1, ... , before_N, after_N)$. It should be of length $2*N$ where $N$ is the number of dimensions of the array.This is equivalent to pad_width in numpy.pad, but flattened.</li>
<li><code>constant_value::double, optional, default=0</code>: The value used for padding when <code>mode</code> is "constant".</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L438' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.pick-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.pick-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.pick</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">pick(data, index, axis, keepdims, mode)
</code></pre>

<p>Picks elements from an input array according to the input indices along the given axis.</p>
<p>Given an input array of shape $(d0, d1)$ and indices of shape $(i0,)$, the result will be an output array of shape $(i0,)$ with::</p>
<p>output[i] = input[i, indices[i]]</p>
<p>By default, if any index mentioned is too large, it is replaced by the index that addresses the last element along an axis (the <code>clip</code> mode).</p>
<p>This function supports n-dimensional input and (n-1)-dimensional indices arrays.</p>
<p>Examples::</p>
<p>x = [[ 1.,  2.],        [ 3.,  4.],        [ 5.,  6.]]</p>
<p>// picks elements with specified indices along axis 0   pick(x, y=[0,1], 0) = [ 1.,  4.]</p>
<p>// picks elements with specified indices along axis 1   pick(x, y=[0,1,0], 1) = [ 1.,  4.,  5.]</p>
<p>// picks elements with specified indices along axis 1 using 'wrap' mode   // to place indicies that would normally be out of bounds   pick(x, y=[2,-1,-2], 1, mode='wrap') = [ 1.,  4.,  5.]</p>
<p>y = [[ 1.],        [ 0.],        [ 2.]]</p>
<p>// picks elements with specified indices along axis 1 and dims are maintained   pick(x, y, 1, keepdims=True) = [[ 2.],                                  [ 3.],                                  [ 6.]]</p>
<p>Defined in src/operator/tensor/broadcast<em>reduce</em>op_index.cc:L151</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array</li>
<li><code>index::NDArray-or-SymbolicNode</code>: The index array</li>
<li><code>axis::int or None, optional, default='-1'</code>: int or None. The axis to picking the elements. Negative values means indexing from right to left. If is <code>None</code>, the elements in the index w.r.t the flattened input will be picked.</li>
<li><code>keepdims::boolean, optional, default=0</code>: If true, the axis where we pick the elements is left in the result as dimension with size one.</li>
<li><code>mode::{'clip', 'wrap'},optional, default='clip'</code>: Specify how out-of-bound indices behave. Default is "clip". "clip" means clip to the range. So, if all indices mentioned are too large, they are replaced by the index that addresses the last element along an axis.  "wrap" means to wrap around.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L394' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.preloaded_multi_mp_sgd_mom_update-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.preloaded_multi_mp_sgd_mom_update-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.preloaded_multi_mp_sgd_mom_update</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">preloaded_multi_mp_sgd_mom_update(data, momentum, rescale_grad, clip_gradient, num_weights)
</code></pre>

<p>Momentum update function for multi-precision Stochastic Gradient Descent (SGD) optimizer.</p>
<p>Momentum update has better convergence rates on neural networks. Mathematically it looks like below:</p>
<p>.. math::</p>
<p>v<em>1 = \alpha * \nabla J(W</em>0)\
  v<em t-1="t-1">t = \gamma v</em> - \alpha * \nabla J(W<em>{t-1})\
  W</em>t = W<em>{t-1} + v</em>t</p>
<p>It updates the weights using::</p>
<p>v = momentum * v - learning_rate * gradient   weight += v</p>
<p>Where the parameter $momentum$ is the decay rate of momentum estimates at each epoch.</p>
<p>Defined in src/operator/contrib/preloaded<em>multi</em>sgd.cc:L200</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode[]</code>: Weights, gradients, momentums, learning rates and weight decays</li>
<li><code>momentum::float, optional, default=0</code>: The decay rate of momentum estimates at each epoch.</li>
<li><code>rescale_grad::float, optional, default=1</code>: Rescale gradient to grad = rescale_grad*grad.</li>
<li><code>clip_gradient::float, optional, default=-1</code>: Clip gradient to the range of [-clip<em>gradient, clip</em>gradient] If clip<em>gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip</em>gradient), -clip_gradient).</li>
<li><code>num_weights::int, optional, default='1'</code>: Number of updated weights.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L375' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.preloaded_multi_mp_sgd_update-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.preloaded_multi_mp_sgd_update-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.preloaded_multi_mp_sgd_update</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">preloaded_multi_mp_sgd_update(data, rescale_grad, clip_gradient, num_weights)
</code></pre>

<p>Update function for multi-precision Stochastic Gradient Descent (SDG) optimizer.</p>
<p>It updates the weights using::</p>
<p>weight = weight - learning_rate * (gradient + wd * weight)</p>
<p>Defined in src/operator/contrib/preloaded<em>multi</em>sgd.cc:L140</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode[]</code>: Weights, gradients, learning rates and weight decays</li>
<li><code>rescale_grad::float, optional, default=1</code>: Rescale gradient to grad = rescale_grad*grad.</li>
<li><code>clip_gradient::float, optional, default=-1</code>: Clip gradient to the range of [-clip<em>gradient, clip</em>gradient] If clip<em>gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip</em>gradient), -clip_gradient).</li>
<li><code>num_weights::int, optional, default='1'</code>: Number of updated weights.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L361' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.preloaded_multi_sgd_mom_update-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.preloaded_multi_sgd_mom_update-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.preloaded_multi_sgd_mom_update</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">preloaded_multi_sgd_mom_update(data, momentum, rescale_grad, clip_gradient, num_weights)
</code></pre>

<p>Momentum update function for Stochastic Gradient Descent (SGD) optimizer.</p>
<p>Momentum update has better convergence rates on neural networks. Mathematically it looks like below:</p>
<p>.. math::</p>
<p>v<em>1 = \alpha * \nabla J(W</em>0)\
  v<em t-1="t-1">t = \gamma v</em> - \alpha * \nabla J(W<em>{t-1})\
  W</em>t = W<em>{t-1} + v</em>t</p>
<p>It updates the weights using::</p>
<p>v = momentum * v - learning_rate * gradient   weight += v</p>
<p>Where the parameter $momentum$ is the decay rate of momentum estimates at each epoch.</p>
<p>Defined in src/operator/contrib/preloaded<em>multi</em>sgd.cc:L91</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode[]</code>: Weights, gradients, momentum, learning rates and weight decays</li>
<li><code>momentum::float, optional, default=0</code>: The decay rate of momentum estimates at each epoch.</li>
<li><code>rescale_grad::float, optional, default=1</code>: Rescale gradient to grad = rescale_grad*grad.</li>
<li><code>clip_gradient::float, optional, default=-1</code>: Clip gradient to the range of [-clip<em>gradient, clip</em>gradient] If clip<em>gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip</em>gradient), -clip_gradient).</li>
<li><code>num_weights::int, optional, default='1'</code>: Number of updated weights.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L375' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.preloaded_multi_sgd_update-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.preloaded_multi_sgd_update-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.preloaded_multi_sgd_update</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">preloaded_multi_sgd_update(data, rescale_grad, clip_gradient, num_weights)
</code></pre>

<p>Update function for Stochastic Gradient Descent (SDG) optimizer.</p>
<p>It updates the weights using::</p>
<p>weight = weight - learning_rate * (gradient + wd * weight)</p>
<p>Defined in src/operator/contrib/preloaded<em>multi</em>sgd.cc:L42</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode[]</code>: Weights, gradients, learning rates and weight decays</li>
<li><code>rescale_grad::float, optional, default=1</code>: Rescale gradient to grad = rescale_grad*grad.</li>
<li><code>clip_gradient::float, optional, default=-1</code>: Clip gradient to the range of [-clip<em>gradient, clip</em>gradient] If clip<em>gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip</em>gradient), -clip_gradient).</li>
<li><code>num_weights::int, optional, default='1'</code>: Number of updated weights.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L361' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.radians-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.radians-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.radians</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">radians(data)
</code></pre>

<p>Converts each element of the input array from degrees to radians.</p>
<p>.. math::    radians([0, 90, 180, 270, 360]) = [0, \pi/2, \pi, 3\pi/2, 2\pi]</p>
<p>The storage type of $radians$ output depends upon the input storage type:</p>
<ul>
<li>radians(default) = default</li>
<li>radians(row<em>sparse) = row</em>sparse</li>
<li>radians(csr) = csr</li>
</ul>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_trig.cc:L351</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L360' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.random_exponential-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.random_exponential-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.random_exponential</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">random_exponential(lam, shape, ctx, dtype)
</code></pre>

<p>random<em>exponential is an alias of _random</em>exponential.</p>
<p>Draw random samples from an exponential distribution.</p>
<p>Samples are distributed according to an exponential distribution parametrized by <em>lambda</em> (rate).</p>
<p>Example::</p>
<p>exponential(lam=4, shape=(2,2)) = [[ 0.0097189 ,  0.08999364],                                       [ 0.04146638,  0.31715935]]</p>
<p>Defined in src/operator/random/sample_op.cc:L137</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lam::float, optional, default=1</code>: Lambda parameter (rate) of the exponential distribution.</li>
<li><code>shape::Shape(tuple), optional, default=None</code>: Shape of the output.</li>
<li><code>ctx::string, optional, default=''</code>: Context of output, in format <a href="n">cpu|gpu|cpu_pinned</a>. Only used for imperative calls.</li>
<li><code>dtype::{'None', 'float16', 'float32', 'float64'},optional, default='None'</code>: DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L365' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.random_gamma-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.random_gamma-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.random_gamma</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">random_gamma(alpha, beta, shape, ctx, dtype)
</code></pre>

<p>random<em>gamma is an alias of _random</em>gamma.</p>
<p>Draw random samples from a gamma distribution.</p>
<p>Samples are distributed according to a gamma distribution parametrized by <em>alpha</em> (shape) and <em>beta</em> (scale).</p>
<p>Example::</p>
<p>gamma(alpha=9, beta=0.5, shape=(2,2)) = [[ 7.10486984,  3.37695289],                                             [ 3.91697288,  3.65933681]]</p>
<p>Defined in src/operator/random/sample_op.cc:L125</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>alpha::float, optional, default=1</code>: Alpha parameter (shape) of the gamma distribution.</li>
<li><code>beta::float, optional, default=1</code>: Beta parameter (scale) of the gamma distribution.</li>
<li><code>shape::Shape(tuple), optional, default=None</code>: Shape of the output.</li>
<li><code>ctx::string, optional, default=''</code>: Context of output, in format <a href="n">cpu|gpu|cpu_pinned</a>. Only used for imperative calls.</li>
<li><code>dtype::{'None', 'float16', 'float32', 'float64'},optional, default='None'</code>: DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L367' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.random_generalized_negative_binomial-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.random_generalized_negative_binomial-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.random_generalized_negative_binomial</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">random_generalized_negative_binomial(mu, alpha, shape, ctx, dtype)
</code></pre>

<p>random<em>generalized</em>negative<em>binomial is an alias of _random</em>generalized<em>negative</em>binomial.</p>
<p>Draw random samples from a generalized negative binomial distribution.</p>
<p>Samples are distributed according to a generalized negative binomial distribution parametrized by <em>mu</em> (mean) and <em>alpha</em> (dispersion). <em>alpha</em> is defined as <em>1/k</em> where <em>k</em> is the failure limit of the number of unsuccessful experiments (generalized to real numbers). Samples will always be returned as a floating point data type.</p>
<p>Example::</p>
<p>generalized<em>negative</em>binomial(mu=2.0, alpha=0.3, shape=(2,2)) = [[ 2.,  1.],                                                                     [ 6.,  4.]]</p>
<p>Defined in src/operator/random/sample_op.cc:L179</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>mu::float, optional, default=1</code>: Mean of the negative binomial distribution.</li>
<li><code>alpha::float, optional, default=1</code>: Alpha (dispersion) parameter of the negative binomial distribution.</li>
<li><code>shape::Shape(tuple), optional, default=None</code>: Shape of the output.</li>
<li><code>ctx::string, optional, default=''</code>: Context of output, in format <a href="n">cpu|gpu|cpu_pinned</a>. Only used for imperative calls.</li>
<li><code>dtype::{'None', 'float16', 'float32', 'float64'},optional, default='None'</code>: DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L370' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.random_negative_binomial-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.random_negative_binomial-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.random_negative_binomial</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">random_negative_binomial(k, p, shape, ctx, dtype)
</code></pre>

<p>random<em>negative</em>binomial is an alias of <em>random</em>negative_binomial.</p>
<p>Draw random samples from a negative binomial distribution.</p>
<p>Samples are distributed according to a negative binomial distribution parametrized by <em>k</em> (limit of unsuccessful experiments) and <em>p</em> (failure probability in each experiment). Samples will always be returned as a floating point data type.</p>
<p>Example::</p>
<p>negative_binomial(k=3, p=0.4, shape=(2,2)) = [[ 4.,  7.],                                                  [ 2.,  5.]]</p>
<p>Defined in src/operator/random/sample_op.cc:L164</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>k::int, optional, default='1'</code>: Limit of unsuccessful experiments.</li>
<li><code>p::float, optional, default=1</code>: Failure probability in each experiment.</li>
<li><code>shape::Shape(tuple), optional, default=None</code>: Shape of the output.</li>
<li><code>ctx::string, optional, default=''</code>: Context of output, in format <a href="n">cpu|gpu|cpu_pinned</a>. Only used for imperative calls.</li>
<li><code>dtype::{'None', 'float16', 'float32', 'float64'},optional, default='None'</code>: DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L369' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.random_normal-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.random_normal-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.random_normal</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">random_normal(loc, scale, shape, ctx, dtype)
</code></pre>

<p>random<em>normal is an alias of _random</em>normal.</p>
<p>Draw random samples from a normal (Gaussian) distribution.</p>
<p>.. note:: The existing alias $normal$ is deprecated.</p>
<p>Samples are distributed according to a normal distribution parametrized by <em>loc</em> (mean) and <em>scale</em> (standard deviation).</p>
<p>Example::</p>
<p>normal(loc=0, scale=1, shape=(2,2)) = [[ 1.89171135, -1.16881478],                                           [-1.23474145,  1.55807114]]</p>
<p>Defined in src/operator/random/sample_op.cc:L113</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>loc::float, optional, default=0</code>: Mean of the distribution.</li>
<li><code>scale::float, optional, default=1</code>: Standard deviation of the distribution.</li>
<li><code>shape::Shape(tuple), optional, default=None</code>: Shape of the output.</li>
<li><code>ctx::string, optional, default=''</code>: Context of output, in format <a href="n">cpu|gpu|cpu_pinned</a>. Only used for imperative calls.</li>
<li><code>dtype::{'None', 'float16', 'float32', 'float64'},optional, default='None'</code>: DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L370' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.random_pdf_dirichlet-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.random_pdf_dirichlet-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.random_pdf_dirichlet</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">random_pdf_dirichlet(sample, alpha, is_log)
</code></pre>

<p>random<em>pdf</em>dirichlet is an alias of <em>random</em>pdf_dirichlet.</p>
<p>Computes the value of the PDF of <em>sample</em> of Dirichlet distributions with parameter <em>alpha</em>.</p>
<p>The shape of <em>alpha</em> must match the leftmost subshape of <em>sample</em>.  That is, <em>sample</em> can have the same shape as <em>alpha</em>, in which case the output contains one density per distribution, or <em>sample</em> can be a tensor of tensors with that shape, in which case the output is a tensor of densities such that the densities at index <em>i</em> in the output are given by the samples at index <em>i</em> in <em>sample</em> parameterized by the value of <em>alpha</em> at index <em>i</em>.</p>
<p>Examples::</p>
<pre><code>random_pdf_dirichlet(sample=[[1,2],[2,3],[3,4]], alpha=[2.5, 2.5]) =
    [38.413498, 199.60245, 564.56085]

sample = [[[1, 2, 3], [10, 20, 30], [100, 200, 300]],
          [[0.1, 0.2, 0.3], [0.01, 0.02, 0.03], [0.001, 0.002, 0.003]]]

random_pdf_dirichlet(sample=sample, alpha=[0.1, 0.4, 0.9]) =
    [[2.3257459e-02, 5.8420084e-04, 1.4674458e-05],
     [9.2589635e-01, 3.6860607e+01, 1.4674468e+03]]
</code></pre>

<p>Defined in src/operator/random/pdf_op.cc:L316</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>sample::NDArray-or-SymbolicNode</code>: Samples from the distributions.</li>
<li><code>alpha::NDArray-or-SymbolicNode</code>: Concentration parameters of the distributions.</li>
<li><code>is_log::boolean, optional, default=0</code>: If set, compute the density of the log-probability instead of the probability.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L376' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.random_pdf_exponential-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.random_pdf_exponential-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.random_pdf_exponential</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">random_pdf_exponential(sample, lam, is_log)
</code></pre>

<p>random<em>pdf</em>exponential is an alias of <em>random</em>pdf_exponential.</p>
<p>Computes the value of the PDF of <em>sample</em> of exponential distributions with parameters <em>lam</em> (rate).</p>
<p>The shape of <em>lam</em> must match the leftmost subshape of <em>sample</em>.  That is, <em>sample</em> can have the same shape as <em>lam</em>, in which case the output contains one density per distribution, or <em>sample</em> can be a tensor of tensors with that shape, in which case the output is a tensor of densities such that the densities at index <em>i</em> in the output are given by the samples at index <em>i</em> in <em>sample</em> parameterized by the value of <em>lam</em> at index <em>i</em>.</p>
<p>Examples::</p>
<p>random<em>pdf</em>exponential(sample=[[1, 2, 3]], lam=[1]) =       [[0.36787945, 0.13533528, 0.04978707]]</p>
<p>sample = [[1,2,3],             [1,2,3],             [1,2,3]]</p>
<p>random<em>pdf</em>exponential(sample=sample, lam=[1,0.5,0.25]) =       [[0.36787945, 0.13533528, 0.04978707],        [0.30326533, 0.18393973, 0.11156508],        [0.1947002,  0.15163267, 0.11809164]]</p>
<p>Defined in src/operator/random/pdf_op.cc:L305</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>sample::NDArray-or-SymbolicNode</code>: Samples from the distributions.</li>
<li><code>lam::NDArray-or-SymbolicNode</code>: Lambda (rate) parameters of the distributions.</li>
<li><code>is_log::boolean, optional, default=0</code>: If set, compute the density of the log-probability instead of the probability.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L378' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.random_pdf_gamma-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.random_pdf_gamma-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.random_pdf_gamma</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">random_pdf_gamma(sample, alpha, is_log, beta)
</code></pre>

<p>random<em>pdf</em>gamma is an alias of <em>random</em>pdf_gamma.</p>
<p>Computes the value of the PDF of <em>sample</em> of gamma distributions with parameters <em>alpha</em> (shape) and <em>beta</em> (rate).</p>
<p><em>alpha</em> and <em>beta</em> must have the same shape, which must match the leftmost subshape of <em>sample</em>.  That is, <em>sample</em> can have the same shape as <em>alpha</em> and <em>beta</em>, in which case the output contains one density per distribution, or <em>sample</em> can be a tensor of tensors with that shape, in which case the output is a tensor of densities such that the densities at index <em>i</em> in the output are given by the samples at index <em>i</em> in <em>sample</em> parameterized by the values of <em>alpha</em> and <em>beta</em> at index <em>i</em>.</p>
<p>Examples::</p>
<p>random<em>pdf</em>gamma(sample=[[1,2,3,4,5]], alpha=[5], beta=[1]) =       [[0.01532831, 0.09022352, 0.16803136, 0.19536681, 0.17546739]]</p>
<p>sample = [[1, 2, 3, 4, 5],             [2, 3, 4, 5, 6],             [3, 4, 5, 6, 7]]</p>
<p>random<em>pdf</em>gamma(sample=sample, alpha=[5,6,7], beta=[1,1,1]) =       [[0.01532831, 0.09022352, 0.16803136, 0.19536681, 0.17546739],        [0.03608941, 0.10081882, 0.15629345, 0.17546739, 0.16062315],        [0.05040941, 0.10419563, 0.14622283, 0.16062315, 0.14900276]]</p>
<p>Defined in src/operator/random/pdf_op.cc:L303</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>sample::NDArray-or-SymbolicNode</code>: Samples from the distributions.</li>
<li><code>alpha::NDArray-or-SymbolicNode</code>: Alpha (shape) parameters of the distributions.</li>
<li><code>is_log::boolean, optional, default=0</code>: If set, compute the density of the log-probability instead of the probability.</li>
<li><code>beta::NDArray-or-SymbolicNode</code>: Beta (scale) parameters of the distributions.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L380' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.random_pdf_generalized_negative_binomial-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.random_pdf_generalized_negative_binomial-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.random_pdf_generalized_negative_binomial</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">random_pdf_generalized_negative_binomial(sample, mu, is_log, alpha)
</code></pre>

<p>random<em>pdf</em>generalized<em>negative</em>binomial is an alias of <em>random</em>pdf<em>generalized</em>negative_binomial.</p>
<p>Computes the value of the PDF of <em>sample</em> of generalized negative binomial distributions with parameters <em>mu</em> (mean) and <em>alpha</em> (dispersion).  This can be understood as a reparameterization of the negative binomial, where <em>k</em> = <em>1 / alpha</em> and <em>p</em> = <em>1 / (mu * alpha + 1)</em>.</p>
<p><em>mu</em> and <em>alpha</em> must have the same shape, which must match the leftmost subshape of <em>sample</em>.  That is, <em>sample</em> can have the same shape as <em>mu</em> and <em>alpha</em>, in which case the output contains one density per distribution, or <em>sample</em> can be a tensor of tensors with that shape, in which case the output is a tensor of densities such that the densities at index <em>i</em> in the output are given by the samples at index <em>i</em> in <em>sample</em> parameterized by the values of <em>mu</em> and <em>alpha</em> at index <em>i</em>.</p>
<p>Examples::</p>
<pre><code>random_pdf_generalized_negative_binomial(sample=[[1, 2, 3, 4]], alpha=[1], mu=[1]) =
    [[0.25, 0.125, 0.0625, 0.03125]]

sample = [[1,2,3,4],
          [1,2,3,4]]
random_pdf_generalized_negative_binomial(sample=sample, alpha=[1, 0.6666], mu=[1, 1.5]) =
    [[0.25,       0.125,      0.0625,     0.03125   ],
     [0.26517063, 0.16573331, 0.09667706, 0.05437994]]
</code></pre>

<p>Defined in src/operator/random/pdf_op.cc:L314</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>sample::NDArray-or-SymbolicNode</code>: Samples from the distributions.</li>
<li><code>mu::NDArray-or-SymbolicNode</code>: Means of the distributions.</li>
<li><code>is_log::boolean, optional, default=0</code>: If set, compute the density of the log-probability instead of the probability.</li>
<li><code>alpha::NDArray-or-SymbolicNode</code>: Alpha (dispersion) parameters of the distributions.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L379' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.random_pdf_negative_binomial-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.random_pdf_negative_binomial-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.random_pdf_negative_binomial</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">random_pdf_negative_binomial(sample, k, is_log, p)
</code></pre>

<p>random<em>pdf</em>negative<em>binomial is an alias of _random</em>pdf<em>negative</em>binomial.</p>
<p>Computes the value of the PDF of samples of negative binomial distributions with parameters <em>k</em> (failure limit) and <em>p</em> (failure probability).</p>
<p><em>k</em> and <em>p</em> must have the same shape, which must match the leftmost subshape of <em>sample</em>.  That is, <em>sample</em> can have the same shape as <em>k</em> and <em>p</em>, in which case the output contains one density per distribution, or <em>sample</em> can be a tensor of tensors with that shape, in which case the output is a tensor of densities such that the densities at index <em>i</em> in the output are given by the samples at index <em>i</em> in <em>sample</em> parameterized by the values of <em>k</em> and <em>p</em> at index <em>i</em>.</p>
<p>Examples::</p>
<pre><code>random_pdf_negative_binomial(sample=[[1,2,3,4]], k=[1], p=a[0.5]) =
    [[0.25, 0.125, 0.0625, 0.03125]]

# Note that k may be real-valued
sample = [[1,2,3,4],
          [1,2,3,4]]
random_pdf_negative_binomial(sample=sample, k=[1, 1.5], p=[0.5, 0.5]) =
    [[0.25,       0.125,      0.0625,     0.03125   ],
     [0.26516506, 0.16572815, 0.09667476, 0.05437956]]
</code></pre>

<p>Defined in src/operator/random/pdf_op.cc:L310</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>sample::NDArray-or-SymbolicNode</code>: Samples from the distributions.</li>
<li><code>k::NDArray-or-SymbolicNode</code>: Limits of unsuccessful experiments.</li>
<li><code>is_log::boolean, optional, default=0</code>: If set, compute the density of the log-probability instead of the probability.</li>
<li><code>p::NDArray-or-SymbolicNode</code>: Failure probabilities in each experiment.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L378' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.random_pdf_normal-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.random_pdf_normal-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.random_pdf_normal</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">random_pdf_normal(sample, mu, is_log, sigma)
</code></pre>

<p>random<em>pdf</em>normal is an alias of <em>random</em>pdf_normal.</p>
<p>Computes the value of the PDF of <em>sample</em> of normal distributions with parameters <em>mu</em> (mean) and <em>sigma</em> (standard deviation).</p>
<p><em>mu</em> and <em>sigma</em> must have the same shape, which must match the leftmost subshape of <em>sample</em>.  That is, <em>sample</em> can have the same shape as <em>mu</em> and <em>sigma</em>, in which case the output contains one density per distribution, or <em>sample</em> can be a tensor of tensors with that shape, in which case the output is a tensor of densities such that the densities at index <em>i</em> in the output are given by the samples at index <em>i</em> in <em>sample</em> parameterized by the values of <em>mu</em> and <em>sigma</em> at index <em>i</em>.</p>
<p>Examples::</p>
<pre><code>sample = [[-2, -1, 0, 1, 2]]
random_pdf_normal(sample=sample, mu=[0], sigma=[1]) =
    [[0.05399097, 0.24197073, 0.3989423, 0.24197073, 0.05399097]]

random_pdf_normal(sample=sample*2, mu=[0,0], sigma=[1,2]) =
    [[0.05399097, 0.24197073, 0.3989423,  0.24197073, 0.05399097],
     [0.12098537, 0.17603266, 0.19947115, 0.17603266, 0.12098537]]
</code></pre>

<p>Defined in src/operator/random/pdf_op.cc:L300</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>sample::NDArray-or-SymbolicNode</code>: Samples from the distributions.</li>
<li><code>mu::NDArray-or-SymbolicNode</code>: Means of the distributions.</li>
<li><code>is_log::boolean, optional, default=0</code>: If set, compute the density of the log-probability instead of the probability.</li>
<li><code>sigma::NDArray-or-SymbolicNode</code>: Standard deviations of the distributions.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L376' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.random_pdf_poisson-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.random_pdf_poisson-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.random_pdf_poisson</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">random_pdf_poisson(sample, lam, is_log)
</code></pre>

<p>random<em>pdf</em>poisson is an alias of <em>random</em>pdf_poisson.</p>
<p>Computes the value of the PDF of <em>sample</em> of Poisson distributions with parameters <em>lam</em> (rate).</p>
<p>The shape of <em>lam</em> must match the leftmost subshape of <em>sample</em>.  That is, <em>sample</em> can have the same shape as <em>lam</em>, in which case the output contains one density per distribution, or <em>sample</em> can be a tensor of tensors with that shape, in which case the output is a tensor of densities such that the densities at index <em>i</em> in the output are given by the samples at index <em>i</em> in <em>sample</em> parameterized by the value of <em>lam</em> at index <em>i</em>.</p>
<p>Examples::</p>
<pre><code>random_pdf_poisson(sample=[[0,1,2,3]], lam=[1]) =
    [[0.36787945, 0.36787945, 0.18393973, 0.06131324]]

sample = [[0,1,2,3],
          [0,1,2,3],
          [0,1,2,3]]

random_pdf_poisson(sample=sample, lam=[1,2,3]) =
    [[0.36787945, 0.36787945, 0.18393973, 0.06131324],
     [0.13533528, 0.27067056, 0.27067056, 0.18044704],
     [0.04978707, 0.14936121, 0.22404182, 0.22404182]]
</code></pre>

<p>Defined in src/operator/random/pdf_op.cc:L307</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>sample::NDArray-or-SymbolicNode</code>: Samples from the distributions.</li>
<li><code>lam::NDArray-or-SymbolicNode</code>: Lambda (rate) parameters of the distributions.</li>
<li><code>is_log::boolean, optional, default=0</code>: If set, compute the density of the log-probability instead of the probability.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L378' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.random_pdf_uniform-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.random_pdf_uniform-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.random_pdf_uniform</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">random_pdf_uniform(sample, low, is_log, high)
</code></pre>

<p>random<em>pdf</em>uniform is an alias of <em>random</em>pdf_uniform.</p>
<p>Computes the value of the PDF of <em>sample</em> of uniform distributions on the intervals given by <em>[low,high)</em>.</p>
<p><em>low</em> and <em>high</em> must have the same shape, which must match the leftmost subshape of <em>sample</em>.  That is, <em>sample</em> can have the same shape as <em>low</em> and <em>high</em>, in which case the output contains one density per distribution, or <em>sample</em> can be a tensor of tensors with that shape, in which case the output is a tensor of densities such that the densities at index <em>i</em> in the output are given by the samples at index <em>i</em> in <em>sample</em> parameterized by the values of <em>low</em> and <em>high</em> at index <em>i</em>.</p>
<p>Examples::</p>
<pre><code>random_pdf_uniform(sample=[[1,2,3,4]], low=[0], high=[10]) = [0.1, 0.1, 0.1, 0.1]

sample = [[[1, 2, 3],
           [1, 2, 3]],
          [[1, 2, 3],
           [1, 2, 3]]]
low  = [[0, 0],
        [0, 0]]
high = [[ 5, 10],
        [15, 20]]
random_pdf_uniform(sample=sample, low=low, high=high) =
    [[[0.2,        0.2,        0.2    ],
      [0.1,        0.1,        0.1    ]],
     [[0.06667,    0.06667,    0.06667],
      [0.05,       0.05,       0.05   ]]]
</code></pre>

<p>Defined in src/operator/random/pdf_op.cc:L298</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>sample::NDArray-or-SymbolicNode</code>: Samples from the distributions.</li>
<li><code>low::NDArray-or-SymbolicNode</code>: Lower bounds of the distributions.</li>
<li><code>is_log::boolean, optional, default=0</code>: If set, compute the density of the log-probability instead of the probability.</li>
<li><code>high::NDArray-or-SymbolicNode</code>: Upper bounds of the distributions.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L385' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.random_poisson-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.random_poisson-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.random_poisson</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">random_poisson(lam, shape, ctx, dtype)
</code></pre>

<p>random<em>poisson is an alias of _random</em>poisson.</p>
<p>Draw random samples from a Poisson distribution.</p>
<p>Samples are distributed according to a Poisson distribution parametrized by <em>lambda</em> (rate). Samples will always be returned as a floating point data type.</p>
<p>Example::</p>
<p>poisson(lam=4, shape=(2,2)) = [[ 5.,  2.],                                   [ 4.,  6.]]</p>
<p>Defined in src/operator/random/sample_op.cc:L150</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lam::float, optional, default=1</code>: Lambda parameter (rate) of the Poisson distribution.</li>
<li><code>shape::Shape(tuple), optional, default=None</code>: Shape of the output.</li>
<li><code>ctx::string, optional, default=''</code>: Context of output, in format <a href="n">cpu|gpu|cpu_pinned</a>. Only used for imperative calls.</li>
<li><code>dtype::{'None', 'float16', 'float32', 'float64'},optional, default='None'</code>: DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L366' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.random_randint-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.random_randint-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.random_randint</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">random_randint(low, high, shape, ctx, dtype)
</code></pre>

<p>random<em>randint is an alias of _random</em>randint.</p>
<p>Draw random samples from a discrete uniform distribution.</p>
<p>Samples are uniformly distributed over the half-open interval <em>[low, high)</em> (includes <em>low</em>, but excludes <em>high</em>).</p>
<p>Example::</p>
<p>randint(low=0, high=5, shape=(2,2)) = [[ 0,  2],                                           [ 3,  1]]</p>
<p>Defined in src/operator/random/sample_op.cc:L194</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>low::long, required</code>: Lower bound of the distribution.</li>
<li><code>high::long, required</code>: Upper bound of the distribution.</li>
<li><code>shape::Shape(tuple), optional, default=None</code>: Shape of the output.</li>
<li><code>ctx::string, optional, default=''</code>: Context of output, in format <a href="n">cpu|gpu|cpu_pinned</a>. Only used for imperative calls.</li>
<li><code>dtype::{'None', 'int32', 'int64'},optional, default='None'</code>: DType of the output in case this can't be inferred. Defaults to int32 if not defined (dtype=None).</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L369' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.random_uniform-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.random_uniform-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.random_uniform</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">random_uniform(low, high, shape, ctx, dtype)
</code></pre>

<p>random<em>uniform is an alias of _random</em>uniform.</p>
<p>Draw random samples from a uniform distribution.</p>
<p>.. note:: The existing alias $uniform$ is deprecated.</p>
<p>Samples are uniformly distributed over the half-open interval <em>[low, high)</em> (includes <em>low</em>, but excludes <em>high</em>).</p>
<p>Example::</p>
<p>uniform(low=0, high=1, shape=(2,2)) = [[ 0.60276335,  0.85794562],                                           [ 0.54488319,  0.84725171]]</p>
<p>Defined in src/operator/random/sample_op.cc:L96</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>low::float, optional, default=0</code>: Lower bound of the distribution.</li>
<li><code>high::float, optional, default=1</code>: Upper bound of the distribution.</li>
<li><code>shape::Shape(tuple), optional, default=None</code>: Shape of the output.</li>
<li><code>ctx::string, optional, default=''</code>: Context of output, in format <a href="n">cpu|gpu|cpu_pinned</a>. Only used for imperative calls.</li>
<li><code>dtype::{'None', 'float16', 'float32', 'float64'},optional, default='None'</code>: DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L371' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.ravel_multi_index-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.ravel_multi_index-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.ravel_multi_index</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">ravel_multi_index(data, shape)
</code></pre>

<p>ravel<em>multi</em>index is an alias of <em>ravel</em>multi_index.</p>
<p>Converts a batch of index arrays into an array of flat indices. The operator follows numpy conventions so a single multi index is given by a column of the input matrix. The leading dimension may be left unspecified by using -1 as placeholder.  </p>
<p>Examples::</p>
<p>A = [[3,6,6],[4,5,1]]    ravel(A, shape=(7,6)) = [22,41,37]    ravel(A, shape=(-1,6)) = [22,41,37]</p>
<p>Defined in src/operator/tensor/ravel.cc:L42</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Batch of multi-indices</li>
<li><code>shape::Shape(tuple), optional, default=None</code>: Shape of the array into which the multi-indices apply.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L361' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.rcbrt-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.rcbrt-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.rcbrt</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">rcbrt(data)
</code></pre>

<p>Returns element-wise inverse cube-root value of the input.</p>
<p>.. math::    rcbrt(x) = 1/\sqrt[3]{x}</p>
<p>Example::</p>
<p>rcbrt([1,8,-125]) = [1.0, 0.5, -0.2]</p>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_pow.cc:L323</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L358' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.reciprocal-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.reciprocal-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.reciprocal</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">reciprocal(data)
</code></pre>

<p>Returns the reciprocal of the argument, element-wise.</p>
<p>Calculates 1/x.</p>
<p>Example::</p>
<pre><code>reciprocal([-2, 1, 3, 1.6, 0.2]) = [-0.5, 1.0, 0.33333334, 0.625, 5.0]
</code></pre>

<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_pow.cc:L43</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L357' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.reset_arrays-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.reset_arrays-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.reset_arrays</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">reset_arrays(data, num_arrays)
</code></pre>

<p>Set to zero multiple arrays</p>
<p>Defined in src/operator/contrib/reset_arrays.cc:L36</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode[]</code>: Arrays</li>
<li><code>num_arrays::int, required</code>: number of input arrays.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L352' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.reshape_like-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.reshape_like-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.reshape_like</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">reshape_like(lhs, rhs, lhs_begin, lhs_end, rhs_begin, rhs_end)
</code></pre>

<p>Reshape some or all dimensions of <code>lhs</code> to have the same shape as some or all dimensions of <code>rhs</code>.</p>
<p>Returns a <strong>view</strong> of the <code>lhs</code> array with a new shape without altering any data.</p>
<p>Example::</p>
<p>x = [1, 2, 3, 4, 5, 6]   y = [[0, -4], [3, 2], [2, 2]]   reshape_like(x, y) = [[1, 2], [3, 4], [5, 6]]</p>
<p>More precise control over how dimensions are inherited is achieved by specifying 
slices over the <code>lhs</code> and <code>rhs</code> array dimensions. Only the sliced <code>lhs</code> dimensions 
are reshaped to the <code>rhs</code> sliced dimensions, with the non-sliced <code>lhs</code> dimensions staying the same.</p>
<p>Examples::</p>
<ul>
<li>lhs shape = (30,7), rhs shape = (15,2,4), lhs<em>begin=0, lhs</em>end=1, rhs<em>begin=0, rhs</em>end=2, output shape = (15,2,7)</li>
<li>lhs shape = (3, 5), rhs shape = (1,15,4), lhs<em>begin=0, lhs</em>end=2, rhs<em>begin=1, rhs</em>end=2, output shape = (15)</li>
</ul>
<p>Negative indices are supported, and <code>None</code> can be used for either <code>lhs_end</code> or <code>rhs_end</code> to indicate the end of the range.</p>
<p>Example::</p>
<ul>
<li>lhs shape = (30, 12), rhs shape = (4, 2, 2, 3), lhs<em>begin=-1, lhs</em>end=None, rhs<em>begin=1, rhs</em>end=None, output shape = (30, 2, 2, 3)</li>
</ul>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_basic.cc:L511</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: First input.</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: Second input.</li>
<li><code>lhs_begin::int or None, optional, default='None'</code>: Defaults to 0. The beginning index along which the lhs dimensions are to be reshaped. Supports negative indices.</li>
<li><code>lhs_end::int or None, optional, default='None'</code>: Defaults to None. The ending index along which the lhs dimensions are to be used for reshaping. Supports negative indices.</li>
<li><code>rhs_begin::int or None, optional, default='None'</code>: Defaults to 0. The beginning index along which the rhs dimensions are to be used for reshaping. Supports negative indices.</li>
<li><code>rhs_end::int or None, optional, default='None'</code>: Defaults to None. The ending index along which the rhs dimensions are to be used for reshaping. Supports negative indices.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L384' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.rint-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.rint-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.rint</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">rint(data)
</code></pre>

<p>Returns element-wise rounded value to the nearest integer of the input.</p>
<p>.. note::</p>
<ul>
<li>For input $n.5$ $rint$ returns $n$ while $round$ returns $n+1$.</li>
<li>For input $-n.5$ both $rint$ and $round$ returns $-n-1$.</li>
</ul>
<p>Example::</p>
<p>rint([-1.5, 1.5, -1.9, 1.9, 2.1]) = [-2.,  1., -2.,  2.,  2.]</p>
<p>The storage type of $rint$ output depends upon the input storage type:</p>
<ul>
<li>rint(default) = default</li>
<li>rint(row<em>sparse) = row</em>sparse</li>
<li>rint(csr) = csr</li>
</ul>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_basic.cc:L798</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L365' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.rmsprop_update-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.rmsprop_update-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.rmsprop_update</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">rmsprop_update(weight, grad, n, lr, rho, epsilon, wd, rescale_grad, clip_gradient, clip_weights)
</code></pre>

<p>Update function for <code>RMSProp</code> optimizer.</p>
<p><code>RMSprop</code> is a variant of stochastic gradient descent where the gradients are divided by a cache which grows with the sum of squares of recent gradients?</p>
<p><code>RMSProp</code> is similar to <code>AdaGrad</code>, a popular variant of <code>SGD</code> which adaptively tunes the learning rate of each parameter. <code>AdaGrad</code> lowers the learning rate for each parameter monotonically over the course of training. While this is analytically motivated for convex optimizations, it may not be ideal for non-convex problems. <code>RMSProp</code> deals with this heuristically by allowing the learning rates to rebound as the denominator decays over time.</p>
<p>Define the Root Mean Square (RMS) error criterion of the gradient as :math:<code>RMS[g]_t = \sqrt{E[g^2]_t + \epsilon}</code>, where :math:<code>g</code> represents gradient and :math:<code>E[g^2]_t</code> is the decaying average over past squared gradient.</p>
<p>The :math:<code>E[g^2]_t</code> is given by:</p>
<p>.. math::   E[g^2]<em t-1="t-1">t = \rho * E[g^2]</em> + (1-\rho) * g_t^2</p>
<p>The update step is</p>
<p>.. math::   \theta<em>{t+1} = \theta</em>t - \frac{\eta}{RMS[g]<em>t} g</em>t</p>
<p>The RMSProp code follows the version in http://www.cs.toronto.edu/~tijmen/csc321/slides/lecture<em>slides</em>lec6.pdf Tieleman &amp; Hinton, 2012.</p>
<p>Hinton suggests the momentum term :math:<code>\rho</code> to be 0.9 and the learning rate :math:<code>\eta</code> to be 0.001.</p>
<p>Defined in src/operator/optimizer_op.cc:L788</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>weight::NDArray-or-SymbolicNode</code>: Weight</li>
<li><code>grad::NDArray-or-SymbolicNode</code>: Gradient</li>
<li><code>n::NDArray-or-SymbolicNode</code>: n</li>
<li><code>lr::float, required</code>: Learning rate</li>
<li><code>rho::float, optional, default=0.949999988</code>: The decay rate of momentum estimates.</li>
<li><code>epsilon::float, optional, default=9.99999994e-09</code>: A small constant for numerical stability.</li>
<li><code>wd::float, optional, default=0</code>: Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</li>
<li><code>rescale_grad::float, optional, default=1</code>: Rescale gradient to grad = rescale_grad*grad.</li>
<li><code>clip_gradient::float, optional, default=-1</code>: Clip gradient to the range of [-clip<em>gradient, clip</em>gradient] If clip<em>gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip</em>gradient), -clip_gradient).</li>
<li><code>clip_weights::float, optional, default=-1</code>: Clip weights to the range of [-clip<em>weights, clip</em>weights] If clip<em>weights &lt;= 0, weight clipping is turned off. weights = max(min(weights, clip</em>weights), -clip_weights).</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L400' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.rmspropalex_update-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.rmspropalex_update-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.rmspropalex_update</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">rmspropalex_update(weight, grad, n, g, delta, lr, rho, momentum, epsilon, wd, rescale_grad, clip_gradient, clip_weights)
</code></pre>

<p>Update function for RMSPropAlex optimizer.</p>
<p><code>RMSPropAlex</code> is non-centered version of <code>RMSProp</code>.</p>
<p>Define :math:<code>E[g^2]_t</code> is the decaying average over past squared gradient and :math:<code>E[g]_t</code> is the decaying average over past gradient.</p>
<p>.. math::   E[g^2]<em t-1="t-1">t = \rho * E[g^2]</em> + (1 - \rho) * g<em>t^2\
  E[g]</em>t = \rho * E[g]<em>{t-1} + (1 - \rho) * g</em>t\
  momentum<em t-1="t-1">t = \gamma * momentum</em> - \frac{\eta}{\sqrt{E[g^2]<em>t - E[g]</em>t^2 + \epsilon}} g_t\
 The update step is</p>
<p>.. math::   \theta<em>{t+1} = \theta</em>t + momentum_t</p>
<p>The RMSPropAlex code follows the version in http://arxiv.org/pdf/1308.0850v5.pdf Eq(38) - Eq(45) by Alex Graves, 2013.</p>
<p>Graves suggests the momentum term :math:<code>\rho</code> to be 0.95, :math:<code>\gamma</code> to be 0.9 and the learning rate :math:<code>\eta</code> to be 0.0001.</p>
<p>Defined in src/operator/optimizer_op.cc:L827</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>weight::NDArray-or-SymbolicNode</code>: Weight</li>
<li><code>grad::NDArray-or-SymbolicNode</code>: Gradient</li>
<li><code>n::NDArray-or-SymbolicNode</code>: n</li>
<li><code>g::NDArray-or-SymbolicNode</code>: g</li>
<li><code>delta::NDArray-or-SymbolicNode</code>: delta</li>
<li><code>lr::float, required</code>: Learning rate</li>
<li><code>rho::float, optional, default=0.949999988</code>: Decay rate.</li>
<li><code>momentum::float, optional, default=0.899999976</code>: Decay rate.</li>
<li><code>epsilon::float, optional, default=9.99999994e-09</code>: A small constant for numerical stability.</li>
<li><code>wd::float, optional, default=0</code>: Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</li>
<li><code>rescale_grad::float, optional, default=1</code>: Rescale gradient to grad = rescale_grad*grad.</li>
<li><code>clip_gradient::float, optional, default=-1</code>: Clip gradient to the range of [-clip<em>gradient, clip</em>gradient] If clip<em>gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip</em>gradient), -clip_gradient).</li>
<li><code>clip_weights::float, optional, default=-1</code>: Clip weights to the range of [-clip<em>weights, clip</em>weights] If clip<em>weights &lt;= 0, weight clipping is turned off. weights = max(min(weights, clip</em>weights), -clip_weights).</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L395' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.rsqrt-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.rsqrt-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.rsqrt</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">rsqrt(data)
</code></pre>

<p>Returns element-wise inverse square-root value of the input.</p>
<p>.. math::    rsqrt(x) = 1/\sqrt{x}</p>
<p>Example::</p>
<p>rsqrt([4,9,16]) = [0.5, 0.33333334, 0.25]</p>
<p>The storage type of $rsqrt$ output is always dense</p>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_pow.cc:L221</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L360' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.sample_exponential-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.sample_exponential-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.sample_exponential</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">sample_exponential(lam, shape, dtype)
</code></pre>

<p>sample<em>exponential is an alias of _sample</em>exponential.</p>
<p>Concurrent sampling from multiple exponential distributions with parameters lambda (rate).</p>
<p>The parameters of the distributions are provided as an input array. Let <em>[s]</em> be the shape of the input array, <em>n</em> be the dimension of <em>[s]</em>, <em>[t]</em> be the shape specified as the parameter of the operator, and <em>m</em> be the dimension of <em>[t]</em>. Then the output will be a <em>(n+m)</em>-dimensional array with shape <em>[s]x[t]</em>.</p>
<p>For any valid <em>n</em>-dimensional index <em>i</em> with respect to the input array, <em>output[i]</em> will be an <em>m</em>-dimensional array that holds randomly drawn samples from the distribution which is parameterized by the input value at index <em>i</em>. If the shape parameter of the operator is not set, then one sample will be drawn per distribution and the output array has the same shape as the input array.</p>
<p>Examples::</p>
<p>lam = [ 1.0, 8.5 ]</p>
<p>// Draw a single sample for each distribution    sample_exponential(lam) = [ 0.51837951,  0.09994757]</p>
<p>// Draw a vector containing two samples for each distribution    sample_exponential(lam, shape=(2)) = [[ 0.51837951,  0.19866663],                                          [ 0.09994757,  0.50447971]]</p>
<p>Defined in src/operator/random/multisample_op.cc:L284</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lam::NDArray-or-SymbolicNode</code>: Lambda (rate) parameters of the distributions.</li>
<li><code>shape::Shape(tuple), optional, default=[]</code>: Shape to be sampled from each random distribution.</li>
<li><code>dtype::{'None', 'float16', 'float32', 'float64'},optional, default='None'</code>: DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L379' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.sample_gamma-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.sample_gamma-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.sample_gamma</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">sample_gamma(alpha, shape, dtype, beta)
</code></pre>

<p>sample<em>gamma is an alias of _sample</em>gamma.</p>
<p>Concurrent sampling from multiple gamma distributions with parameters <em>alpha</em> (shape) and <em>beta</em> (scale).</p>
<p>The parameters of the distributions are provided as input arrays. Let <em>[s]</em> be the shape of the input arrays, <em>n</em> be the dimension of <em>[s]</em>, <em>[t]</em> be the shape specified as the parameter of the operator, and <em>m</em> be the dimension of <em>[t]</em>. Then the output will be a <em>(n+m)</em>-dimensional array with shape <em>[s]x[t]</em>.</p>
<p>For any valid <em>n</em>-dimensional index <em>i</em> with respect to the input arrays, <em>output[i]</em> will be an <em>m</em>-dimensional array that holds randomly drawn samples from the distribution which is parameterized by the input values at index <em>i</em>. If the shape parameter of the operator is not set, then one sample will be drawn per distribution and the output array has the same shape as the input arrays.</p>
<p>Examples::</p>
<p>alpha = [ 0.0, 2.5 ]    beta = [ 1.0, 0.7 ]</p>
<p>// Draw a single sample for each distribution    sample_gamma(alpha, beta) = [ 0.        ,  2.25797319]</p>
<p>// Draw a vector containing two samples for each distribution    sample_gamma(alpha, beta, shape=(2)) = [[ 0.        ,  0.        ],                                            [ 2.25797319,  1.70734084]]</p>
<p>Defined in src/operator/random/multisample_op.cc:L282</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>alpha::NDArray-or-SymbolicNode</code>: Alpha (shape) parameters of the distributions.</li>
<li><code>shape::Shape(tuple), optional, default=[]</code>: Shape to be sampled from each random distribution.</li>
<li><code>dtype::{'None', 'float16', 'float32', 'float64'},optional, default='None'</code>: DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).</li>
<li><code>beta::NDArray-or-SymbolicNode</code>: Beta (scale) parameters of the distributions.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L382' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.sample_generalized_negative_binomial-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.sample_generalized_negative_binomial-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.sample_generalized_negative_binomial</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">sample_generalized_negative_binomial(mu, shape, dtype, alpha)
</code></pre>

<p>sample<em>generalized</em>negative<em>binomial is an alias of _sample</em>generalized<em>negative</em>binomial.</p>
<p>Concurrent sampling from multiple generalized negative binomial distributions with parameters <em>mu</em> (mean) and <em>alpha</em> (dispersion).</p>
<p>The parameters of the distributions are provided as input arrays. Let <em>[s]</em> be the shape of the input arrays, <em>n</em> be the dimension of <em>[s]</em>, <em>[t]</em> be the shape specified as the parameter of the operator, and <em>m</em> be the dimension of <em>[t]</em>. Then the output will be a <em>(n+m)</em>-dimensional array with shape <em>[s]x[t]</em>.</p>
<p>For any valid <em>n</em>-dimensional index <em>i</em> with respect to the input arrays, <em>output[i]</em> will be an <em>m</em>-dimensional array that holds randomly drawn samples from the distribution which is parameterized by the input values at index <em>i</em>. If the shape parameter of the operator is not set, then one sample will be drawn per distribution and the output array has the same shape as the input arrays.</p>
<p>Samples will always be returned as a floating point data type.</p>
<p>Examples::</p>
<p>mu = [ 2.0, 2.5 ]    alpha = [ 1.0, 0.1 ]</p>
<p>// Draw a single sample for each distribution    sample<em>generalized</em>negative_binomial(mu, alpha) = [ 0.,  3.]</p>
<p>// Draw a vector containing two samples for each distribution    sample<em>generalized</em>negative_binomial(mu, alpha, shape=(2)) = [[ 0.,  3.],                                                                  [ 3.,  1.]]</p>
<p>Defined in src/operator/random/multisample_op.cc:L293</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>mu::NDArray-or-SymbolicNode</code>: Means of the distributions.</li>
<li><code>shape::Shape(tuple), optional, default=[]</code>: Shape to be sampled from each random distribution.</li>
<li><code>dtype::{'None', 'float16', 'float32', 'float64'},optional, default='None'</code>: DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).</li>
<li><code>alpha::NDArray-or-SymbolicNode</code>: Alpha (dispersion) parameters of the distributions.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L384' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.sample_multinomial-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.sample_multinomial-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.sample_multinomial</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">sample_multinomial(data, shape, get_prob, dtype)
</code></pre>

<p>sample<em>multinomial is an alias of _sample</em>multinomial.</p>
<p>Concurrent sampling from multiple multinomial distributions.</p>
<p><em>data</em> is an <em>n</em> dimensional array whose last dimension has length <em>k</em>, where <em>k</em> is the number of possible outcomes of each multinomial distribution. This operator will draw <em>shape</em> samples from each distribution. If shape is empty one sample will be drawn from each distribution.</p>
<p>If <em>get_prob</em> is true, a second array containing log likelihood of the drawn samples will also be returned. This is usually used for reinforcement learning where you can provide reward as head gradient for this array to estimate gradient.</p>
<p>Note that the input distribution must be normalized, i.e. <em>data</em> must sum to 1 along its last axis.</p>
<p>Examples::</p>
<p>probs = [[0, 0.1, 0.2, 0.3, 0.4], [0.4, 0.3, 0.2, 0.1, 0]]</p>
<p>// Draw a single sample for each distribution    sample_multinomial(probs) = [3, 0]</p>
<p>// Draw a vector containing two samples for each distribution    sample_multinomial(probs, shape=(2)) = [[4, 2],                                            [0, 0]]</p>
<p>// requests log likelihood    sample<em>multinomial(probs, get</em>prob=True) = [2, 1], [0.2, 0.3]</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Distribution probabilities. Must sum to one on the last axis.</li>
<li><code>shape::Shape(tuple), optional, default=[]</code>: Shape to be sampled from each random distribution.</li>
<li><code>get_prob::boolean, optional, default=0</code>: Whether to also return the log probability of sampled result. This is usually used for differentiating through stochastic variables, e.g. in reinforcement learning.</li>
<li><code>dtype::{'float16', 'float32', 'float64', 'int32', 'uint8'},optional, default='int32'</code>: DType of the output in case this can't be inferred.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L383' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.sample_negative_binomial-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.sample_negative_binomial-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.sample_negative_binomial</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">sample_negative_binomial(k, shape, dtype, p)
</code></pre>

<p>sample<em>negative</em>binomial is an alias of <em>sample</em>negative_binomial.</p>
<p>Concurrent sampling from multiple negative binomial distributions with parameters <em>k</em> (failure limit) and <em>p</em> (failure probability).</p>
<p>The parameters of the distributions are provided as input arrays. Let <em>[s]</em> be the shape of the input arrays, <em>n</em> be the dimension of <em>[s]</em>, <em>[t]</em> be the shape specified as the parameter of the operator, and <em>m</em> be the dimension of <em>[t]</em>. Then the output will be a <em>(n+m)</em>-dimensional array with shape <em>[s]x[t]</em>.</p>
<p>For any valid <em>n</em>-dimensional index <em>i</em> with respect to the input arrays, <em>output[i]</em> will be an <em>m</em>-dimensional array that holds randomly drawn samples from the distribution which is parameterized by the input values at index <em>i</em>. If the shape parameter of the operator is not set, then one sample will be drawn per distribution and the output array has the same shape as the input arrays.</p>
<p>Samples will always be returned as a floating point data type.</p>
<p>Examples::</p>
<p>k = [ 20, 49 ]    p = [ 0.4 , 0.77 ]</p>
<p>// Draw a single sample for each distribution    sample<em>negative</em>binomial(k, p) = [ 15.,  16.]</p>
<p>// Draw a vector containing two samples for each distribution    sample<em>negative</em>binomial(k, p, shape=(2)) = [[ 15.,  50.],                                                 [ 16.,  12.]]</p>
<p>Defined in src/operator/random/multisample_op.cc:L289</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>k::NDArray-or-SymbolicNode</code>: Limits of unsuccessful experiments.</li>
<li><code>shape::Shape(tuple), optional, default=[]</code>: Shape to be sampled from each random distribution.</li>
<li><code>dtype::{'None', 'float16', 'float32', 'float64'},optional, default='None'</code>: DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).</li>
<li><code>p::NDArray-or-SymbolicNode</code>: Failure probabilities in each experiment.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L384' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.sample_normal-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.sample_normal-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.sample_normal</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">sample_normal(mu, shape, dtype, sigma)
</code></pre>

<p>sample<em>normal is an alias of _sample</em>normal.</p>
<p>Concurrent sampling from multiple normal distributions with parameters <em>mu</em> (mean) and <em>sigma</em> (standard deviation).</p>
<p>The parameters of the distributions are provided as input arrays. Let <em>[s]</em> be the shape of the input arrays, <em>n</em> be the dimension of <em>[s]</em>, <em>[t]</em> be the shape specified as the parameter of the operator, and <em>m</em> be the dimension of <em>[t]</em>. Then the output will be a <em>(n+m)</em>-dimensional array with shape <em>[s]x[t]</em>.</p>
<p>For any valid <em>n</em>-dimensional index <em>i</em> with respect to the input arrays, <em>output[i]</em> will be an <em>m</em>-dimensional array that holds randomly drawn samples from the distribution which is parameterized by the input values at index <em>i</em>. If the shape parameter of the operator is not set, then one sample will be drawn per distribution and the output array has the same shape as the input arrays.</p>
<p>Examples::</p>
<p>mu = [ 0.0, 2.5 ]    sigma = [ 1.0, 3.7 ]</p>
<p>// Draw a single sample for each distribution    sample_normal(mu, sigma) = [-0.56410581,  0.95934606]</p>
<p>// Draw a vector containing two samples for each distribution    sample_normal(mu, sigma, shape=(2)) = [[-0.56410581,  0.2928229 ],                                           [ 0.95934606,  4.48287058]]</p>
<p>Defined in src/operator/random/multisample_op.cc:L279</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>mu::NDArray-or-SymbolicNode</code>: Means of the distributions.</li>
<li><code>shape::Shape(tuple), optional, default=[]</code>: Shape to be sampled from each random distribution.</li>
<li><code>dtype::{'None', 'float16', 'float32', 'float64'},optional, default='None'</code>: DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).</li>
<li><code>sigma::NDArray-or-SymbolicNode</code>: Standard deviations of the distributions.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L382' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.sample_poisson-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.sample_poisson-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.sample_poisson</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">sample_poisson(lam, shape, dtype)
</code></pre>

<p>sample<em>poisson is an alias of _sample</em>poisson.</p>
<p>Concurrent sampling from multiple Poisson distributions with parameters lambda (rate).</p>
<p>The parameters of the distributions are provided as an input array. Let <em>[s]</em> be the shape of the input array, <em>n</em> be the dimension of <em>[s]</em>, <em>[t]</em> be the shape specified as the parameter of the operator, and <em>m</em> be the dimension of <em>[t]</em>. Then the output will be a <em>(n+m)</em>-dimensional array with shape <em>[s]x[t]</em>.</p>
<p>For any valid <em>n</em>-dimensional index <em>i</em> with respect to the input array, <em>output[i]</em> will be an <em>m</em>-dimensional array that holds randomly drawn samples from the distribution which is parameterized by the input value at index <em>i</em>. If the shape parameter of the operator is not set, then one sample will be drawn per distribution and the output array has the same shape as the input array.</p>
<p>Samples will always be returned as a floating point data type.</p>
<p>Examples::</p>
<p>lam = [ 1.0, 8.5 ]</p>
<p>// Draw a single sample for each distribution    sample_poisson(lam) = [  0.,  13.]</p>
<p>// Draw a vector containing two samples for each distribution    sample_poisson(lam, shape=(2)) = [[  0.,   4.],                                      [ 13.,   8.]]</p>
<p>Defined in src/operator/random/multisample_op.cc:L286</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lam::NDArray-or-SymbolicNode</code>: Lambda (rate) parameters of the distributions.</li>
<li><code>shape::Shape(tuple), optional, default=[]</code>: Shape to be sampled from each random distribution.</li>
<li><code>dtype::{'None', 'float16', 'float32', 'float64'},optional, default='None'</code>: DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L381' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.sample_uniform-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.sample_uniform-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.sample_uniform</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">sample_uniform(low, shape, dtype, high)
</code></pre>

<p>sample<em>uniform is an alias of _sample</em>uniform.</p>
<p>Concurrent sampling from multiple uniform distributions on the intervals given by <em>[low,high)</em>.</p>
<p>The parameters of the distributions are provided as input arrays. Let <em>[s]</em> be the shape of the input arrays, <em>n</em> be the dimension of <em>[s]</em>, <em>[t]</em> be the shape specified as the parameter of the operator, and <em>m</em> be the dimension of <em>[t]</em>. Then the output will be a <em>(n+m)</em>-dimensional array with shape <em>[s]x[t]</em>.</p>
<p>For any valid <em>n</em>-dimensional index <em>i</em> with respect to the input arrays, <em>output[i]</em> will be an <em>m</em>-dimensional array that holds randomly drawn samples from the distribution which is parameterized by the input values at index <em>i</em>. If the shape parameter of the operator is not set, then one sample will be drawn per distribution and the output array has the same shape as the input arrays.</p>
<p>Examples::</p>
<p>low = [ 0.0, 2.5 ]    high = [ 1.0, 3.7 ]</p>
<p>// Draw a single sample for each distribution    sample_uniform(low, high) = [ 0.40451524,  3.18687344]</p>
<p>// Draw a vector containing two samples for each distribution    sample_uniform(low, high, shape=(2)) = [[ 0.40451524,  0.18017688],                                            [ 3.18687344,  3.68352246]]</p>
<p>Defined in src/operator/random/multisample_op.cc:L277</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>low::NDArray-or-SymbolicNode</code>: Lower bounds of the distributions.</li>
<li><code>shape::Shape(tuple), optional, default=[]</code>: Shape to be sampled from each random distribution.</li>
<li><code>dtype::{'None', 'float16', 'float32', 'float64'},optional, default='None'</code>: DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).</li>
<li><code>high::NDArray-or-SymbolicNode</code>: Upper bounds of the distributions.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L382' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.scatter_nd-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.scatter_nd-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.scatter_nd</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">scatter_nd(data, indices, shape)
</code></pre>

<p>Scatters data into a new tensor according to indices.</p>
<p>Given <code>data</code> with shape <code>(Y_0, ..., Y_{K-1}, X_M, ..., X_{N-1})</code> and indices with shape <code>(M, Y_0, ..., Y_{K-1})</code>, the output will have shape <code>(X_0, X_1, ..., X_{N-1})</code>, where <code>M &lt;= N</code>. If <code>M == N</code>, data shape should simply be <code>(Y_0, ..., Y_{K-1})</code>.</p>
<p>The elements in output is defined as follows::</p>
<p>output[indices[0, y<em K-1="K-1">0, ..., y</em>],          ...,          indices[M-1, y<em K-1="K-1">0, ..., y</em>],          x<em N-1="N-1">M, ..., x</em>] = data[y<em K-1="K-1">0, ..., y</em>, x<em N-1="N-1">M, ..., x</em>]</p>
<p>all other entries in output are 0.</p>
<p>.. warning::</p>
<pre><code>If the indices have duplicates, the result will be non-deterministic and
the gradient of `scatter_nd` will not be correct!!
</code></pre>

<p>Examples::</p>
<p>data = [2, 3, 0]   indices = [[1, 1, 0], [0, 1, 0]]   shape = (2, 2)   scatter_nd(data, indices, shape) = [[0, 0], [2, 3]]</p>
<p>data = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]   indices = [[0, 1], [1, 1]]   shape = (2, 2, 2, 2)   scatter_nd(data, indices, shape) = [[[[0, 0],                                         [0, 0]],</p>
<pre><code>                                   [[1, 2],
                                    [3, 4]]],

                                  [[[0, 0],
                                    [0, 0]],

                                   [[5, 6],
                                    [7, 8]]]]
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: data</li>
<li><code>indices::NDArray-or-SymbolicNode</code>: indices</li>
<li><code>shape::Shape(tuple), required</code>: Shape of output.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L394' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.set_attr-Tuple{SymbolicNode,Symbol,AbstractString}' href='#MXNet.mx.set_attr-Tuple{SymbolicNode,Symbol,AbstractString}'>#</a>
<strong><code>MXNet.mx.set_attr</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">set_attr(s::SymbolicNode, key::Symbol, value::AbstractString)
</code></pre>

<p>Set the attribute key to value for this <code>SymbolicNode</code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is encouraged not to call this function directly, unless you know exactly what you are doing. The recommended way of setting attributes is when creating the <code>SymbolicNode</code>. Changing the attributes of a <code>SymbolicNode</code> that is already been used somewhere else might cause unexpected behavior and inconsistency.</p>
</div>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L180-L190' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.sgd_mom_update-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.sgd_mom_update-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.sgd_mom_update</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">sgd_mom_update(weight, grad, mom, lr, momentum, wd, rescale_grad, clip_gradient, lazy_update)
</code></pre>

<p>Momentum update function for Stochastic Gradient Descent (SGD) optimizer.</p>
<p>Momentum update has better convergence rates on neural networks. Mathematically it looks like below:</p>
<p>.. math::</p>
<p>v<em>1 = \alpha * \nabla J(W</em>0)\
  v<em t-1="t-1">t = \gamma v</em> - \alpha * \nabla J(W<em>{t-1})\
  W</em>t = W<em>{t-1} + v</em>t</p>
<p>It updates the weights using::</p>
<p>v = momentum * v - learning_rate * gradient   weight += v</p>
<p>Where the parameter $momentum$ is the decay rate of momentum estimates at each epoch.</p>
<p>However, if grad's storage type is $row_sparse$, $lazy_update$ is True and weight's storage type is the same as momentum's storage type, only the row slices whose indices appear in grad.indices are updated (for both weight and momentum)::</p>
<p>for row in gradient.indices:       v[row] = momentum[row] * v[row] - learning_rate * gradient[row]       weight[row] += v[row]</p>
<p>Defined in src/operator/optimizer_op.cc:L556</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>weight::NDArray-or-SymbolicNode</code>: Weight</li>
<li><code>grad::NDArray-or-SymbolicNode</code>: Gradient</li>
<li><code>mom::NDArray-or-SymbolicNode</code>: Momentum</li>
<li><code>lr::float, required</code>: Learning rate</li>
<li><code>momentum::float, optional, default=0</code>: The decay rate of momentum estimates at each epoch.</li>
<li><code>wd::float, optional, default=0</code>: Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</li>
<li><code>rescale_grad::float, optional, default=1</code>: Rescale gradient to grad = rescale_grad*grad.</li>
<li><code>clip_gradient::float, optional, default=-1</code>: Clip gradient to the range of [-clip<em>gradient, clip</em>gradient] If clip<em>gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip</em>gradient), -clip_gradient).</li>
<li><code>lazy_update::boolean, optional, default=1</code>: If true, lazy updates are applied if gradient's stype is row_sparse and both weight and momentum have the same stype</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L391' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.sgd_update-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.sgd_update-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.sgd_update</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">sgd_update(weight, grad, lr, wd, rescale_grad, clip_gradient, lazy_update)
</code></pre>

<p>Update function for Stochastic Gradient Descent (SGD) optimizer.</p>
<p>It updates the weights using::</p>
<p>weight = weight - learning_rate * (gradient + wd * weight)</p>
<p>However, if gradient is of $row_sparse$ storage type and $lazy_update$ is True, only the row slices whose indices appear in grad.indices are updated::</p>
<p>for row in gradient.indices:      weight[row] = weight[row] - learning_rate * (gradient[row] + wd * weight[row])</p>
<p>Defined in src/operator/optimizer_op.cc:L515</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>weight::NDArray-or-SymbolicNode</code>: Weight</li>
<li><code>grad::NDArray-or-SymbolicNode</code>: Gradient</li>
<li><code>lr::float, required</code>: Learning rate</li>
<li><code>wd::float, optional, default=0</code>: Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</li>
<li><code>rescale_grad::float, optional, default=1</code>: Rescale gradient to grad = rescale_grad*grad.</li>
<li><code>clip_gradient::float, optional, default=-1</code>: Clip gradient to the range of [-clip<em>gradient, clip</em>gradient] If clip<em>gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip</em>gradient), -clip_gradient).</li>
<li><code>lazy_update::boolean, optional, default=1</code>: If true, lazy updates are applied if gradient's stype is row_sparse.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L373' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.shape_array-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.shape_array-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.shape_array</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">shape_array(data)
</code></pre>

<p>Returns a 1D int64 array containing the shape of data.</p>
<p>Example::</p>
<p>shape_array([[1,2,3,4], [5,6,7,8]]) = [2,4]</p>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_basic.cc:L573</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input Array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L355' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.signsgd_update-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.signsgd_update-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.signsgd_update</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">signsgd_update(weight, grad, lr, wd, rescale_grad, clip_gradient)
</code></pre>

<p>Update function for SignSGD optimizer.</p>
<p>.. math::</p>
<p>g<em t-1="t-1">t = \nabla J(W</em>)\
 W<em t-1="t-1">t = W</em> - \eta<em>t \text{sign}(g</em>t)</p>
<p>It updates the weights using::</p>
<p>weight = weight - learning_rate * sign(gradient)</p>
<p>.. note::</p>
<ul>
<li>sparse ndarray not supported for this optimizer yet.</li>
</ul>
<p>Defined in src/operator/optimizer_op.cc:L63</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>weight::NDArray-or-SymbolicNode</code>: Weight</li>
<li><code>grad::NDArray-or-SymbolicNode</code>: Gradient</li>
<li><code>lr::float, required</code>: Learning rate</li>
<li><code>wd::float, optional, default=0</code>: Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</li>
<li><code>rescale_grad::float, optional, default=1</code>: Rescale gradient to grad = rescale_grad*grad.</li>
<li><code>clip_gradient::float, optional, default=-1</code>: Clip gradient to the range of [-clip<em>gradient, clip</em>gradient] If clip<em>gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip</em>gradient), -clip_gradient).</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L372' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.signum_update-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.signum_update-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.signum_update</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">signum_update(weight, grad, mom, lr, momentum, wd, rescale_grad, clip_gradient, wd_lh)
</code></pre>

<p>SIGN momentUM (Signum) optimizer.</p>
<p>.. math::</p>
<p>g<em t-1="t-1">t = \nabla J(W</em>)\
 m<em t-1="t-1">t = \beta m</em> + (1 - \beta) g<em>t\
 W</em>t = W<em>{t-1} - \eta</em>t \text{sign}(m_t)</p>
<p>It updates the weights using::  state = momentum * state + (1-momentum) * gradient  weight = weight - learning_rate * sign(state)</p>
<p>Where the parameter $momentum$ is the decay rate of momentum estimates at each epoch.</p>
<p>.. note::</p>
<ul>
<li>sparse ndarray not supported for this optimizer yet.</li>
</ul>
<p>Defined in src/operator/optimizer_op.cc:L92</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>weight::NDArray-or-SymbolicNode</code>: Weight</li>
<li><code>grad::NDArray-or-SymbolicNode</code>: Gradient</li>
<li><code>mom::NDArray-or-SymbolicNode</code>: Momentum</li>
<li><code>lr::float, required</code>: Learning rate</li>
<li><code>momentum::float, optional, default=0</code>: The decay rate of momentum estimates at each epoch.</li>
<li><code>wd::float, optional, default=0</code>: Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</li>
<li><code>rescale_grad::float, optional, default=1</code>: Rescale gradient to grad = rescale_grad*grad.</li>
<li><code>clip_gradient::float, optional, default=-1</code>: Clip gradient to the range of [-clip<em>gradient, clip</em>gradient] If clip<em>gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip</em>gradient), -clip_gradient).</li>
<li><code>wd_lh::float, optional, default=0</code>: The amount of weight decay that does not go into gradient/momentum calculationsotherwise do weight decay algorithmically only.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L381' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.size_array-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.size_array-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.size_array</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">size_array(data)
</code></pre>

<p>Returns a 1D int64 array containing the size of data.</p>
<p>Example::</p>
<p>size_array([[1,2,3,4], [5,6,7,8]]) = [8]</p>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_basic.cc:L624</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input Array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L355' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.slice-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.slice-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.slice</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">slice(data, begin, end, step)
</code></pre>

<p>Slices a region of the array. .. note:: $crop$ is deprecated. Use $slice$ instead. This function returns a sliced array between the indices given by <code>begin</code> and <code>end</code> with the corresponding <code>step</code>. For an input array of $shape=(d_0, d_1, ..., d_n-1)$, slice operation with $begin=(b_0, b_1...b_m-1)$, $end=(e_0, e_1, ..., e_m-1)$, and $step=(s_0, s_1, ..., s_m-1)$, where m &lt;= n, results in an array with the shape $(|e_0-b_0|/|s_0|, ..., |e_m-1-b_m-1|/|s_m-1|, d_m, ..., d_n-1)$. The resulting array's <em>k</em>-th dimension contains elements from the <em>k</em>-th dimension of the input array starting from index $b_k$ (inclusive) with step $s_k$ until reaching $e_k$ (exclusive). If the <em>k</em>-th elements are <code>None</code> in the sequence of <code>begin</code>, <code>end</code>, and <code>step</code>, the following rule will be used to set default values. If <code>s_k</code> is <code>None</code>, set <code>s_k=1</code>. If <code>s_k &gt; 0</code>, set <code>b_k=0</code>, <code>e_k=d_k</code>; else, set <code>b_k=d_k-1</code>, <code>e_k=-1</code>. The storage type of $slice$ output depends on storage types of inputs</p>
<ul>
<li>slice(csr) = csr</li>
<li>otherwise, $slice$ generates output with default storage</li>
</ul>
<p>.. note:: When input data storage type is csr, it only supports    step=(), or step=(None,), or step=(1,) to generate a csr output.    For other step parameter values, it falls back to slicing    a dense tensor. Example::   x = [[  1.,   2.,   3.,   4.],        [  5.,   6.,   7.,   8.],        [  9.,  10.,  11.,  12.]]   slice(x, begin=(0,1), end=(2,4)) = [[ 2.,  3.,  4.],                                      [ 6.,  7.,  8.]]   slice(x, begin=(None, 0), end=(None, 3), step=(-1, 2)) = [[9., 11.],                                                             [5.,  7.],                                                             [1.,  3.]]</p>
<p>Defined in src/operator/tensor/matrix_op.cc:L482</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Source input</li>
<li><code>begin::Shape(tuple), required</code>: starting indices for the slice operation, supports negative indices.</li>
<li><code>end::Shape(tuple), required</code>: ending indices for the slice operation, supports negative indices.</li>
<li><code>step::Shape(tuple), optional, default=[]</code>: step for the slice operation, supports negative values.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L388' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.slice_axis-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.slice_axis-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.slice_axis</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">slice_axis(data, axis, begin, end)
</code></pre>

<p>Slices along a given axis. Returns an array slice along a given <code>axis</code> starting from the <code>begin</code> index to the <code>end</code> index. Examples::   x = [[  1.,   2.,   3.,   4.],        [  5.,   6.,   7.,   8.],        [  9.,  10.,  11.,  12.]]   slice<em>axis(x, axis=0, begin=1, end=3) = [[  5.,   6.,   7.,   8.],                                            [  9.,  10.,  11.,  12.]]   slice</em>axis(x, axis=1, begin=0, end=2) = [[  1.,   2.],                                            [  5.,   6.],                                            [  9.,  10.]]   slice_axis(x, axis=1, begin=-3, end=-1) = [[  2.,   3.],                                              [  6.,   7.],                                              [ 10.,  11.]]</p>
<p>Defined in src/operator/tensor/matrix_op.cc:L571</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Source input</li>
<li><code>axis::int, required</code>: Axis along which to be sliced, supports negative indexes.</li>
<li><code>begin::int, required</code>: The beginning index along the axis to be sliced,  supports negative indexes.</li>
<li><code>end::int or None, required</code>: The ending index along the axis to be sliced,  supports negative indexes.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L370' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.slice_like-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.slice_like-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.slice_like</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">slice_like(data, shape_like, axes)
</code></pre>

<p>Slices a region of the array like the shape of another array. This function is similar to $slice$, however, the <code>begin</code> are always <code>0</code>s and <code>end</code> of specific axes are inferred from the second input <code>shape_like</code>. Given the second <code>shape_like</code> input of $shape=(d_0, d_1, ..., d_n-1)$, a $slice_like$ operator with default empty <code>axes</code>, it performs the following operation: $out = slice(input, begin=(0, 0, ..., 0), end=(d_0, d_1, ..., d_n-1))$. When <code>axes</code> is not empty, it is used to speficy which axes are being sliced. Given a 4-d input data, $slice_like$ operator with $axes=(0, 2, -1)$ will perform the following operation: $out = slice(input, begin=(0, 0, 0, 0), end=(d_0, None, d_2, d_3))$. Note that it is allowed to have first and second input with different dimensions, however, you have to make sure the <code>axes</code> are specified and not exceeding the dimension limits. For example, given <code>input_1</code> with $shape=(2,3,4,5)$ and <code>input_2</code> with $shape=(1,2,3)$, it is not allowed to use: $out = slice_like(a, b)$ because ndim of <code>input_1</code> is 4, and ndim of <code>input_2</code> is 3. The following is allowed in this situation: $out = slice_like(a, b, axes=(0, 2))$ Example::   x = [[  1.,   2.,   3.,   4.],        [  5.,   6.,   7.,   8.],        [  9.,  10.,  11.,  12.]]   y = [[  0.,   0.,   0.],        [  0.,   0.,   0.]]   slice<em>like(x, y) = [[ 1.,  2.,  3.]                       [ 5.,  6.,  7.]]   slice</em>like(x, y, axes=(0, 1)) = [[ 1.,  2.,  3.]                                    [ 5.,  6.,  7.]]   slice<em>like(x, y, axes=(0)) = [[ 1.,  2.,  3.,  4.]                                 [ 5.,  6.,  7.,  8.]]   slice</em>like(x, y, axes=(-1)) = [[  1.,   2.,   3.]                                  [  5.,   6.,   7.]                                  [  9.,  10.,  11.]]</p>
<p>Defined in src/operator/tensor/matrix_op.cc:L625</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Source input</li>
<li><code>shape_like::NDArray-or-SymbolicNode</code>: Shape like input</li>
<li><code>axes::Shape(tuple), optional, default=[]</code>: List of axes on which input data will be sliced according to the corresponding size of the second input. By default will slice on all axes. Negative axes are supported.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L388' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.smooth_l1-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.smooth_l1-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.smooth_l1</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">smooth_l1(data, scalar)
</code></pre>

<p>Calculate Smooth L1 Loss(lhs, scalar) by summing</p>
<p>.. math::</p>
<pre><code>f(x) =
\begin{cases}
(\sigma x)^2/2,&amp; \text{if }x &lt; 1/\sigma^2\\
|x|-0.5/\sigma^2,&amp; \text{otherwise}
\end{cases}
</code></pre>

<p>where :math:<code>x</code> is an element of the tensor <em>lhs</em> and :math:<code>\sigma</code> is the scalar.</p>
<p>Example::</p>
<p>smooth<em>l1([1, 2, 3, 4]) = [0.5, 1.5, 2.5, 3.5]   smooth</em>l1([1, 2, 3, 4], scalar=1) = [0.5, 1.5, 2.5, 3.5]</p>
<p>Defined in src/operator/tensor/elemwise<em>binary</em>scalar<em>op</em>extended.cc:L108</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L368' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.softmax_cross_entropy-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.softmax_cross_entropy-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.softmax_cross_entropy</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">softmax_cross_entropy(data, label)
</code></pre>

<p>Calculate cross entropy of softmax output and one-hot label.</p>
<ul>
<li>
<p>This operator computes the cross entropy in two steps:</p>
<ul>
<li>Applies softmax function on the input array.</li>
<li>Computes and returns the cross entropy loss between the softmax output and the labels.</li>
<li>
<p>The softmax function and cross entropy loss is given by:</p>
</li>
<li>
<p>Softmax Function:</p>
</li>
</ul>
<p>.. math:: \text{softmax}(x)<em>i = \frac{exp(x</em>i)}{\sum<em>j exp(x</em>j)}</p>
<ul>
<li>Cross Entropy Function:</li>
</ul>
<p>.. math:: \text{CE(label, output)} = - \sum<em>i \text{label}</em>i \log(\text{output}_i)</p>
</li>
</ul>
<p>Example::</p>
<p>x = [[1, 2, 3],        [11, 7, 5]]</p>
<p>label = [2, 0]</p>
<p>softmax(x) = [[0.09003057, 0.24472848, 0.66524094],                 [0.97962922, 0.01794253, 0.00242826]]</p>
<p>softmax<em>cross</em>entropy(data, label) = - log(0.66524084) - log(0.97962922) = 0.4281871</p>
<p>Defined in src/operator/loss<em>binary</em>op.cc:L59</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data</li>
<li><code>label::NDArray-or-SymbolicNode</code>: Input label</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L379' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.softmin-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.softmin-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.softmin</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">softmin(data, axis, temperature, dtype, use_length)
</code></pre>

<p>Applies the softmin function.</p>
<p>The resulting array contains elements in the range (0,1) and the elements along the given axis sum up to 1.</p>
<p>.. math::    softmin(\mathbf{z/t})<em>j = \frac{e^{-z</em>j/t}}{\sum<em>{k=1}^K e^{-z</em>k/t}}</p>
<p>for :math:<code>j = 1, ..., K</code></p>
<p>t is the temperature parameter in softmax function. By default, t equals 1.0</p>
<p>Example::</p>
<p>x = [[ 1.  2.  3.]        [ 3.  2.  1.]]</p>
<p>softmin(x,axis=0) = [[ 0.88079703,  0.5,  0.11920292],                        [ 0.11920292,  0.5,  0.88079703]]</p>
<p>softmin(x,axis=1) = [[ 0.66524094,  0.24472848,  0.09003057],                        [ 0.09003057,  0.24472848,  0.66524094]]</p>
<p>Defined in src/operator/nn/softmin.cc:L57</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>axis::int, optional, default='-1'</code>: The axis along which to compute softmax.</li>
<li><code>temperature::double or None, optional, default=None</code>: Temperature parameter in softmax</li>
<li><code>dtype::{None, 'float16', 'float32', 'float64'},optional, default='None'</code>: DType of the output in case this can't be inferred. Defaults to the same as input's dtype if not defined (dtype=None).</li>
<li><code>use_length::boolean or None, optional, default=0</code>: Whether to use the length input as a mask over the data input.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L380' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.softsign-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.softsign-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.softsign</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">softsign(data)
</code></pre>

<p>Computes softsign of x element-wise.</p>
<p>.. math::    y = x / (1 + abs(x))</p>
<p>The storage type of $softsign$ output is always dense</p>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_basic.cc:L191</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L356' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.space_to_depth-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.space_to_depth-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.space_to_depth</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">space_to_depth(data, block_size)
</code></pre>

<p>Rearranges(permutes) blocks of spatial data into depth. Similar to ONNX SpaceToDepth operator: https://github.com/onnx/onnx/blob/master/docs/Operators.md#SpaceToDepth The output is a new tensor where the values from height and width dimension are moved to the depth dimension. The reverse of this operation is $depth_to_space$. .. math::     <script type="math/tex; mode=display">\begin{gather*}     x \prime = reshape(x, [N, C, H / block_size, block_size, W / block_size, block_size]) \
    x \prime \prime = transpose(x \prime, [0, 3, 5, 1, 2, 4]) \
    y = reshape(x \prime \prime, [N, C * (block_size ^ 2), H / block_size, W / block_size])     \end{gather*}</script> where :math:<code>x</code> is an input tensor with default layout as :math:<code>[N, C, H, W]</code>: [batch, channels, height, width] and :math:<code>y</code> is the output tensor of layout :math:<code>[N, C * (block\_size ^ 2), H / block\_size, W / block\_size]</code> Example::   x = [[[[0, 6, 1, 7, 2, 8],          [12, 18, 13, 19, 14, 20],          [3, 9, 4, 10, 5, 11],          [15, 21, 16, 22, 17, 23]]]]   space<em>to</em>depth(x, 2) = [[[[0, 1, 2],                             [3, 4, 5]],                            [[6, 7, 8],                             [9, 10, 11]],                            [[12, 13, 14],                             [15, 16, 17]],                            [[18, 19, 20],                             [21, 22, 23]]]]</p>
<p>Defined in src/operator/tensor/matrix_op.cc:L1019</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input ndarray</li>
<li><code>block_size::int, required</code>: Blocks of [block<em>size. block</em>size] are moved</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L377' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.square-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.square-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.square</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">square(data)
</code></pre>

<p>Returns element-wise squared value of the input.</p>
<p>.. math::    square(x) = x^2</p>
<p>Example::</p>
<p>square([2, 3, 4]) = [4, 9, 16]</p>
<p>The storage type of $square$ output depends upon the input storage type:</p>
<ul>
<li>square(default) = default</li>
<li>square(row<em>sparse) = row</em>sparse</li>
<li>square(csr) = csr</li>
</ul>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_pow.cc:L119</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L364' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.squeeze-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.squeeze-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.squeeze</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">squeeze(data, axis)
</code></pre>

<p>Remove single-dimensional entries from the shape of an array. Same behavior of defining the output tensor shape as numpy.squeeze for the most of cases. See the following note for exception. Examples::   data = [[[0], [1], [2]]]   squeeze(data) = [0, 1, 2]   squeeze(data, axis=0) = [[0], [1], [2]]   squeeze(data, axis=2) = [[0, 1, 2]]   squeeze(data, axis=(0, 2)) = [0, 1, 2] .. Note::   The output of this operator will keep at least one dimension not removed. For example,   squeeze([[[4]]]) = [4], while in numpy.squeeze, the output will become a scalar.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: data to squeeze</li>
<li><code>axis::Shape or None, optional, default=None</code>: Selects a subset of the single-dimensional entries in the shape. If an axis is selected with shape entry greater than one, an error is raised.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L361' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.stack-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.stack-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.stack</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">stack(data, axis, num_args)
</code></pre>

<p><strong>Note</strong>: stack takes variable number of positional inputs. So instead of calling as stack([x, y, z], num<em>args=3), one should call via stack(x, y, z), and num</em>args will be determined automatically.</p>
<p>Join a sequence of arrays along a new axis. The axis parameter specifies the index of the new axis in the dimensions of the result. For example, if axis=0 it will be the first dimension and if axis=-1 it will be the last dimension. Examples::   x = [1, 2]   y = [3, 4]   stack(x, y) = [[1, 2],                  [3, 4]]   stack(x, y, axis=1) = [[1, 3],                          [2, 4]]</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode[]</code>: List of arrays to stack</li>
<li><code>axis::int, optional, default='0'</code>: The axis in the result array along which the input arrays are stacked.</li>
<li><code>num_args::int, required</code>: Number of inputs to be stacked.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L364' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.stop_gradient-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.stop_gradient-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.stop_gradient</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">stop_gradient(data)
</code></pre>

<p>stop_gradient is an alias of BlockGrad.</p>
<p>Stops gradient computation.</p>
<p>Stops the accumulated gradient of the inputs from flowing through this operator in the backward direction. In other words, this operator prevents the contribution of its inputs to be taken into account for computing gradients.</p>
<p>Example::</p>
<p>v1 = [1, 2]   v2 = [0, 1]   a = Variable('a')   b = Variable('b')   b<em>stop</em>grad = stop<em>gradient(3 * b)   loss = MakeLoss(b</em>stop_grad + a)</p>
<p>executor = loss.simple<em>bind(ctx=cpu(), a=(1,2), b=(1,2))   executor.forward(is</em>train=True, a=v1, b=v2)   executor.outputs   [ 1.  5.]</p>
<p>executor.backward()   executor.grad_arrays   [ 0.  0.]   [ 1.  1.]</p>
<p>Defined in src/operator/tensor/elemwise<em>unary</em>op_basic.cc:L325</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L376' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.sum_axis-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.sum_axis-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.sum_axis</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">sum_axis(data, axis, keepdims, exclude)
</code></pre>

<p>sum_axis is an alias of sum.</p>
<p>Computes the sum of array elements over given axes.</p>
<p>.. Note::</p>
<p><code>sum</code> and <code>sum_axis</code> are equivalent.   For ndarray of csr storage type summation along axis 0 and axis 1 is supported.   Setting keepdims or exclude to True will cause a fallback to dense operator.</p>
<p>Example::</p>
<p>data = [[[1, 2], [2, 3], [1, 3]],           [[1, 4], [4, 3], [5, 2]],           [[7, 1], [7, 2], [7, 3]]]</p>
<p>sum(data, axis=1)   [[  4.   8.]    [ 10.   9.]    [ 21.   6.]]</p>
<p>sum(data, axis=[1,2])   [ 12.  19.  27.]</p>
<p>data = [[1, 2, 0],           [3, 0, 1],           [4, 1, 0]]</p>
<p>csr = cast_storage(data, 'csr')</p>
<p>sum(csr, axis=0)   [ 8.  3.  1.]</p>
<p>sum(csr, axis=1)   [ 3.  4.  5.]</p>
<p>Defined in src/operator/tensor/broadcast<em>reduce</em>sum_value.cc:L67</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input</li>
<li>
<p><code>axis::Shape or None, optional, default=None</code>: The axis or axes along which to perform the reduction.</p>
<p><code>``
The default,</code>axis=()<code>, will compute over all elements into a
scalar array with shape</code>(1,)`.</p>
<p>If <code>axis</code> is int, a reduction is performed on a particular axis.</p>
<p>If <code>axis</code> is a tuple of ints, a reduction is performed on all the axes
specified in the tuple.</p>
<p>If <code>exclude</code> is true, reduction will be performed on the axes that are
NOT in axis instead.</p>
<p>Negative values means indexing from right to left.
<code>``
  *</code>keepdims::boolean, optional, default=0<code>: If this is set to</code>True<code>, the reduced axes are left in the result as dimension with size one.
  *</code>exclude::boolean, optional, default=0<code>: Whether to perform reduction on axis that are NOT in axis instead.
  *</code>name::Symbol<code>: The name of the</code>SymbolicNode<code>. (e.g.</code>:my_symbol<code>), optional.
  *</code>attrs::Dict{Symbol,String}<code>: The attributes associated with this</code>SymbolicNode`.</p>
</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L404' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.swapaxes-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.swapaxes-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.swapaxes</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">swapaxes(data, dim1, dim2)
</code></pre>

<p>swapaxes is an alias of SwapAxis.</p>
<p>Interchanges two axes of an array.</p>
<p>Examples::</p>
<p>x = [[1, 2, 3]])   swapaxes(x, 0, 1) = [[ 1],                        [ 2],                        [ 3]]</p>
<p>x = [[[ 0, 1],         [ 2, 3]],        [[ 4, 5],         [ 6, 7]]]  // (2,2,2) array</p>
<p>swapaxes(x, 0, 2) = [[[ 0, 4],                        [ 2, 6]],                       [[ 1, 5],                        [ 3, 7]]]</p>
<p>Defined in src/operator/swapaxis.cc:L70</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input array.</li>
<li><code>dim1::int, optional, default='0'</code>: the first axis to be swapped.</li>
<li><code>dim2::int, optional, default='0'</code>: the second axis to be swapped.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L373' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.take-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.take-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.take</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">take(a, indices, axis, mode)
</code></pre>

<p>Takes elements from an input array along the given axis.</p>
<p>This function slices the input array along a particular axis with the provided indices.</p>
<p>Given data tensor of rank r &gt;= 1, and indices tensor of rank q, gather entries of the axis dimension of data (by default outer-most one as axis=0) indexed by indices, and concatenates them in an output tensor of rank q + (r - 1).</p>
<p>Examples::</p>
<p>x = [4.  5.  6.]</p>
<p>// Trivial case, take the second element along the first axis.</p>
<p>take(x, [1]) = [ 5. ]</p>
<p>// The other trivial case, axis=-1, take the third element along the first axis</p>
<p>take(x, [3], axis=-1, mode='clip') = [ 6. ]</p>
<p>x = [[ 1.,  2.],        [ 3.,  4.],        [ 5.,  6.]]</p>
<p>// In this case we will get rows 0 and 1, then 1 and 2. Along axis 0</p>
<p>take(x, [[0,1],[1,2]]) = [[[ 1.,  2.],                              [ 3.,  4.]],</p>
<pre><code>                        [[ 3.,  4.],
                         [ 5.,  6.]]]
</code></pre>

<p>// In this case we will get rows 0 and 1, then 1 and 2 (calculated by wrapping around).   // Along axis 1</p>
<p>take(x, [[0, 3], [-1, -2]], axis=1, mode='wrap') = [[[ 1.  2.]                                                        [ 2.  1.]]</p>
<pre><code>                                                  [[ 3.  4.]
                                                   [ 4.  3.]]

                                                  [[ 5.  6.]
                                                   [ 6.  5.]]]
</code></pre>

<p>The storage type of $take$ output depends upon the input storage type:</p>
<ul>
<li>take(default, default) = default</li>
<li>take(csr, default, axis=0) = csr</li>
</ul>
<p>Defined in src/operator/tensor/indexing_op.cc:L782</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>a::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>indices::NDArray-or-SymbolicNode</code>: The indices of the values to be extracted.</li>
<li><code>axis::int, optional, default='0'</code>: The axis of input array to be taken.For input tensor of rank r, it could be in the range of [-r, r-1]</li>
<li><code>mode::{'clip', 'raise', 'wrap'},optional, default='clip'</code>: Specify how out-of-bound indices bahave. Default is "clip". "clip" means clip to the range. So, if all indices mentioned are too large, they are replaced by the index that addresses the last element along an axis. "wrap" means to wrap around. "raise" means to raise an error when index out of range.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L404' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.tile-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.tile-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.tile</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">tile(data, reps)
</code></pre>

<p>Repeats the whole array multiple times. If $reps$ has length <em>d</em>, and input array has dimension of <em>n</em>. There are three cases:</p>
<ul>
<li><strong>n=d</strong>. Repeat <em>i</em>-th dimension of the input by $reps[i]$ times::   x = [[1, 2],        [3, 4]]   tile(x, reps=(2,3)) = [[ 1.,  2.,  1.,  2.,  1.,  2.],                          [ 3.,  4.,  3.,  4.,  3.,  4.],                          [ 1.,  2.,  1.,  2.,  1.,  2.],                          [ 3.,  4.,  3.,  4.,  3.,  4.]]</li>
<li><strong>n&gt;d</strong>. $reps$ is promoted to length <em>n</em> by pre-pending 1's to it. Thus for an input shape $(2,3)$, $repos=(2,)$ is treated as $(1,2)$::   tile(x, reps=(2,)) = [[ 1.,  2.,  1.,  2.],                         [ 3.,  4.,  3.,  4.]]</li>
<li><strong>n&lt;d</strong>. The input is promoted to be d-dimensional by prepending new axes. So a shape $(2,2)$ array is promoted to $(1,2,2)$ for 3-D replication::   tile(x, reps=(2,2,3)) = [[[ 1.,  2.,  1.,  2.,  1.,  2.],                             [ 3.,  4.,  3.,  4.,  3.,  4.],                             [ 1.,  2.,  1.,  2.,  1.,  2.],                             [ 3.,  4.,  3.,  4.,  3.,  4.]],                            [[ 1.,  2.,  1.,  2.,  1.,  2.],                             [ 3.,  4.,  3.,  4.,  3.,  4.],                             [ 1.,  2.,  1.,  2.,  1.,  2.],                             [ 3.,  4.,  3.,  4.,  3.,  4.]]]</li>
</ul>
<p>Defined in src/operator/tensor/matrix_op.cc:L796</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data array</li>
<li><code>reps::Shape(tuple), required</code>: The number of times for repeating the tensor a. Each dim size of reps must be a positive integer. If reps has length d, the result will have dimension of max(d, a.ndim); If a.ndim &lt; d, a is promoted to be d-dimensional by prepending new axes. If a.ndim &gt; d, reps is promoted to a.ndim by pre-pending 1's to it.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L375' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.topk-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.topk-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.topk</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">topk(data, axis, k, ret_typ, is_ascend, dtype)
</code></pre>

<p>Returns the indices of the top <em>k</em> elements in an input array along the given  axis (by default).  If ret<em>type is set to 'value' returns the value of top </em>k<em> elements (instead of indices).  In case of ret</em>type = 'both', both value and index would be returned.  The returned elements will be sorted.</p>
<p>Examples::</p>
<p>x = [[ 0.3,  0.2,  0.4],        [ 0.1,  0.3,  0.2]]</p>
<p>// returns an index of the largest element on last axis   topk(x) = [[ 2.],              [ 1.]]</p>
<p>// returns the value of top-2 largest elements on last axis   topk(x, ret_typ='value', k=2) = [[ 0.4,  0.3],                                    [ 0.3,  0.2]]</p>
<p>// returns the value of top-2 smallest elements on last axis   topk(x, ret<em>typ='value', k=2, is</em>ascend=1) = [[ 0.2 ,  0.3],                                                [ 0.1 ,  0.2]]</p>
<p>// returns the value of top-2 largest elements on axis 0   topk(x, axis=0, ret_typ='value', k=2) = [[ 0.3,  0.3,  0.4],                                            [ 0.1,  0.2,  0.2]]</p>
<p>// flattens and then returns list of both values and indices   topk(x, ret_typ='both', k=2) = [[[ 0.4,  0.3], [ 0.3,  0.2]] ,  [[ 2.,  0.], [ 1.,  2.]]]</p>
<p>Defined in src/operator/tensor/ordering_op.cc:L68</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array</li>
<li><code>axis::int or None, optional, default='-1'</code>: Axis along which to choose the top k indices. If not given, the flattened array is used. Default is -1.</li>
<li><code>k::int, optional, default='1'</code>: Number of top elements to select, should be always smaller than or equal to the element number in the given axis. A global sort is performed if set k &lt; 1.</li>
<li><code>ret_typ::{'both', 'indices', 'mask', 'value'},optional, default='indices'</code>: The return type.</li>
</ul>
<p>"value" means to return the top k values, "indices" means to return the indices of the top k values, "mask" means to return a mask array containing 0 and 1. 1 means the top k values. "both" means to return a list of both values and indices of top k elements.</p>
<ul>
<li><code>is_ascend::boolean, optional, default=0</code>: Whether to choose k largest or k smallest elements. Top K largest elements will be chosen if set to false.</li>
<li><code>dtype::{'float16', 'float32', 'float64', 'int32', 'int64', 'uint8'},optional, default='float32'</code>: DType of the output indices when ret_typ is "indices" or "both". An error will be raised if the selected data type cannot precisely represent the indices.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L390' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.uniform-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.uniform-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.uniform</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">uniform(low, high, shape, ctx, dtype)
</code></pre>

<p>uniform is an alias of <em>random</em>uniform.</p>
<p>Draw random samples from a uniform distribution.</p>
<p>.. note:: The existing alias $uniform$ is deprecated.</p>
<p>Samples are uniformly distributed over the half-open interval <em>[low, high)</em> (includes <em>low</em>, but excludes <em>high</em>).</p>
<p>Example::</p>
<p>uniform(low=0, high=1, shape=(2,2)) = [[ 0.60276335,  0.85794562],                                           [ 0.54488319,  0.84725171]]</p>
<p>Defined in src/operator/random/sample_op.cc:L96</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>low::float, optional, default=0</code>: Lower bound of the distribution.</li>
<li><code>high::float, optional, default=1</code>: Upper bound of the distribution.</li>
<li><code>shape::Shape(tuple), optional, default=None</code>: Shape of the output.</li>
<li><code>ctx::string, optional, default=''</code>: Context of output, in format <a href="n">cpu|gpu|cpu_pinned</a>. Only used for imperative calls.</li>
<li><code>dtype::{'None', 'float16', 'float32', 'float64'},optional, default='None'</code>: DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L371' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.unravel_index-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.unravel_index-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.unravel_index</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">unravel_index(data, shape)
</code></pre>

<p>unravel<em>index is an alias of _unravel</em>index.</p>
<p>Converts an array of flat indices into a batch of index arrays. The operator follows numpy conventions so a single multi index is given by a column of the output matrix. The leading dimension may be left unspecified by using -1 as placeholder.  </p>
<p>Examples::</p>
<p>A = [22,41,37]    unravel(A, shape=(7,6)) = [[3,6,6],[4,5,1]]    unravel(A, shape=(-1,6)) = [[3,6,6],[4,5,1]]</p>
<p>Defined in src/operator/tensor/ravel.cc:L68</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Array of flat indices</li>
<li><code>shape::Shape(tuple), optional, default=None</code>: Shape of the array into which the multi-indices apply.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L361' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.where-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.where-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.where</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">where(condition, x, y)
</code></pre>

<p>Return the elements, either from x or y, depending on the condition.</p>
<p>Given three ndarrays, condition, x, and y, return an ndarray with the elements from x or y, depending on the elements from condition are true or false. x and y must have the same shape. If condition has the same shape as x, each element in the output array is from x if the corresponding element in the condition is true, and from y if false.</p>
<p>If condition does not have the same shape as x, it must be a 1D array whose size is the same as x's first dimension size. Each row of the output array is from x's row if the corresponding element from condition is true, and from y's row if false.</p>
<p>Note that all non-zero values are interpreted as $True$ in condition.</p>
<p>Examples::</p>
<p>x = [[1, 2], [3, 4]]   y = [[5, 6], [7, 8]]   cond = [[0, 1], [-1, 0]]</p>
<p>where(cond, x, y) = [[5, 2], [3, 8]]</p>
<p>csr<em>cond = cast</em>storage(cond, 'csr')</p>
<p>where(csr_cond, x, y) = [[5, 2], [3, 8]]</p>
<p>Defined in src/operator/tensor/control<em>flow</em>op.cc:L57</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>condition::NDArray-or-SymbolicNode</code>: condition array</li>
<li><code>x::NDArray-or-SymbolicNode</code>:</li>
<li><code>y::NDArray-or-SymbolicNode</code>:</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L378' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.zeros_like-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.zeros_like-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.zeros_like</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">zeros_like(data)
</code></pre>

<p>Return an array of zeros with the same shape, type and storage type as the input array.</p>
<p>The storage type of $zeros_like$ output depends on the storage type of the input</p>
<ul>
<li>zeros<em>like(row</em>sparse) = row_sparse</li>
<li>zeros_like(csr) = csr</li>
<li>zeros_like(default) = default</li>
</ul>
<p>Examples::</p>
<p>x = [[ 1.,  1.,  1.],        [ 1.,  1.,  1.]]</p>
<p>zeros_like(x) = [[ 0.,  0.,  0.],                    [ 0.,  0.,  0.]]</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L364' class='documenter-source'>source</a><br></p>
<p><a id='Random.shuffle-Tuple{Vararg{SymbolicNode,N} where N}' href='#Random.shuffle-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>Random.shuffle</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">shuffle(data)
</code></pre>

<p>shuffle is an alias of _shuffle.</p>
<p>Randomly shuffle the elements.</p>
<p>This shuffles the array along the first axis. The order of the elements in each subarray does not change. For example, if a 2D array is given, the order of the rows randomly changes, but the order of the elements in each row does not change.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Data to be shuffled.</li>
<li><code>name::Symbol</code>: The name of the <code>SymbolicNode</code>. (e.g. <code>:my_symbol</code>), optional.</li>
<li><code>attrs::Dict{Symbol,String}</code>: The attributes associated with this <code>SymbolicNode</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/op.jl#L337-L355' class='documenter-source'>source</a><br></p>
<p><a id='Base.print-Tuple{IO,SymbolicNode}' href='#Base.print-Tuple{IO,SymbolicNode}'>#</a>
<strong><code>Base.print</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">print([io::IO], sym::SymbolicNode)
</code></pre>

<p>Print the content of symbol, used for debug.</p>
<pre><code class="julia">julia&gt; layer = @mx.chain mx.Variable(:data)           =&gt;
         mx.FullyConnected(name=:fc1, num_hidden=128) =&gt;
         mx.Activation(name=:relu1, act_type=:relu)
MXNet.mx.SymbolicNode(MXNet.mx.MX_SymbolHandle(Ptr{Nothing} @0x000055b29b9c3520))

julia&gt; print(layer)
Symbol Outputs:
        output[0]=relu1(0)
Variable:data
Variable:fc1_weight
Variable:fc1_bias
--------------------
Op:FullyConnected, Name=fc1
Inputs:
        arg[0]=data(0) version=0
        arg[1]=fc1_weight(0) version=0
        arg[2]=fc1_bias(0) version=0
Attrs:
        num_hidden=128
--------------------
Op:Activation, Name=relu1
Inputs:
        arg[0]=fc1(0)
Attrs:
        act_type=relu
</code></pre>

<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/show.jl#L21-L53' class='documenter-source'>source</a><br></p>
<p><a id='Base.copy-Tuple{SymbolicNode}' href='#Base.copy-Tuple{SymbolicNode}'>#</a>
<strong><code>Base.copy</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">copy(s::SymbolicNode)
</code></pre>

<p>Make a copy of a SymbolicNode. The same as making a deep copy.</p>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/type.jl#L52-L56' class='documenter-source'>source</a><br></p>
<p><a id='Base.deepcopy-Tuple{SymbolicNode}' href='#Base.deepcopy-Tuple{SymbolicNode}'>#</a>
<strong><code>Base.deepcopy</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">deepcopy(s::SymbolicNode)
</code></pre>

<p>Make a deep copy of a SymbolicNode.</p>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/type.jl#L41-L45' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.Group-Tuple{Vararg{SymbolicNode,N} where N}' href='#MXNet.mx.Group-Tuple{Vararg{SymbolicNode,N} where N}'>#</a>
<strong><code>MXNet.mx.Group</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">Group(nodes::SymbolicNode...)
</code></pre>

<p>Create a <code>SymbolicNode</code> by grouping nodes together.</p>
<p><a target='_blank' href='https://github.com/connorgoggins/incubator-mxnet/blob/721f1a3e7dd37062422bcec991e21d7cfd05d387/julia/src/symbolic-node/type.jl#L112-L116' class='documenter-source'>source</a><br></p>
                
                  
                
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid">
        
          <a href="../ndarray/" title="NDArray API" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
            </div>
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  Previous
                </span>
                NDArray API
              </span>
            </div>
          </a>
        
        
          <a href="../nn-factory/" title="Neural Networks Factory" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  Next
                </span>
                Neural Networks Factory
              </span>
            </div>
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
            </div>
          </a>
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        powered by
        <a href="https://www.mkdocs.org">MkDocs</a>
        and
        <a href="https://squidfunk.github.io/mkdocs-material/">
          Material for MkDocs</a>
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../../assets/javascripts/application.808e90bb.js"></script>
      
      <script>app.initialize({version:"1.0.4",url:{base:"../.."}})</script>
      
        <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
      
        <script src="../../assets/mathjaxhelper.js"></script>
      
    
  </body>
</html>