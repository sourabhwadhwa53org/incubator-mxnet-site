<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>mxnet: dmlc Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">mxnet
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">dmlc Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>namespace for dmlc  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacedmlc_1_1io"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc_1_1io.html">io</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedmlc_1_1lua__stack"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc_1_1lua__stack.html">lua_stack</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedmlc_1_1parameter"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc_1_1parameter.html">parameter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedmlc_1_1serializer"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc_1_1serializer.html">serializer</a></td></tr>
<tr class="memdesc:namespacedmlc_1_1serializer"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal namespace for serializers <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1array__view.html">array_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read only data structure to reference continuous memory region of array. Provide unified view for vector, array and C style array. This data structure do not guarantee aliveness of referenced array.  <a href="classdmlc_1_1array__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1BlockingQueueThread.html">BlockingQueueThread</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking queue thread class.  <a href="classdmlc_1_1BlockingQueueThread.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1ConcurrentBlockingQueue.html">ConcurrentBlockingQueue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cocurrent blocking queue.  <a href="classdmlc_1_1ConcurrentBlockingQueue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1Config.html">Config</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">class for config parser  <a href="classdmlc_1_1Config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1DataIter.html">DataIter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">data iterator interface this is not a C++ style iterator, but nice for data pulling:) This interface is used to pull in the data The system can do some useful tricks for you like pre-fetching from disk and pre-computation.  <a href="classdmlc_1_1DataIter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1FunctionRegEntryBase.html">FunctionRegEntryBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common base class for function registry.  <a href="classdmlc_1_1FunctionRegEntryBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdmlc_1_1has__saveload.html">has_saveload</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether a type have save/load function  <a href="structdmlc_1_1has__saveload.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdmlc_1_1IfThenElseType.html">IfThenElseType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">template to select type based on condition For example, IfThenElseType&lt;true, int, float&gt;::Type will give int  <a href="structdmlc_1_1IfThenElseType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1InputSplit.html">InputSplit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">input split creates that allows reading of records from split of data, independent part that covers all the dataset  <a href="classdmlc_1_1InputSplit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1InputSplitShuffle.html">InputSplitShuffle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">class to construct input split with global shuffling  <a href="classdmlc_1_1InputSplitShuffle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdmlc_1_1is__arithmetic.html">is_arithmetic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether a type is arithemetic type  <a href="structdmlc_1_1is__arithmetic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdmlc_1_1is__floating__point.html">is_floating_point</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether a type is floating point type  <a href="structdmlc_1_1is__floating__point.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdmlc_1_1is__integral.html">is_integral</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether a type is integer type  <a href="structdmlc_1_1is__integral.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdmlc_1_1is__pod.html">is_pod</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether a type is pod type  <a href="structdmlc_1_1is__pod.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1istream.html">istream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a std::istream class that can can wrap <a class="el" href="classdmlc_1_1Stream.html" title="interface of stream I/O for serialization ">Stream</a> objects, can use istream with that output to underlying <a class="el" href="classdmlc_1_1Stream.html" title="interface of stream I/O for serialization ">Stream</a>  <a href="classdmlc_1_1istream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1JSONObjectReadHelper.html">JSONObjectReadHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to read JSON into a class or struct object.  <a href="classdmlc_1_1JSONObjectReadHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1JSONReader.html">JSONReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lightweight JSON Reader to read any STL compositions and structs. The user need to know the schema of the.  <a href="classdmlc_1_1JSONReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1JSONWriter.html">JSONWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lightweight json to write any STL compositions.  <a href="classdmlc_1_1JSONWriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1LuaRef.html">LuaRef</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">an reference to lua object  <a href="classdmlc_1_1LuaRef.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1LuaState.html">LuaState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Lua state.  <a href="classdmlc_1_1LuaState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1ManualEvent.html">ManualEvent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple manual-reset event gate which remains open after signalled.  <a href="classdmlc_1_1ManualEvent.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdmlc_1_1MemoryFixedSizeStream.html">MemoryFixedSizeStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classdmlc_1_1Stream.html" title="interface of stream I/O for serialization ">Stream</a> that operates on fixed region of memory This class allows us to read/write from/to a fixed memory region.  <a href="structdmlc_1_1MemoryFixedSizeStream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1MemoryPool.html">MemoryPool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A memory pool that allocate memory of fixed size and alignment.  <a href="classdmlc_1_1MemoryPool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdmlc_1_1MemoryStringStream.html">MemoryStringStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A in memory stream that is backed by std::string. This class allows us to read/write from/to a std::string.  <a href="structdmlc_1_1MemoryStringStream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdmlc_1_1nullopt__t.html">nullopt_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">dummy type for assign null to optional  <a href="structdmlc_1_1nullopt__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1OMPException.html">OMPException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">OMP Exception class catches, saves and rethrows exception from OMP blocks.  <a href="classdmlc_1_1OMPException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1optional.html">optional</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">c++17 compatible optional class.  <a href="classdmlc_1_1optional.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1ostream.html">ostream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a std::ostream class that can can wrap <a class="el" href="classdmlc_1_1Stream.html" title="interface of stream I/O for serialization ">Stream</a> objects, can use ostream with that output to underlying <a class="el" href="classdmlc_1_1Stream.html" title="interface of stream I/O for serialization ">Stream</a>  <a href="classdmlc_1_1ostream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1Parser.html">Parser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">parser interface that parses input data used to load dmlc data format into your own data format Difference between <a class="el" href="classdmlc_1_1RowBlockIter.html" title="Data structure that holds the data Row block iterator interface that gets RowBlocks Difference betwee...">RowBlockIter</a> and <a class="el" href="classdmlc_1_1Parser.html" title="parser interface that parses input data used to load dmlc data format into your own data format Diffe...">Parser</a>: <a class="el" href="classdmlc_1_1RowBlockIter.html" title="Data structure that holds the data Row block iterator interface that gets RowBlocks Difference betwee...">RowBlockIter</a> caches the data internally that can be used to iterate the dataset multiple times, <a class="el" href="classdmlc_1_1Parser.html" title="parser interface that parses input data used to load dmlc data format into your own data format Diffe...">Parser</a> holds very limited internal state and was usually used to read data only once  <a href="classdmlc_1_1Parser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdmlc_1_1ParserFactoryReg.html">ParserFactoryReg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">registry entry of parser factory  <a href="structdmlc_1_1ParserFactoryReg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1RecordIOChunkReader.html">RecordIOChunkReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">reader of binary recordio from Blob returned by <a class="el" href="classdmlc_1_1InputSplit.html" title="input split creates that allows reading of records from split of data, independent part that covers a...">InputSplit</a> This class divides the blob into several independent parts specified by caller, and read from one segment. The part reading can be used together with <a class="el" href="classdmlc_1_1InputSplit.html#a2e835c07ce77d8d873592e006c242156" title="get a chunk of memory that can contain multiple records, the caller needs to parse the content of the...">InputSplit::NextChunk</a> for multi-threaded parsing(each thread take a RecordIOChunkReader)  <a href="classdmlc_1_1RecordIOChunkReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1RecordIOReader.html">RecordIOReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">reader of binary recordio to reads in record from stream  <a href="classdmlc_1_1RecordIOReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1RecordIOWriter.html">RecordIOWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">writer of binary recordio binary format for recordio recordio format: magic lrecord data pad  <a href="classdmlc_1_1RecordIOWriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1Registry.html">Registry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classdmlc_1_1Registry.html" title="Registry class. Registry can be used to register global singletons. The most commonly use case are fa...">Registry</a> class. <a class="el" href="classdmlc_1_1Registry.html" title="Registry class. Registry can be used to register global singletons. The most commonly use case are fa...">Registry</a> can be used to register global singletons. The most commonly use case are factory functions.  <a href="classdmlc_1_1Registry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1Row.html">Row</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">one row of training instance  <a href="classdmlc_1_1Row.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdmlc_1_1RowBlock.html">RowBlock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a block of data, containing several rows in sparse matrix This is useful for (streaming-sxtyle) algorithms that scans through rows of data examples include: SGD, GD, L-BFGS, kmeans  <a href="structdmlc_1_1RowBlock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1RowBlockIter.html">RowBlockIter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure that holds the data <a class="el" href="classdmlc_1_1Row.html" title="one row of training instance ">Row</a> block iterator interface that gets RowBlocks Difference between <a class="el" href="classdmlc_1_1RowBlockIter.html" title="Data structure that holds the data Row block iterator interface that gets RowBlocks Difference betwee...">RowBlockIter</a> and <a class="el" href="classdmlc_1_1Parser.html" title="parser interface that parses input data used to load dmlc data format into your own data format Diffe...">Parser</a>: <a class="el" href="classdmlc_1_1RowBlockIter.html" title="Data structure that holds the data Row block iterator interface that gets RowBlocks Difference betwee...">RowBlockIter</a> caches the data internally that can be used to iterate the dataset multiple times, <a class="el" href="classdmlc_1_1Parser.html" title="parser interface that parses input data used to load dmlc data format into your own data format Diffe...">Parser</a> holds very limited internal state and was usually used to read data only once.  <a href="classdmlc_1_1RowBlockIter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1ScopedThread.html">ScopedThread</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper class to manage std::thread; uses RAII pattern to automatically join std::thread upon destruction.  <a href="classdmlc_1_1ScopedThread.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1SeekStream.html">SeekStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">interface of i/o stream that support seek  <a href="classdmlc_1_1SeekStream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1Serializable.html">Serializable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">interface for serializable objects  <a href="classdmlc_1_1Serializable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1Spinlock.html">Spinlock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple userspace spinlock implementation.  <a href="classdmlc_1_1Spinlock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1Str2T.html">Str2T</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface class that defines a single method <a class="el" href="classdmlc_1_1Str2T.html#aca32f0e0494f795c76ba5447671045c4" title="Convert a string into type T. ">get()</a> to convert a string into type T. Define template specialization of this class to define the conversion method for a particular type.  <a href="classdmlc_1_1Str2T.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1Str2T_3_01double_01_4.html">Str2T&lt; double &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization of Str2T&lt;&gt; interface for double type.  <a href="classdmlc_1_1Str2T_3_01double_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1Str2T_3_01float_01_4.html">Str2T&lt; float &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization of Str2T&lt;&gt; interface for float type.  <a href="classdmlc_1_1Str2T_3_01float_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1Str2T_3_01int32__t_01_4.html">Str2T&lt; int32_t &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization of Str2T&lt;&gt; interface for signed 32-bit integer.  <a href="classdmlc_1_1Str2T_3_01int32__t_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1Str2T_3_01int64__t_01_4.html">Str2T&lt; int64_t &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization of Str2T&lt;&gt; interface for signed 64-bit integer.  <a href="classdmlc_1_1Str2T_3_01int64__t_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1Str2T_3_01uint32__t_01_4.html">Str2T&lt; uint32_t &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization of Str2T&lt;&gt; interface for unsigned 32-bit integer.  <a href="classdmlc_1_1Str2T_3_01uint32__t_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1Str2T_3_01uint64__t_01_4.html">Str2T&lt; uint64_t &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization of Str2T&lt;&gt; interface for unsigned 64-bit integer.  <a href="classdmlc_1_1Str2T_3_01uint64__t_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1Stream.html">Stream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">interface of stream I/O for serialization  <a href="classdmlc_1_1Stream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1TemporaryDirectory.html">TemporaryDirectory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manager class for temporary directories. Whenever a new <a class="el" href="classdmlc_1_1TemporaryDirectory.html" title="Manager class for temporary directories. Whenever a new TemporaryDirectory object is constructed...">TemporaryDirectory</a> object is constructed, a temporary directory is created. The directory is deleted when the object is deleted or goes out of scope. Note: no symbolic links are allowed inside the temporary directory.  <a href="classdmlc_1_1TemporaryDirectory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1ThreadedIter.html">ThreadedIter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a iterator that was backed by a thread to pull data eagerly from a single producer into a bounded buffer the consumer can pull the data at its own rate  <a href="classdmlc_1_1ThreadedIter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1ThreadGroup.html">ThreadGroup</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classdmlc_1_1ThreadGroup_1_1Thread.html" title="Lifecycle-managed thread (used by ThreadGroup) ">Thread</a> lifecycle management group.  <a href="classdmlc_1_1ThreadGroup.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1ThreadlocalAllocator.html">ThreadlocalAllocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A thread local allocator that get memory from a threadlocal memory pool. This is suitable to allocate objects that do not cross thread.  <a href="classdmlc_1_1ThreadlocalAllocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdmlc_1_1ThreadlocalSharedPtr.html">ThreadlocalSharedPtr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a shared pointer like type that allocate object from a threadlocal object pool. This object is not thread-safe but can be faster than shared_ptr in certain usecases.  <a href="structdmlc_1_1ThreadlocalSharedPtr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1ThreadLocalStore.html">ThreadLocalStore</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A threadlocal store to store threadlocal variables. Will return a thread local singleton of type T.  <a href="classdmlc_1_1ThreadLocalStore.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1TimerThread.html">TimerThread</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed timer thread.  <a href="classdmlc_1_1TimerThread.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdmlc_1_1type__name__helper.html">type_name_helper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper class to construct a string that represents type name  <a href="structdmlc_1_1type__name__helper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdmlc_1_1type__name__helper_3_01mxnet_1_1Tuple_3_01T_01_4_01_4.html">type_name_helper&lt; mxnet::Tuple&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdmlc_1_1type__name__helper_3_01nnvm_1_1Tuple_3_01T_01_4_01_4.html">type_name_helper&lt; nnvm::Tuple&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ab23d78846b42ebd3a436e3bc295b73f4"><td class="memItemLeft" align="right" valign="top">typedef float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#ab23d78846b42ebd3a436e3bc295b73f4">real_t</a></td></tr>
<tr class="memdesc:ab23d78846b42ebd3a436e3bc295b73f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">this defines the float point that will be used to store feature values  <a href="#ab23d78846b42ebd3a436e3bc295b73f4">More...</a><br /></td></tr>
<tr class="separator:ab23d78846b42ebd3a436e3bc295b73f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a89c6e0909617034aa818dafe83a361"><td class="memItemLeft" align="right" valign="top">typedef unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#a7a89c6e0909617034aa818dafe83a361">index_t</a></td></tr>
<tr class="memdesc:a7a89c6e0909617034aa818dafe83a361"><td class="mdescLeft">&#160;</td><td class="mdescRight">this defines the unsigned integer type that can normally be used to store feature index  <a href="#a7a89c6e0909617034aa818dafe83a361">More...</a><br /></td></tr>
<tr class="separator:a7a89c6e0909617034aa818dafe83a361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34fec5df74dfed6c51540a1fcf5bae54"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#a34fec5df74dfed6c51540a1fcf5bae54">SharedMutex</a> = std::recursive_mutex</td></tr>
<tr class="memdesc:a34fec5df74dfed6c51540a1fcf5bae54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard mutex for C++ &lt; 14.  <a href="#a34fec5df74dfed6c51540a1fcf5bae54">More...</a><br /></td></tr>
<tr class="separator:a34fec5df74dfed6c51540a1fcf5bae54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad58a9dfecc6e970348c217de29bb916"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#aad58a9dfecc6e970348c217de29bb916">WriteLock</a> = std::unique_lock&lt; <a class="el" href="namespacedmlc.html#a34fec5df74dfed6c51540a1fcf5bae54">SharedMutex</a> &gt;</td></tr>
<tr class="memdesc:aad58a9dfecc6e970348c217de29bb916"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard unique lock for C++ &lt; 14.  <a href="#aad58a9dfecc6e970348c217de29bb916">More...</a><br /></td></tr>
<tr class="separator:aad58a9dfecc6e970348c217de29bb916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a591cc4d1980f6074fbc450bcf9d40876"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#a591cc4d1980f6074fbc450bcf9d40876">ReadLock</a> = std::unique_lock&lt; <a class="el" href="namespacedmlc.html#a34fec5df74dfed6c51540a1fcf5bae54">SharedMutex</a> &gt;</td></tr>
<tr class="memdesc:a591cc4d1980f6074fbc450bcf9d40876"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard unique lock for C++ &lt; 14.  <a href="#a591cc4d1980f6074fbc450bcf9d40876">More...</a><br /></td></tr>
<tr class="separator:a591cc4d1980f6074fbc450bcf9d40876"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:aa9dd9270ccf6f3442c9d9af5300fb2cf"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#aa9dd9270ccf6f3442c9d9af5300fb2cf">ConcurrentQueueType</a> { <a class="el" href="namespacedmlc.html#aa9dd9270ccf6f3442c9d9af5300fb2cfa5a986096cebd351a04b4720be719ec8c">ConcurrentQueueType::kFIFO</a>, 
<a class="el" href="namespacedmlc.html#aa9dd9270ccf6f3442c9d9af5300fb2cfa140635f78446d3b7e16e1bed1772e754">ConcurrentQueueType::kPriority</a>
 }<tr class="memdesc:aa9dd9270ccf6f3442c9d9af5300fb2cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of concurrent queue  <a href="namespacedmlc.html#aa9dd9270ccf6f3442c9d9af5300fb2cf">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:aa9dd9270ccf6f3442c9d9af5300fb2cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a62bd2fe3e7c1902c42e70245cd6983bd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a62bd2fe3e7c1902c42e70245cd6983bd"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#a62bd2fe3e7c1902c42e70245cd6983bd">BeginPtr</a> (std::vector&lt; T &gt; &amp;vec)</td></tr>
<tr class="memdesc:a62bd2fe3e7c1902c42e70245cd6983bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">safely get the beginning address of a vector  <a href="#a62bd2fe3e7c1902c42e70245cd6983bd">More...</a><br /></td></tr>
<tr class="separator:a62bd2fe3e7c1902c42e70245cd6983bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a787d6b6919d4127ce5a968b8f63adf"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8a787d6b6919d4127ce5a968b8f63adf"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#a8a787d6b6919d4127ce5a968b8f63adf">BeginPtr</a> (const std::vector&lt; T &gt; &amp;vec)</td></tr>
<tr class="memdesc:a8a787d6b6919d4127ce5a968b8f63adf"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the beginning address of a const vector  <a href="#a8a787d6b6919d4127ce5a968b8f63adf">More...</a><br /></td></tr>
<tr class="separator:a8a787d6b6919d4127ce5a968b8f63adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81a7936da19fbc1dd4715b746e3d41ba"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#a81a7936da19fbc1dd4715b746e3d41ba">BeginPtr</a> (std::string &amp;str)</td></tr>
<tr class="memdesc:a81a7936da19fbc1dd4715b746e3d41ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the beginning address of a string  <a href="#a81a7936da19fbc1dd4715b746e3d41ba">More...</a><br /></td></tr>
<tr class="separator:a81a7936da19fbc1dd4715b746e3d41ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae07e0f993322f84664f7c99d1f41cf82"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#ae07e0f993322f84664f7c99d1f41cf82">BeginPtr</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:ae07e0f993322f84664f7c99d1f41cf82"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the beginning address of a const string  <a href="#ae07e0f993322f84664f7c99d1f41cf82">More...</a><br /></td></tr>
<tr class="separator:ae07e0f993322f84664f7c99d1f41cf82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a28a7405b2f734090912c073434091c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#a3a28a7405b2f734090912c073434091c">Split</a> (const std::string &amp;s, char delim)</td></tr>
<tr class="memdesc:a3a28a7405b2f734090912c073434091c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a string by delimiter.  <a href="#a3a28a7405b2f734090912c073434091c">More...</a><br /></td></tr>
<tr class="separator:a3a28a7405b2f734090912c073434091c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8620a9c7572cd3aab1ed3135b7a8e137"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8620a9c7572cd3aab1ed3135b7a8e137"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#a8620a9c7572cd3aab1ed3135b7a8e137">HashCombine</a> (size_t key, const T &amp;value)</td></tr>
<tr class="memdesc:a8620a9c7572cd3aab1ed3135b7a8e137"><td class="mdescLeft">&#160;</td><td class="mdescRight">hash an object and combines the key with previous keys  <a href="#a8620a9c7572cd3aab1ed3135b7a8e137">More...</a><br /></td></tr>
<tr class="separator:a8620a9c7572cd3aab1ed3135b7a8e137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0be2b34771107606d968712e54b25ce6"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a0be2b34771107606d968712e54b25ce6"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#a0be2b34771107606d968712e54b25ce6">HashCombine&lt; size_t &gt;</a> (size_t key, const size_t &amp;value)</td></tr>
<tr class="memdesc:a0be2b34771107606d968712e54b25ce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialize for size_t  <a href="#a0be2b34771107606d968712e54b25ce6">More...</a><br /></td></tr>
<tr class="separator:a0be2b34771107606d968712e54b25ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbe9d2411f71ee9f165b44bd0a6fbad1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#adbe9d2411f71ee9f165b44bd0a6fbad1">ByteSwap</a> (void *data, size_t elem_bytes, size_t num_elems)</td></tr>
<tr class="memdesc:adbe9d2411f71ee9f165b44bd0a6fbad1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic inplace byte swapping function.  <a href="#adbe9d2411f71ee9f165b44bd0a6fbad1">More...</a><br /></td></tr>
<tr class="separator:adbe9d2411f71ee9f165b44bd0a6fbad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf31f99192b5ed0d5d77398d58023912"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acf31f99192b5ed0d5d77398d58023912"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#acf31f99192b5ed0d5d77398d58023912">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classdmlc_1_1optional.html">optional</a>&lt; T &gt; &amp;t)</td></tr>
<tr class="memdesc:acf31f99192b5ed0d5d77398d58023912"><td class="mdescLeft">&#160;</td><td class="mdescRight">serialize an optional object to string.  <a href="#acf31f99192b5ed0d5d77398d58023912">More...</a><br /></td></tr>
<tr class="separator:acf31f99192b5ed0d5d77398d58023912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc4b71c13985425358cb63cc45d49512"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acc4b71c13985425358cb63cc45d49512"><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#acc4b71c13985425358cb63cc45d49512">operator&gt;&gt;</a> (std::istream &amp;is, <a class="el" href="classdmlc_1_1optional.html">optional</a>&lt; T &gt; &amp;t)</td></tr>
<tr class="memdesc:acc4b71c13985425358cb63cc45d49512"><td class="mdescLeft">&#160;</td><td class="mdescRight">parse a string object into optional&lt;T&gt;  <a href="#acc4b71c13985425358cb63cc45d49512">More...</a><br /></td></tr>
<tr class="separator:acc4b71c13985425358cb63cc45d49512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5018d09b0f92f75d2c3ee572f62c0346"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#a5018d09b0f92f75d2c3ee572f62c0346">operator&gt;&gt;</a> (std::istream &amp;is, <a class="el" href="classdmlc_1_1optional.html">optional</a>&lt; bool &gt; &amp;t)</td></tr>
<tr class="memdesc:a5018d09b0f92f75d2c3ee572f62c0346"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialization of '&gt;&gt;' istream parsing for optional&lt;bool&gt;  <a href="#a5018d09b0f92f75d2c3ee572f62c0346">More...</a><br /></td></tr>
<tr class="separator:a5018d09b0f92f75d2c3ee572f62c0346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b77ebc5503453ec022a011c89e7d9a0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#a6b77ebc5503453ec022a011c89e7d9a0">DMLC_DECLARE_TYPE_NAME</a> (<a class="el" href="classdmlc_1_1optional.html">optional</a>&lt; int &gt;,&quot;int or None&quot;)</td></tr>
<tr class="memdesc:a6b77ebc5503453ec022a011c89e7d9a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">description for optional int  <a href="#a6b77ebc5503453ec022a011c89e7d9a0">More...</a><br /></td></tr>
<tr class="separator:a6b77ebc5503453ec022a011c89e7d9a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8190c53a1e172499c145a8bba96b9dae"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#a8190c53a1e172499c145a8bba96b9dae">DMLC_DECLARE_TYPE_NAME</a> (<a class="el" href="classdmlc_1_1optional.html">optional</a>&lt; bool &gt;,&quot;boolean or None&quot;)</td></tr>
<tr class="memdesc:a8190c53a1e172499c145a8bba96b9dae"><td class="mdescLeft">&#160;</td><td class="mdescRight">description for optional bool  <a href="#a8190c53a1e172499c145a8bba96b9dae">More...</a><br /></td></tr>
<tr class="separator:a8190c53a1e172499c145a8bba96b9dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa968c0e4fc27336c3fa3f6b42dbed591"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#aa968c0e4fc27336c3fa3f6b42dbed591">DMLC_DECLARE_TYPE_NAME</a> (<a class="el" href="classdmlc_1_1optional.html">optional</a>&lt; float &gt;,&quot;float or None&quot;)</td></tr>
<tr class="memdesc:aa968c0e4fc27336c3fa3f6b42dbed591"><td class="mdescLeft">&#160;</td><td class="mdescRight">description for optional float  <a href="#aa968c0e4fc27336c3fa3f6b42dbed591">More...</a><br /></td></tr>
<tr class="separator:aa968c0e4fc27336c3fa3f6b42dbed591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc48dd106b1a9542db8a4baf13760bbc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#adc48dd106b1a9542db8a4baf13760bbc">DMLC_DECLARE_TYPE_NAME</a> (<a class="el" href="classdmlc_1_1optional.html">optional</a>&lt; double &gt;,&quot;double or None&quot;)</td></tr>
<tr class="memdesc:adc48dd106b1a9542db8a4baf13760bbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">description for optional double  <a href="#adc48dd106b1a9542db8a4baf13760bbc">More...</a><br /></td></tr>
<tr class="separator:adc48dd106b1a9542db8a4baf13760bbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52dcf01c9ba22be9b08e455194fb2ab3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#a52dcf01c9ba22be9b08e455194fb2ab3">isspace</a> (char c)</td></tr>
<tr class="memdesc:a52dcf01c9ba22be9b08e455194fb2ab3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inline implementation of <a class="el" href="namespacedmlc.html#a52dcf01c9ba22be9b08e455194fb2ab3" title="Inline implementation of isspace(). Tests whether the given character is a whitespace letter...">isspace()</a>. Tests whether the given character is a whitespace letter.  <a href="#a52dcf01c9ba22be9b08e455194fb2ab3">More...</a><br /></td></tr>
<tr class="separator:a52dcf01c9ba22be9b08e455194fb2ab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a382379acc79620379a9f7ee29ad5caaf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#a382379acc79620379a9f7ee29ad5caaf">isblank</a> (char c)</td></tr>
<tr class="memdesc:a382379acc79620379a9f7ee29ad5caaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inline implementation of <a class="el" href="namespacedmlc.html#a382379acc79620379a9f7ee29ad5caaf" title="Inline implementation of isblank(). Tests whether the given character is a space or tab character...">isblank()</a>. Tests whether the given character is a space or tab character.  <a href="#a382379acc79620379a9f7ee29ad5caaf">More...</a><br /></td></tr>
<tr class="separator:a382379acc79620379a9f7ee29ad5caaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dab1c816301d0261e96d002ab157d3a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#a5dab1c816301d0261e96d002ab157d3a">isdigit</a> (char c)</td></tr>
<tr class="memdesc:a5dab1c816301d0261e96d002ab157d3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inline implementation of <a class="el" href="namespacedmlc.html#a5dab1c816301d0261e96d002ab157d3a" title="Inline implementation of isdigit(). Tests whether the given character is a decimal digit...">isdigit()</a>. Tests whether the given character is a decimal digit.  <a href="#a5dab1c816301d0261e96d002ab157d3a">More...</a><br /></td></tr>
<tr class="separator:a5dab1c816301d0261e96d002ab157d3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8234006cb1d67dcba5f9f856fe805c19"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#a8234006cb1d67dcba5f9f856fe805c19">isalpha</a> (char c)</td></tr>
<tr class="memdesc:a8234006cb1d67dcba5f9f856fe805c19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inline implementation of <a class="el" href="namespacedmlc.html#a8234006cb1d67dcba5f9f856fe805c19" title="Inline implementation of isalpha(). Tests whether the given character is an alphabet letter...">isalpha()</a>. Tests whether the given character is an alphabet letter.  <a href="#a8234006cb1d67dcba5f9f856fe805c19">More...</a><br /></td></tr>
<tr class="separator:a8234006cb1d67dcba5f9f856fe805c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadc240ae898cb7f29bd88c5bd96bd3cb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#aadc240ae898cb7f29bd88c5bd96bd3cb">isdigitchars</a> (char c)</td></tr>
<tr class="memdesc:aadc240ae898cb7f29bd88c5bd96bd3cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether the given character is a valid letter in the string representation of a floating-point value, i.e. decimal digits, signs (+/-), decimal point (.), or exponent marker (e/E).  <a href="#aadc240ae898cb7f29bd88c5bd96bd3cb">More...</a><br /></td></tr>
<tr class="separator:aadc240ae898cb7f29bd88c5bd96bd3cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade80237502ab5ae86b9c1454a09c66ee"><td class="memTemplParams" colspan="2">template&lt;typename FloatType , bool CheckRange = false&gt; </td></tr>
<tr class="memitem:ade80237502ab5ae86b9c1454a09c66ee"><td class="memTemplItemLeft" align="right" valign="top">FloatType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#ade80237502ab5ae86b9c1454a09c66ee">ParseFloat</a> (const char *nptr, char **endptr)</td></tr>
<tr class="memdesc:ade80237502ab5ae86b9c1454a09c66ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common implementation for <a class="el" href="namespacedmlc.html#a93c2c8f7859b02cecb9c094cddd91af9" title="A faster implementation of strtof(). See documentation of std::strtof() for more information. Note that this function does not check for overflow. Use strtof_check_range() to check for overflow. TODO: the current version does not support hex number TODO: the current version does not handle long decimals: you may only have up to 19 digits after the decimal point, and you cannot have too many digits before the decimal point either. ">dmlc::strtof()</a> and <a class="el" href="namespacedmlc.html#a345b262c3cbb6d700c22c4d69d46db6e" title="A faster implementation of strtod(). See documentation of std::strtof() for more information. Note that this function does not check for overflow. Use strtod_check_range() to check for overflow. TODO: the current version does not support hex number TODO: the current version does not handle long decimals: you may only have up to 19 digits after the decimal point, and you cannot have too many digits before the decimal point either. ">dmlc::strtod()</a> TODO: the current version does not support hex number.  <a href="#ade80237502ab5ae86b9c1454a09c66ee">More...</a><br /></td></tr>
<tr class="separator:ade80237502ab5ae86b9c1454a09c66ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93c2c8f7859b02cecb9c094cddd91af9"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#a93c2c8f7859b02cecb9c094cddd91af9">strtof</a> (const char *nptr, char **endptr)</td></tr>
<tr class="memdesc:a93c2c8f7859b02cecb9c094cddd91af9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A faster implementation of <a class="el" href="namespacedmlc.html#a93c2c8f7859b02cecb9c094cddd91af9" title="A faster implementation of strtof(). See documentation of std::strtof() for more information. Note that this function does not check for overflow. Use strtof_check_range() to check for overflow. TODO: the current version does not support hex number TODO: the current version does not handle long decimals: you may only have up to 19 digits after the decimal point, and you cannot have too many digits before the decimal point either. ">strtof()</a>. See documentation of <a class="el" href="namespacedmlc.html#a93c2c8f7859b02cecb9c094cddd91af9" title="A faster implementation of strtof(). See documentation of std::strtof() for more information. Note that this function does not check for overflow. Use strtof_check_range() to check for overflow. TODO: the current version does not support hex number TODO: the current version does not handle long decimals: you may only have up to 19 digits after the decimal point, and you cannot have too many digits before the decimal point either. ">std::strtof()</a> for more information. Note that this function does not check for overflow. Use <a class="el" href="namespacedmlc.html#a3717fca311a75301eedca7e77e744459" title="A faster implementation of strtof(). See documentation of std::strtof() for more information. This function will check for overflow. If the converted value is outside the range for the float type, errno is set to ERANGE and HUGE_VALF is returned. TODO: the current version does not support hex number TODO: the current version does not handle long decimals: you may only have up to 19 digits after the decimal point, and you cannot have too many digits before the decimal point either. ">strtof_check_range()</a> to check for overflow. TODO: the current version does not support hex number TODO: the current version does not handle long decimals: you may only have up to 19 digits after the decimal point, and you cannot have too many digits before the decimal point either.  <a href="#a93c2c8f7859b02cecb9c094cddd91af9">More...</a><br /></td></tr>
<tr class="separator:a93c2c8f7859b02cecb9c094cddd91af9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3717fca311a75301eedca7e77e744459"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#a3717fca311a75301eedca7e77e744459">strtof_check_range</a> (const char *nptr, char **endptr)</td></tr>
<tr class="memdesc:a3717fca311a75301eedca7e77e744459"><td class="mdescLeft">&#160;</td><td class="mdescRight">A faster implementation of <a class="el" href="namespacedmlc.html#a93c2c8f7859b02cecb9c094cddd91af9" title="A faster implementation of strtof(). See documentation of std::strtof() for more information. Note that this function does not check for overflow. Use strtof_check_range() to check for overflow. TODO: the current version does not support hex number TODO: the current version does not handle long decimals: you may only have up to 19 digits after the decimal point, and you cannot have too many digits before the decimal point either. ">strtof()</a>. See documentation of <a class="el" href="namespacedmlc.html#a93c2c8f7859b02cecb9c094cddd91af9" title="A faster implementation of strtof(). See documentation of std::strtof() for more information. Note that this function does not check for overflow. Use strtof_check_range() to check for overflow. TODO: the current version does not support hex number TODO: the current version does not handle long decimals: you may only have up to 19 digits after the decimal point, and you cannot have too many digits before the decimal point either. ">std::strtof()</a> for more information. This function will check for overflow. If the converted value is outside the range for the float type, errno is set to ERANGE and HUGE_VALF is returned. TODO: the current version does not support hex number TODO: the current version does not handle long decimals: you may only have up to 19 digits after the decimal point, and you cannot have too many digits before the decimal point either.  <a href="#a3717fca311a75301eedca7e77e744459">More...</a><br /></td></tr>
<tr class="separator:a3717fca311a75301eedca7e77e744459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a345b262c3cbb6d700c22c4d69d46db6e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#a345b262c3cbb6d700c22c4d69d46db6e">strtod</a> (const char *nptr, char **endptr)</td></tr>
<tr class="memdesc:a345b262c3cbb6d700c22c4d69d46db6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A faster implementation of <a class="el" href="namespacedmlc.html#a345b262c3cbb6d700c22c4d69d46db6e" title="A faster implementation of strtod(). See documentation of std::strtof() for more information. Note that this function does not check for overflow. Use strtod_check_range() to check for overflow. TODO: the current version does not support hex number TODO: the current version does not handle long decimals: you may only have up to 19 digits after the decimal point, and you cannot have too many digits before the decimal point either. ">strtod()</a>. See documentation of <a class="el" href="namespacedmlc.html#a93c2c8f7859b02cecb9c094cddd91af9" title="A faster implementation of strtof(). See documentation of std::strtof() for more information. Note that this function does not check for overflow. Use strtof_check_range() to check for overflow. TODO: the current version does not support hex number TODO: the current version does not handle long decimals: you may only have up to 19 digits after the decimal point, and you cannot have too many digits before the decimal point either. ">std::strtof()</a> for more information. Note that this function does not check for overflow. Use <a class="el" href="namespacedmlc.html#abd212a404ead6ae94faa2b65b4af796d" title="A faster implementation of strtod(). See documentation of std::strtod() for more information. This function will check for overflow. If the converted value is outside the range for the double type, errno is set to ERANGE and HUGE_VAL is returned. TODO: the current version does not support hex number TODO: the current version does not handle long decimals: you may only have up to 19 digits after the decimal point, and you cannot have too many digits before the decimal point either. ">strtod_check_range()</a> to check for overflow. TODO: the current version does not support hex number TODO: the current version does not handle long decimals: you may only have up to 19 digits after the decimal point, and you cannot have too many digits before the decimal point either.  <a href="#a345b262c3cbb6d700c22c4d69d46db6e">More...</a><br /></td></tr>
<tr class="separator:a345b262c3cbb6d700c22c4d69d46db6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd212a404ead6ae94faa2b65b4af796d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#abd212a404ead6ae94faa2b65b4af796d">strtod_check_range</a> (const char *nptr, char **endptr)</td></tr>
<tr class="memdesc:abd212a404ead6ae94faa2b65b4af796d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A faster implementation of <a class="el" href="namespacedmlc.html#a345b262c3cbb6d700c22c4d69d46db6e" title="A faster implementation of strtod(). See documentation of std::strtof() for more information. Note that this function does not check for overflow. Use strtod_check_range() to check for overflow. TODO: the current version does not support hex number TODO: the current version does not handle long decimals: you may only have up to 19 digits after the decimal point, and you cannot have too many digits before the decimal point either. ">strtod()</a>. See documentation of <a class="el" href="namespacedmlc.html#a345b262c3cbb6d700c22c4d69d46db6e" title="A faster implementation of strtod(). See documentation of std::strtof() for more information. Note that this function does not check for overflow. Use strtod_check_range() to check for overflow. TODO: the current version does not support hex number TODO: the current version does not handle long decimals: you may only have up to 19 digits after the decimal point, and you cannot have too many digits before the decimal point either. ">std::strtod()</a> for more information. This function will check for overflow. If the converted value is outside the range for the double type, errno is set to ERANGE and HUGE_VAL is returned. TODO: the current version does not support hex number TODO: the current version does not handle long decimals: you may only have up to 19 digits after the decimal point, and you cannot have too many digits before the decimal point either.  <a href="#abd212a404ead6ae94faa2b65b4af796d">More...</a><br /></td></tr>
<tr class="separator:abd212a404ead6ae94faa2b65b4af796d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe766bbcae14a7ff2720bb248cca0db9"><td class="memTemplParams" colspan="2">template&lt;typename SignedIntType &gt; </td></tr>
<tr class="memitem:abe766bbcae14a7ff2720bb248cca0db9"><td class="memTemplItemLeft" align="right" valign="top">SignedIntType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#abe766bbcae14a7ff2720bb248cca0db9">ParseSignedInt</a> (const char *nptr, char **endptr, int base)</td></tr>
<tr class="memdesc:abe766bbcae14a7ff2720bb248cca0db9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A fast string-to-integer convertor, for signed integers TODO: the current version supports only base &lt;= 10.  <a href="#abe766bbcae14a7ff2720bb248cca0db9">More...</a><br /></td></tr>
<tr class="separator:abe766bbcae14a7ff2720bb248cca0db9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5d2f93a1b7b7683df3c674e0c3d1863"><td class="memTemplParams" colspan="2">template&lt;typename UnsignedIntType &gt; </td></tr>
<tr class="memitem:ae5d2f93a1b7b7683df3c674e0c3d1863"><td class="memTemplItemLeft" align="right" valign="top">UnsignedIntType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#ae5d2f93a1b7b7683df3c674e0c3d1863">ParseUnsignedInt</a> (const char *nptr, char **endptr, int base)</td></tr>
<tr class="memdesc:ae5d2f93a1b7b7683df3c674e0c3d1863"><td class="mdescLeft">&#160;</td><td class="mdescRight">A fast string-to-integer convertor, for unsigned integers TODO: the current version supports only base &lt;= 10.  <a href="#ae5d2f93a1b7b7683df3c674e0c3d1863">More...</a><br /></td></tr>
<tr class="separator:ae5d2f93a1b7b7683df3c674e0c3d1863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac63dcf48b6a8ec204720a121f01477e9"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#ac63dcf48b6a8ec204720a121f01477e9">strtoull</a> (const char *nptr, char **endptr, int base)</td></tr>
<tr class="memdesc:ac63dcf48b6a8ec204720a121f01477e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A faster implementation of <a class="el" href="namespacedmlc.html#ac63dcf48b6a8ec204720a121f01477e9" title="A faster implementation of strtoull(). See documentation of std::strtoull() for more information...">strtoull()</a>. See documentation of <a class="el" href="namespacedmlc.html#ac63dcf48b6a8ec204720a121f01477e9" title="A faster implementation of strtoull(). See documentation of std::strtoull() for more information...">std::strtoull()</a> for more information. Note that this function does not check for overflow. TODO: the current version supports only base &lt;= 10.  <a href="#ac63dcf48b6a8ec204720a121f01477e9">More...</a><br /></td></tr>
<tr class="separator:ac63dcf48b6a8ec204720a121f01477e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46a57f902842152f71261ab44e887017"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#a46a57f902842152f71261ab44e887017">atol</a> (const char *p)</td></tr>
<tr class="memdesc:a46a57f902842152f71261ab44e887017"><td class="mdescLeft">&#160;</td><td class="mdescRight">A faster implementation of <a class="el" href="namespacedmlc.html#a46a57f902842152f71261ab44e887017" title="A faster implementation of atol(). See documentation of std::atol() for more information. This function will use base 10. Note that this function does not check for overflow. ">atol()</a>. See documentation of <a class="el" href="namespacedmlc.html#a46a57f902842152f71261ab44e887017" title="A faster implementation of atol(). See documentation of std::atol() for more information. This function will use base 10. Note that this function does not check for overflow. ">std::atol()</a> for more information. This function will use base 10. Note that this function does not check for overflow.  <a href="#a46a57f902842152f71261ab44e887017">More...</a><br /></td></tr>
<tr class="separator:a46a57f902842152f71261ab44e887017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c6820d1e6705361c263364b709d15a8"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#a4c6820d1e6705361c263364b709d15a8">atof</a> (const char *nptr)</td></tr>
<tr class="memdesc:a4c6820d1e6705361c263364b709d15a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A faster implementation of <a class="el" href="namespacedmlc.html#a4c6820d1e6705361c263364b709d15a8" title="A faster implementation of atof(). Unlike std::atof(), this function returns float type...">atof()</a>. Unlike <a class="el" href="namespacedmlc.html#a4c6820d1e6705361c263364b709d15a8" title="A faster implementation of atof(). Unlike std::atof(), this function returns float type...">std::atof()</a>, this function returns float type. Note that this function does not check for overflow. TODO: the current version does not support hex number TODO: the current version does not handle long decimals: you may only have up to 19 digits after the decimal point, and you cannot have too many digits before the decimal point either.  <a href="#a4c6820d1e6705361c263364b709d15a8">More...</a><br /></td></tr>
<tr class="separator:a4c6820d1e6705361c263364b709d15a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43a149fb880b527d393975a884255341"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#a43a149fb880b527d393975a884255341">stof</a> (const std::string &amp;value, size_t *pos=nullptr)</td></tr>
<tr class="memdesc:a43a149fb880b527d393975a884255341"><td class="mdescLeft">&#160;</td><td class="mdescRight">A faster implementation of <a class="el" href="namespacedmlc.html#a43a149fb880b527d393975a884255341" title="A faster implementation of stof(). See documentation of std::stof() for more information. This function will test for overflow and invalid arguments. TODO: the current version does not support hex number TODO: the current version does not handle long decimals: you may only have up to 19 digits after the decimal point, and you cannot have too many digits before the decimal point either. ">stof()</a>. See documentation of <a class="el" href="namespacedmlc.html#a43a149fb880b527d393975a884255341" title="A faster implementation of stof(). See documentation of std::stof() for more information. This function will test for overflow and invalid arguments. TODO: the current version does not support hex number TODO: the current version does not handle long decimals: you may only have up to 19 digits after the decimal point, and you cannot have too many digits before the decimal point either. ">std::stof()</a> for more information. This function will test for overflow and invalid arguments. TODO: the current version does not support hex number TODO: the current version does not handle long decimals: you may only have up to 19 digits after the decimal point, and you cannot have too many digits before the decimal point either.  <a href="#a43a149fb880b527d393975a884255341">More...</a><br /></td></tr>
<tr class="separator:a43a149fb880b527d393975a884255341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f49479b0736b8709986ead800e1bfdc"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#a5f49479b0736b8709986ead800e1bfdc">stod</a> (const std::string &amp;value, size_t *pos=nullptr)</td></tr>
<tr class="memdesc:a5f49479b0736b8709986ead800e1bfdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">A faster implementation of <a class="el" href="namespacedmlc.html#a5f49479b0736b8709986ead800e1bfdc" title="A faster implementation of stod(). See documentation of std::stod() for more information. This function will test for overflow and invalid arguments. TODO: the current version does not support hex number TODO: the current version does not handle long decimals: you may only have up to 19 digits after the decimal point, and you cannot have too many digits before the decimal point either. ">stod()</a>. See documentation of <a class="el" href="namespacedmlc.html#a5f49479b0736b8709986ead800e1bfdc" title="A faster implementation of stod(). See documentation of std::stod() for more information. This function will test for overflow and invalid arguments. TODO: the current version does not support hex number TODO: the current version does not handle long decimals: you may only have up to 19 digits after the decimal point, and you cannot have too many digits before the decimal point either. ">std::stod()</a> for more information. This function will test for overflow and invalid arguments. TODO: the current version does not support hex number TODO: the current version does not handle long decimals: you may only have up to 19 digits after the decimal point, and you cannot have too many digits before the decimal point either.  <a href="#a5f49479b0736b8709986ead800e1bfdc">More...</a><br /></td></tr>
<tr class="separator:a5f49479b0736b8709986ead800e1bfdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a890c9ebefc22941afb32fd849b1b3a3f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a890c9ebefc22941afb32fd849b1b3a3f"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#a890c9ebefc22941afb32fd849b1b3a3f">Str2Type</a> (const char *begin, const char *end)</td></tr>
<tr class="memdesc:a890c9ebefc22941afb32fd849b1b3a3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function for converting string into type T.  <a href="#a890c9ebefc22941afb32fd849b1b3a3f">More...</a><br /></td></tr>
<tr class="separator:a890c9ebefc22941afb32fd849b1b3a3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1bd2f744b450d3a7a06fd4e4276f667"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ac1bd2f744b450d3a7a06fd4e4276f667"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#ac1bd2f744b450d3a7a06fd4e4276f667">ParsePair</a> (const char *begin, const char *end, const char **endptr, T1 &amp;v1, T2 &amp;v2)</td></tr>
<tr class="memdesc:ac1bd2f744b450d3a7a06fd4e4276f667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse colon seperated pair v1[:v2].  <a href="#ac1bd2f744b450d3a7a06fd4e4276f667">More...</a><br /></td></tr>
<tr class="separator:ac1bd2f744b450d3a7a06fd4e4276f667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade27d0fd3a6c3e57a64e225a78e56ced"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 &gt; </td></tr>
<tr class="memitem:ade27d0fd3a6c3e57a64e225a78e56ced"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#ade27d0fd3a6c3e57a64e225a78e56ced">ParseTriple</a> (const char *begin, const char *end, const char **endptr, T1 &amp;v1, T2 &amp;v2, T3 &amp;v3)</td></tr>
<tr class="memdesc:ade27d0fd3a6c3e57a64e225a78e56ced"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse colon seperated triple v1:v2[:v3].  <a href="#ade27d0fd3a6c3e57a64e225a78e56ced">More...</a><br /></td></tr>
<tr class="separator:ade27d0fd3a6c3e57a64e225a78e56ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3af1c5a5f5dd3a6741693071f85d67ce"><td class="memTemplParams" colspan="2">template&lt;typename Duration , typename TimerFunction &gt; </td></tr>
<tr class="memitem:a3af1c5a5f5dd3a6741693071f85d67ce"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#a3af1c5a5f5dd3a6741693071f85d67ce">CreateTimer</a> (const std::string &amp;timer_name, const Duration &amp;duration, <a class="el" href="classdmlc_1_1ThreadGroup.html">ThreadGroup</a> *owner, TimerFunction timer_function)</td></tr>
<tr class="memdesc:a3af1c5a5f5dd3a6741693071f85d67ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to easily create a timer.  <a href="#a3af1c5a5f5dd3a6741693071f85d67ce">More...</a><br /></td></tr>
<tr class="separator:a3af1c5a5f5dd3a6741693071f85d67ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6607ababd562edcce61938343ae0db6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#ac6607ababd562edcce61938343ae0db6">GetTime</a> (void)</td></tr>
<tr class="memdesc:ac6607ababd562edcce61938343ae0db6"><td class="mdescLeft">&#160;</td><td class="mdescRight">return time in seconds  <a href="#ac6607ababd562edcce61938343ae0db6">More...</a><br /></td></tr>
<tr class="separator:ac6607ababd562edcce61938343ae0db6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e731f276d3a3efa8e17f46ccf35f828"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1e731f276d3a3efa8e17f46ccf35f828"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#a1e731f276d3a3efa8e17f46ccf35f828">type_name</a> ()</td></tr>
<tr class="memdesc:a1e731f276d3a3efa8e17f46ccf35f828"><td class="mdescLeft">&#160;</td><td class="mdescRight">the string representation of type name  <a href="#a1e731f276d3a3efa8e17f46ccf35f828">More...</a><br /></td></tr>
<tr class="separator:a1e731f276d3a3efa8e17f46ccf35f828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7272c846fa03dee55916aadce0165a46"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#a7272c846fa03dee55916aadce0165a46">DMLC_DECLARE_TRAITS</a> (<a class="el" href="structdmlc_1_1has__saveload.html">has_saveload</a>, <a class="el" href="classmxnet_1_1NDArray.html">mxnet::NDArray</a>, true)</td></tr>
<tr class="memdesc:a7272c846fa03dee55916aadce0165a46"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits  <a href="#a7272c846fa03dee55916aadce0165a46">More...</a><br /></td></tr>
<tr class="separator:a7272c846fa03dee55916aadce0165a46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bb53a09f94357722a2099ff7309f9f3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#a2bb53a09f94357722a2099ff7309f9f3">DMLC_DECLARE_TYPE_NAME</a> (<a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a>,&quot;Shape(tuple)&quot;)</td></tr>
<tr class="separator:a2bb53a09f94357722a2099ff7309f9f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad583c75721dd060377b1117b3798a5d3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#ad583c75721dd060377b1117b3798a5d3">DMLC_DECLARE_TYPE_NAME</a> (<a class="el" href="classmxnet_1_1Tuple.html">mxnet::Tuple</a>&lt; int &gt;,&quot;Shape(tuple)&quot;)</td></tr>
<tr class="separator:ad583c75721dd060377b1117b3798a5d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3316d57ba1678b6dc1d4a38c933cb04"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#aa3316d57ba1678b6dc1d4a38c933cb04">DMLC_DECLARE_TYPE_NAME</a> (<a class="el" href="classmxnet_1_1Tuple.html">mxnet::Tuple</a>&lt; <a class="el" href="classdmlc_1_1optional.html">dmlc::optional</a>&lt; int &gt;&gt;,&quot;Shape(tuple)&quot;)</td></tr>
<tr class="separator:aa3316d57ba1678b6dc1d4a38c933cb04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2dedf41507bf76166d85fe447fa95de"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#ad2dedf41507bf76166d85fe447fa95de">DMLC_DECLARE_TYPE_NAME</a> (<a class="el" href="classnnvm_1_1Tuple.html">nnvm::Tuple</a>&lt; int &gt;,&quot;Shape(tuple)&quot;)</td></tr>
<tr class="separator:ad2dedf41507bf76166d85fe447fa95de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4d7485dc06589628bb4488ec9e8b1c9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#aa4d7485dc06589628bb4488ec9e8b1c9">DMLC_DECLARE_TYPE_NAME</a> (<a class="el" href="classnnvm_1_1Tuple.html">nnvm::Tuple</a>&lt; <a class="el" href="classdmlc_1_1optional.html">dmlc::optional</a>&lt; int &gt;&gt;,&quot;Shape(tuple)&quot;)</td></tr>
<tr class="separator:aa4d7485dc06589628bb4488ec9e8b1c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc716e3c499f760565f2cb19fb06348f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#acc716e3c499f760565f2cb19fb06348f">DMLC_DECLARE_TYPE_NAME</a> (<a class="el" href="classdmlc_1_1optional.html">optional</a>&lt; <a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a> &gt;,&quot;Shape or None&quot;)</td></tr>
<tr class="memdesc:acc716e3c499f760565f2cb19fb06348f"><td class="mdescLeft">&#160;</td><td class="mdescRight">description for optional TShape  <a href="#acc716e3c499f760565f2cb19fb06348f">More...</a><br /></td></tr>
<tr class="separator:acc716e3c499f760565f2cb19fb06348f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac47f5e5624885ad9508f4ce9688ba510"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#ac47f5e5624885ad9508f4ce9688ba510">DMLC_DECLARE_TYPE_NAME</a> (<a class="el" href="classdmlc_1_1optional.html">optional</a>&lt; <a class="el" href="classmxnet_1_1Tuple.html">mxnet::Tuple</a>&lt; int &gt;&gt;,&quot;Shape or None&quot;)</td></tr>
<tr class="separator:ac47f5e5624885ad9508f4ce9688ba510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3892f01ea4c355fe1998fdbe7f386d6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#af3892f01ea4c355fe1998fdbe7f386d6">DMLC_DECLARE_TYPE_NAME</a> (<a class="el" href="classdmlc_1_1optional.html">optional</a>&lt; <a class="el" href="classnnvm_1_1TShape.html">nnvm::TShape</a> &gt;,&quot;Shape or None&quot;)</td></tr>
<tr class="memdesc:af3892f01ea4c355fe1998fdbe7f386d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">description for optional TShape  <a href="#af3892f01ea4c355fe1998fdbe7f386d6">More...</a><br /></td></tr>
<tr class="separator:af3892f01ea4c355fe1998fdbe7f386d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a7e0f62af45e67c3b6fa22080e756b379"><td class="memItemLeft" align="right" valign="top">constexpr const <a class="el" href="structdmlc_1_1nullopt__t.html">nullopt_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#a7e0f62af45e67c3b6fa22080e756b379">nullopt</a> = <a class="el" href="structdmlc_1_1nullopt__t.html">nullopt_t</a>(0)</td></tr>
<tr class="separator:a7e0f62af45e67c3b6fa22080e756b379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e6f99de792eaca82bdf6189ba6e0d77"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#a7e6f99de792eaca82bdf6189ba6e0d77">kStrtofMaxDigits</a> = 19</td></tr>
<tr class="memdesc:a7e6f99de792eaca82bdf6189ba6e0d77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of decimal digits <a class="el" href="namespacedmlc.html#a93c2c8f7859b02cecb9c094cddd91af9" title="A faster implementation of strtof(). See documentation of std::strtof() for more information. Note that this function does not check for overflow. Use strtof_check_range() to check for overflow. TODO: the current version does not support hex number TODO: the current version does not handle long decimals: you may only have up to 19 digits after the decimal point, and you cannot have too many digits before the decimal point either. ">dmlc::strtof()</a> / <a class="el" href="namespacedmlc.html#a345b262c3cbb6d700c22c4d69d46db6e" title="A faster implementation of strtod(). See documentation of std::strtof() for more information. Note that this function does not check for overflow. Use strtod_check_range() to check for overflow. TODO: the current version does not support hex number TODO: the current version does not handle long decimals: you may only have up to 19 digits after the decimal point, and you cannot have too many digits before the decimal point either. ">dmlc::strtod()</a> will process. Trailing digits will be ignored.  <a href="#a7e6f99de792eaca82bdf6189ba6e0d77">More...</a><br /></td></tr>
<tr class="separator:a7e6f99de792eaca82bdf6189ba6e0d77"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>namespace for dmlc </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a7a89c6e0909617034aa818dafe83a361"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned <a class="el" href="namespacedmlc.html#a7a89c6e0909617034aa818dafe83a361">dmlc::index_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>this defines the unsigned integer type that can normally be used to store feature index </p>

</div>
</div>
<a class="anchor" id="a591cc4d1980f6074fbc450bcf9d40876"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedmlc.html#a591cc4d1980f6074fbc450bcf9d40876">dmlc::ReadLock</a> = typedef std::unique_lock&lt;<a class="el" href="namespacedmlc.html#a34fec5df74dfed6c51540a1fcf5bae54">SharedMutex</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Standard unique lock for C++ &lt; 14. </p>

</div>
</div>
<a class="anchor" id="ab23d78846b42ebd3a436e3bc295b73f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef float <a class="el" href="namespacedmlc.html#ab23d78846b42ebd3a436e3bc295b73f4">dmlc::real_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>this defines the float point that will be used to store feature values </p>

</div>
</div>
<a class="anchor" id="a34fec5df74dfed6c51540a1fcf5bae54"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedmlc.html#a34fec5df74dfed6c51540a1fcf5bae54">dmlc::SharedMutex</a> = typedef std::recursive_mutex</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Standard mutex for C++ &lt; 14. </p>

</div>
</div>
<a class="anchor" id="aad58a9dfecc6e970348c217de29bb916"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedmlc.html#aad58a9dfecc6e970348c217de29bb916">dmlc::WriteLock</a> = typedef std::unique_lock&lt;<a class="el" href="namespacedmlc.html#a34fec5df74dfed6c51540a1fcf5bae54">SharedMutex</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Standard unique lock for C++ &lt; 14. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="aa9dd9270ccf6f3442c9d9af5300fb2cf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacedmlc.html#aa9dd9270ccf6f3442c9d9af5300fb2cf">dmlc::ConcurrentQueueType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>type of concurrent queue </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="aa9dd9270ccf6f3442c9d9af5300fb2cfa5a986096cebd351a04b4720be719ec8c"></a>kFIFO&#160;</td><td class="fielddoc">
<p>FIFO queue. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aa9dd9270ccf6f3442c9d9af5300fb2cfa140635f78446d3b7e16e1bed1772e754"></a>kPriority&#160;</td><td class="fielddoc">
<p>queue with priority </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a4c6820d1e6705361c263364b709d15a8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float dmlc::atof </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>nptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A faster implementation of <a class="el" href="namespacedmlc.html#a4c6820d1e6705361c263364b709d15a8" title="A faster implementation of atof(). Unlike std::atof(), this function returns float type...">atof()</a>. Unlike <a class="el" href="namespacedmlc.html#a4c6820d1e6705361c263364b709d15a8" title="A faster implementation of atof(). Unlike std::atof(), this function returns float type...">std::atof()</a>, this function returns float type. Note that this function does not check for overflow. TODO: the current version does not support hex number TODO: the current version does not handle long decimals: you may only have up to 19 digits after the decimal point, and you cannot have too many digits before the decimal point either. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nptr</td><td>Beginning of the string that's to be converted into float </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Converted value, in float type </dd></dl>

</div>
</div>
<a class="anchor" id="a46a57f902842152f71261ab44e887017"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long dmlc::atol </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A faster implementation of <a class="el" href="namespacedmlc.html#a46a57f902842152f71261ab44e887017" title="A faster implementation of atol(). See documentation of std::atol() for more information. This function will use base 10. Note that this function does not check for overflow. ">atol()</a>. See documentation of <a class="el" href="namespacedmlc.html#a46a57f902842152f71261ab44e887017" title="A faster implementation of atol(). See documentation of std::atol() for more information. This function will use base 10. Note that this function does not check for overflow. ">std::atol()</a> for more information. This function will use base 10. Note that this function does not check for overflow. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Beginning of the string that's to be converted into integer of type long </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Converted value, as long integer (width is system-dependent) </dd></dl>

</div>
</div>
<a class="anchor" id="a62bd2fe3e7c1902c42e70245cd6983bd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* dmlc::BeginPtr </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>safely get the beginning address of a vector </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>input vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>beginning address of a vector </dd></dl>

</div>
</div>
<a class="anchor" id="a8a787d6b6919d4127ce5a968b8f63adf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* dmlc::BeginPtr </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get the beginning address of a const vector </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>input vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>beginning address of a vector </dd></dl>

</div>
</div>
<a class="anchor" id="a81a7936da19fbc1dd4715b746e3d41ba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char* dmlc::BeginPtr </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get the beginning address of a string </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>input string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>beginning address of a string </dd></dl>

</div>
</div>
<a class="anchor" id="ae07e0f993322f84664f7c99d1f41cf82"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* dmlc::BeginPtr </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get the beginning address of a const string </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>input string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>beginning address of a string </dd></dl>

</div>
</div>
<a class="anchor" id="adbe9d2411f71ee9f165b44bd0a6fbad1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dmlc::ByteSwap </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>elem_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_elems</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A generic inplace byte swapping function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data pointer. </td></tr>
    <tr><td class="paramname">elem_bytes</td><td>The number of bytes of the data elements </td></tr>
    <tr><td class="paramname">num_elems</td><td>Number of elements in the data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Always try pass in constant elem_bytes to enable compiler optimization </dd></dl>

</div>
</div>
<a class="anchor" id="a3af1c5a5f5dd3a6741693071f85d67ce"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Duration , typename TimerFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool dmlc::CreateTimer </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>timer_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Duration &amp;&#160;</td>
          <td class="paramname"><em>duration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdmlc_1_1ThreadGroup.html">ThreadGroup</a> *&#160;</td>
          <td class="paramname"><em>owner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TimerFunction&#160;</td>
          <td class="paramname"><em>timer_function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function to easily create a timer. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Duration</td><td>Duration type (i.e. std::chrono::milliseconds) </td></tr>
    <tr><td class="paramname">TimerFunction</td><td>Function to call each time the timer expires </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timer_name</td><td>Name of the timer. Must be unique per <a class="el" href="classdmlc_1_1ThreadGroup.html" title="Thread lifecycle management group. ">ThreadGroup</a> object </td></tr>
    <tr><td class="paramname">duration</td><td>Duration of the timer between calls to timer_function </td></tr>
    <tr><td class="paramname">owner</td><td><a class="el" href="classdmlc_1_1ThreadGroup.html" title="Thread lifecycle management group. ">ThreadGroup</a> owner of the timer </td></tr>
    <tr><td class="paramname">timer_function</td><td>Function to call each time the timer expires </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the timer was successfully created </dd></dl>

</div>
</div>
<a class="anchor" id="a7272c846fa03dee55916aadce0165a46"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dmlc::DMLC_DECLARE_TRAITS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmlc_1_1has__saveload.html">has_saveload</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmxnet_1_1NDArray.html">mxnet::NDArray</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">true&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>traits </p>

</div>
</div>
<a class="anchor" id="a6b77ebc5503453ec022a011c89e7d9a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dmlc::DMLC_DECLARE_TYPE_NAME </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdmlc_1_1optional.html">optional</a>&lt; int &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;int or None&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>description for optional int </p>

</div>
</div>
<a class="anchor" id="a8190c53a1e172499c145a8bba96b9dae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dmlc::DMLC_DECLARE_TYPE_NAME </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdmlc_1_1optional.html">optional</a>&lt; bool &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;boolean or None&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>description for optional bool </p>

</div>
</div>
<a class="anchor" id="aa968c0e4fc27336c3fa3f6b42dbed591"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dmlc::DMLC_DECLARE_TYPE_NAME </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdmlc_1_1optional.html">optional</a>&lt; float &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;float or None&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>description for optional float </p>

</div>
</div>
<a class="anchor" id="adc48dd106b1a9542db8a4baf13760bbc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dmlc::DMLC_DECLARE_TYPE_NAME </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdmlc_1_1optional.html">optional</a>&lt; double &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;double or None&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>description for optional double </p>

</div>
</div>
<a class="anchor" id="a2bb53a09f94357722a2099ff7309f9f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dmlc::DMLC_DECLARE_TYPE_NAME </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Shape(tuple)&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad583c75721dd060377b1117b3798a5d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dmlc::DMLC_DECLARE_TYPE_NAME </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmxnet_1_1Tuple.html">mxnet::Tuple</a>&lt; int &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Shape(tuple)&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa3316d57ba1678b6dc1d4a38c933cb04"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dmlc::DMLC_DECLARE_TYPE_NAME </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmxnet_1_1Tuple.html">mxnet::Tuple</a>&lt; <a class="el" href="classdmlc_1_1optional.html">dmlc::optional</a>&lt; int &gt;&gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Shape(tuple)&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad2dedf41507bf76166d85fe447fa95de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dmlc::DMLC_DECLARE_TYPE_NAME </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnnvm_1_1Tuple.html">nnvm::Tuple</a>&lt; int &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Shape(tuple)&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa4d7485dc06589628bb4488ec9e8b1c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dmlc::DMLC_DECLARE_TYPE_NAME </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnnvm_1_1Tuple.html">nnvm::Tuple</a>&lt; <a class="el" href="classdmlc_1_1optional.html">dmlc::optional</a>&lt; int &gt;&gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Shape(tuple)&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af3892f01ea4c355fe1998fdbe7f386d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dmlc::DMLC_DECLARE_TYPE_NAME </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdmlc_1_1optional.html">optional</a>&lt; <a class="el" href="classnnvm_1_1TShape.html">nnvm::TShape</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Shape or None&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>description for optional TShape </p>

</div>
</div>
<a class="anchor" id="acc716e3c499f760565f2cb19fb06348f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dmlc::DMLC_DECLARE_TYPE_NAME </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdmlc_1_1optional.html">optional</a>&lt; <a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Shape or None&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>description for optional TShape </p>

</div>
</div>
<a class="anchor" id="ac47f5e5624885ad9508f4ce9688ba510"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dmlc::DMLC_DECLARE_TYPE_NAME </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdmlc_1_1optional.html">optional</a>&lt; <a class="el" href="classmxnet_1_1Tuple.html">mxnet::Tuple</a>&lt; int &gt;&gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Shape or None&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac6607ababd562edcce61938343ae0db6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double dmlc::GetTime </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return time in seconds </p>

</div>
</div>
<a class="anchor" id="a8620a9c7572cd3aab1ed3135b7a8e137"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t dmlc::HashCombine </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>hash an object and combines the key with previous keys </p>

</div>
</div>
<a class="anchor" id="a0be2b34771107606d968712e54b25ce6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="namespacedmlc.html#a8620a9c7572cd3aab1ed3135b7a8e137">dmlc::HashCombine</a>&lt; size_t &gt; </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>specialize for size_t </p>

</div>
</div>
<a class="anchor" id="a8234006cb1d67dcba5f9f856fe805c19"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool dmlc::isalpha </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inline implementation of <a class="el" href="namespacedmlc.html#a8234006cb1d67dcba5f9f856fe805c19" title="Inline implementation of isalpha(). Tests whether the given character is an alphabet letter...">isalpha()</a>. Tests whether the given character is an alphabet letter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Character to test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result of the test </dd></dl>

</div>
</div>
<a class="anchor" id="a382379acc79620379a9f7ee29ad5caaf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool dmlc::isblank </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inline implementation of <a class="el" href="namespacedmlc.html#a382379acc79620379a9f7ee29ad5caaf" title="Inline implementation of isblank(). Tests whether the given character is a space or tab character...">isblank()</a>. Tests whether the given character is a space or tab character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Character to test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result of the test </dd></dl>

</div>
</div>
<a class="anchor" id="a5dab1c816301d0261e96d002ab157d3a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool dmlc::isdigit </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inline implementation of <a class="el" href="namespacedmlc.html#a5dab1c816301d0261e96d002ab157d3a" title="Inline implementation of isdigit(). Tests whether the given character is a decimal digit...">isdigit()</a>. Tests whether the given character is a decimal digit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Character to test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result of the test </dd></dl>

</div>
</div>
<a class="anchor" id="aadc240ae898cb7f29bd88c5bd96bd3cb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool dmlc::isdigitchars </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests whether the given character is a valid letter in the string representation of a floating-point value, i.e. decimal digits, signs (+/-), decimal point (.), or exponent marker (e/E). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Character to test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result of the test </dd></dl>

</div>
</div>
<a class="anchor" id="a52dcf01c9ba22be9b08e455194fb2ab3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool dmlc::isspace </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inline implementation of <a class="el" href="namespacedmlc.html#a52dcf01c9ba22be9b08e455194fb2ab3" title="Inline implementation of isspace(). Tests whether the given character is a whitespace letter...">isspace()</a>. Tests whether the given character is a whitespace letter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Character to test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result of the test </dd></dl>

</div>
</div>
<a class="anchor" id="acf31f99192b5ed0d5d77398d58023912"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; dmlc::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdmlc_1_1optional.html">optional</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>serialize an optional object to string. </p>
<div class="fragment"><div class="line"><a class="code" href="classdmlc_1_1optional.html">dmlc::optional&lt;int&gt;</a> x;</div><div class="line">std::cout &lt;&lt; x;  <span class="comment">// None</span></div><div class="line">x = 0;</div><div class="line">std::cout &lt;&lt; x;  <span class="comment">// 0</span></div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>output stream </td></tr>
    <tr><td class="paramname">t</td><td>source optional&lt;T&gt; object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>output stream </dd></dl>

</div>
</div>
<a class="anchor" id="acc4b71c13985425358cb63cc45d49512"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::istream&amp; dmlc::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdmlc_1_1optional.html">optional</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>parse a string object into optional&lt;T&gt; </p>
<div class="fragment"><div class="line"><a class="code" href="classdmlc_1_1optional.html">dmlc::optional&lt;int&gt;</a> x;</div><div class="line">std::string s1 = <span class="stringliteral">&quot;1&quot;</span>;</div><div class="line">std::istringstream is1(s1);</div><div class="line">s1 &gt;&gt; x;  <span class="comment">// x == optional&lt;int&gt;(1)</span></div><div class="line"></div><div class="line">std::string s2 = <span class="stringliteral">&quot;None&quot;</span>;</div><div class="line">std::istringstream is2(s2);</div><div class="line">s2 &gt;&gt; x;  <span class="comment">// x == optional&lt;int&gt;()</span></div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">is</td><td>input stream </td></tr>
    <tr><td class="paramname">t</td><td>target optional&lt;T&gt; object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>input stream </dd></dl>

</div>
</div>
<a class="anchor" id="a5018d09b0f92f75d2c3ee572f62c0346"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::istream&amp; dmlc::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdmlc_1_1optional.html">optional</a>&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>specialization of '&gt;&gt;' istream parsing for optional&lt;bool&gt; </p>
<p>Permits use of generic parameter FieldEntry&lt;DType&gt; class to create FieldEntry&lt;optional&lt;bool&gt;&gt; without explicit specialization.</p>
<div class="fragment"><div class="line"><a class="code" href="classdmlc_1_1optional.html">dmlc::optional&lt;bool&gt;</a> x;</div><div class="line">std::string s1 = <span class="stringliteral">&quot;true&quot;</span>;</div><div class="line">std::istringstream is1(s1);</div><div class="line">s1 &gt;&gt; x;  <span class="comment">// x == optional&lt;bool&gt;(true)</span></div><div class="line"></div><div class="line">std::string s2 = <span class="stringliteral">&quot;None&quot;</span>;</div><div class="line">std::istringstream is2(s2);</div><div class="line">s2 &gt;&gt; x;  <span class="comment">// x == optional&lt;bool&gt;()</span></div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">is</td><td>input stream </td></tr>
    <tr><td class="paramname">t</td><td>target optional&lt;bool&gt; object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>input stream </dd></dl>

</div>
</div>
<a class="anchor" id="ade80237502ab5ae86b9c1454a09c66ee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FloatType , bool CheckRange = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FloatType dmlc::ParseFloat </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>nptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>endptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Common implementation for <a class="el" href="namespacedmlc.html#a93c2c8f7859b02cecb9c094cddd91af9" title="A faster implementation of strtof(). See documentation of std::strtof() for more information. Note that this function does not check for overflow. Use strtof_check_range() to check for overflow. TODO: the current version does not support hex number TODO: the current version does not handle long decimals: you may only have up to 19 digits after the decimal point, and you cannot have too many digits before the decimal point either. ">dmlc::strtof()</a> and <a class="el" href="namespacedmlc.html#a345b262c3cbb6d700c22c4d69d46db6e" title="A faster implementation of strtod(). See documentation of std::strtof() for more information. Note that this function does not check for overflow. Use strtod_check_range() to check for overflow. TODO: the current version does not support hex number TODO: the current version does not handle long decimals: you may only have up to 19 digits after the decimal point, and you cannot have too many digits before the decimal point either. ">dmlc::strtod()</a> TODO: the current version does not support hex number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nptr</td><td>Beginning of the string that's to be converted into a floating-point number </td></tr>
    <tr><td class="paramname">endptr</td><td>After the conversion, this pointer will be set to point one past the last character used in the conversion. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Converted floating-point value, in FloatType </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FloatType</td><td>Type of floating-point number to be obtained. This must be either float or double. </td></tr>
    <tr><td class="paramname">CheckRange</td><td>Whether to check for overflow. If set to true, an out- of-range value will cause errno to be set to ERANGE and <a class="el" href="namespacedmlc.html#ade80237502ab5ae86b9c1454a09c66ee" title="Common implementation for dmlc::strtof() and dmlc::strtod() TODO: the current version does not suppor...">ParseFloat()</a> to return HUGE_VAL / HUGE_VALF; otherwise, all out-of-range vlaues will be silently clipped. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac1bd2f744b450d3a7a06fd4e4276f667"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int dmlc::ParsePair </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>endptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T1 &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse colon seperated pair v1[:v2]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>pointer to string </td></tr>
    <tr><td class="paramname">end</td><td>one past end of string </td></tr>
    <tr><td class="paramname">endptr</td><td>After conversion, will be set to one past of parsed string </td></tr>
    <tr><td class="paramname">v1</td><td>first value in the pair </td></tr>
    <tr><td class="paramname">v2</td><td>second value in the pair </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of values parsed </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>type of v1 </td></tr>
    <tr><td class="paramname">T2</td><td>type of v2 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abe766bbcae14a7ff2720bb248cca0db9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SignedIntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SignedIntType dmlc::ParseSignedInt </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>nptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>endptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A fast string-to-integer convertor, for signed integers TODO: the current version supports only base &lt;= 10. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nptr</td><td>Beginning of the string that's to be converted into a signed integer </td></tr>
    <tr><td class="paramname">endptr</td><td>After the conversion, this pointer will be set to point one past the last character used in the conversion. </td></tr>
    <tr><td class="paramname">base</td><td>Base to use for integer conversion </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Converted value, in SignedIntType </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SignedIntType</td><td>Type of signed integer to be obtained. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ade27d0fd3a6c3e57a64e225a78e56ced"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename T3 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int dmlc::ParseTriple </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>endptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T1 &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T3 &amp;&#160;</td>
          <td class="paramname"><em>v3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse colon seperated triple v1:v2[:v3]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>pointer to string </td></tr>
    <tr><td class="paramname">end</td><td>one past end of string </td></tr>
    <tr><td class="paramname">endptr</td><td>After conversion, will be set to one past of parsed string </td></tr>
    <tr><td class="paramname">v1</td><td>first value in the triple </td></tr>
    <tr><td class="paramname">v2</td><td>second value in the triple </td></tr>
    <tr><td class="paramname">v3</td><td>third value in the triple </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of values parsed </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>type of v1 </td></tr>
    <tr><td class="paramname">T2</td><td>type of v2 </td></tr>
    <tr><td class="paramname">T3</td><td>type of v3 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae5d2f93a1b7b7683df3c674e0c3d1863"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UnsignedIntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UnsignedIntType dmlc::ParseUnsignedInt </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>nptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>endptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A fast string-to-integer convertor, for unsigned integers TODO: the current version supports only base &lt;= 10. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nptr</td><td>Beginning of the string that's to be converted into an unsigned integer </td></tr>
    <tr><td class="paramname">endptr</td><td>After the conversion, this pointer will be set to point one past the last character used in the conversion. </td></tr>
    <tr><td class="paramname">base</td><td>Base to use for integer conversion </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Converted value, in UnsignedIntType </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">UnsignedIntType</td><td>Type of unsigned integer to be obtained. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3a28a7405b2f734090912c073434091c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; dmlc::Split </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split a string by delimiter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>String to be splitted. </td></tr>
    <tr><td class="paramname">delim</td><td>The delimiter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a splitted vector of strings. </dd></dl>

</div>
</div>
<a class="anchor" id="a5f49479b0736b8709986ead800e1bfdc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double dmlc::stod </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>pos</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A faster implementation of <a class="el" href="namespacedmlc.html#a5f49479b0736b8709986ead800e1bfdc" title="A faster implementation of stod(). See documentation of std::stod() for more information. This function will test for overflow and invalid arguments. TODO: the current version does not support hex number TODO: the current version does not handle long decimals: you may only have up to 19 digits after the decimal point, and you cannot have too many digits before the decimal point either. ">stod()</a>. See documentation of <a class="el" href="namespacedmlc.html#a5f49479b0736b8709986ead800e1bfdc" title="A faster implementation of stod(). See documentation of std::stod() for more information. This function will test for overflow and invalid arguments. TODO: the current version does not support hex number TODO: the current version does not handle long decimals: you may only have up to 19 digits after the decimal point, and you cannot have too many digits before the decimal point either. ">std::stod()</a> for more information. This function will test for overflow and invalid arguments. TODO: the current version does not support hex number TODO: the current version does not handle long decimals: you may only have up to 19 digits after the decimal point, and you cannot have too many digits before the decimal point either. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The string to convert into double </td></tr>
    <tr><td class="paramname">pos</td><td>If not null, it will store the number of characters processed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Converted value, in double type </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>If the converted value would fall out of the range of the double type </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>If no conversion could be performed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a43a149fb880b527d393975a884255341"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float dmlc::stof </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>pos</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A faster implementation of <a class="el" href="namespacedmlc.html#a43a149fb880b527d393975a884255341" title="A faster implementation of stof(). See documentation of std::stof() for more information. This function will test for overflow and invalid arguments. TODO: the current version does not support hex number TODO: the current version does not handle long decimals: you may only have up to 19 digits after the decimal point, and you cannot have too many digits before the decimal point either. ">stof()</a>. See documentation of <a class="el" href="namespacedmlc.html#a43a149fb880b527d393975a884255341" title="A faster implementation of stof(). See documentation of std::stof() for more information. This function will test for overflow and invalid arguments. TODO: the current version does not support hex number TODO: the current version does not handle long decimals: you may only have up to 19 digits after the decimal point, and you cannot have too many digits before the decimal point either. ">std::stof()</a> for more information. This function will test for overflow and invalid arguments. TODO: the current version does not support hex number TODO: the current version does not handle long decimals: you may only have up to 19 digits after the decimal point, and you cannot have too many digits before the decimal point either. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The string to convert into float </td></tr>
    <tr><td class="paramname">pos</td><td>If not null, it will store the number of characters processed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Converted value, in float type </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>If the converted value would fall out of the range of the double type </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>If no conversion could be performed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a890c9ebefc22941afb32fd849b1b3a3f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T dmlc::Str2Type </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience function for converting string into type T. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>Beginning of the string to convert </td></tr>
    <tr><td class="paramname">end</td><td>End of the string to convert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Converted value, in type T </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>of converted value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a345b262c3cbb6d700c22c4d69d46db6e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double dmlc::strtod </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>nptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>endptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A faster implementation of <a class="el" href="namespacedmlc.html#a345b262c3cbb6d700c22c4d69d46db6e" title="A faster implementation of strtod(). See documentation of std::strtof() for more information. Note that this function does not check for overflow. Use strtod_check_range() to check for overflow. TODO: the current version does not support hex number TODO: the current version does not handle long decimals: you may only have up to 19 digits after the decimal point, and you cannot have too many digits before the decimal point either. ">strtod()</a>. See documentation of <a class="el" href="namespacedmlc.html#a93c2c8f7859b02cecb9c094cddd91af9" title="A faster implementation of strtof(). See documentation of std::strtof() for more information. Note that this function does not check for overflow. Use strtof_check_range() to check for overflow. TODO: the current version does not support hex number TODO: the current version does not handle long decimals: you may only have up to 19 digits after the decimal point, and you cannot have too many digits before the decimal point either. ">std::strtof()</a> for more information. Note that this function does not check for overflow. Use <a class="el" href="namespacedmlc.html#abd212a404ead6ae94faa2b65b4af796d" title="A faster implementation of strtod(). See documentation of std::strtod() for more information. This function will check for overflow. If the converted value is outside the range for the double type, errno is set to ERANGE and HUGE_VAL is returned. TODO: the current version does not support hex number TODO: the current version does not handle long decimals: you may only have up to 19 digits after the decimal point, and you cannot have too many digits before the decimal point either. ">strtod_check_range()</a> to check for overflow. TODO: the current version does not support hex number TODO: the current version does not handle long decimals: you may only have up to 19 digits after the decimal point, and you cannot have too many digits before the decimal point either. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nptr</td><td>Beginning of the string that's to be converted into double </td></tr>
    <tr><td class="paramname">endptr</td><td>After the conversion, this pointer will be set to point one past the last character used in the conversion. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Converted floating-point value, in double type </dd></dl>

</div>
</div>
<a class="anchor" id="abd212a404ead6ae94faa2b65b4af796d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double dmlc::strtod_check_range </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>nptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>endptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A faster implementation of <a class="el" href="namespacedmlc.html#a345b262c3cbb6d700c22c4d69d46db6e" title="A faster implementation of strtod(). See documentation of std::strtof() for more information. Note that this function does not check for overflow. Use strtod_check_range() to check for overflow. TODO: the current version does not support hex number TODO: the current version does not handle long decimals: you may only have up to 19 digits after the decimal point, and you cannot have too many digits before the decimal point either. ">strtod()</a>. See documentation of <a class="el" href="namespacedmlc.html#a345b262c3cbb6d700c22c4d69d46db6e" title="A faster implementation of strtod(). See documentation of std::strtof() for more information. Note that this function does not check for overflow. Use strtod_check_range() to check for overflow. TODO: the current version does not support hex number TODO: the current version does not handle long decimals: you may only have up to 19 digits after the decimal point, and you cannot have too many digits before the decimal point either. ">std::strtod()</a> for more information. This function will check for overflow. If the converted value is outside the range for the double type, errno is set to ERANGE and HUGE_VAL is returned. TODO: the current version does not support hex number TODO: the current version does not handle long decimals: you may only have up to 19 digits after the decimal point, and you cannot have too many digits before the decimal point either. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nptr</td><td>Beginning of the string that's to be converted into double </td></tr>
    <tr><td class="paramname">endptr</td><td>After the conversion, this pointer will be set to point one past the last character used in the conversion. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Converted floating-point value, in float type </dd></dl>

</div>
</div>
<a class="anchor" id="a93c2c8f7859b02cecb9c094cddd91af9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float dmlc::strtof </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>nptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>endptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A faster implementation of <a class="el" href="namespacedmlc.html#a93c2c8f7859b02cecb9c094cddd91af9" title="A faster implementation of strtof(). See documentation of std::strtof() for more information. Note that this function does not check for overflow. Use strtof_check_range() to check for overflow. TODO: the current version does not support hex number TODO: the current version does not handle long decimals: you may only have up to 19 digits after the decimal point, and you cannot have too many digits before the decimal point either. ">strtof()</a>. See documentation of <a class="el" href="namespacedmlc.html#a93c2c8f7859b02cecb9c094cddd91af9" title="A faster implementation of strtof(). See documentation of std::strtof() for more information. Note that this function does not check for overflow. Use strtof_check_range() to check for overflow. TODO: the current version does not support hex number TODO: the current version does not handle long decimals: you may only have up to 19 digits after the decimal point, and you cannot have too many digits before the decimal point either. ">std::strtof()</a> for more information. Note that this function does not check for overflow. Use <a class="el" href="namespacedmlc.html#a3717fca311a75301eedca7e77e744459" title="A faster implementation of strtof(). See documentation of std::strtof() for more information. This function will check for overflow. If the converted value is outside the range for the float type, errno is set to ERANGE and HUGE_VALF is returned. TODO: the current version does not support hex number TODO: the current version does not handle long decimals: you may only have up to 19 digits after the decimal point, and you cannot have too many digits before the decimal point either. ">strtof_check_range()</a> to check for overflow. TODO: the current version does not support hex number TODO: the current version does not handle long decimals: you may only have up to 19 digits after the decimal point, and you cannot have too many digits before the decimal point either. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nptr</td><td>Beginning of the string that's to be converted into float </td></tr>
    <tr><td class="paramname">endptr</td><td>After the conversion, this pointer will be set to point one past the last character used in the conversion. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Converted floating-point value, in float type </dd></dl>

</div>
</div>
<a class="anchor" id="a3717fca311a75301eedca7e77e744459"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float dmlc::strtof_check_range </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>nptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>endptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A faster implementation of <a class="el" href="namespacedmlc.html#a93c2c8f7859b02cecb9c094cddd91af9" title="A faster implementation of strtof(). See documentation of std::strtof() for more information. Note that this function does not check for overflow. Use strtof_check_range() to check for overflow. TODO: the current version does not support hex number TODO: the current version does not handle long decimals: you may only have up to 19 digits after the decimal point, and you cannot have too many digits before the decimal point either. ">strtof()</a>. See documentation of <a class="el" href="namespacedmlc.html#a93c2c8f7859b02cecb9c094cddd91af9" title="A faster implementation of strtof(). See documentation of std::strtof() for more information. Note that this function does not check for overflow. Use strtof_check_range() to check for overflow. TODO: the current version does not support hex number TODO: the current version does not handle long decimals: you may only have up to 19 digits after the decimal point, and you cannot have too many digits before the decimal point either. ">std::strtof()</a> for more information. This function will check for overflow. If the converted value is outside the range for the float type, errno is set to ERANGE and HUGE_VALF is returned. TODO: the current version does not support hex number TODO: the current version does not handle long decimals: you may only have up to 19 digits after the decimal point, and you cannot have too many digits before the decimal point either. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nptr</td><td>Beginning of the string that's to be converted into float </td></tr>
    <tr><td class="paramname">endptr</td><td>After the conversion, this pointer will be set to point one past the last character used in the conversion. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Converted floating-point value, in float type </dd></dl>

</div>
</div>
<a class="anchor" id="ac63dcf48b6a8ec204720a121f01477e9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t dmlc::strtoull </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>nptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>endptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A faster implementation of <a class="el" href="namespacedmlc.html#ac63dcf48b6a8ec204720a121f01477e9" title="A faster implementation of strtoull(). See documentation of std::strtoull() for more information...">strtoull()</a>. See documentation of <a class="el" href="namespacedmlc.html#ac63dcf48b6a8ec204720a121f01477e9" title="A faster implementation of strtoull(). See documentation of std::strtoull() for more information...">std::strtoull()</a> for more information. Note that this function does not check for overflow. TODO: the current version supports only base &lt;= 10. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nptr</td><td>Beginning of the string that's to be converted into integer of type unsigned long long </td></tr>
    <tr><td class="paramname">endptr</td><td>After the conversion, this pointer will be set to point one past the last character used in the conversion. </td></tr>
    <tr><td class="paramname">base</td><td>Base to use for integer conversion </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Converted value, as unsigned 64-bit integer </dd></dl>

</div>
</div>
<a class="anchor" id="a1e731f276d3a3efa8e17f46ccf35f828"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string dmlc::type_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>the string representation of type name </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type to query </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a const string of typename. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a7e6f99de792eaca82bdf6189ba6e0d77"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int dmlc::kStrtofMaxDigits = 19</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum number of decimal digits <a class="el" href="namespacedmlc.html#a93c2c8f7859b02cecb9c094cddd91af9" title="A faster implementation of strtof(). See documentation of std::strtof() for more information. Note that this function does not check for overflow. Use strtof_check_range() to check for overflow. TODO: the current version does not support hex number TODO: the current version does not handle long decimals: you may only have up to 19 digits after the decimal point, and you cannot have too many digits before the decimal point either. ">dmlc::strtof()</a> / <a class="el" href="namespacedmlc.html#a345b262c3cbb6d700c22c4d69d46db6e" title="A faster implementation of strtod(). See documentation of std::strtof() for more information. Note that this function does not check for overflow. Use strtod_check_range() to check for overflow. TODO: the current version does not support hex number TODO: the current version does not handle long decimals: you may only have up to 19 digits after the decimal point, and you cannot have too many digits before the decimal point either. ">dmlc::strtod()</a> will process. Trailing digits will be ignored. </p>

</div>
</div>
<a class="anchor" id="a7e0f62af45e67c3b6fa22080e756b379"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const <a class="el" href="structdmlc_1_1nullopt__t.html">nullopt_t</a> dmlc::nullopt = <a class="el" href="structdmlc_1_1nullopt__t.html">nullopt_t</a>(0)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assign null to optional: optional&lt;T&gt; x = nullopt; </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Mar 28 2020 00:52:31 for mxnet by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
