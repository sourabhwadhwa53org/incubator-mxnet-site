<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>mxnet: mxnet Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">mxnet
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">mxnet Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>namespace of mxnet  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacemxnet_1_1common"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1common.html">common</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemxnet_1_1cpp"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1cpp.html">cpp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemxnet_1_1csr"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1csr.html">csr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemxnet_1_1engine"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1engine.html">engine</a></td></tr>
<tr class="memdesc:namespacemxnet_1_1engine"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace of engine internal types. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemxnet_1_1features"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1features.html">features</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemxnet_1_1op"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1op.html">op</a></td></tr>
<tr class="memdesc:namespacemxnet_1_1op"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace of arguments <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemxnet_1_1rowsparse"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1rowsparse.html">rowsparse</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmxnet_1_1Context.html">Context</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structmxnet_1_1Context.html" title="Context information about the execution environment. ">Context</a> information about the execution environment.  <a href="structmxnet_1_1Context.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmxnet_1_1DataBatch.html">DataBatch</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structmxnet_1_1DataBatch.html" title="DataBatch of NDArray, returned by Iterator. ">DataBatch</a> of <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>, returned by Iterator.  <a href="structmxnet_1_1DataBatch.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmxnet_1_1DataInst.html">DataInst</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a single data instance  <a href="structmxnet_1_1DataInst.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmxnet_1_1DataIteratorReg.html">DataIteratorReg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registry entry for DataIterator factory functions.  <a href="structmxnet_1_1DataIteratorReg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1Engine.html">Engine</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dependency engine that schedules operations.  <a href="classmxnet_1_1Engine.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1Executor.html">Executor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmxnet_1_1Executor.html" title="Executor of a computation graph. Executor can be created by Binding a symbol. ">Executor</a> of a computation graph. <a class="el" href="classmxnet_1_1Executor.html" title="Executor of a computation graph. Executor can be created by Binding a symbol. ">Executor</a> can be created by Binding a symbol.  <a href="classmxnet_1_1Executor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1GPUAuxStream.html">GPUAuxStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds an auxiliary mshadow gpu stream that can be synced with a primary stream.  <a href="classmxnet_1_1GPUAuxStream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1IIterator.html">IIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">iterator type  <a href="classmxnet_1_1IIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1Imperative.html">Imperative</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">runtime functions for <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>  <a href="classmxnet_1_1Imperative.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmxnet_1_1InspectorManager.html">InspectorManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">this singleton struct mediates individual <a class="el" href="classmxnet_1_1TensorInspector.html" title="This class provides a unified interface to inspect the value of all data types including Tensor...">TensorInspector</a> objects so that we can control the global behavior from each of them  <a href="structmxnet_1_1InspectorManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1KVStore.html">KVStore</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">distributed key-value store  <a href="classmxnet_1_1KVStore.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ndarray interface  <a href="classmxnet_1_1NDArray.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmxnet_1_1NDArrayFunctionReg.html">NDArrayFunctionReg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registry entry for NDArrayFunction.  <a href="structmxnet_1_1NDArrayFunctionReg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmxnet_1_1OpContext.html">OpContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">All the possible information needed by <a class="el" href="classmxnet_1_1Operator.html#a3dbe23d985df86da51eeb868439872dd" title="perform a forward operation of Operator, save the output to TBlob. ">Operator.Forward</a> and Backward This is the superset of <a class="el" href="structmxnet_1_1RunContext.html" title="execution time context. The information needed in runtime for actual execution. ">RunContext</a>. We use this data structure to bookkeep everything needed by Forward and Backward.  <a href="structmxnet_1_1OpContext.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1Operator.html">Operator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmxnet_1_1Operator.html" title="Operator interface. Operator defines basic operation unit of optimized computation graph in mxnet...">Operator</a> interface. <a class="el" href="classmxnet_1_1Operator.html" title="Operator interface. Operator defines basic operation unit of optimized computation graph in mxnet...">Operator</a> defines basic operation unit of optimized computation graph in mxnet. This interface relies on pre-allocated memory in <a class="el" href="classmxnet_1_1TBlob.html" title="tensor blob class that can be used to hold tensor of any dimension, any device and any data type...">TBlob</a>, the caller need to set the memory region in <a class="el" href="classmxnet_1_1TBlob.html" title="tensor blob class that can be used to hold tensor of any dimension, any device and any data type...">TBlob</a> correctly before calling Forward and Backward.  <a href="classmxnet_1_1Operator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1OperatorProperty.html">OperatorProperty</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmxnet_1_1OperatorProperty.html" title="OperatorProperty is a object that stores all information about Operator. It also contains method to g...">OperatorProperty</a> is a object that stores all information about <a class="el" href="classmxnet_1_1Operator.html" title="Operator interface. Operator defines basic operation unit of optimized computation graph in mxnet...">Operator</a>. It also contains method to generate context(device) specific operators.  <a href="classmxnet_1_1OperatorProperty.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmxnet_1_1OperatorPropertyReg.html">OperatorPropertyReg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registry entry for <a class="el" href="classmxnet_1_1OperatorProperty.html" title="OperatorProperty is a object that stores all information about Operator. It also contains method to g...">OperatorProperty</a> factory functions.  <a href="structmxnet_1_1OperatorPropertyReg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1OpStatePtr.html">OpStatePtr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmxnet_1_1Operator.html" title="Operator interface. Operator defines basic operation unit of optimized computation graph in mxnet...">Operator</a> state. This is a pointer type, its content is mutable even if <a class="el" href="classmxnet_1_1OpStatePtr.html" title="Operator state. This is a pointer type, its content is mutable even if OpStatePtr is const...">OpStatePtr</a> is const.  <a href="classmxnet_1_1OpStatePtr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmxnet_1_1Resource.html">Resource</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resources used by mxnet operations. A resource is something special other than <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>, but will still participate.  <a href="structmxnet_1_1Resource.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1ResourceManager.html">ResourceManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global resource manager.  <a href="classmxnet_1_1ResourceManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmxnet_1_1ResourceRequest.html">ResourceRequest</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The resources that can be requested by <a class="el" href="classmxnet_1_1Operator.html" title="Operator interface. Operator defines basic operation unit of optimized computation graph in mxnet...">Operator</a>.  <a href="structmxnet_1_1ResourceRequest.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmxnet_1_1RunContext.html">RunContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">execution time context. The information needed in runtime for actual execution.  <a href="structmxnet_1_1RunContext.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1Storage.html">Storage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmxnet_1_1Storage.html" title="Storage manager across multiple devices. ">Storage</a> manager across multiple devices.  <a href="classmxnet_1_1Storage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1SyncedGPUAuxStream.html">SyncedGPUAuxStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides automatic coordination of an auxilary stream with a primary one. This object, upon construction, prepares an aux stream for use by syncing it with enqueued primary-stream work. Object destruction will sync again so future primary-stream work will wait on enqueued aux-stream work. If MXNET_GPU_WORKER_NSTREAMS == 1, then this defaults simply: the primary stream will equal the aux stream and the syncs will be executed as nops. See ./src/operator/cudnn/cudnn_convolution-inl.h for a usage example.  <a href="classmxnet_1_1SyncedGPUAuxStream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1TBlob.html">TBlob</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">tensor blob class that can be used to hold tensor of any dimension, any device and any data type, This is a weak type that can be used to transfer data through interface <a class="el" href="classmxnet_1_1TBlob.html" title="tensor blob class that can be used to hold tensor of any dimension, any device and any data type...">TBlob</a> itself doesn't involve any arithmetic operations, but it can be converted to tensor of fixed dimension for further operations  <a href="classmxnet_1_1TBlob.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1TensorInspector.html">TensorInspector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides a unified interface to inspect the value of all data types including Tensor, <a class="el" href="classmxnet_1_1TBlob.html" title="tensor blob class that can be used to hold tensor of any dimension, any device and any data type...">TBlob</a>, and <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>. If the tensor resides on GPU, then it will be copied from GPU memory back to CPU memory to be operated on. Internally, all data types are stored as a <a class="el" href="classmxnet_1_1TBlob.html" title="tensor blob class that can be used to hold tensor of any dimension, any device and any data type...">TBlob</a> object tb_.  <a href="classmxnet_1_1TensorInspector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1TShape.html">TShape</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Shape class that is used to represent shape of each tensor.  <a href="classmxnet_1_1TShape.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1Tuple.html">Tuple</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dynamic sized array data structure that is optimized for storing small number of elements with same type.  <a href="classmxnet_1_1Tuple.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a850af9d76d9d4beaeb5234c1434973e3"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structmshadow_1_1cpu.html">mshadow::cpu</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#a850af9d76d9d4beaeb5234c1434973e3">cpu</a></td></tr>
<tr class="memdesc:a850af9d76d9d4beaeb5234c1434973e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">mxnet cpu  <a href="#a850af9d76d9d4beaeb5234c1434973e3">More...</a><br /></td></tr>
<tr class="separator:a850af9d76d9d4beaeb5234c1434973e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31ef33571a4f6ba8847eeee1f4907141"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structmshadow_1_1gpu.html">mshadow::gpu</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#a31ef33571a4f6ba8847eeee1f4907141">gpu</a></td></tr>
<tr class="memdesc:a31ef33571a4f6ba8847eeee1f4907141"><td class="mdescLeft">&#160;</td><td class="mdescRight">mxnet gpu  <a href="#a31ef33571a4f6ba8847eeee1f4907141">More...</a><br /></td></tr>
<tr class="separator:a31ef33571a4f6ba8847eeee1f4907141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abadedc1b42ee3e5b8852e63783b982ef"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespacemshadow.html#adcbc2e1131386fccb1474b0bdf045926">mshadow::index_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#abadedc1b42ee3e5b8852e63783b982ef">index_t</a></td></tr>
<tr class="memdesc:abadedc1b42ee3e5b8852e63783b982ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">index type usually use unsigned  <a href="#abadedc1b42ee3e5b8852e63783b982ef">More...</a><br /></td></tr>
<tr class="separator:abadedc1b42ee3e5b8852e63783b982ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4421326e33f2a848cb2fa3e70ab24ff4"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespacemshadow.html#a10a73dbdb4a2b833495c2315b6da69ce">mshadow::default_real_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a></td></tr>
<tr class="memdesc:a4421326e33f2a848cb2fa3e70ab24ff4"><td class="mdescLeft">&#160;</td><td class="mdescRight">data type that will be used to store ndarray  <a href="#a4421326e33f2a848cb2fa3e70ab24ff4">More...</a><br /></td></tr>
<tr class="separator:a4421326e33f2a848cb2fa3e70ab24ff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2fb286fd7ddfbc7af1456f6c7a7ee52"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#ac2fb286fd7ddfbc7af1456f6c7a7ee52">Op</a> = <a class="el" href="classnnvm_1_1Op.html">nnvm::Op</a></td></tr>
<tr class="memdesc:ac2fb286fd7ddfbc7af1456f6c7a7ee52"><td class="mdescLeft">&#160;</td><td class="mdescRight">operator structure from NNVM  <a href="#ac2fb286fd7ddfbc7af1456f6c7a7ee52">More...</a><br /></td></tr>
<tr class="separator:ac2fb286fd7ddfbc7af1456f6c7a7ee52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6606bef15f41cccade14c9400e8447cf"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#a6606bef15f41cccade14c9400e8447cf">StorageTypeVector</a> = std::vector&lt; int &gt;</td></tr>
<tr class="memdesc:a6606bef15f41cccade14c9400e8447cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">The result holder of storage type of each NodeEntry in the graph.  <a href="#a6606bef15f41cccade14c9400e8447cf">More...</a><br /></td></tr>
<tr class="separator:a6606bef15f41cccade14c9400e8447cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1183dd8b779392f7ddafe1b010a6a2fe"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#a1183dd8b779392f7ddafe1b010a6a2fe">DispatchModeVector</a> = std::vector&lt; <a class="el" href="namespacemxnet.html#aad5fec2b4bceabbf4b884460cc2e0a2b">DispatchMode</a> &gt;</td></tr>
<tr class="memdesc:a1183dd8b779392f7ddafe1b010a6a2fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">The result holder of dispatch mode of each Node in the graph.  <a href="#a1183dd8b779392f7ddafe1b010a6a2fe">More...</a><br /></td></tr>
<tr class="separator:a1183dd8b779392f7ddafe1b010a6a2fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dca73c81706d54b0ddb0ef967d1e132"><td class="memItemLeft" align="right" valign="top">typedef std::function&lt; <a class="el" href="classmxnet_1_1IIterator.html">IIterator</a>&lt; <a class="el" href="structmxnet_1_1DataBatch.html">DataBatch</a> &gt; *()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#a6dca73c81706d54b0ddb0ef967d1e132">DataIteratorFactory</a></td></tr>
<tr class="memdesc:a6dca73c81706d54b0ddb0ef967d1e132"><td class="mdescLeft">&#160;</td><td class="mdescRight">typedef the factory function of data iterator  <a href="#a6dca73c81706d54b0ddb0ef967d1e132">More...</a><br /></td></tr>
<tr class="separator:a6dca73c81706d54b0ddb0ef967d1e132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0d55b0edf98cf8f3caeb050662ae9ec"><td class="memItemLeft" align="right" valign="top">typedef std::function&lt; void(<a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> **used_vars, <a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a> *scalars, <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> **mutate_vars, int num_params, char **param_keys, char **param_vals)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#ab0d55b0edf98cf8f3caeb050662ae9ec">NDArrayAPIFunction</a></td></tr>
<tr class="memdesc:ab0d55b0edf98cf8f3caeb050662ae9ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">definition of <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> function  <a href="#ab0d55b0edf98cf8f3caeb050662ae9ec">More...</a><br /></td></tr>
<tr class="separator:ab0d55b0edf98cf8f3caeb050662ae9ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7ea5e68a319e4f7d7c0b4ee91c2d20f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#ac7ea5e68a319e4f7d7c0b4ee91c2d20f">FCreateOpState</a> = std::function&lt; <a class="el" href="classmxnet_1_1OpStatePtr.html">OpStatePtr</a>(const <a class="el" href="structnnvm_1_1NodeAttrs.html">NodeAttrs</a> &amp;attrs, <a class="el" href="structmxnet_1_1Context.html">Context</a> ctx, const <a class="el" href="namespacemxnet.html#a87e1c30aafac389774c6f4d905c0e5ea">mxnet::ShapeVector</a> &amp;in_shape, const std::vector&lt; int &gt; &amp;in_type)&gt;</td></tr>
<tr class="memdesc:ac7ea5e68a319e4f7d7c0b4ee91c2d20f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a Layer style, forward/backward operator. This is easy to write code that contains state. <a class="el" href="classmxnet_1_1OpStatePtr.html" title="Operator state. This is a pointer type, its content is mutable even if OpStatePtr is const...">OpStatePtr</a> is a pointer type, it's content is mutable even if <a class="el" href="classmxnet_1_1OpStatePtr.html" title="Operator state. This is a pointer type, its content is mutable even if OpStatePtr is const...">OpStatePtr</a> is constant.  <a href="#ac7ea5e68a319e4f7d7c0b4ee91c2d20f">More...</a><br /></td></tr>
<tr class="separator:ac7ea5e68a319e4f7d7c0b4ee91c2d20f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab11a4e6d5c8c47c99cfc3306db6538c8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#ab11a4e6d5c8c47c99cfc3306db6538c8">THasDeterministicOutput</a> = bool</td></tr>
<tr class="memdesc:ab11a4e6d5c8c47c99cfc3306db6538c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the operator always produces the same output given the same input. This enables certain optimizations like common expression elimination.  <a href="#ab11a4e6d5c8c47c99cfc3306db6538c8">More...</a><br /></td></tr>
<tr class="separator:ab11a4e6d5c8c47c99cfc3306db6538c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a666f1055e5401ecec0278e8ba5790732"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#a666f1055e5401ecec0278e8ba5790732">FExecType</a> = std::function&lt; <a class="el" href="namespacemxnet.html#ad7801fb2dd68294d4c7a9e289bc071ad">ExecType</a>(const <a class="el" href="structnnvm_1_1NodeAttrs.html">NodeAttrs</a> &amp;attrs)&gt;</td></tr>
<tr class="memdesc:a666f1055e5401ecec0278e8ba5790732"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execution mode of this operator.  <a href="#a666f1055e5401ecec0278e8ba5790732">More...</a><br /></td></tr>
<tr class="separator:a666f1055e5401ecec0278e8ba5790732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9097a269dd76d833c014149ff3eaab9b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#a9097a269dd76d833c014149ff3eaab9b">FStatefulCompute</a> = std::function&lt; void(const <a class="el" href="classmxnet_1_1OpStatePtr.html">OpStatePtr</a> &amp;state, const <a class="el" href="structmxnet_1_1OpContext.html">OpContext</a> &amp;ctx, const std::vector&lt; <a class="el" href="classmxnet_1_1TBlob.html">TBlob</a> &gt; &amp;inputs, const std::vector&lt; <a class="el" href="namespacemxnet.html#a7cd7094ef222e9ae1f520c3b6a214398">OpReqType</a> &gt; &amp;req, const std::vector&lt; <a class="el" href="classmxnet_1_1TBlob.html">TBlob</a> &gt; &amp;outputs)&gt;</td></tr>
<tr class="memdesc:a9097a269dd76d833c014149ff3eaab9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resiger a compute function for stateful operator. <a class="el" href="classmxnet_1_1OpStatePtr.html" title="Operator state. This is a pointer type, its content is mutable even if OpStatePtr is const...">OpStatePtr</a> is a pointer type, it's content is mutable even if <a class="el" href="classmxnet_1_1OpStatePtr.html" title="Operator state. This is a pointer type, its content is mutable even if OpStatePtr is const...">OpStatePtr</a> is constant.  <a href="#a9097a269dd76d833c014149ff3eaab9b">More...</a><br /></td></tr>
<tr class="separator:a9097a269dd76d833c014149ff3eaab9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab12f1853179b1456152a563edff844a9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#ab12f1853179b1456152a563edff844a9">FStatefulComputeEx</a> = std::function&lt; void(const <a class="el" href="classmxnet_1_1OpStatePtr.html">OpStatePtr</a> &amp;state, const <a class="el" href="structmxnet_1_1OpContext.html">OpContext</a> &amp;ctx, const std::vector&lt; <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &gt; &amp;inputs, const std::vector&lt; <a class="el" href="namespacemxnet.html#a7cd7094ef222e9ae1f520c3b6a214398">OpReqType</a> &gt; &amp;req, const std::vector&lt; <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &gt; &amp;outputs)&gt;</td></tr>
<tr class="memdesc:ab12f1853179b1456152a563edff844a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resiger a compute function for stateful operator using <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> interface. <a class="el" href="classmxnet_1_1OpStatePtr.html" title="Operator state. This is a pointer type, its content is mutable even if OpStatePtr is const...">OpStatePtr</a> is a pointer type, it's content is mutable even if <a class="el" href="classmxnet_1_1OpStatePtr.html" title="Operator state. This is a pointer type, its content is mutable even if OpStatePtr is const...">OpStatePtr</a> is constant.  <a href="#ab12f1853179b1456152a563edff844a9">More...</a><br /></td></tr>
<tr class="separator:ab12f1853179b1456152a563edff844a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaa687cbca9e992614be285711c1d72d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#afaa687cbca9e992614be285711c1d72d">FResourceRequest</a> = std::function&lt; std::vector&lt; <a class="el" href="structmxnet_1_1ResourceRequest.html">ResourceRequest</a> &gt;(const <a class="el" href="structnnvm_1_1NodeAttrs.html">NodeAttrs</a> &amp;n)&gt;</td></tr>
<tr class="memdesc:afaa687cbca9e992614be285711c1d72d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The resource request from the operator. An operator could register ResourceRequestEx, or <a class="el" href="structmxnet_1_1ResourceRequest.html" title="The resources that can be requested by Operator. ">ResourceRequest</a>, or neither.  <a href="#afaa687cbca9e992614be285711c1d72d">More...</a><br /></td></tr>
<tr class="separator:afaa687cbca9e992614be285711c1d72d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45b0a850c44c45609adc320b04c7ac7f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#a45b0a850c44c45609adc320b04c7ac7f">FResourceRequestEx</a> = std::function&lt; std::vector&lt; <a class="el" href="structmxnet_1_1ResourceRequest.html">ResourceRequest</a> &gt;(const <a class="el" href="structnnvm_1_1NodeAttrs.html">NodeAttrs</a> &amp;n, const int dev_mask, const <a class="el" href="namespacemxnet.html#aad5fec2b4bceabbf4b884460cc2e0a2b">DispatchMode</a> dispatch_mode)&gt;</td></tr>
<tr class="memdesc:a45b0a850c44c45609adc320b04c7ac7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The resource request from the operator. An operator could register ResourceRequestEx, or <a class="el" href="structmxnet_1_1ResourceRequest.html" title="The resources that can be requested by Operator. ">ResourceRequest</a>, or neither. If an operator registers both ResourceRequestEx and <a class="el" href="structmxnet_1_1ResourceRequest.html" title="The resources that can be requested by Operator. ">ResourceRequest</a>, <a class="el" href="structmxnet_1_1ResourceRequest.html" title="The resources that can be requested by Operator. ">ResourceRequest</a> is ignored.  <a href="#a45b0a850c44c45609adc320b04c7ac7f">More...</a><br /></td></tr>
<tr class="separator:a45b0a850c44c45609adc320b04c7ac7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0906e49a921265634672f555451075ed"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#a0906e49a921265634672f555451075ed">FNDArrayFunction</a> = std::function&lt; void(const <a class="el" href="structnnvm_1_1NodeAttrs.html">nnvm::NodeAttrs</a> &amp;attrs, const std::vector&lt; <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &gt; &amp;inputs, std::vector&lt; <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &gt; *outputs)&gt;</td></tr>
<tr class="memdesc:a0906e49a921265634672f555451075ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register an operator called as a <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> function.  <a href="#a0906e49a921265634672f555451075ed">More...</a><br /></td></tr>
<tr class="separator:a0906e49a921265634672f555451075ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad77e2048b7e8db91a12e05b477aac13e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#ad77e2048b7e8db91a12e05b477aac13e">FCompute</a> = std::function&lt; void(const <a class="el" href="structnnvm_1_1NodeAttrs.html">nnvm::NodeAttrs</a> &amp;attrs, const <a class="el" href="structmxnet_1_1OpContext.html">OpContext</a> &amp;ctx, const std::vector&lt; <a class="el" href="classmxnet_1_1TBlob.html">TBlob</a> &gt; &amp;inputs, const std::vector&lt; <a class="el" href="namespacemxnet.html#a7cd7094ef222e9ae1f520c3b6a214398">OpReqType</a> &gt; &amp;req, const std::vector&lt; <a class="el" href="classmxnet_1_1TBlob.html">TBlob</a> &gt; &amp;outputs)&gt;</td></tr>
<tr class="memdesc:ad77e2048b7e8db91a12e05b477aac13e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a compute function for simple stateless forward only operator.  <a href="#ad77e2048b7e8db91a12e05b477aac13e">More...</a><br /></td></tr>
<tr class="separator:ad77e2048b7e8db91a12e05b477aac13e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a294d2660c065f8d229c27e65f0461e10"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#a294d2660c065f8d229c27e65f0461e10">FComputeEx</a> = std::function&lt; void(const <a class="el" href="structnnvm_1_1NodeAttrs.html">nnvm::NodeAttrs</a> &amp;attrs, const <a class="el" href="structmxnet_1_1OpContext.html">OpContext</a> &amp;ctx, const std::vector&lt; <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &gt; &amp;inputs, const std::vector&lt; <a class="el" href="namespacemxnet.html#a7cd7094ef222e9ae1f520c3b6a214398">OpReqType</a> &gt; &amp;req, const std::vector&lt; <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &gt; &amp;outputs)&gt;</td></tr>
<tr class="memdesc:a294d2660c065f8d229c27e65f0461e10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register an <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> compute function for simple stateless forward only operator.  <a href="#a294d2660c065f8d229c27e65f0461e10">More...</a><br /></td></tr>
<tr class="separator:a294d2660c065f8d229c27e65f0461e10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a1395f21139ba975a6268539df6a15d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#a0a1395f21139ba975a6268539df6a15d">FInferStorageType</a> = std::function&lt; bool(const <a class="el" href="structnnvm_1_1NodeAttrs.html">NodeAttrs</a> &amp;attrs, const int dev_mask, <a class="el" href="namespacemxnet.html#aad5fec2b4bceabbf4b884460cc2e0a2b">DispatchMode</a> *dispatch_mode, std::vector&lt; int &gt; *in_attrs, std::vector&lt; int &gt; *out_attrs)&gt;</td></tr>
<tr class="memdesc:a0a1395f21139ba975a6268539df6a15d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a storage and dispatch mode inference function based on storage types of the inputs and outputs, and the dev_mask for the operator.  <a href="#a0a1395f21139ba975a6268539df6a15d">More...</a><br /></td></tr>
<tr class="separator:a0a1395f21139ba975a6268539df6a15d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5d610fd675a9b9c811901394ee07709"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#ae5d610fd675a9b9c811901394ee07709">FQuantizable</a> = std::function&lt; <a class="el" href="namespacemxnet.html#a8e417d85458838afaba8b269f082226d">QuantizeType</a>(const <a class="el" href="structnnvm_1_1NodeAttrs.html">NodeAttrs</a> &amp;attrs)&gt;</td></tr>
<tr class="memdesc:ae5d610fd675a9b9c811901394ee07709"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a quantized node creation function based on the attrs of the node.  <a href="#ae5d610fd675a9b9c811901394ee07709">More...</a><br /></td></tr>
<tr class="separator:ae5d610fd675a9b9c811901394ee07709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4a55ce92442f122a1a0e6ae8d134f10"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#ac4a55ce92442f122a1a0e6ae8d134f10">FQuantizedOp</a> = std::function&lt; <a class="el" href="namespacennvm.html#a4259d4f89d9f0feb94111a1c8cb5a1ae">nnvm::NodePtr</a>(const <a class="el" href="structnnvm_1_1NodeAttrs.html">NodeAttrs</a> &amp;attrs)&gt;</td></tr>
<tr class="memdesc:ac4a55ce92442f122a1a0e6ae8d134f10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a quantized node creation function based on the attrs of the node.  <a href="#ac4a55ce92442f122a1a0e6ae8d134f10">More...</a><br /></td></tr>
<tr class="separator:ac4a55ce92442f122a1a0e6ae8d134f10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f7c271f6d03ee358eb9e66486e41045"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#a7f7c271f6d03ee358eb9e66486e41045">FNeedRequantize</a> = std::function&lt; bool(const <a class="el" href="structnnvm_1_1NodeAttrs.html">NodeAttrs</a> &amp;attrs)&gt;</td></tr>
<tr class="memdesc:a7f7c271f6d03ee358eb9e66486e41045"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a function to determine if the output of a quantized operator needs to be requantized. This is usually used for the operators taking int8 data types while accumulating in int32, e.g. quantized_conv.  <a href="#a7f7c271f6d03ee358eb9e66486e41045">More...</a><br /></td></tr>
<tr class="separator:a7f7c271f6d03ee358eb9e66486e41045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa80f4ba59193c91fe9d168fbe4b0ea50"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#aa80f4ba59193c91fe9d168fbe4b0ea50">FAvoidQuantizeInput</a> = std::function&lt; bool(const <a class="el" href="structnnvm_1_1NodeAttrs.html">NodeAttrs</a> &amp;attrs, size_t index)&gt;</td></tr>
<tr class="memdesc:aa80f4ba59193c91fe9d168fbe4b0ea50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a function to determine if the input of a quantized operator needs to be quantized. This is usually used for the quantized operators which can handle fp32 inputs directly.  <a href="#aa80f4ba59193c91fe9d168fbe4b0ea50">More...</a><br /></td></tr>
<tr class="separator:aa80f4ba59193c91fe9d168fbe4b0ea50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbd92d7ce22448f485be2946e79322bd"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#abbd92d7ce22448f485be2946e79322bd">FNeedCalibrateInput</a> = std::function&lt; std::vector&lt; int &gt;(const <a class="el" href="structnnvm_1_1NodeAttrs.html">NodeAttrs</a> &amp;attrs)&gt;</td></tr>
<tr class="memdesc:abbd92d7ce22448f485be2946e79322bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a function to determine if the input of a quantized operator needs to be calibrated. This is usually used for the quantized operators which need calibration on its input.  <a href="#abbd92d7ce22448f485be2946e79322bd">More...</a><br /></td></tr>
<tr class="separator:abbd92d7ce22448f485be2946e79322bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5874b9dfca8a1e2e7c72da5e3b6a9d0b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#a5874b9dfca8a1e2e7c72da5e3b6a9d0b">FNeedCalibrateOutput</a> = std::function&lt; std::vector&lt; int &gt;(const <a class="el" href="structnnvm_1_1NodeAttrs.html">NodeAttrs</a> &amp;attrs)&gt;</td></tr>
<tr class="memdesc:a5874b9dfca8a1e2e7c72da5e3b6a9d0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a function to determine if the output of a quantized operator needs to be calibrated. This is usually used for the quantized operators which need calibration on its output.  <a href="#a5874b9dfca8a1e2e7c72da5e3b6a9d0b">More...</a><br /></td></tr>
<tr class="separator:a5874b9dfca8a1e2e7c72da5e3b6a9d0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f5428fbf261a94eaac079ec24413815"><td class="memItemLeft" align="right" valign="top">typedef std::function&lt; <a class="el" href="classmxnet_1_1OperatorProperty.html">OperatorProperty</a> *()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#a6f5428fbf261a94eaac079ec24413815">OperatorPropertyFactory</a></td></tr>
<tr class="memdesc:a6f5428fbf261a94eaac079ec24413815"><td class="mdescLeft">&#160;</td><td class="mdescRight">typedef the factory function of operator property  <a href="#a6f5428fbf261a94eaac079ec24413815">More...</a><br /></td></tr>
<tr class="separator:a6f5428fbf261a94eaac079ec24413815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87e1c30aafac389774c6f4d905c0e5ea"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#a87e1c30aafac389774c6f4d905c0e5ea">ShapeVector</a> = std::vector&lt; <a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a> &gt;</td></tr>
<tr class="memdesc:a87e1c30aafac389774c6f4d905c0e5ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">The result holder of shape of each NodeEntry in the graph.  <a href="#a87e1c30aafac389774c6f4d905c0e5ea">More...</a><br /></td></tr>
<tr class="separator:a87e1c30aafac389774c6f4d905c0e5ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad58e24850ee80ff4ccfe160fd1ffa6c1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#ad58e24850ee80ff4ccfe160fd1ffa6c1">FInferShape</a> = <a class="el" href="namespacennvm.html#a39a12a38eb8f3ac625170e8be2099d57">nnvm::FInferNodeEntryAttr</a>&lt; <a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a> &gt;</td></tr>
<tr class="memdesc:ad58e24850ee80ff4ccfe160fd1ffa6c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shape inference function. Update the shapes given the input shape information. <a class="el" href="classmxnet_1_1Tuple.html#a0b256fbd00206384efb20873d39d5994">TShape.ndim()</a> == -1 means the shape is still unknown.  <a href="#ad58e24850ee80ff4ccfe160fd1ffa6c1">More...</a><br /></td></tr>
<tr class="separator:ad58e24850ee80ff4ccfe160fd1ffa6c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a998b74220fab2b012cf8a179650e1b3b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#a998b74220fab2b012cf8a179650e1b3b">FnProperty</a> { <br />
&#160;&#160;<a class="el" href="namespacemxnet.html#a998b74220fab2b012cf8a179650e1b3ba07fa7a19aa722c635a15e94cb7f50416">FnProperty::kNormal</a>, 
<a class="el" href="namespacemxnet.html#a998b74220fab2b012cf8a179650e1b3ba739f2f416f05f4728c217f09e93958d1">FnProperty::kCopyFromGPU</a>, 
<a class="el" href="namespacemxnet.html#a998b74220fab2b012cf8a179650e1b3ba6cd75f41e0ec8d61b0a2f0e20ef6d1e8">FnProperty::kCopyToGPU</a>, 
<a class="el" href="namespacemxnet.html#a998b74220fab2b012cf8a179650e1b3bac41ceb98eeb9b2e208e3e242a7357142">FnProperty::kCPUPrioritized</a>, 
<br />
&#160;&#160;<a class="el" href="namespacemxnet.html#a998b74220fab2b012cf8a179650e1b3ba9f2b960005d2a3a5f35ac32809d84db7">FnProperty::kAsync</a>, 
<a class="el" href="namespacemxnet.html#a998b74220fab2b012cf8a179650e1b3bac41fda8552e9d327ad3b06b1bafa663a">FnProperty::kDeleteVar</a>, 
<a class="el" href="namespacemxnet.html#a998b74220fab2b012cf8a179650e1b3ba4879e1f172ddec6223d17ea90e691ddd">FnProperty::kGPUPrioritized</a>, 
<a class="el" href="namespacemxnet.html#a998b74220fab2b012cf8a179650e1b3bac76ad5584b42e2ba06f1b5e9ebac8b2a">FnProperty::kNoSkip</a>
<br />
 }<tr class="memdesc:a998b74220fab2b012cf8a179650e1b3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function property, used to hint what action is pushed to engine.  <a href="namespacemxnet.html#a998b74220fab2b012cf8a179650e1b3b">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a998b74220fab2b012cf8a179650e1b3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a487cb76fa5483d32c5d87ca448e94e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#a2a487cb76fa5483d32c5d87ca448e94e">NumpyShape</a> { <a class="el" href="namespacemxnet.html#a2a487cb76fa5483d32c5d87ca448e94eaebed4fa3c7982aa607d3e0c7b65f7375">Off</a>, 
<a class="el" href="namespacemxnet.html#a2a487cb76fa5483d32c5d87ca448e94ea6c821188baf6990fa992093cbece00ce">ThreadLocalOn</a>, 
<a class="el" href="namespacemxnet.html#a2a487cb76fa5483d32c5d87ca448e94ea6de602d5b5a661f930ace1cddfbcd5b9">GlobalOn</a>
 }<tr class="memdesc:a2a487cb76fa5483d32c5d87ca448e94e"><td class="mdescLeft">&#160;</td><td class="mdescRight">there are three numpy shape flags based on priority. GlobalOn turn on numpy shape flag globally, it includes thread local. The flag can be seen in any thread. ThreadLocalOn only turn on thread local numpy shape flag, it cannot be seen in other threads. Off turn off numpy shape flag globally.  <a href="namespacemxnet.html#a2a487cb76fa5483d32c5d87ca448e94e">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a2a487cb76fa5483d32c5d87ca448e94e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a691b662ef3ae22904fc7d7d63db4c14e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#a691b662ef3ae22904fc7d7d63db4c14e">KVStoreServerProfilerCommand</a> { <a class="el" href="namespacemxnet.html#a691b662ef3ae22904fc7d7d63db4c14eac01ffbc8ad7ddf59499b096d62edcdff">KVStoreServerProfilerCommand::kSetConfig</a>, 
<a class="el" href="namespacemxnet.html#a691b662ef3ae22904fc7d7d63db4c14eaafd8bac1c90d2b1e9ad1ea7d74c46618">KVStoreServerProfilerCommand::kState</a>, 
<a class="el" href="namespacemxnet.html#a691b662ef3ae22904fc7d7d63db4c14ea583e1d2af95bc205bafe3341b26ea286">KVStoreServerProfilerCommand::kPause</a>, 
<a class="el" href="namespacemxnet.html#a691b662ef3ae22904fc7d7d63db4c14ea0193ec3ba4814ec4c6c0714a97f1bcac">KVStoreServerProfilerCommand::kDump</a>
 }<tr class="memdesc:a691b662ef3ae22904fc7d7d63db4c14e"><td class="mdescLeft">&#160;</td><td class="mdescRight">enum to denote types of commands kvstore sends to server regarding profiler kSetConfig sets profiler configs. Similar to mx.profiler.set_config() kState allows changing state of profiler to stop or run kPause allows pausing and resuming of profiler kDump asks profiler to dump output  <a href="namespacemxnet.html#a691b662ef3ae22904fc7d7d63db4c14e">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a691b662ef3ae22904fc7d7d63db4c14e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a536b732faa980e1de446c552460ff76a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#a536b732faa980e1de446c552460ff76a">NDArrayStorageType</a> { <a class="el" href="namespacemxnet.html#a536b732faa980e1de446c552460ff76aadf6c6faf0de1e55119c679180c99e584">kUndefinedStorage</a> = -1, 
<a class="el" href="namespacemxnet.html#a536b732faa980e1de446c552460ff76aabf6395d98a9668e8066a0c0da5570608">kDefaultStorage</a>, 
<a class="el" href="namespacemxnet.html#a536b732faa980e1de446c552460ff76aac095f52c31076adc7207f4a4f17d7aa3">kRowSparseStorage</a>, 
<a class="el" href="namespacemxnet.html#a536b732faa980e1de446c552460ff76aa777c7ad3afa566f2e841f12c81aab254">kCSRStorage</a>
 }</td></tr>
<tr class="separator:a536b732faa980e1de446c552460ff76a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace60510752753f459193f95cab0e9e1a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#ace60510752753f459193f95cab0e9e1a">NDArrayFormatErr</a> { <br />
&#160;&#160;<a class="el" href="namespacemxnet.html#ace60510752753f459193f95cab0e9e1aa322b8b178929b43f1b4b16c8cb9003ef">kNormalErr</a>, 
<a class="el" href="namespacemxnet.html#ace60510752753f459193f95cab0e9e1aaf64429479d4a48998e6cd122a3117628">kCSRShapeErr</a>, 
<a class="el" href="namespacemxnet.html#ace60510752753f459193f95cab0e9e1aa11ce5dbb8ad355e9ee5a678f2f51a5bb">kCSRIndPtrErr</a>, 
<a class="el" href="namespacemxnet.html#ace60510752753f459193f95cab0e9e1aaf3ee084ba1d9a6203922ff7c9ddb12e3">kCSRIdxErr</a>, 
<br />
&#160;&#160;<a class="el" href="namespacemxnet.html#ace60510752753f459193f95cab0e9e1aa200492eeec6fa431683ef0d943bfbc2d">kRSPShapeErr</a>, 
<a class="el" href="namespacemxnet.html#ace60510752753f459193f95cab0e9e1aa7636cc230df4abe46f3210846faac799">kRSPIdxErr</a>
<br />
 }</td></tr>
<tr class="separator:ace60510752753f459193f95cab0e9e1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89a5f0f5cfd9e1e94604a7b42dda818a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#a89a5f0f5cfd9e1e94604a7b42dda818a">NDArrayFunctionTypeMask</a> { <a class="el" href="namespacemxnet.html#a89a5f0f5cfd9e1e94604a7b42dda818aabbc1ba0bb3f8647dcfd8bad69efdbb51">kNDArrayArgBeforeScalar</a> = 1, 
<a class="el" href="namespacemxnet.html#a89a5f0f5cfd9e1e94604a7b42dda818aaef9818c8aae9d0046b3d9033a62fcfbb">kScalarArgBeforeNDArray</a> = 1 &lt;&lt; 1, 
<a class="el" href="namespacemxnet.html#a89a5f0f5cfd9e1e94604a7b42dda818aa334598420a4246d5412ddc346b2b57bd">kAcceptEmptyMutateTarget</a> = 1 &lt;&lt; 2
 }<tr class="memdesc:a89a5f0f5cfd9e1e94604a7b42dda818a"><td class="mdescLeft">&#160;</td><td class="mdescRight">mask information on how functions can be exposed  <a href="namespacemxnet.html#a89a5f0f5cfd9e1e94604a7b42dda818a">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a89a5f0f5cfd9e1e94604a7b42dda818a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cd7094ef222e9ae1f520c3b6a214398"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#a7cd7094ef222e9ae1f520c3b6a214398">OpReqType</a> { <a class="el" href="namespacemxnet.html#a7cd7094ef222e9ae1f520c3b6a214398a001b85096e07108e174fe4c406368a26">kNullOp</a>, 
<a class="el" href="namespacemxnet.html#a7cd7094ef222e9ae1f520c3b6a214398a03b4c19f34d3add7deecd7ef6c54b42a">kWriteTo</a>, 
<a class="el" href="namespacemxnet.html#a7cd7094ef222e9ae1f520c3b6a214398a640322face587ca12684378d0f053d51">kWriteInplace</a>, 
<a class="el" href="namespacemxnet.html#a7cd7094ef222e9ae1f520c3b6a214398a1b850737dba4d2c42a2687d14c10f383">kAddTo</a>
 }<tr class="memdesc:a7cd7094ef222e9ae1f520c3b6a214398"><td class="mdescLeft">&#160;</td><td class="mdescRight">operation request type to Forward and Backward  <a href="namespacemxnet.html#a7cd7094ef222e9ae1f520c3b6a214398">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a7cd7094ef222e9ae1f520c3b6a214398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7801fb2dd68294d4c7a9e289bc071ad"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#ad7801fb2dd68294d4c7a9e289bc071ad">ExecType</a> { <a class="el" href="namespacemxnet.html#ad7801fb2dd68294d4c7a9e289bc071adae3bade32f12a5139b27ef40b3689b77c">ExecType::kSync</a>, 
<a class="el" href="namespacemxnet.html#ad7801fb2dd68294d4c7a9e289bc071ada9f2b960005d2a3a5f35ac32809d84db7">ExecType::kAsync</a>, 
<a class="el" href="namespacemxnet.html#ad7801fb2dd68294d4c7a9e289bc071ada3864860a073c64d74d3fc8e765fa6cad">ExecType::kCrossDeviceCopy</a>, 
<a class="el" href="namespacemxnet.html#ad7801fb2dd68294d4c7a9e289bc071adabfccd41d634d8095c956c29c9ee35257">ExecType::kSubgraphExec</a>
 }<tr class="memdesc:ad7801fb2dd68294d4c7a9e289bc071ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">the execution type of the operator  <a href="namespacemxnet.html#ad7801fb2dd68294d4c7a9e289bc071ad">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ad7801fb2dd68294d4c7a9e289bc071ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad5fec2b4bceabbf4b884460cc2e0a2b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#aad5fec2b4bceabbf4b884460cc2e0a2b">DispatchMode</a> { <br />
&#160;&#160;<a class="el" href="namespacemxnet.html#aad5fec2b4bceabbf4b884460cc2e0a2ba7934d40c7c17315d892e8d5d745b1c66">DispatchMode::kUndefined</a> = -1, 
<a class="el" href="namespacemxnet.html#aad5fec2b4bceabbf4b884460cc2e0a2ba2157864769b54d1d0f8f9be63393e7d6">DispatchMode::kFCompute</a>, 
<a class="el" href="namespacemxnet.html#aad5fec2b4bceabbf4b884460cc2e0a2ba57f93219462690bc438372ecd92fedd5">DispatchMode::kFComputeEx</a>, 
<a class="el" href="namespacemxnet.html#aad5fec2b4bceabbf4b884460cc2e0a2ba18bf63b4c196f79c9bca4ad8637e8fef">DispatchMode::kFComputeFallback</a>, 
<br />
&#160;&#160;<a class="el" href="namespacemxnet.html#aad5fec2b4bceabbf4b884460cc2e0a2bafb751f6ee1af15e773242f2accd2dbff">DispatchMode::kVariable</a>
<br />
 }<tr class="memdesc:aad5fec2b4bceabbf4b884460cc2e0a2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">the dispatch mode of the operator  <a href="namespacemxnet.html#aad5fec2b4bceabbf4b884460cc2e0a2b">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:aad5fec2b4bceabbf4b884460cc2e0a2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e417d85458838afaba8b269f082226d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#a8e417d85458838afaba8b269f082226d">QuantizeType</a> { <a class="el" href="namespacemxnet.html#a8e417d85458838afaba8b269f082226da35c3ace1970663a16e5c65baa5941b13">QuantizeType::kNone</a> = 0, 
<a class="el" href="namespacemxnet.html#a8e417d85458838afaba8b269f082226da9d2303d7a748e1b486e5aeb1f2194610">QuantizeType::kMust</a>, 
<a class="el" href="namespacemxnet.html#a8e417d85458838afaba8b269f082226daaab0226a1be7a88fdffaa2442c55aa60">QuantizeType::kSupport</a>
 }<tr class="memdesc:a8e417d85458838afaba8b269f082226d"><td class="mdescLeft">&#160;</td><td class="mdescRight">the quantization type of the operator  <a href="namespacemxnet.html#a8e417d85458838afaba8b269f082226d">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a8e417d85458838afaba8b269f082226d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a286a016d2cb3a88a394adbaead2e3303"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#a286a016d2cb3a88a394adbaead2e3303">CheckerType</a> { <br />
&#160;&#160;<a class="el" href="namespacemxnet.html#a286a016d2cb3a88a394adbaead2e3303a38bfc686acfe31c2670216c1e0ef65ef">NegativeChecker</a>, 
<a class="el" href="namespacemxnet.html#a286a016d2cb3a88a394adbaead2e3303aa26bbdf09680680119c3be0def04ecf7">PositiveChecker</a>, 
<a class="el" href="namespacemxnet.html#a286a016d2cb3a88a394adbaead2e3303af7c958b058dd779d6fb9cf825e7ee6bf">ZeroChecker</a>, 
<a class="el" href="namespacemxnet.html#a286a016d2cb3a88a394adbaead2e3303a99cb159d08f27ceb0738438da1dde770">NaNChecker</a>, 
<br />
&#160;&#160;<a class="el" href="namespacemxnet.html#a286a016d2cb3a88a394adbaead2e3303a41568236c8a2f1ec604d1269895a8fde">InfChecker</a>, 
<a class="el" href="namespacemxnet.html#a286a016d2cb3a88a394adbaead2e3303a3f9eda89782731af17943b517aa19c98">PositiveInfChecker</a>, 
<a class="el" href="namespacemxnet.html#a286a016d2cb3a88a394adbaead2e3303a91a123f1efdee67133cebe8ae25d14e4">NegativeInfChecker</a>, 
<a class="el" href="namespacemxnet.html#a286a016d2cb3a88a394adbaead2e3303ac2ee25776e6f679b2cabd000aa9b9fe8">FiniteChecker</a>, 
<br />
&#160;&#160;<a class="el" href="namespacemxnet.html#a286a016d2cb3a88a394adbaead2e3303a99abb2dee0e16655ca48a46a33a0435f">NormalChecker</a>, 
<a class="el" href="namespacemxnet.html#a286a016d2cb3a88a394adbaead2e3303a8dd3c3f3f02ca0da2fe3653fb7483373">AbnormalChecker</a>
<br />
 }<tr class="memdesc:a286a016d2cb3a88a394adbaead2e3303"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum for building value checkers for TensorInspector::check_value()  <a href="namespacemxnet.html#a286a016d2cb3a88a394adbaead2e3303">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a286a016d2cb3a88a394adbaead2e3303"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a96185db91240c6ff9409834aa2451aac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#a96185db91240c6ff9409834aa2451aac">on_enter_api</a> (const char *function)</td></tr>
<tr class="separator:a96185db91240c6ff9409834aa2451aac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a015b61168caa28b3f4effe4f106ac8f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#a015b61168caa28b3f4effe4f106ac8f7">on_exit_api</a> ()</td></tr>
<tr class="separator:a015b61168caa28b3f4effe4f106ac8f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4143fe21881cbf0174bba638e8e0330"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#ae4143fe21881cbf0174bba638e8e0330">num_aux_data</a> (<a class="el" href="namespacemxnet.html#a536b732faa980e1de446c552460ff76a">NDArrayStorageType</a> stype)</td></tr>
<tr class="separator:ae4143fe21881cbf0174bba638e8e0330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7b0809624683afc59b6d7f7784d8bfb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#ae7b0809624683afc59b6d7f7784d8bfb">CopyFromTo</a> (const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;from, const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> *to, int priority=0)</td></tr>
<tr class="memdesc:ae7b0809624683afc59b6d7f7784d8bfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">issue an copy operation from one <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> to another the two ndarray can sit on different devices this operation will be scheduled by the engine  <a href="#ae7b0809624683afc59b6d7f7784d8bfb">More...</a><br /></td></tr>
<tr class="separator:ae7b0809624683afc59b6d7f7784d8bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93d1595ce990d6bbfe75a1e8f45ac81b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#a93d1595ce990d6bbfe75a1e8f45ac81b">CopyFromTo</a> (const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;from, const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;to, int priority=0, bool is_opr=false)</td></tr>
<tr class="memdesc:a93d1595ce990d6bbfe75a1e8f45ac81b"><td class="mdescLeft">&#160;</td><td class="mdescRight">issue an copy operation from one <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> to another the two ndarray can sit on different devices this operation will be scheduled by the engine  <a href="#a93d1595ce990d6bbfe75a1e8f45ac81b">More...</a><br /></td></tr>
<tr class="separator:a93d1595ce990d6bbfe75a1e8f45ac81b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15dfd6f3fa03dc2cf39dbab1225e1a51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#a15dfd6f3fa03dc2cf39dbab1225e1a51">ElementwiseSum</a> (const std::vector&lt; <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &gt; &amp;source, <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> *out, int priority=0)</td></tr>
<tr class="memdesc:a15dfd6f3fa03dc2cf39dbab1225e1a51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform elementwise sum over each data from source, store result into out.  <a href="#a15dfd6f3fa03dc2cf39dbab1225e1a51">More...</a><br /></td></tr>
<tr class="separator:a15dfd6f3fa03dc2cf39dbab1225e1a51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dafe3aae43025fd21bc44b98c18ed1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#a4dafe3aae43025fd21bc44b98c18ed1e">operator+</a> (const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;lhs, const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;rhs)</td></tr>
<tr class="memdesc:a4dafe3aae43025fd21bc44b98c18ed1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">elementwise add  <a href="#a4dafe3aae43025fd21bc44b98c18ed1e">More...</a><br /></td></tr>
<tr class="separator:a4dafe3aae43025fd21bc44b98c18ed1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30bfda0e3e1b347e3057097cafc628be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#a30bfda0e3e1b347e3057097cafc628be">operator+</a> (const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;lhs, const <a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a> &amp;rhs)</td></tr>
<tr class="memdesc:a30bfda0e3e1b347e3057097cafc628be"><td class="mdescLeft">&#160;</td><td class="mdescRight">elementwise add  <a href="#a30bfda0e3e1b347e3057097cafc628be">More...</a><br /></td></tr>
<tr class="separator:a30bfda0e3e1b347e3057097cafc628be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3356844b657c9ae1b84d3ddd56bccf6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#ae3356844b657c9ae1b84d3ddd56bccf6">operator-</a> (const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;lhs, const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;rhs)</td></tr>
<tr class="memdesc:ae3356844b657c9ae1b84d3ddd56bccf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">elementwise subtraction  <a href="#ae3356844b657c9ae1b84d3ddd56bccf6">More...</a><br /></td></tr>
<tr class="separator:ae3356844b657c9ae1b84d3ddd56bccf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c8542953df5093060985db5518a339b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#a0c8542953df5093060985db5518a339b">operator-</a> (const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;lhs, const <a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a> &amp;rhs)</td></tr>
<tr class="memdesc:a0c8542953df5093060985db5518a339b"><td class="mdescLeft">&#160;</td><td class="mdescRight">elementwise subtraction  <a href="#a0c8542953df5093060985db5518a339b">More...</a><br /></td></tr>
<tr class="separator:a0c8542953df5093060985db5518a339b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af26b09fbcda865d34ec4fdad482d266a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#af26b09fbcda865d34ec4fdad482d266a">operator*</a> (const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;lhs, const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;rhs)</td></tr>
<tr class="memdesc:af26b09fbcda865d34ec4fdad482d266a"><td class="mdescLeft">&#160;</td><td class="mdescRight">elementwise multiplication  <a href="#af26b09fbcda865d34ec4fdad482d266a">More...</a><br /></td></tr>
<tr class="separator:af26b09fbcda865d34ec4fdad482d266a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66510f6a344ee38bb89cb552e974b838"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#a66510f6a344ee38bb89cb552e974b838">operator*</a> (const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;lhs, const <a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a> &amp;rhs)</td></tr>
<tr class="memdesc:a66510f6a344ee38bb89cb552e974b838"><td class="mdescLeft">&#160;</td><td class="mdescRight">elementwise multiplication  <a href="#a66510f6a344ee38bb89cb552e974b838">More...</a><br /></td></tr>
<tr class="separator:a66510f6a344ee38bb89cb552e974b838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a502e3e00dc61cedb9c6eef711f1176ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#a502e3e00dc61cedb9c6eef711f1176ac">operator/</a> (const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;lhs, const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;rhs)</td></tr>
<tr class="memdesc:a502e3e00dc61cedb9c6eef711f1176ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">elementwise division  <a href="#a502e3e00dc61cedb9c6eef711f1176ac">More...</a><br /></td></tr>
<tr class="separator:a502e3e00dc61cedb9c6eef711f1176ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3455659b714488e8e53e4e4580a43ec7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#a3455659b714488e8e53e4e4580a43ec7">operator/</a> (const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;lhs, const <a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a> &amp;rhs)</td></tr>
<tr class="memdesc:a3455659b714488e8e53e4e4580a43ec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">elementwise division  <a href="#a3455659b714488e8e53e4e4580a43ec7">More...</a><br /></td></tr>
<tr class="separator:a3455659b714488e8e53e4e4580a43ec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bf83454c8f41259eb9d471f59feda2b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#a5bf83454c8f41259eb9d471f59feda2b">RandomSeed</a> (uint32_t seed)</td></tr>
<tr class="memdesc:a5bf83454c8f41259eb9d471f59feda2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Seed all random number generator in mxnet.  <a href="#a5bf83454c8f41259eb9d471f59feda2b">More...</a><br /></td></tr>
<tr class="separator:a5bf83454c8f41259eb9d471f59feda2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6d578be9be3a2a0d3e21246834d3e71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#ab6d578be9be3a2a0d3e21246834d3e71">RandomSeed</a> (<a class="el" href="structmxnet_1_1Context.html">Context</a> ctx, uint32_t seed)</td></tr>
<tr class="memdesc:ab6d578be9be3a2a0d3e21246834d3e71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Seed the random number generator of the device.  <a href="#ab6d578be9be3a2a0d3e21246834d3e71">More...</a><br /></td></tr>
<tr class="separator:ab6d578be9be3a2a0d3e21246834d3e71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2846f4556c9ca9bd0f567504ce60f274"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#a2846f4556c9ca9bd0f567504ce60f274">SampleUniform</a> (<a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a> begin, <a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a> end, <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> *out)</td></tr>
<tr class="memdesc:a2846f4556c9ca9bd0f567504ce60f274"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sample uniform distribution for each elements of out.  <a href="#a2846f4556c9ca9bd0f567504ce60f274">More...</a><br /></td></tr>
<tr class="separator:a2846f4556c9ca9bd0f567504ce60f274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a28062f52ca576a126599e7ad487077"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#a5a28062f52ca576a126599e7ad487077">SampleGaussian</a> (<a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a> mu, <a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a> sigma, <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> *out)</td></tr>
<tr class="memdesc:a5a28062f52ca576a126599e7ad487077"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sample gaussian distribution for each elements of out.  <a href="#a5a28062f52ca576a126599e7ad487077">More...</a><br /></td></tr>
<tr class="separator:a5a28062f52ca576a126599e7ad487077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a050beaa505f11e0b844deb91efe0cac2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#a050beaa505f11e0b844deb91efe0cac2">SampleGamma</a> (<a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a> alpha, <a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a> beta, <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> *out)</td></tr>
<tr class="memdesc:a050beaa505f11e0b844deb91efe0cac2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sample gamma distribution for each elements of out.  <a href="#a050beaa505f11e0b844deb91efe0cac2">More...</a><br /></td></tr>
<tr class="separator:a050beaa505f11e0b844deb91efe0cac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51f9b094369a349c05463de2be9f0a31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#a51f9b094369a349c05463de2be9f0a31">SampleExponential</a> (<a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a> lambda, <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> *out)</td></tr>
<tr class="memdesc:a51f9b094369a349c05463de2be9f0a31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sample exponential distribution for each elements of out.  <a href="#a51f9b094369a349c05463de2be9f0a31">More...</a><br /></td></tr>
<tr class="separator:a51f9b094369a349c05463de2be9f0a31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed55e8197182b7c66126902b2a43739a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#aed55e8197182b7c66126902b2a43739a">SamplePoisson</a> (<a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a> lambda, <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> *out)</td></tr>
<tr class="memdesc:aed55e8197182b7c66126902b2a43739a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sample Poisson distribution for each elements of out.  <a href="#aed55e8197182b7c66126902b2a43739a">More...</a><br /></td></tr>
<tr class="separator:aed55e8197182b7c66126902b2a43739a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae82f70918b2d946f7ad66a158b1733dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#ae82f70918b2d946f7ad66a158b1733dc">SampleNegBinomial</a> (int32_t k, <a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a> p, <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> *out)</td></tr>
<tr class="memdesc:ae82f70918b2d946f7ad66a158b1733dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sample negative binomial distribution for each elements of out.  <a href="#ae82f70918b2d946f7ad66a158b1733dc">More...</a><br /></td></tr>
<tr class="separator:ae82f70918b2d946f7ad66a158b1733dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8e0dad88ce27133fd24811763b7afdb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#ad8e0dad88ce27133fd24811763b7afdb">SampleGenNegBinomial</a> (<a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a> mu, <a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a> alpha, <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> *out)</td></tr>
<tr class="memdesc:ad8e0dad88ce27133fd24811763b7afdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sample generalized negative binomial distribution for each elements of out.  <a href="#ad8e0dad88ce27133fd24811763b7afdb">More...</a><br /></td></tr>
<tr class="separator:ad8e0dad88ce27133fd24811763b7afdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a429718781f8f77397f9437016511be6e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#a429718781f8f77397f9437016511be6e">ndim_is_known</a> (const int ndim)</td></tr>
<tr class="separator:a429718781f8f77397f9437016511be6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ddc5fdc5ddb39296ad9606e99fdcd5a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#a4ddc5fdc5ddb39296ad9606e99fdcd5a">dim_size_is_known</a> (const <a class="el" href="include_2mxnet_2c__api_8h.html#ab15fcfeedbe50ea6db54a98b582d7eaf">dim_t</a> dim_size)</td></tr>
<tr class="separator:a4ddc5fdc5ddb39296ad9606e99fdcd5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb878a67c0368b32a9baf1ef654eb855"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#afb878a67c0368b32a9baf1ef654eb855">ndim_is_known</a> (const <a class="el" href="classmxnet_1_1TShape.html">TShape</a> &amp;x)</td></tr>
<tr class="separator:afb878a67c0368b32a9baf1ef654eb855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfa461d1d4f7eca161d63c5e60e7217f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#abfa461d1d4f7eca161d63c5e60e7217f">dim_size_is_known</a> (const <a class="el" href="classmxnet_1_1TShape.html">TShape</a> &amp;x, const int idx)</td></tr>
<tr class="separator:abfa461d1d4f7eca161d63c5e60e7217f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c29d398f4166fdc0f95f63ce0ef66ee"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#a6c29d398f4166fdc0f95f63ce0ef66ee">shape_is_known</a> (const <a class="el" href="classmxnet_1_1TShape.html">TShape</a> &amp;x)</td></tr>
<tr class="separator:a6c29d398f4166fdc0f95f63ce0ef66ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae7f255485143a22ed0274d70598e562"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#aae7f255485143a22ed0274d70598e562">shape_is_known</a> (const std::vector&lt; <a class="el" href="classmxnet_1_1TShape.html">TShape</a> &gt; &amp;shapes)</td></tr>
<tr class="separator:aae7f255485143a22ed0274d70598e562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0b1cf5c3dc47bf0e258fa888323a3d9"><td class="memTemplParams" colspan="2">template&lt;typename SrcIter , typename DstIter &gt; </td></tr>
<tr class="memitem:af0b1cf5c3dc47bf0e258fa888323a3d9"><td class="memTemplItemLeft" align="right" valign="top">DstIter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#af0b1cf5c3dc47bf0e258fa888323a3d9">ShapeTypeCast</a> (const SrcIter begin, const SrcIter end, DstIter dst_begin)</td></tr>
<tr class="memdesc:af0b1cf5c3dc47bf0e258fa888323a3d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper function to cast type of container elements  <a href="#af0b1cf5c3dc47bf0e258fa888323a3d9">More...</a><br /></td></tr>
<tr class="separator:af0b1cf5c3dc47bf0e258fa888323a3d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0aa7f65ef62500c7c978d4f577ff8bf"><td class="memTemplParams" colspan="2">template&lt;typename SrcIter &gt; </td></tr>
<tr class="memitem:ae0aa7f65ef62500c7c978d4f577ff8bf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmxnet_1_1TShape.html">TShape</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#ae0aa7f65ef62500c7c978d4f577ff8bf">ShapeTypeCast</a> (const SrcIter begin, const SrcIter end)</td></tr>
<tr class="memdesc:ae0aa7f65ef62500c7c978d4f577ff8bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper function to transform a container to <a class="el" href="classmxnet_1_1TShape.html" title="A Shape class that is used to represent shape of each tensor. ">TShape</a> with type cast  <a href="#ae0aa7f65ef62500c7c978d4f577ff8bf">More...</a><br /></td></tr>
<tr class="separator:ae0aa7f65ef62500c7c978d4f577ff8bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a512ee02aece77cb0bf39b6e2ded77686"><td class="memItemLeft" align="right" valign="top">constexpr const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#a512ee02aece77cb0bf39b6e2ded77686">kCPU</a> = <a class="el" href="dlpack_8h.html#a49db572e18d84c47738fc746568fb573ab736fabc9e37c2acf3b09b88fdc65c9e">kDLCPU</a></td></tr>
<tr class="separator:a512ee02aece77cb0bf39b6e2ded77686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43ebce8ff01c0bee0dddb4417ea1239d"><td class="memItemLeft" align="right" valign="top">constexpr const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#a43ebce8ff01c0bee0dddb4417ea1239d">kGPU</a> = <a class="el" href="dlpack_8h.html#a49db572e18d84c47738fc746568fb573ae04bfdcc919948d170b2ba26da09e680">kDLGPU</a></td></tr>
<tr class="separator:a43ebce8ff01c0bee0dddb4417ea1239d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab96d1eea6c8d006db2b33bbdf9d90bd2"><td class="memItemLeft" align="right" valign="top">constexpr const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet.html#ab96d1eea6c8d006db2b33bbdf9d90bd2">kTVMNDArrayTypeCode</a> = 19</td></tr>
<tr class="separator:ab96d1eea6c8d006db2b33bbdf9d90bd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>namespace of mxnet </p>
<p>Copyright (c) 2015 by Contributors </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a850af9d76d9d4beaeb5234c1434973e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structmshadow_1_1cpu.html">mshadow::cpu</a> <a class="el" href="namespacemxnet.html#a850af9d76d9d4beaeb5234c1434973e3">mxnet::cpu</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>mxnet cpu </p>

</div>
</div>
<a class="anchor" id="a6dca73c81706d54b0ddb0ef967d1e132"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::function&lt;<a class="el" href="classmxnet_1_1IIterator.html">IIterator</a>&lt;<a class="el" href="structmxnet_1_1DataBatch.html">DataBatch</a>&gt; *()&gt; <a class="el" href="namespacemxnet.html#a6dca73c81706d54b0ddb0ef967d1e132">mxnet::DataIteratorFactory</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>typedef the factory function of data iterator </p>

</div>
</div>
<a class="anchor" id="a1183dd8b779392f7ddafe1b010a6a2fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemxnet.html#a1183dd8b779392f7ddafe1b010a6a2fe">mxnet::DispatchModeVector</a> = typedef std::vector&lt;<a class="el" href="namespacemxnet.html#aad5fec2b4bceabbf4b884460cc2e0a2b">DispatchMode</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The result holder of dispatch mode of each Node in the graph. </p>
<ul>
<li>*+ * <dl class="section note"><dt>Note</dt><dd>Stored under graph.attrs["dispatch_mode"], provided by Pass "InferStorageType"</dd></dl>
</li>
<li>*</li>
<li>*<div class="fragment"><div class="line">+ *  Graph g = <a class="code" href="namespacennvm.html#af9e352fbb58722c23de790c9cfafdfd7">ApplyPass</a>(src_graph, <span class="stringliteral">&quot;InferStorageType&quot;</span>);</div><div class="line">+ *  <span class="keyword">const</span> <a class="code" href="namespacemxnet.html#a1183dd8b779392f7ddafe1b010a6a2fe">DispatchModeVector</a>&amp; dispatch_modes = g.GetAttr&lt;<a class="code" href="namespacemxnet.html#a1183dd8b779392f7ddafe1b010a6a2fe">DispatchModeVector</a>&gt;(<span class="stringliteral">&quot;dispatch_mode&quot;</span>);</div><div class="line">+ *  <span class="comment">// get dispatch mode by entry node id</span></div><div class="line">+ *  <span class="keywordtype">int</span> node_type = dispatch_modes[nid];</div><div class="line">+ * </div></div><!-- fragment --></li>
<li>*</li>
<li>* <dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacemxnet.html#a0a1395f21139ba975a6268539df6a15d" title="Register a storage and dispatch mode inference function based on storage types of the inputs and outp...">FInferStorageType</a></dd></dl>
</li>
<li></li>
</ul>

</div>
</div>
<a class="anchor" id="aa80f4ba59193c91fe9d168fbe4b0ea50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemxnet.html#aa80f4ba59193c91fe9d168fbe4b0ea50">mxnet::FAvoidQuantizeInput</a> = typedef std::function&lt;bool (const <a class="el" href="structnnvm_1_1NodeAttrs.html">NodeAttrs</a>&amp; attrs, size_t index)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a function to determine if the input of a quantized operator needs to be quantized. This is usually used for the quantized operators which can handle fp32 inputs directly. </p>

</div>
</div>
<a class="anchor" id="ad77e2048b7e8db91a12e05b477aac13e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemxnet.html#ad77e2048b7e8db91a12e05b477aac13e">mxnet::FCompute</a> = typedef std::function&lt;void (const <a class="el" href="structnnvm_1_1NodeAttrs.html">nnvm::NodeAttrs</a>&amp; attrs, const <a class="el" href="structmxnet_1_1OpContext.html">OpContext</a>&amp; ctx, const std::vector&lt;<a class="el" href="classmxnet_1_1TBlob.html">TBlob</a>&gt;&amp; inputs, const std::vector&lt;<a class="el" href="namespacemxnet.html#a7cd7094ef222e9ae1f520c3b6a214398">OpReqType</a>&gt;&amp; req, const std::vector&lt;<a class="el" href="classmxnet_1_1TBlob.html">TBlob</a>&gt;&amp; outputs)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a compute function for simple stateless forward only operator. </p>
<dl class="section note"><dt>Note</dt><dd>Register under "FCompute&lt;cpu&gt;" and "FCompute&lt;gpu&gt;" </dd></dl>

</div>
</div>
<a class="anchor" id="a294d2660c065f8d229c27e65f0461e10"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemxnet.html#a294d2660c065f8d229c27e65f0461e10">mxnet::FComputeEx</a> = typedef std::function&lt;void (const <a class="el" href="structnnvm_1_1NodeAttrs.html">nnvm::NodeAttrs</a>&amp; attrs, const <a class="el" href="structmxnet_1_1OpContext.html">OpContext</a>&amp; ctx, const std::vector&lt;<a class="el" href="classmxnet_1_1NDArray.html">NDArray</a>&gt;&amp; inputs, const std::vector&lt;<a class="el" href="namespacemxnet.html#a7cd7094ef222e9ae1f520c3b6a214398">OpReqType</a>&gt;&amp; req, const std::vector&lt;<a class="el" href="classmxnet_1_1NDArray.html">NDArray</a>&gt;&amp; outputs)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register an <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> compute function for simple stateless forward only operator. </p>
<dl class="section note"><dt>Note</dt><dd>Register under "FComputeEx&lt;xpu&gt;" and "FComputeEx&lt;xpu&gt;" Dispatched only when inferred dispatch_mode is FDispatchComputeEx </dd></dl>

</div>
</div>
<a class="anchor" id="ac7ea5e68a319e4f7d7c0b4ee91c2d20f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemxnet.html#ac7ea5e68a319e4f7d7c0b4ee91c2d20f">mxnet::FCreateOpState</a> = typedef std::function&lt;<a class="el" href="classmxnet_1_1OpStatePtr.html">OpStatePtr</a> (const <a class="el" href="structnnvm_1_1NodeAttrs.html">NodeAttrs</a>&amp; attrs, <a class="el" href="structmxnet_1_1Context.html">Context</a> ctx, const <a class="el" href="namespacemxnet.html#a87e1c30aafac389774c6f4d905c0e5ea">mxnet::ShapeVector</a>&amp; in_shape, const std::vector&lt;int&gt;&amp; in_type)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a Layer style, forward/backward operator. This is easy to write code that contains state. <a class="el" href="classmxnet_1_1OpStatePtr.html" title="Operator state. This is a pointer type, its content is mutable even if OpStatePtr is const...">OpStatePtr</a> is a pointer type, it's content is mutable even if <a class="el" href="classmxnet_1_1OpStatePtr.html" title="Operator state. This is a pointer type, its content is mutable even if OpStatePtr is const...">OpStatePtr</a> is constant. </p>
<p>This is not the only way to register an op execution function. More simpler or specialized operator form can be registered</p>
<dl class="section note"><dt>Note</dt><dd>Register under "FCreateLayerOp" </dd></dl>

</div>
</div>
<a class="anchor" id="a666f1055e5401ecec0278e8ba5790732"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemxnet.html#a666f1055e5401ecec0278e8ba5790732">mxnet::FExecType</a> = typedef std::function&lt;<a class="el" href="namespacemxnet.html#ad7801fb2dd68294d4c7a9e289bc071ad">ExecType</a> (const <a class="el" href="structnnvm_1_1NodeAttrs.html">NodeAttrs</a>&amp; attrs)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execution mode of this operator. </p>

</div>
</div>
<a class="anchor" id="ad58e24850ee80ff4ccfe160fd1ffa6c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemxnet.html#ad58e24850ee80ff4ccfe160fd1ffa6c1">mxnet::FInferShape</a> = typedef <a class="el" href="namespacennvm.html#a39a12a38eb8f3ac625170e8be2099d57">nnvm::FInferNodeEntryAttr</a>&lt;<a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shape inference function. Update the shapes given the input shape information. <a class="el" href="classmxnet_1_1Tuple.html#a0b256fbd00206384efb20873d39d5994">TShape.ndim()</a> == -1 means the shape is still unknown. </p>
<dl class="section note"><dt>Note</dt><dd>Register under "FInferShape", by default do not update any shapes.</dd></dl>
<p>FInferShape is needed by shape inference </p>

</div>
</div>
<a class="anchor" id="a0a1395f21139ba975a6268539df6a15d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemxnet.html#a0a1395f21139ba975a6268539df6a15d">mxnet::FInferStorageType</a> = typedef std::function&lt;bool (const <a class="el" href="structnnvm_1_1NodeAttrs.html">NodeAttrs</a>&amp; attrs, const int dev_mask, <a class="el" href="namespacemxnet.html#aad5fec2b4bceabbf4b884460cc2e0a2b">DispatchMode</a>* dispatch_mode, std::vector&lt;int&gt;* in_attrs, std::vector&lt;int&gt;* out_attrs)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a storage and dispatch mode inference function based on storage types of the inputs and outputs, and the dev_mask for the operator. </p>
<dl class="section note"><dt>Note</dt><dd>Register under "FInferStorageType" </dd></dl>

</div>
</div>
<a class="anchor" id="a0906e49a921265634672f555451075ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemxnet.html#a0906e49a921265634672f555451075ed">mxnet::FNDArrayFunction</a> = typedef std::function&lt;void (const <a class="el" href="structnnvm_1_1NodeAttrs.html">nnvm::NodeAttrs</a>&amp; attrs, const std::vector&lt;<a class="el" href="classmxnet_1_1NDArray.html">NDArray</a>&gt;&amp; inputs, std::vector&lt;<a class="el" href="classmxnet_1_1NDArray.html">NDArray</a>&gt;* outputs)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register an operator called as a <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> function. </p>
<dl class="section note"><dt>Note</dt><dd>Register under "FNDArrayFunction" </dd></dl>

</div>
</div>
<a class="anchor" id="abbd92d7ce22448f485be2946e79322bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemxnet.html#abbd92d7ce22448f485be2946e79322bd">mxnet::FNeedCalibrateInput</a> = typedef std::function&lt;std::vector&lt;int&gt; (const <a class="el" href="structnnvm_1_1NodeAttrs.html">NodeAttrs</a>&amp; attrs)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a function to determine if the input of a quantized operator needs to be calibrated. This is usually used for the quantized operators which need calibration on its input. </p>

</div>
</div>
<a class="anchor" id="a5874b9dfca8a1e2e7c72da5e3b6a9d0b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemxnet.html#a5874b9dfca8a1e2e7c72da5e3b6a9d0b">mxnet::FNeedCalibrateOutput</a> = typedef std::function&lt;std::vector&lt;int&gt; (const <a class="el" href="structnnvm_1_1NodeAttrs.html">NodeAttrs</a>&amp; attrs)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a function to determine if the output of a quantized operator needs to be calibrated. This is usually used for the quantized operators which need calibration on its output. </p>

</div>
</div>
<a class="anchor" id="a7f7c271f6d03ee358eb9e66486e41045"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemxnet.html#a7f7c271f6d03ee358eb9e66486e41045">mxnet::FNeedRequantize</a> = typedef std::function&lt;bool (const <a class="el" href="structnnvm_1_1NodeAttrs.html">NodeAttrs</a>&amp; attrs)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a function to determine if the output of a quantized operator needs to be requantized. This is usually used for the operators taking int8 data types while accumulating in int32, e.g. quantized_conv. </p>
<dl class="section note"><dt>Note</dt><dd>Register under "FNeedRequantize" for non-quantized operators </dd></dl>

</div>
</div>
<a class="anchor" id="ae5d610fd675a9b9c811901394ee07709"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemxnet.html#ae5d610fd675a9b9c811901394ee07709">mxnet::FQuantizable</a> = typedef std::function&lt;<a class="el" href="namespacemxnet.html#a8e417d85458838afaba8b269f082226d">QuantizeType</a> (const <a class="el" href="structnnvm_1_1NodeAttrs.html">NodeAttrs</a>&amp; attrs)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a quantized node creation function based on the attrs of the node. </p>
<dl class="section note"><dt>Note</dt><dd>Register under "FQuantizedOp" for non-quantized operators </dd></dl>

</div>
</div>
<a class="anchor" id="ac4a55ce92442f122a1a0e6ae8d134f10"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemxnet.html#ac4a55ce92442f122a1a0e6ae8d134f10">mxnet::FQuantizedOp</a> = typedef std::function&lt;<a class="el" href="namespacennvm.html#a4259d4f89d9f0feb94111a1c8cb5a1ae">nnvm::NodePtr</a> (const <a class="el" href="structnnvm_1_1NodeAttrs.html">NodeAttrs</a>&amp; attrs)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a quantized node creation function based on the attrs of the node. </p>
<dl class="section note"><dt>Note</dt><dd>Register under "FQuantizedOp" for non-quantized operators </dd></dl>

</div>
</div>
<a class="anchor" id="afaa687cbca9e992614be285711c1d72d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemxnet.html#afaa687cbca9e992614be285711c1d72d">mxnet::FResourceRequest</a> = typedef std::function&lt; std::vector&lt;<a class="el" href="structmxnet_1_1ResourceRequest.html">ResourceRequest</a>&gt; (const <a class="el" href="structnnvm_1_1NodeAttrs.html">NodeAttrs</a>&amp; n)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The resource request from the operator. An operator could register ResourceRequestEx, or <a class="el" href="structmxnet_1_1ResourceRequest.html" title="The resources that can be requested by Operator. ">ResourceRequest</a>, or neither. </p>
<dl class="section note"><dt>Note</dt><dd>Register under "FResourceRequest" </dd></dl>

</div>
</div>
<a class="anchor" id="a45b0a850c44c45609adc320b04c7ac7f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemxnet.html#a45b0a850c44c45609adc320b04c7ac7f">mxnet::FResourceRequestEx</a> = typedef std::function&lt; std::vector&lt;<a class="el" href="structmxnet_1_1ResourceRequest.html">ResourceRequest</a>&gt; (const <a class="el" href="structnnvm_1_1NodeAttrs.html">NodeAttrs</a>&amp; n, const int dev_mask, const <a class="el" href="namespacemxnet.html#aad5fec2b4bceabbf4b884460cc2e0a2b">DispatchMode</a> dispatch_mode)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The resource request from the operator. An operator could register ResourceRequestEx, or <a class="el" href="structmxnet_1_1ResourceRequest.html" title="The resources that can be requested by Operator. ">ResourceRequest</a>, or neither. If an operator registers both ResourceRequestEx and <a class="el" href="structmxnet_1_1ResourceRequest.html" title="The resources that can be requested by Operator. ">ResourceRequest</a>, <a class="el" href="structmxnet_1_1ResourceRequest.html" title="The resources that can be requested by Operator. ">ResourceRequest</a> is ignored. </p>
<dl class="section note"><dt>Note</dt><dd>Register under "FResourceRequestEx" </dd></dl>

</div>
</div>
<a class="anchor" id="a9097a269dd76d833c014149ff3eaab9b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemxnet.html#a9097a269dd76d833c014149ff3eaab9b">mxnet::FStatefulCompute</a> = typedef std::function&lt;void (const <a class="el" href="classmxnet_1_1OpStatePtr.html">OpStatePtr</a>&amp; state, const <a class="el" href="structmxnet_1_1OpContext.html">OpContext</a>&amp; ctx, const std::vector&lt;<a class="el" href="classmxnet_1_1TBlob.html">TBlob</a>&gt;&amp; inputs, const std::vector&lt;<a class="el" href="namespacemxnet.html#a7cd7094ef222e9ae1f520c3b6a214398">OpReqType</a>&gt;&amp; req, const std::vector&lt;<a class="el" href="classmxnet_1_1TBlob.html">TBlob</a>&gt;&amp; outputs)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resiger a compute function for stateful operator. <a class="el" href="classmxnet_1_1OpStatePtr.html" title="Operator state. This is a pointer type, its content is mutable even if OpStatePtr is const...">OpStatePtr</a> is a pointer type, it's content is mutable even if <a class="el" href="classmxnet_1_1OpStatePtr.html" title="Operator state. This is a pointer type, its content is mutable even if OpStatePtr is const...">OpStatePtr</a> is constant. </p>
<dl class="section note"><dt>Note</dt><dd>Register under "FStatefulCompute&lt;cpu&gt;" and "FStatefulCompute&lt;gpu&gt;" </dd></dl>

</div>
</div>
<a class="anchor" id="ab12f1853179b1456152a563edff844a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemxnet.html#ab12f1853179b1456152a563edff844a9">mxnet::FStatefulComputeEx</a> = typedef std::function&lt;void (const <a class="el" href="classmxnet_1_1OpStatePtr.html">OpStatePtr</a>&amp; state, const <a class="el" href="structmxnet_1_1OpContext.html">OpContext</a>&amp; ctx, const std::vector&lt;<a class="el" href="classmxnet_1_1NDArray.html">NDArray</a>&gt;&amp; inputs, const std::vector&lt;<a class="el" href="namespacemxnet.html#a7cd7094ef222e9ae1f520c3b6a214398">OpReqType</a>&gt;&amp; req, const std::vector&lt;<a class="el" href="classmxnet_1_1NDArray.html">NDArray</a>&gt;&amp; outputs)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resiger a compute function for stateful operator using <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> interface. <a class="el" href="classmxnet_1_1OpStatePtr.html" title="Operator state. This is a pointer type, its content is mutable even if OpStatePtr is const...">OpStatePtr</a> is a pointer type, it's content is mutable even if <a class="el" href="classmxnet_1_1OpStatePtr.html" title="Operator state. This is a pointer type, its content is mutable even if OpStatePtr is const...">OpStatePtr</a> is constant. </p>
<dl class="section note"><dt>Note</dt><dd>Register under "FStatefulComputeEx&lt;cpu&gt;" and "FStatefulComputeEx&lt;gpu&gt;" </dd></dl>

</div>
</div>
<a class="anchor" id="a31ef33571a4f6ba8847eeee1f4907141"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structmshadow_1_1gpu.html">mshadow::gpu</a> <a class="el" href="namespacemxnet.html#a31ef33571a4f6ba8847eeee1f4907141">mxnet::gpu</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>mxnet gpu </p>

</div>
</div>
<a class="anchor" id="abadedc1b42ee3e5b8852e63783b982ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespacemshadow.html#adcbc2e1131386fccb1474b0bdf045926">mshadow::index_t</a> <a class="el" href="namespacemxnet.html#abadedc1b42ee3e5b8852e63783b982ef">mxnet::index_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>index type usually use unsigned </p>

</div>
</div>
<a class="anchor" id="ab0d55b0edf98cf8f3caeb050662ae9ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::function&lt;void (<a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> **used_vars, <a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a> *scalars, <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> **mutate_vars, int num_params, char **param_keys, char **param_vals)&gt; <a class="el" href="namespacemxnet.html#ab0d55b0edf98cf8f3caeb050662ae9ec">mxnet::NDArrayAPIFunction</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>definition of <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> function </p>

</div>
</div>
<a class="anchor" id="ac2fb286fd7ddfbc7af1456f6c7a7ee52"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemxnet.html#ac2fb286fd7ddfbc7af1456f6c7a7ee52">mxnet::Op</a> = typedef <a class="el" href="classnnvm_1_1Op.html">nnvm::Op</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>operator structure from NNVM </p>

</div>
</div>
<a class="anchor" id="a6f5428fbf261a94eaac079ec24413815"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::function&lt;<a class="el" href="classmxnet_1_1OperatorProperty.html">OperatorProperty</a> *()&gt; <a class="el" href="namespacemxnet.html#a6f5428fbf261a94eaac079ec24413815">mxnet::OperatorPropertyFactory</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>typedef the factory function of operator property </p>

</div>
</div>
<a class="anchor" id="a4421326e33f2a848cb2fa3e70ab24ff4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespacemshadow.html#a10a73dbdb4a2b833495c2315b6da69ce">mshadow::default_real_t</a> <a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">mxnet::real_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>data type that will be used to store ndarray </p>

</div>
</div>
<a class="anchor" id="a87e1c30aafac389774c6f4d905c0e5ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemxnet.html#a87e1c30aafac389774c6f4d905c0e5ea">mxnet::ShapeVector</a> = typedef std::vector&lt;<a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The result holder of shape of each NodeEntry in the graph. </p>
<dl class="section note"><dt>Note</dt><dd>Stored under graph.attrs["shape"], provided by Pass "InferShape"</dd></dl>
<div class="fragment"><div class="line">Graph g = <a class="code" href="namespacennvm.html#af9e352fbb58722c23de790c9cfafdfd7">ApplyPass</a>(src_graph, <span class="stringliteral">&quot;InferShape&quot;</span>);</div><div class="line"><span class="keyword">const</span> <a class="code" href="namespacemxnet.html#a87e1c30aafac389774c6f4d905c0e5ea">ShapeVector</a>&amp; shapes = g.GetAttr&lt;<a class="code" href="namespacemxnet.html#a87e1c30aafac389774c6f4d905c0e5ea">ShapeVector</a>&gt;(<span class="stringliteral">&quot;shape&quot;</span>);</div><div class="line"><span class="comment">// get shape by entry id</span></div><div class="line">TShape entry_shape = shapes[g.indexed_graph().entry_id(my_entry)];</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacemxnet.html#ad58e24850ee80ff4ccfe160fd1ffa6c1" title="Shape inference function. Update the shapes given the input shape information. TShape.ndim() == -1 means the shape is still unknown. ">FInferShape</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6606bef15f41cccade14c9400e8447cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemxnet.html#a6606bef15f41cccade14c9400e8447cf">mxnet::StorageTypeVector</a> = typedef std::vector&lt;int&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The result holder of storage type of each NodeEntry in the graph. </p>
<dl class="section note"><dt>Note</dt><dd>Stored under graph.attrs["storage_type"], provided by Pass "InferStorageType"</dd></dl>
<div class="fragment"><div class="line">Graph g = <a class="code" href="namespacennvm.html#af9e352fbb58722c23de790c9cfafdfd7">ApplyPass</a>(src_graph, <span class="stringliteral">&quot;InferStorageType&quot;</span>);</div><div class="line"><span class="keyword">const</span> <a class="code" href="namespacennvm.html#ad3ab8a09faa366b06b78d31c65f620af">StorageVector</a>&amp; stypes = g.GetAttr&lt;<a class="code" href="namespacemxnet.html#a6606bef15f41cccade14c9400e8447cf">StorageTypeVector</a>&gt;(<span class="stringliteral">&quot;storage_type&quot;</span>);</div><div class="line"><span class="comment">// get storage type by entry id</span></div><div class="line"><span class="keywordtype">int</span> entry_type = stypes[g.indexed_graph().entry_id(my_entry)];</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacemxnet.html#a0a1395f21139ba975a6268539df6a15d" title="Register a storage and dispatch mode inference function based on storage types of the inputs and outp...">FInferStorageType</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab11a4e6d5c8c47c99cfc3306db6538c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemxnet.html#ab11a4e6d5c8c47c99cfc3306db6538c8">mxnet::THasDeterministicOutput</a> = typedef bool</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether the operator always produces the same output given the same input. This enables certain optimizations like common expression elimination. </p>
<dl class="section note"><dt>Note</dt><dd>Register under "THasDeterministicOutput" </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="a286a016d2cb3a88a394adbaead2e3303"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemxnet.html#a286a016d2cb3a88a394adbaead2e3303">mxnet::CheckerType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enum for building value checkers for <a class="el" href="classmxnet_1_1TensorInspector.html#a1bf441242f8d8d13bbdd3cd72e8019cb" title="check/validate the values within the tensor, return the coordinates where the value checker evaluates...">TensorInspector::check_value()</a> </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a286a016d2cb3a88a394adbaead2e3303a38bfc686acfe31c2670216c1e0ef65ef"></a>NegativeChecker&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a286a016d2cb3a88a394adbaead2e3303aa26bbdf09680680119c3be0def04ecf7"></a>PositiveChecker&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a286a016d2cb3a88a394adbaead2e3303af7c958b058dd779d6fb9cf825e7ee6bf"></a>ZeroChecker&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a286a016d2cb3a88a394adbaead2e3303a99cb159d08f27ceb0738438da1dde770"></a>NaNChecker&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a286a016d2cb3a88a394adbaead2e3303a41568236c8a2f1ec604d1269895a8fde"></a>InfChecker&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a286a016d2cb3a88a394adbaead2e3303a3f9eda89782731af17943b517aa19c98"></a>PositiveInfChecker&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a286a016d2cb3a88a394adbaead2e3303a91a123f1efdee67133cebe8ae25d14e4"></a>NegativeInfChecker&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a286a016d2cb3a88a394adbaead2e3303ac2ee25776e6f679b2cabd000aa9b9fe8"></a>FiniteChecker&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a286a016d2cb3a88a394adbaead2e3303a99abb2dee0e16655ca48a46a33a0435f"></a>NormalChecker&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a286a016d2cb3a88a394adbaead2e3303a8dd3c3f3f02ca0da2fe3653fb7483373"></a>AbnormalChecker&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="aad5fec2b4bceabbf4b884460cc2e0a2b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemxnet.html#aad5fec2b4bceabbf4b884460cc2e0a2b">mxnet::DispatchMode</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>the dispatch mode of the operator </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="aad5fec2b4bceabbf4b884460cc2e0a2ba7934d40c7c17315d892e8d5d745b1c66"></a>kUndefined&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aad5fec2b4bceabbf4b884460cc2e0a2ba2157864769b54d1d0f8f9be63393e7d6"></a>kFCompute&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aad5fec2b4bceabbf4b884460cc2e0a2ba57f93219462690bc438372ecd92fedd5"></a>kFComputeEx&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aad5fec2b4bceabbf4b884460cc2e0a2ba18bf63b4c196f79c9bca4ad8637e8fef"></a>kFComputeFallback&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aad5fec2b4bceabbf4b884460cc2e0a2bafb751f6ee1af15e773242f2accd2dbff"></a>kVariable&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ad7801fb2dd68294d4c7a9e289bc071ad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemxnet.html#ad7801fb2dd68294d4c7a9e289bc071ad">mxnet::ExecType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>the execution type of the operator </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ad7801fb2dd68294d4c7a9e289bc071adae3bade32f12a5139b27ef40b3689b77c"></a>kSync&#160;</td><td class="fielddoc">
<p>Forward/Backward are synchronous calls. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad7801fb2dd68294d4c7a9e289bc071ada9f2b960005d2a3a5f35ac32809d84db7"></a>kAsync&#160;</td><td class="fielddoc">
<p>Forward/Backward are asynchronous, will call <a class="el" href="structmxnet_1_1OpContext.html#a40ce0e3d4ac21412cfafafc5b1fd32ef" title="the callback when operation completes, used by asynchronize ops ">OpContext.async_on_complete</a> when operation finishes. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad7801fb2dd68294d4c7a9e289bc071ada3864860a073c64d74d3fc8e765fa6cad"></a>kCrossDeviceCopy&#160;</td><td class="fielddoc">
<p>Cross device copy operation, this is a special operator that indicates it will copy across devices. For example the input and output for this type of operator can potentially reside on different devices. In the current implementation, a copy operator is specially handled by an executor. This flag is used for special case treatment and future extension of different copy ops. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad7801fb2dd68294d4c7a9e289bc071adabfccd41d634d8095c956c29c9ee35257"></a>kSubgraphExec&#160;</td><td class="fielddoc">
<p>A subgraph execution should happen in the main thread, instead of in the execution engine. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a998b74220fab2b012cf8a179650e1b3b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemxnet.html#a998b74220fab2b012cf8a179650e1b3b">mxnet::FnProperty</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function property, used to hint what action is pushed to engine. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a998b74220fab2b012cf8a179650e1b3ba07fa7a19aa722c635a15e94cb7f50416"></a>kNormal&#160;</td><td class="fielddoc">
<p>Normal operation. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a998b74220fab2b012cf8a179650e1b3ba739f2f416f05f4728c217f09e93958d1"></a>kCopyFromGPU&#160;</td><td class="fielddoc">
<p>Copy operation from GPU to other devices. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a998b74220fab2b012cf8a179650e1b3ba6cd75f41e0ec8d61b0a2f0e20ef6d1e8"></a>kCopyToGPU&#160;</td><td class="fielddoc">
<p>Copy operation from CPU to other devices. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a998b74220fab2b012cf8a179650e1b3bac41ceb98eeb9b2e208e3e242a7357142"></a>kCPUPrioritized&#160;</td><td class="fielddoc">
<p>Prioritized sync operation on CPU. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a998b74220fab2b012cf8a179650e1b3ba9f2b960005d2a3a5f35ac32809d84db7"></a>kAsync&#160;</td><td class="fielddoc">
<p>Asynchronous function call. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a998b74220fab2b012cf8a179650e1b3bac41fda8552e9d327ad3b06b1bafa663a"></a>kDeleteVar&#160;</td><td class="fielddoc">
<p>Delete variable call. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a998b74220fab2b012cf8a179650e1b3ba4879e1f172ddec6223d17ea90e691ddd"></a>kGPUPrioritized&#160;</td><td class="fielddoc">
<p>Prioritized sync operation on GPU. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a998b74220fab2b012cf8a179650e1b3bac76ad5584b42e2ba06f1b5e9ebac8b2a"></a>kNoSkip&#160;</td><td class="fielddoc">
<p>Operation not to be skipped even with associated exception. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a691b662ef3ae22904fc7d7d63db4c14e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemxnet.html#a691b662ef3ae22904fc7d7d63db4c14e">mxnet::KVStoreServerProfilerCommand</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>enum to denote types of commands kvstore sends to server regarding profiler kSetConfig sets profiler configs. Similar to mx.profiler.set_config() kState allows changing state of profiler to stop or run kPause allows pausing and resuming of profiler kDump asks profiler to dump output </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a691b662ef3ae22904fc7d7d63db4c14eac01ffbc8ad7ddf59499b096d62edcdff"></a>kSetConfig&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a691b662ef3ae22904fc7d7d63db4c14eaafd8bac1c90d2b1e9ad1ea7d74c46618"></a>kState&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a691b662ef3ae22904fc7d7d63db4c14ea583e1d2af95bc205bafe3341b26ea286"></a>kPause&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a691b662ef3ae22904fc7d7d63db4c14ea0193ec3ba4814ec4c6c0714a97f1bcac"></a>kDump&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ace60510752753f459193f95cab0e9e1a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemxnet.html#ace60510752753f459193f95cab0e9e1a">mxnet::NDArrayFormatErr</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ace60510752753f459193f95cab0e9e1aa322b8b178929b43f1b4b16c8cb9003ef"></a>kNormalErr&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ace60510752753f459193f95cab0e9e1aaf64429479d4a48998e6cd122a3117628"></a>kCSRShapeErr&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ace60510752753f459193f95cab0e9e1aa11ce5dbb8ad355e9ee5a678f2f51a5bb"></a>kCSRIndPtrErr&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ace60510752753f459193f95cab0e9e1aaf3ee084ba1d9a6203922ff7c9ddb12e3"></a>kCSRIdxErr&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ace60510752753f459193f95cab0e9e1aa200492eeec6fa431683ef0d943bfbc2d"></a>kRSPShapeErr&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ace60510752753f459193f95cab0e9e1aa7636cc230df4abe46f3210846faac799"></a>kRSPIdxErr&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a89a5f0f5cfd9e1e94604a7b42dda818a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemxnet.html#a89a5f0f5cfd9e1e94604a7b42dda818a">mxnet::NDArrayFunctionTypeMask</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>mask information on how functions can be exposed </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a89a5f0f5cfd9e1e94604a7b42dda818aabbc1ba0bb3f8647dcfd8bad69efdbb51"></a>kNDArrayArgBeforeScalar&#160;</td><td class="fielddoc">
<p>all the use_vars should go before scalar </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a89a5f0f5cfd9e1e94604a7b42dda818aaef9818c8aae9d0046b3d9033a62fcfbb"></a>kScalarArgBeforeNDArray&#160;</td><td class="fielddoc">
<p>all the scalar should go before use_vars </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a89a5f0f5cfd9e1e94604a7b42dda818aa334598420a4246d5412ddc346b2b57bd"></a>kAcceptEmptyMutateTarget&#160;</td><td class="fielddoc">
<p>whether this function allows the handles in the target to be empty <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> that are not yet initialized, and will initialize them when the function is invoked. </p>
<p>most function should support this, except copy between different devices, which requires the <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> to be pre-initialized with context </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a536b732faa980e1de446c552460ff76a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemxnet.html#a536b732faa980e1de446c552460ff76a">mxnet::NDArrayStorageType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a536b732faa980e1de446c552460ff76aadf6c6faf0de1e55119c679180c99e584"></a>kUndefinedStorage&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a536b732faa980e1de446c552460ff76aabf6395d98a9668e8066a0c0da5570608"></a>kDefaultStorage&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a536b732faa980e1de446c552460ff76aac095f52c31076adc7207f4a4f17d7aa3"></a>kRowSparseStorage&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a536b732faa980e1de446c552460ff76aa777c7ad3afa566f2e841f12c81aab254"></a>kCSRStorage&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a2a487cb76fa5483d32c5d87ca448e94e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemxnet.html#a2a487cb76fa5483d32c5d87ca448e94e">mxnet::NumpyShape</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>there are three numpy shape flags based on priority. GlobalOn turn on numpy shape flag globally, it includes thread local. The flag can be seen in any thread. ThreadLocalOn only turn on thread local numpy shape flag, it cannot be seen in other threads. Off turn off numpy shape flag globally. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a2a487cb76fa5483d32c5d87ca448e94eaebed4fa3c7982aa607d3e0c7b65f7375"></a>Off&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2a487cb76fa5483d32c5d87ca448e94ea6c821188baf6990fa992093cbece00ce"></a>ThreadLocalOn&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2a487cb76fa5483d32c5d87ca448e94ea6de602d5b5a661f930ace1cddfbcd5b9"></a>GlobalOn&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a7cd7094ef222e9ae1f520c3b6a214398"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemxnet.html#a7cd7094ef222e9ae1f520c3b6a214398">mxnet::OpReqType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>operation request type to Forward and Backward </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a7cd7094ef222e9ae1f520c3b6a214398a001b85096e07108e174fe4c406368a26"></a>kNullOp&#160;</td><td class="fielddoc">
<p>no operation, do not write anything </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7cd7094ef222e9ae1f520c3b6a214398a03b4c19f34d3add7deecd7ef6c54b42a"></a>kWriteTo&#160;</td><td class="fielddoc">
<p>write gradient to provided space </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7cd7094ef222e9ae1f520c3b6a214398a640322face587ca12684378d0f053d51"></a>kWriteInplace&#160;</td><td class="fielddoc">
<p>perform an inplace write, This option only happen when Target shares memory with one of input arguments. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7cd7094ef222e9ae1f520c3b6a214398a1b850737dba4d2c42a2687d14c10f383"></a>kAddTo&#160;</td><td class="fielddoc">
<p>add to the provided space </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a8e417d85458838afaba8b269f082226d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemxnet.html#a8e417d85458838afaba8b269f082226d">mxnet::QuantizeType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>the quantization type of the operator </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a8e417d85458838afaba8b269f082226da35c3ace1970663a16e5c65baa5941b13"></a>kNone&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8e417d85458838afaba8b269f082226da9d2303d7a748e1b486e5aeb1f2194610"></a>kMust&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8e417d85458838afaba8b269f082226daaab0226a1be7a88fdffaa2442c55aa60"></a>kSupport&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ae7b0809624683afc59b6d7f7784d8bfb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mxnet::CopyFromTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> *&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>priority</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>issue an copy operation from one <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> to another the two ndarray can sit on different devices this operation will be scheduled by the engine </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>the ndarray we want to copy data from </td></tr>
    <tr><td class="paramname">to</td><td>the target ndarray </td></tr>
    <tr><td class="paramname">priority</td><td>Priority of the action. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The function name explicitly marks the order of from and to due to different possible convention carried by copy function. </dd></dl>

</div>
</div>
<a class="anchor" id="a93d1595ce990d6bbfe75a1e8f45ac81b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mxnet::CopyFromTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>priority</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_opr</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>issue an copy operation from one <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> to another the two ndarray can sit on different devices this operation will be scheduled by the engine </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>the ndarray we want to copy data from </td></tr>
    <tr><td class="paramname">to</td><td>the target ndarray </td></tr>
    <tr><td class="paramname">priority</td><td>Priority of the action. </td></tr>
    <tr><td class="paramname">is_opr</td><td>whether it is invoked by an operator. For example, false if invoked from <a class="el" href="classmxnet_1_1KVStore.html" title="distributed key-value store ">KVStore</a>, true if invoked from <code>_copyto</code> operator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The function name explicitly marks the order of from and to due to different possible convention carried by copy function. </dd></dl>

</div>
</div>
<a class="anchor" id="a4ddc5fdc5ddb39296ad9606e99fdcd5a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mxnet::dim_size_is_known </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="include_2mxnet_2c__api_8h.html#ab15fcfeedbe50ea6db54a98b582d7eaf">dim_t</a>&#160;</td>
          <td class="paramname"><em>dim_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>brief check if a shape's dim size is known. </p>

</div>
</div>
<a class="anchor" id="abfa461d1d4f7eca161d63c5e60e7217f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mxnet::dim_size_is_known </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmxnet_1_1TShape.html">TShape</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>brief check if a shape's dim size is known. </p>

</div>
</div>
<a class="anchor" id="a15dfd6f3fa03dc2cf39dbab1225e1a51"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mxnet::ElementwiseSum </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>priority</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform elementwise sum over each data from source, store result into out. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the ndarray we want to sum </td></tr>
    <tr><td class="paramname">out</td><td>the target ndarray </td></tr>
    <tr><td class="paramname">priority</td><td>Priority of the action. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a429718781f8f77397f9437016511be6e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mxnet::ndim_is_known </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>ndim</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>brief check if a shape's ndim is known. </p>

</div>
</div>
<a class="anchor" id="afb878a67c0368b32a9baf1ef654eb855"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mxnet::ndim_is_known </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmxnet_1_1TShape.html">TShape</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>brief check if a shape's ndim is known. </p>

</div>
</div>
<a class="anchor" id="ae4143fe21881cbf0174bba638e8e0330"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mxnet::num_aux_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemxnet.html#a536b732faa980e1de446c552460ff76a">NDArrayStorageType</a>&#160;</td>
          <td class="paramname"><em>stype</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the number of aux data used for given storage type </dd></dl>

</div>
</div>
<a class="anchor" id="a96185db91240c6ff9409834aa2451aac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mxnet::on_enter_api </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a015b61168caa28b3f4effe4f106ac8f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mxnet::on_exit_api </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af26b09fbcda865d34ec4fdad482d266a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> mxnet::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>elementwise multiplication </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>left operand </td></tr>
    <tr><td class="paramname">rhs</td><td>right operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new result ndarray </dd></dl>

</div>
</div>
<a class="anchor" id="a66510f6a344ee38bb89cb552e974b838"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> mxnet::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>elementwise multiplication </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>left operand </td></tr>
    <tr><td class="paramname">rhs</td><td>right operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new result ndarray </dd></dl>

</div>
</div>
<a class="anchor" id="a4dafe3aae43025fd21bc44b98c18ed1e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> mxnet::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>elementwise add </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>left operand </td></tr>
    <tr><td class="paramname">rhs</td><td>right operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new result ndarray </dd></dl>

</div>
</div>
<a class="anchor" id="a30bfda0e3e1b347e3057097cafc628be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> mxnet::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>elementwise add </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>left operand </td></tr>
    <tr><td class="paramname">rhs</td><td>right operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new result ndarray </dd></dl>

</div>
</div>
<a class="anchor" id="ae3356844b657c9ae1b84d3ddd56bccf6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> mxnet::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>elementwise subtraction </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>left operand </td></tr>
    <tr><td class="paramname">rhs</td><td>right operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new result ndarray </dd></dl>

</div>
</div>
<a class="anchor" id="a0c8542953df5093060985db5518a339b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> mxnet::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>elementwise subtraction </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>left operand </td></tr>
    <tr><td class="paramname">rhs</td><td>right operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new result ndarray </dd></dl>

</div>
</div>
<a class="anchor" id="a502e3e00dc61cedb9c6eef711f1176ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> mxnet::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>elementwise division </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>left operand </td></tr>
    <tr><td class="paramname">rhs</td><td>right operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new result ndarray </dd></dl>

</div>
</div>
<a class="anchor" id="a3455659b714488e8e53e4e4580a43ec7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> mxnet::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>elementwise division </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>left operand </td></tr>
    <tr><td class="paramname">rhs</td><td>right operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new result ndarray </dd></dl>

</div>
</div>
<a class="anchor" id="a5bf83454c8f41259eb9d471f59feda2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mxnet::RandomSeed </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>seed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Seed all random number generator in mxnet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seed</td><td>the seed to set to global random number generators. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab6d578be9be3a2a0d3e21246834d3e71"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mxnet::RandomSeed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmxnet_1_1Context.html">Context</a>&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>seed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Seed the random number generator of the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seed</td><td>the seed to set to global random number generators. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a51f9b094369a349c05463de2be9f0a31"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mxnet::SampleExponential </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a>&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sample exponential distribution for each elements of out. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lambda</td><td>parameter (rate) of the exponential distribution </td></tr>
    <tr><td class="paramname">out</td><td>output <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a050beaa505f11e0b844deb91efe0cac2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mxnet::SampleGamma </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a>&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a>&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sample gamma distribution for each elements of out. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>parameter (shape) of the gamma distribution </td></tr>
    <tr><td class="paramname">beta</td><td>parameter (scale) of the gamma distribution </td></tr>
    <tr><td class="paramname">out</td><td>output <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5a28062f52ca576a126599e7ad487077"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mxnet::SampleGaussian </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a>&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a>&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sample gaussian distribution for each elements of out. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mu</td><td>mean of gaussian distribution. </td></tr>
    <tr><td class="paramname">sigma</td><td>standard deviation of gaussian distribution. </td></tr>
    <tr><td class="paramname">out</td><td>output <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad8e0dad88ce27133fd24811763b7afdb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mxnet::SampleGenNegBinomial </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a>&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a>&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sample generalized negative binomial distribution for each elements of out. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mu</td><td>parameter (mean) of the distribution </td></tr>
    <tr><td class="paramname">alpha</td><td>parameter (over dispersion) of the distribution </td></tr>
    <tr><td class="paramname">out</td><td>output <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae82f70918b2d946f7ad66a158b1733dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mxnet::SampleNegBinomial </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sample negative binomial distribution for each elements of out. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>failure limit </td></tr>
    <tr><td class="paramname">p</td><td>success probability </td></tr>
    <tr><td class="paramname">out</td><td>output <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aed55e8197182b7c66126902b2a43739a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mxnet::SamplePoisson </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a>&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sample Poisson distribution for each elements of out. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lambda</td><td>parameter (rate) of the Poisson distribution </td></tr>
    <tr><td class="paramname">out</td><td>output <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2846f4556c9ca9bd0f567504ce60f274"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mxnet::SampleUniform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a>&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a>&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sample uniform distribution for each elements of out. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>lower bound of distribution. </td></tr>
    <tr><td class="paramname">end</td><td>upper bound of distribution. </td></tr>
    <tr><td class="paramname">out</td><td>output <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6c29d398f4166fdc0f95f63ce0ef66ee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mxnet::shape_is_known </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmxnet_1_1TShape.html">TShape</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>brief check if shape is known using the NumPy compatible definition. zero-dim and zero-size tensors are valid. -1 means unknown. </p>

</div>
</div>
<a class="anchor" id="aae7f255485143a22ed0274d70598e562"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mxnet::shape_is_known </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classmxnet_1_1TShape.html">TShape</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>shapes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af0b1cf5c3dc47bf0e258fa888323a3d9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SrcIter , typename DstIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DstIter mxnet::ShapeTypeCast </td>
          <td>(</td>
          <td class="paramtype">const SrcIter&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SrcIter&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DstIter&#160;</td>
          <td class="paramname"><em>dst_begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>helper function to cast type of container elements </p>

</div>
</div>
<a class="anchor" id="ae0aa7f65ef62500c7c978d4f577ff8bf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SrcIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmxnet_1_1TShape.html">TShape</a> mxnet::ShapeTypeCast </td>
          <td>(</td>
          <td class="paramtype">const SrcIter&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SrcIter&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>helper function to transform a container to <a class="el" href="classmxnet_1_1TShape.html" title="A Shape class that is used to represent shape of each tensor. ">TShape</a> with type cast </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a512ee02aece77cb0bf39b6e2ded77686"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const int mxnet::kCPU = <a class="el" href="dlpack_8h.html#a49db572e18d84c47738fc746568fb573ab736fabc9e37c2acf3b09b88fdc65c9e">kDLCPU</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a43ebce8ff01c0bee0dddb4417ea1239d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const int mxnet::kGPU = <a class="el" href="dlpack_8h.html#a49db572e18d84c47738fc746568fb573ae04bfdcc919948d170b2ba26da09e680">kDLGPU</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab96d1eea6c8d006db2b33bbdf9d90bd2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const int mxnet::kTVMNDArrayTypeCode = 19</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Mar 28 2020 00:52:32 for mxnet by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
