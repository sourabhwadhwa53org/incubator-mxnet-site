<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="IE=edge" http-equiv="X-UA-Compatible"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<meta content="mxnet.gluon.loss" property="og:title">
<meta content="https://raw.githubusercontent.com/dmlc/web-data/master/mxnet/image/og-logo.png" property="og:image">
<meta content="https://raw.githubusercontent.com/dmlc/web-data/master/mxnet/image/og-logo.png" property="og:image:secure_url">
<meta content="mxnet.gluon.loss" property="og:description"/>
<title>mxnet.gluon.loss — mxnet  documentation</title>
<link crossorigin="anonymous" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" rel="stylesheet"/>
<link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet"/>
<link href="../../../_static/basic.css" rel="stylesheet" type="text/css">
<link href="../../../_static/pygments.css" rel="stylesheet" type="text/css">
<link href="../../../_static/mxnet.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
<script src="https://code.jquery.com/jquery-1.11.1.min.js" type="text/javascript"></script>
<script src="../../../_static/underscore.js" type="text/javascript"></script>
<script src="../../../_static/searchtools_custom.js" type="text/javascript"></script>
<script src="../../../_static/doctools.js" type="text/javascript"></script>
<script src="../../../_static/selectlang.js" type="text/javascript"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
<script type="text/javascript"> jQuery(function() { Search.loadIndex("/versions/1.4.1/searchindex.js"); Search.init();}); </script>
<script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new
      Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-96378503-1', 'auto');
      ga('send', 'pageview');

    </script>
<!-- -->
<!-- <script type="text/javascript" src="../../../_static/jquery.js"></script> -->
<!-- -->
<!-- <script type="text/javascript" src="../../../_static/underscore.js"></script> -->
<!-- -->
<!-- <script type="text/javascript" src="../../../_static/doctools.js"></script> -->
<!-- -->
<!-- <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> -->
<!-- -->
<link href="../../../genindex.html" rel="index" title="Index">
<link href="../../../search.html" rel="search" title="Search"/>
<link href="../../index.html" rel="up" title="Module code"/>
<link href="https://raw.githubusercontent.com/dmlc/web-data/master/mxnet/image/mxnet-icon.png" rel="icon" type="image/png"/>
</link></link></link></meta></meta></meta></head>
<body background="https://raw.githubusercontent.com/dmlc/web-data/master/mxnet/image/mxnet-background-compressed.jpeg" role="document">
<div class="content-block"><div class="navbar navbar-fixed-top">
<div class="container" id="navContainer">
<div class="innder" id="header-inner">
<h1 id="logo-wrap">
<a href="../../../" id="logo"><img src="https://raw.githubusercontent.com/dmlc/web-data/master/mxnet/image/mxnet_logo.png"/></a>
</h1>
<nav class="nav-bar" id="main-nav">
<a class="main-nav-link" href="/versions/1.4.1/install/index.html">Install</a>
<span id="dropdown-menu-position-anchor">
<a aria-expanded="true" aria-haspopup="true" class="main-nav-link dropdown-toggle" data-toggle="dropdown" href="#" role="button">Gluon <span class="caret"></span></a>
<ul class="dropdown-menu navbar-menu" id="package-dropdown-menu">
<li><a class="main-nav-link" href="/versions/1.4.1/tutorials/gluon/gluon.html">About</a></li>
<li><a class="main-nav-link" href="https://www.d2l.ai/">Dive into Deep Learning</a></li>
<li><a class="main-nav-link" href="https://gluon-cv.mxnet.io">GluonCV Toolkit</a></li>
<li><a class="main-nav-link" href="https://gluon-nlp.mxnet.io/">GluonNLP Toolkit</a></li>
</ul>
</span>
<span id="dropdown-menu-position-anchor">
<a aria-expanded="true" aria-haspopup="true" class="main-nav-link dropdown-toggle" data-toggle="dropdown" href="#" role="button">API <span class="caret"></span></a>
<ul class="dropdown-menu navbar-menu" id="package-dropdown-menu">
<li><a class="main-nav-link" href="/versions/1.4.1/api/python/index.html">Python</a></li>
<li><a class="main-nav-link" href="/versions/1.4.1/api/c++/index.html">C++</a></li>
<li><a class="main-nav-link" href="/versions/1.4.1/api/clojure/index.html">Clojure</a></li>
<li><a class="main-nav-link" href="/versions/1.4.1/api/java/index.html">Java</a></li>
<li><a class="main-nav-link" href="/versions/1.4.1/api/julia/index.html">Julia</a></li>
<li><a class="main-nav-link" href="/versions/1.4.1/api/perl/index.html">Perl</a></li>
<li><a class="main-nav-link" href="/versions/1.4.1/api/r/index.html">R</a></li>
<li><a class="main-nav-link" href="/versions/1.4.1/api/scala/index.html">Scala</a></li>
</ul>
</span>
<span id="dropdown-menu-position-anchor-docs">
<a aria-expanded="true" aria-haspopup="true" class="main-nav-link dropdown-toggle" data-toggle="dropdown" href="#" role="button">Docs <span class="caret"></span></a>
<ul class="dropdown-menu navbar-menu" id="package-dropdown-menu-docs">
<li><a class="main-nav-link" href="/versions/1.4.1/faq/index.html">FAQ</a></li>
<li><a class="main-nav-link" href="/versions/1.4.1/tutorials/index.html">Tutorials</a>
<li><a class="main-nav-link" href="https://github.com/apache/incubator-mxnet/tree/1.4.1/example">Examples</a></li>
<li><a class="main-nav-link" href="/versions/1.4.1/architecture/index.html">Architecture</a></li>
<li><a class="main-nav-link" href="https://cwiki.apache.org/confluence/display/MXNET/Apache+MXNet+Home">Developer Wiki</a></li>
<li><a class="main-nav-link" href="/versions/1.4.1/model_zoo/index.html">Model Zoo</a></li>
<li><a class="main-nav-link" href="https://github.com/onnx/onnx-mxnet">ONNX</a></li>
</li></ul>
</span>
<span id="dropdown-menu-position-anchor-community">
<a aria-expanded="true" aria-haspopup="true" class="main-nav-link dropdown-toggle" data-toggle="dropdown" href="#" role="button">Community <span class="caret"></span></a>
<ul class="dropdown-menu navbar-menu" id="package-dropdown-menu-community">
<li><a class="main-nav-link" href="http://discuss.mxnet.io">Forum</a></li>
<li><a class="main-nav-link" href="https://github.com/apache/incubator-mxnet/tree/1.4.1">Github</a></li>
<li><a class="main-nav-link" href="/versions/1.4.1/community/contribute.html">Contribute</a></li>
<li><a class="main-nav-link" href="/versions/1.4.1/community/ecosystem.html">Ecosystem</a></li>
<li><a class="main-nav-link" href="/versions/1.4.1/community/powered_by.html">Powered By</a></li>
</ul>
</span>
<span id="dropdown-menu-position-anchor-version" style="position: relative"><a href="#" class="main-nav-link dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="true">1.4.1<span class="caret"></span></a><ul id="package-dropdown-menu" class="dropdown-menu"><li><a href="/">master</a></li><li><a href=/versions/1.6/>1.6</a></li><li><a href=/versions/1.5.0/>1.5.0</a></li><li><a href=/versions/1.4.1/>1.4.1</a></li><li><a href=/versions/1.3.1/>1.3.1</a></li><li><a href=/versions/1.2.1/>1.2.1</a></li><li><a href=/versions/1.1.0/>1.1.0</a></li><li><a href=/versions/1.0.0/>1.0.0</a></li><li><a href=/versions/0.12.1/>0.12.1</a></li><li><a href=/versions/0.11.0/>0.11.0</a></li></ul></span></nav>
<script> function getRootPath(){ return "../../../" } </script>
<div class="burgerIcon dropdown">
<a class="dropdown-toggle" data-toggle="dropdown" href="#" role="button">☰</a>
<ul class="dropdown-menu" id="burgerMenu">
<li><a href="/versions/1.4.1/install/index.html">Install</a></li>
<li><a class="main-nav-link" href="/versions/1.4.1/tutorials/index.html">Tutorials</a></li>
<li class="dropdown-submenu dropdown">
<a aria-expanded="true" aria-haspopup="true" class="dropdown-toggle burger-link" data-toggle="dropdown" href="#" tabindex="-1">Gluon</a>
<ul class="dropdown-menu navbar-menu" id="package-dropdown-menu">
<li><a class="main-nav-link" href="/versions/1.4.1/tutorials/gluon/gluon.html">About</a></li>
<li><a class="main-nav-link" href="http://gluon.mxnet.io">The Straight Dope (Tutorials)</a></li>
<li><a class="main-nav-link" href="https://gluon-cv.mxnet.io">GluonCV Toolkit</a></li>
<li><a class="main-nav-link" href="https://gluon-nlp.mxnet.io/">GluonNLP Toolkit</a></li>
</ul>
</li>
<li class="dropdown-submenu">
<a aria-expanded="true" aria-haspopup="true" class="dropdown-toggle burger-link" data-toggle="dropdown" href="#" tabindex="-1">API</a>
<ul class="dropdown-menu">
<li><a class="main-nav-link" href="/versions/1.4.1/api/python/index.html">Python</a></li>
<li><a class="main-nav-link" href="/versions/1.4.1/api/c++/index.html">C++</a></li>
<li><a class="main-nav-link" href="/versions/1.4.1/api/clojure/index.html">Clojure</a></li>
<li><a class="main-nav-link" href="/versions/1.4.1/api/java/index.html">Java</a></li>
<li><a class="main-nav-link" href="/versions/1.4.1/api/julia/index.html">Julia</a></li>
<li><a class="main-nav-link" href="/versions/1.4.1/api/perl/index.html">Perl</a></li>
<li><a class="main-nav-link" href="/versions/1.4.1/api/r/index.html">R</a></li>
<li><a class="main-nav-link" href="/versions/1.4.1/api/scala/index.html">Scala</a></li>
</ul>
</li>
<li class="dropdown-submenu">
<a aria-expanded="true" aria-haspopup="true" class="dropdown-toggle burger-link" data-toggle="dropdown" href="#" tabindex="-1">Docs</a>
<ul class="dropdown-menu">
<li><a href="/versions/1.4.1/faq/index.html" tabindex="-1">FAQ</a></li>
<li><a href="/versions/1.4.1/tutorials/index.html" tabindex="-1">Tutorials</a></li>
<li><a href="https://github.com/apache/incubator-mxnet/tree/1.4.1/example" tabindex="-1">Examples</a></li>
<li><a href="/versions/1.4.1/architecture/index.html" tabindex="-1">Architecture</a></li>
<li><a href="https://cwiki.apache.org/confluence/display/MXNET/Apache+MXNet+Home" tabindex="-1">Developer Wiki</a></li>
<li><a href="/versions/1.4.1/model_zoo/index.html" tabindex="-1">Gluon Model Zoo</a></li>
<li><a href="https://github.com/onnx/onnx-mxnet" tabindex="-1">ONNX</a></li>
</ul>
</li>
<li class="dropdown-submenu dropdown">
<a aria-haspopup="true" class="dropdown-toggle burger-link" data-toggle="dropdown" href="#" role="button" tabindex="-1">Community</a>
<ul class="dropdown-menu">
<li><a href="http://discuss.mxnet.io" tabindex="-1">Forum</a></li>
<li><a href="https://github.com/apache/incubator-mxnet/tree/1.4.1" tabindex="-1">Github</a></li>
<li><a href="/versions/1.4.1/community/contribute.html" tabindex="-1">Contribute</a></li>
<li><a href="/versions/1.4.1/community/ecosystem.html" tabindex="-1">Ecosystem</a></li>
<li><a href="/versions/1.4.1/community/powered_by.html" tabindex="-1">Powered By</a></li>
</ul>
</li>
<li id="dropdown-menu-position-anchor-version-mobile" class="dropdown-submenu" style="position: relative"><a href="#" tabindex="-1">1.4.1</a><ul class="dropdown-menu"><li><a tabindex="-1" href=/>master</a></li><li><a tabindex="-1" href=/versions/1.6/>1.6</a></li><li><a tabindex="-1" href=/versions/1.5.0/>1.5.0</a></li><li><a tabindex="-1" href=/versions/1.4.1/>1.4.1</a></li><li><a tabindex="-1" href=/versions/1.3.1/>1.3.1</a></li><li><a tabindex="-1" href=/versions/1.2.1/>1.2.1</a></li><li><a tabindex="-1" href=/versions/1.1.0/>1.1.0</a></li><li><a tabindex="-1" href=/versions/1.0.0/>1.0.0</a></li><li><a tabindex="-1" href=/versions/0.12.1/>0.12.1</a></li><li><a tabindex="-1" href=/versions/0.11.0/>0.11.0</a></li></ul></li></ul>
</div>
<div class="plusIcon dropdown">
<a class="dropdown-toggle" data-toggle="dropdown" href="#" role="button"><span aria-hidden="true" class="glyphicon glyphicon-plus"></span></a>
<ul class="dropdown-menu dropdown-menu-right" id="plusMenu"></ul>
</div>
<div id="search-input-wrap">
<form action="../../../search.html" autocomplete="off" class="" method="get" role="search">
<div class="form-group inner-addon left-addon">
<i class="glyphicon glyphicon-search"></i>
<input class="form-control" name="q" placeholder="Search" type="text"/>
</div>
<input name="check_keywords" type="hidden" value="yes">
<input name="area" type="hidden" value="default"/>
</input></form>
<div id="search-preview"></div>
</div>
<div id="searchIcon">
<span aria-hidden="true" class="glyphicon glyphicon-search"></span>
</div>
<!-- <div id="lang-select-wrap"> -->
<!--   <label id="lang-select-label"> -->
<!--     <\!-- <i class="fa fa-globe"></i> -\-> -->
<!--     <span></span> -->
<!--   </label> -->
<!--   <select id="lang-select"> -->
<!--     <option value="en">Eng</option> -->
<!--     <option value="zh">中文</option> -->
<!--   </select> -->
<!-- </div> -->
<!--     <a id="mobile-nav-toggle">
        <span class="mobile-nav-toggle-bar"></span>
        <span class="mobile-nav-toggle-bar"></span>
        <span class="mobile-nav-toggle-bar"></span>
      </a> -->
</div>
</div>
</div>
<script type="text/javascript">
        $('body').css('background', 'white');
    </script>
<div class="container">
<div class="row">
<div aria-label="main navigation" class="sphinxsidebar leftsidebar" role="navigation">
<div class="sphinxsidebarwrapper">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api/index.html">MXNet APIs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../architecture/index.html">MXNet Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../community/index.html">MXNet Community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../faq/index.html">MXNet FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../gluon/index.html">About Gluon</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../install/index.html">Installing MXNet</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../install/index.html#nvidia-jetson-tx-family">Nvidia Jetson TX family</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../install/index.html#source-download">Source Download</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../model_zoo/index.html">MXNet Model Zoo</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/index.html">Tutorials</a></li>
</ul>
</div>
</div>
<div class="content">
<div class="page-tracker"></div>
<h1>Source code for mxnet.gluon.loss</h1><div class="highlight"><pre>
<span></span><span class="c1"># Licensed to the Apache Software Foundation (ASF) under one</span>
<span class="c1"># or more contributor license agreements.  See the NOTICE file</span>
<span class="c1"># distributed with this work for additional information</span>
<span class="c1"># regarding copyright ownership.  The ASF licenses this file</span>
<span class="c1"># to you under the Apache License, Version 2.0 (the</span>
<span class="c1"># "License"); you may not use this file except in compliance</span>
<span class="c1"># with the License.  You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1">#   http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing,</span>
<span class="c1"># software distributed under the License is distributed on an</span>
<span class="c1"># "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY</span>
<span class="c1"># KIND, either express or implied.  See the License for the</span>
<span class="c1"># specific language governing permissions and limitations</span>
<span class="c1"># under the License.</span>

<span class="c1"># coding: utf-8</span>
<span class="c1"># pylint: disable=arguments-differ</span>
<span class="sd">""" losses for training neural networks """</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">absolute_import</span>
<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'Loss'</span><span class="p">,</span> <span class="s1">'L2Loss'</span><span class="p">,</span> <span class="s1">'L1Loss'</span><span class="p">,</span>
           <span class="s1">'SigmoidBinaryCrossEntropyLoss'</span><span class="p">,</span> <span class="s1">'SigmoidBCELoss'</span><span class="p">,</span>
           <span class="s1">'SoftmaxCrossEntropyLoss'</span><span class="p">,</span> <span class="s1">'SoftmaxCELoss'</span><span class="p">,</span>
           <span class="s1">'KLDivLoss'</span><span class="p">,</span> <span class="s1">'CTCLoss'</span><span class="p">,</span> <span class="s1">'HuberLoss'</span><span class="p">,</span> <span class="s1">'HingeLoss'</span><span class="p">,</span>
           <span class="s1">'SquaredHingeLoss'</span><span class="p">,</span> <span class="s1">'LogisticLoss'</span><span class="p">,</span> <span class="s1">'TripletLoss'</span><span class="p">,</span> <span class="s1">'PoissonNLLLoss'</span><span class="p">,</span> <span class="s1">'CosineEmbeddingLoss'</span><span class="p">]</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="k">import</span> <span class="n">ndarray</span>
<span class="kn">from</span> <span class="nn">..base</span> <span class="k">import</span> <span class="n">numeric_types</span>
<span class="kn">from</span> <span class="nn">.block</span> <span class="k">import</span> <span class="n">HybridBlock</span>

<span class="k">def</span> <span class="nf">_apply_weighting</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">loss</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sample_weight</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">"""Apply weighting to loss.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    loss : Symbol</span>
<span class="sd">        The loss to be weighted.</span>
<span class="sd">    weight : float or None</span>
<span class="sd">        Global scalar weight for loss.</span>
<span class="sd">    sample_weight : Symbol or None</span>
<span class="sd">        Per sample weighting. Must be broadcastable to</span>
<span class="sd">        the same shape as loss. For example, if loss has</span>
<span class="sd">        shape (64, 10) and you want to weight each sample</span>
<span class="sd">        in the batch separately, `sample_weight` should have</span>
<span class="sd">        shape (64, 1).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    loss : Symbol</span>
<span class="sd">        Weighted loss</span>
<span class="sd">    """</span>
    <span class="k">if</span> <span class="n">sample_weight</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">loss</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">broadcast_mul</span><span class="p">(</span><span class="n">loss</span><span class="p">,</span> <span class="n">sample_weight</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">weight</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="n">numeric_types</span><span class="p">),</span> <span class="s2">"weight must be a number"</span>
        <span class="n">loss</span> <span class="o">=</span> <span class="n">loss</span> <span class="o">*</span> <span class="n">weight</span>

    <span class="k">return</span> <span class="n">loss</span>

<span class="k">def</span> <span class="nf">_reshape_like</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="sd">"""Reshapes x to the same shape as y."""</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="k">if</span> <span class="n">F</span> <span class="ow">is</span> <span class="n">ndarray</span> <span class="k">else</span> <span class="n">F</span><span class="o">.</span><span class="n">reshape_like</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

<div class="viewcode-block" id="Loss"><a class="viewcode-back" href="../../../api/python/gluon/loss.html#mxnet.gluon.loss.Loss">[docs]</a><span class="k">class</span> <span class="nc">Loss</span><span class="p">(</span><span class="n">HybridBlock</span><span class="p">):</span>
    <span class="sd">"""Base class for loss.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    weight : float or None</span>
<span class="sd">        Global scalar weight for loss.</span>
<span class="sd">    batch_axis : int, default 0</span>
<span class="sd">        The axis that represents mini-batch.</span>
<span class="sd">    """</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">batch_axis</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Loss</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_weight</span> <span class="o">=</span> <span class="n">weight</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_batch_axis</span> <span class="o">=</span> <span class="n">batch_axis</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s1">'</span><span class="si">{name}</span><span class="s1">(batch_axis=</span><span class="si">{_batch_axis}</span><span class="s1">, w=</span><span class="si">{_weight}</span><span class="s1">)'</span>
        <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>

<div class="viewcode-block" id="Loss.hybrid_forward"><a class="viewcode-back" href="../../../api/python/gluon/loss.html#mxnet.gluon.loss.Loss.hybrid_forward">[docs]</a>    <span class="k">def</span> <span class="nf">hybrid_forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""Overrides to construct symbolic graph for this `Block`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : Symbol or NDArray</span>
<span class="sd">            The first input tensor.</span>
<span class="sd">        *args : list of Symbol or list of NDArray</span>
<span class="sd">            Additional input tensors.</span>

<span class="sd">        """</span>
        <span class="c1"># pylint: disable= invalid-name</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div></div>


<div class="viewcode-block" id="L2Loss"><a class="viewcode-back" href="../../../api/python/gluon/loss.html#mxnet.gluon.loss.L2Loss">[docs]</a><span class="k">class</span> <span class="nc">L2Loss</span><span class="p">(</span><span class="n">Loss</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">"""Calculates the mean squared error between `pred` and `label`.</span>

<span class="sd">    .. math:: L = \frac{1}{2} \sum_i \vert {pred}_i - {label}_i \vert^2.</span>

<span class="sd">    `pred` and `label` can have arbitrary shape as long as they have the same</span>
<span class="sd">    number of elements.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    weight : float or None</span>
<span class="sd">        Global scalar weight for loss.</span>
<span class="sd">    batch_axis : int, default 0</span>
<span class="sd">        The axis that represents mini-batch.</span>


<span class="sd">    Inputs:</span>
<span class="sd">        - **pred**: prediction tensor with arbitrary shape</span>
<span class="sd">        - **label**: target tensor with the same size as pred.</span>
<span class="sd">        - **sample_weight**: element-wise weighting tensor. Must be broadcastable</span>
<span class="sd">          to the same shape as pred. For example, if pred has shape (64, 10)</span>
<span class="sd">          and you want to weigh each sample in the batch separately,</span>
<span class="sd">          sample_weight should have shape (64, 1).</span>

<span class="sd">    Outputs:</span>
<span class="sd">        - **loss**: loss tensor with shape (batch_size,). Dimenions other than</span>
<span class="sd">          batch_axis are averaged out.</span>
<span class="sd">    """</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">batch_axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">L2Loss</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="n">batch_axis</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">hybrid_forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">pred</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">sample_weight</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">label</span> <span class="o">=</span> <span class="n">_reshape_like</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">pred</span><span class="p">)</span>
        <span class="n">loss</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">pred</span> <span class="o">-</span> <span class="n">label</span><span class="p">)</span>
        <span class="n">loss</span> <span class="o">=</span> <span class="n">_apply_weighting</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">loss</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_weight</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">sample_weight</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">F</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">loss</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_batch_axis</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


<div class="viewcode-block" id="L1Loss"><a class="viewcode-back" href="../../../api/python/gluon/loss.html#mxnet.gluon.loss.L1Loss">[docs]</a><span class="k">class</span> <span class="nc">L1Loss</span><span class="p">(</span><span class="n">Loss</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">"""Calculates the mean absolute error between `pred` and `label`.</span>

<span class="sd">    .. math:: L = \sum_i \vert {pred}_i - {label}_i \vert.</span>

<span class="sd">    `pred` and `label` can have arbitrary shape as long as they have the same</span>
<span class="sd">    number of elements.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    weight : float or None</span>
<span class="sd">        Global scalar weight for loss.</span>
<span class="sd">    batch_axis : int, default 0</span>
<span class="sd">        The axis that represents mini-batch.</span>


<span class="sd">    Inputs:</span>
<span class="sd">        - **pred**: prediction tensor with arbitrary shape</span>
<span class="sd">        - **label**: target tensor with the same size as pred.</span>
<span class="sd">        - **sample_weight**: element-wise weighting tensor. Must be broadcastable</span>
<span class="sd">          to the same shape as pred. For example, if pred has shape (64, 10)</span>
<span class="sd">          and you want to weigh each sample in the batch separately,</span>
<span class="sd">          sample_weight should have shape (64, 1).</span>

<span class="sd">    Outputs:</span>
<span class="sd">        - **loss**: loss tensor with shape (batch_size,). Dimenions other than</span>
<span class="sd">          batch_axis are averaged out.</span>
<span class="sd">    """</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">batch_axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">L1Loss</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="n">batch_axis</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">hybrid_forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">pred</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">sample_weight</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">label</span> <span class="o">=</span> <span class="n">_reshape_like</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">pred</span><span class="p">)</span>
        <span class="n">loss</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">pred</span> <span class="o">-</span> <span class="n">label</span><span class="p">)</span>
        <span class="n">loss</span> <span class="o">=</span> <span class="n">_apply_weighting</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">loss</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_weight</span><span class="p">,</span> <span class="n">sample_weight</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">F</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">loss</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_batch_axis</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


<div class="viewcode-block" id="SigmoidBinaryCrossEntropyLoss"><a class="viewcode-back" href="../../../api/python/gluon/loss.html#mxnet.gluon.loss.SigmoidBinaryCrossEntropyLoss">[docs]</a><span class="k">class</span> <span class="nc">SigmoidBinaryCrossEntropyLoss</span><span class="p">(</span><span class="n">Loss</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">"""The cross-entropy loss for binary classification. (alias: SigmoidBCELoss)</span>

<span class="sd">    BCE loss is useful when training logistic regression. If `from_sigmoid`</span>
<span class="sd">    is False (default), this loss computes:</span>

<span class="sd">    .. math::</span>

<span class="sd">        prob = \frac{1}{1 + \exp(-{pred})}</span>

<span class="sd">        L = - \sum_i {label}_i * \log({prob}_i) +</span>
<span class="sd">            (1 - {label}_i) * \log(1 - {prob}_i)</span>

<span class="sd">    If `from_sigmoid` is True, this loss computes:</span>

<span class="sd">    .. math::</span>

<span class="sd">        L = - \sum_i {label}_i * \log({pred}_i) +</span>
<span class="sd">            (1 - {label}_i) * \log(1 - {pred}_i)</span>


<span class="sd">    `pred` and `label` can have arbitrary shape as long as they have the same</span>
<span class="sd">    number of elements.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    from_sigmoid : bool, default is `False`</span>
<span class="sd">        Whether the input is from the output of sigmoid. Set this to false will make</span>
<span class="sd">        the loss calculate sigmoid and BCE together, which is more numerically</span>
<span class="sd">        stable through log-sum-exp trick.</span>
<span class="sd">    weight : float or None</span>
<span class="sd">        Global scalar weight for loss.</span>
<span class="sd">    batch_axis : int, default 0</span>
<span class="sd">        The axis that represents mini-batch.</span>


<span class="sd">    Inputs:</span>
<span class="sd">        - **pred**: prediction tensor with arbitrary shape</span>
<span class="sd">        - **label**: target tensor with values in range `[0, 1]`. Must have the</span>
<span class="sd">          same size as `pred`.</span>
<span class="sd">        - **sample_weight**: element-wise weighting tensor. Must be broadcastable</span>
<span class="sd">          to the same shape as pred. For example, if pred has shape (64, 10)</span>
<span class="sd">          and you want to weigh each sample in the batch separately,</span>
<span class="sd">          sample_weight should have shape (64, 1).</span>

<span class="sd">    Outputs:</span>
<span class="sd">        - **loss**: loss tensor with shape (batch_size,). Dimenions other than</span>
<span class="sd">          batch_axis are averaged out.</span>
<span class="sd">    """</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">from_sigmoid</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">batch_axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SigmoidBinaryCrossEntropyLoss</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="n">batch_axis</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_from_sigmoid</span> <span class="o">=</span> <span class="n">from_sigmoid</span>

    <span class="k">def</span> <span class="nf">hybrid_forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">pred</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">sample_weight</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">label</span> <span class="o">=</span> <span class="n">_reshape_like</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">pred</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_from_sigmoid</span><span class="p">:</span>
            <span class="c1"># We use the stable formula: max(x, 0) - x * z + log(1 + exp(-abs(x)))</span>
            <span class="n">loss</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">relu</span><span class="p">(</span><span class="n">pred</span><span class="p">)</span> <span class="o">-</span> <span class="n">pred</span> <span class="o">*</span> <span class="n">label</span> <span class="o">+</span> <span class="n">F</span><span class="o">.</span><span class="n">Activation</span><span class="p">(</span><span class="o">-</span><span class="n">F</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">pred</span><span class="p">),</span> <span class="n">act_type</span><span class="o">=</span><span class="s1">'softrelu'</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">loss</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">pred</span><span class="o">+</span><span class="mf">1e-12</span><span class="p">)</span><span class="o">*</span><span class="n">label</span> <span class="o">+</span> <span class="n">F</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">pred</span><span class="o">+</span><span class="mf">1e-12</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">label</span><span class="p">))</span>
        <span class="n">loss</span> <span class="o">=</span> <span class="n">_apply_weighting</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">loss</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_weight</span><span class="p">,</span> <span class="n">sample_weight</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">F</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">loss</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_batch_axis</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

<span class="n">SigmoidBCELoss</span> <span class="o">=</span> <span class="n">SigmoidBinaryCrossEntropyLoss</span>


<div class="viewcode-block" id="SoftmaxCrossEntropyLoss"><a class="viewcode-back" href="../../../api/python/gluon/loss.html#mxnet.gluon.loss.SoftmaxCrossEntropyLoss">[docs]</a><span class="k">class</span> <span class="nc">SoftmaxCrossEntropyLoss</span><span class="p">(</span><span class="n">Loss</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">"""Computes the softmax cross entropy loss. (alias: SoftmaxCELoss)</span>

<span class="sd">    If `sparse_label` is `True` (default), label should contain integer</span>
<span class="sd">    category indicators:</span>

<span class="sd">    .. math::</span>

<span class="sd">        \DeclareMathOperator{softmax}{softmax}</span>

<span class="sd">        p = \softmax({pred})</span>

<span class="sd">        L = -\sum_i \log p_{i,{label}_i}</span>

<span class="sd">    `label`'s shape should be `pred`'s shape with the `axis` dimension removed.</span>
<span class="sd">    i.e. for `pred` with shape (1,2,3,4) and `axis = 2`, `label`'s shape should</span>
<span class="sd">    be (1,2,4).</span>

<span class="sd">    If `sparse_label` is `False`, `label` should contain probability distribution</span>
<span class="sd">    and `label`'s shape should be the same with `pred`:</span>

<span class="sd">    .. math::</span>

<span class="sd">        p = \softmax({pred})</span>

<span class="sd">        L = -\sum_i \sum_j {label}_j \log p_{ij}</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    axis : int, default -1</span>
<span class="sd">        The axis to sum over when computing softmax and entropy.</span>
<span class="sd">    sparse_label : bool, default True</span>
<span class="sd">        Whether label is an integer array instead of probability distribution.</span>
<span class="sd">    from_logits : bool, default False</span>
<span class="sd">        Whether input is a log probability (usually from log_softmax) instead</span>
<span class="sd">        of unnormalized numbers.</span>
<span class="sd">    weight : float or None</span>
<span class="sd">        Global scalar weight for loss.</span>
<span class="sd">    batch_axis : int, default 0</span>
<span class="sd">        The axis that represents mini-batch.</span>


<span class="sd">    Inputs:</span>
<span class="sd">        - **pred**: the prediction tensor, where the `batch_axis` dimension</span>
<span class="sd">          ranges over batch size and `axis` dimension ranges over the number</span>
<span class="sd">          of classes.</span>
<span class="sd">        - **label**: the truth tensor. When `sparse_label` is True, `label`'s</span>
<span class="sd">          shape should be `pred`'s shape with the `axis` dimension removed.</span>
<span class="sd">          i.e. for `pred` with shape (1,2,3,4) and `axis = 2`, `label`'s shape</span>
<span class="sd">          should be (1,2,4) and values should be integers between 0 and 2. If</span>
<span class="sd">          `sparse_label` is False, `label`'s shape must be the same as `pred`</span>
<span class="sd">          and values should be floats in the range `[0, 1]`.</span>
<span class="sd">        - **sample_weight**: element-wise weighting tensor. Must be broadcastable</span>
<span class="sd">          to the same shape as label. For example, if label has shape (64, 10)</span>
<span class="sd">          and you want to weigh each sample in the batch separately,</span>
<span class="sd">          sample_weight should have shape (64, 1).</span>

<span class="sd">    Outputs:</span>
<span class="sd">        - **loss**: loss tensor with shape (batch_size,). Dimenions other than</span>
<span class="sd">          batch_axis are averaged out.</span>
<span class="sd">    """</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">sparse_label</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">from_logits</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">batch_axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SoftmaxCrossEntropyLoss</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="n">batch_axis</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_axis</span> <span class="o">=</span> <span class="n">axis</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sparse_label</span> <span class="o">=</span> <span class="n">sparse_label</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_from_logits</span> <span class="o">=</span> <span class="n">from_logits</span>

    <span class="k">def</span> <span class="nf">hybrid_forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">pred</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">sample_weight</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_from_logits</span><span class="p">:</span>
            <span class="n">pred</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">log_softmax</span><span class="p">(</span><span class="n">pred</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_axis</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sparse_label</span><span class="p">:</span>
            <span class="n">loss</span> <span class="o">=</span> <span class="o">-</span><span class="n">F</span><span class="o">.</span><span class="n">pick</span><span class="p">(</span><span class="n">pred</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">label</span> <span class="o">=</span> <span class="n">_reshape_like</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">pred</span><span class="p">)</span>
            <span class="n">loss</span> <span class="o">=</span> <span class="o">-</span><span class="n">F</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">pred</span><span class="o">*</span><span class="n">label</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">loss</span> <span class="o">=</span> <span class="n">_apply_weighting</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">loss</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_weight</span><span class="p">,</span> <span class="n">sample_weight</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">F</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">loss</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_batch_axis</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

<span class="n">SoftmaxCELoss</span> <span class="o">=</span> <span class="n">SoftmaxCrossEntropyLoss</span>


<div class="viewcode-block" id="KLDivLoss"><a class="viewcode-back" href="../../../api/python/gluon/loss.html#mxnet.gluon.loss.KLDivLoss">[docs]</a><span class="k">class</span> <span class="nc">KLDivLoss</span><span class="p">(</span><span class="n">Loss</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">"""The Kullback-Leibler divergence loss.</span>

<span class="sd">    KL divergence measures the distance between contiguous distributions. It</span>
<span class="sd">    can be used to minimize information loss when approximating a distribution.</span>
<span class="sd">    If `from_logits` is True (default), loss is defined as:</span>

<span class="sd">    .. math::</span>

<span class="sd">        L = \sum_i {label}_i * \big[\log({label}_i) - {pred}_i\big]</span>

<span class="sd">    If `from_logits` is False, loss is defined as:</span>

<span class="sd">    .. math::</span>

<span class="sd">        \DeclareMathOperator{softmax}{softmax}</span>

<span class="sd">        prob = \softmax({pred})</span>

<span class="sd">        L = \sum_i {label}_i * \big[\log({label}_i) - log({pred}_i)\big]</span>


<span class="sd">    `pred` and `label` can have arbitrary shape as long as they have the same</span>
<span class="sd">    number of elements.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    from_logits : bool, default is `True`</span>
<span class="sd">        Whether the input is log probability (usually from log_softmax) instead</span>
<span class="sd">        of unnormalized numbers.</span>
<span class="sd">    axis : int, default -1</span>
<span class="sd">        The dimension along with to compute softmax. Only used when `from_logits`</span>
<span class="sd">        is False.</span>
<span class="sd">    weight : float or None</span>
<span class="sd">        Global scalar weight for loss.</span>
<span class="sd">    batch_axis : int, default 0</span>
<span class="sd">        The axis that represents mini-batch.</span>


<span class="sd">    Inputs:</span>
<span class="sd">        - **pred**: prediction tensor with arbitrary shape. If `from_logits` is</span>
<span class="sd">          True, `pred` should be log probabilities. Otherwise, it should be</span>
<span class="sd">          unnormalized predictions, i.e. from a dense layer.</span>
<span class="sd">        - **label**: truth tensor with values in range `(0, 1)`. Must have</span>
<span class="sd">          the same size as `pred`.</span>
<span class="sd">        - **sample_weight**: element-wise weighting tensor. Must be broadcastable</span>
<span class="sd">          to the same shape as pred. For example, if pred has shape (64, 10)</span>
<span class="sd">          and you want to weigh each sample in the batch separately,</span>
<span class="sd">          sample_weight should have shape (64, 1).</span>

<span class="sd">    Outputs:</span>
<span class="sd">        - **loss**: loss tensor with shape (batch_size,). Dimenions other than</span>
<span class="sd">          batch_axis are averaged out.</span>


<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">        `Kullback-Leibler divergence</span>
<span class="sd">        <https://en.wikipedia.org/wiki/Kullback-Leibler_divergence>`_</span>
<span class="sd">    """</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">from_logits</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">batch_axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">KLDivLoss</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="n">batch_axis</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_from_logits</span> <span class="o">=</span> <span class="n">from_logits</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_axis</span> <span class="o">=</span> <span class="n">axis</span>

    <span class="k">def</span> <span class="nf">hybrid_forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">pred</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">sample_weight</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_from_logits</span><span class="p">:</span>
            <span class="n">pred</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">log_softmax</span><span class="p">(</span><span class="n">pred</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_axis</span><span class="p">)</span>
        <span class="n">loss</span> <span class="o">=</span> <span class="n">label</span> <span class="o">*</span> <span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">label</span><span class="o">+</span><span class="mf">1e-12</span><span class="p">)</span> <span class="o">-</span> <span class="n">pred</span><span class="p">)</span>
        <span class="n">loss</span> <span class="o">=</span> <span class="n">_apply_weighting</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">loss</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_weight</span><span class="p">,</span> <span class="n">sample_weight</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">F</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">loss</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_batch_axis</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


<div class="viewcode-block" id="CTCLoss"><a class="viewcode-back" href="../../../api/python/gluon/loss.html#mxnet.gluon.loss.CTCLoss">[docs]</a><span class="k">class</span> <span class="nc">CTCLoss</span><span class="p">(</span><span class="n">Loss</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">"""Connectionist Temporal Classification Loss.</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    layout : str, default 'NTC'</span>
<span class="sd">        Layout of prediction tensor. 'N', 'T', 'C' stands for batch size,</span>
<span class="sd">        sequence length, and alphabet_size respectively.</span>
<span class="sd">    label_layout : str, default 'NT'</span>
<span class="sd">        Layout of the labels. 'N', 'T' stands for batch size, and sequence</span>
<span class="sd">        length respectively.</span>
<span class="sd">    weight : float or None</span>
<span class="sd">        Global scalar weight for loss.</span>


<span class="sd">    Inputs:</span>
<span class="sd">        - **pred**: unnormalized prediction tensor (before softmax).</span>
<span class="sd">          Its shape depends on `layout`. If `layout` is 'TNC', pred</span>
<span class="sd">          should have shape `(sequence_length, batch_size, alphabet_size)`.</span>
<span class="sd">          Note that in the last dimension, index `alphabet_size-1` is reserved</span>
<span class="sd">          for internal use as blank label. So `alphabet_size` is one plus the</span>
<span class="sd">          actual alphabet size.</span>

<span class="sd">        - **label**: zero-based label tensor. Its shape depends on `label_layout`.</span>
<span class="sd">          If `label_layout` is 'TN', `label` should have shape</span>
<span class="sd">          `(label_sequence_length, batch_size)`.</span>

<span class="sd">        - **pred_lengths**: optional (default None), used for specifying the</span>
<span class="sd">          length of each entry when different `pred` entries in the same batch</span>
<span class="sd">          have different lengths. `pred_lengths` should have shape `(batch_size,)`.</span>

<span class="sd">        - **label_lengths**: optional (default None), used for specifying the</span>
<span class="sd">          length of each entry when different `label` entries in the same batch</span>
<span class="sd">          have different lengths. `label_lengths` should have shape `(batch_size,)`.</span>

<span class="sd">    Outputs:</span>
<span class="sd">        - **loss**: output loss has shape `(batch_size,)`.</span>


<span class="sd">    **Example**: suppose the vocabulary is `[a, b, c]`, and in one batch we</span>
<span class="sd">    have three sequences 'ba', 'cbb', and 'abac'. We can index the labels as</span>
<span class="sd">    `{'a': 0, 'b': 1, 'c': 2, blank: 3}`. Then `alphabet_size` should be 4,</span>
<span class="sd">    where label 3 is reserved for internal use by `CTCLoss`. We then need to</span>
<span class="sd">    pad each sequence with `-1` to make a rectangular `label` tensor::</span>

<span class="sd">        [[1, 0, -1, -1],</span>
<span class="sd">         [2, 1,  1, -1],</span>
<span class="sd">         [0, 1,  0,  2]]</span>


<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">        `Connectionist Temporal Classification: Labelling Unsegmented</span>
<span class="sd">        Sequence Data with Recurrent Neural Networks</span>
<span class="sd">        <http://www.cs.toronto.edu/~graves/icml_2006.pdf>`_</span>
<span class="sd">    """</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">layout</span><span class="o">=</span><span class="s1">'NTC'</span><span class="p">,</span> <span class="n">label_layout</span><span class="o">=</span><span class="s1">'NT'</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">layout</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">'NTC'</span><span class="p">,</span> <span class="s1">'TNC'</span><span class="p">],</span>\
               <span class="s2">"Only 'NTC' and 'TNC' layouts for pred are supported. Got: </span><span class="si">%s</span><span class="s2">"</span><span class="o">%</span><span class="n">layout</span>
        <span class="k">assert</span> <span class="n">label_layout</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">'NT'</span><span class="p">,</span> <span class="s1">'TN'</span><span class="p">],</span>\
               <span class="s2">"Only 'NT' and 'TN' layouts for label are supported. Got: </span><span class="si">%s</span><span class="s2">"</span><span class="o">%</span><span class="n">label_layout</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_layout</span> <span class="o">=</span> <span class="n">layout</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_label_layout</span> <span class="o">=</span> <span class="n">label_layout</span>
        <span class="n">batch_axis</span> <span class="o">=</span> <span class="n">label_layout</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">'N'</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">CTCLoss</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="n">batch_axis</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">hybrid_forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">pred</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span>
                       <span class="n">pred_lengths</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">label_lengths</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sample_weight</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_layout</span> <span class="o">==</span> <span class="s1">'NTC'</span><span class="p">:</span>
            <span class="n">pred</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">pred</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_batch_axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">label</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">loss</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">CTCLoss</span><span class="p">(</span><span class="n">pred</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">pred_lengths</span><span class="p">,</span> <span class="n">label_lengths</span><span class="p">,</span>
                         <span class="n">use_data_lengths</span><span class="o">=</span><span class="n">pred_lengths</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span>
                         <span class="n">use_label_lengths</span><span class="o">=</span><span class="n">label_lengths</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span>
                         <span class="n">blank_label</span><span class="o">=</span><span class="s1">'last'</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_apply_weighting</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">loss</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_weight</span><span class="p">,</span> <span class="n">sample_weight</span><span class="p">)</span></div>


<div class="viewcode-block" id="HuberLoss"><a class="viewcode-back" href="../../../api/python/gluon/loss.html#mxnet.gluon.loss.HuberLoss">[docs]</a><span class="k">class</span> <span class="nc">HuberLoss</span><span class="p">(</span><span class="n">Loss</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">"""Calculates smoothed L1 loss that is equal to L1 loss if absolute error</span>
<span class="sd">    exceeds rho but is equal to L2 loss otherwise. Also called SmoothedL1 loss.</span>

<span class="sd">    .. math::</span>
<span class="sd">        L = \sum_i \begin{cases} \frac{1}{2 {rho}} ({pred}_i - {label}_i)^2 &amp;</span>
<span class="sd">                           \text{ if } |{pred}_i - {label}_i| < {rho} \\</span>
<span class="sd">                           |{pred}_i - {label}_i| - \frac{{rho}}{2} &amp;</span>
<span class="sd">                           \text{ otherwise }</span>
<span class="sd">            \end{cases}</span>

<span class="sd">    `pred` and `label` can have arbitrary shape as long as they have the same</span>
<span class="sd">    number of elements.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    rho : float, default 1</span>
<span class="sd">        Threshold for trimmed mean estimator.</span>
<span class="sd">    weight : float or None</span>
<span class="sd">        Global scalar weight for loss.</span>
<span class="sd">    batch_axis : int, default 0</span>
<span class="sd">        The axis that represents mini-batch.</span>


<span class="sd">    Inputs:</span>
<span class="sd">        - **pred**: prediction tensor with arbitrary shape</span>
<span class="sd">        - **label**: target tensor with the same size as pred.</span>
<span class="sd">        - **sample_weight**: element-wise weighting tensor. Must be broadcastable</span>
<span class="sd">          to the same shape as pred. For example, if pred has shape (64, 10)</span>
<span class="sd">          and you want to weigh each sample in the batch separately,</span>
<span class="sd">          sample_weight should have shape (64, 1).</span>

<span class="sd">    Outputs:</span>
<span class="sd">        - **loss**: loss tensor with shape (batch_size,). Dimenions other than</span>
<span class="sd">          batch_axis are averaged out.</span>
<span class="sd">    """</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rho</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">batch_axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">HuberLoss</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="n">batch_axis</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rho</span> <span class="o">=</span> <span class="n">rho</span>

    <span class="k">def</span> <span class="nf">hybrid_forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">pred</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">sample_weight</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">label</span> <span class="o">=</span> <span class="n">_reshape_like</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">pred</span><span class="p">)</span>
        <span class="n">loss</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">pred</span> <span class="o">-</span> <span class="n">label</span><span class="p">)</span>
        <span class="n">loss</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">loss</span> <span class="o">></span> <span class="bp">self</span><span class="o">.</span><span class="n">_rho</span><span class="p">,</span> <span class="n">loss</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rho</span><span class="p">,</span>
                       <span class="p">(</span><span class="mf">0.5</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">_rho</span><span class="p">)</span> <span class="o">*</span> <span class="n">F</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">loss</span><span class="p">))</span>
        <span class="n">loss</span> <span class="o">=</span> <span class="n">_apply_weighting</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">loss</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_weight</span><span class="p">,</span> <span class="n">sample_weight</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">F</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">loss</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_batch_axis</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


<div class="viewcode-block" id="HingeLoss"><a class="viewcode-back" href="../../../api/python/gluon/loss.html#mxnet.gluon.loss.HingeLoss">[docs]</a><span class="k">class</span> <span class="nc">HingeLoss</span><span class="p">(</span><span class="n">Loss</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">"""Calculates the hinge loss function often used in SVMs:</span>

<span class="sd">    .. math::</span>
<span class="sd">        L = \sum_i max(0, {margin} - {pred}_i \cdot {label}_i)</span>

<span class="sd">    where `pred` is the classifier prediction and `label` is the target tensor</span>
<span class="sd">    containing values -1 or 1. `pred` and `label` must have the same number of</span>
<span class="sd">    elements.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    margin : float</span>
<span class="sd">        The margin in hinge loss. Defaults to 1.0</span>
<span class="sd">    weight : float or None</span>
<span class="sd">        Global scalar weight for loss.</span>
<span class="sd">    batch_axis : int, default 0</span>
<span class="sd">        The axis that represents mini-batch.</span>


<span class="sd">    Inputs:</span>
<span class="sd">        - **pred**: prediction tensor with arbitrary shape.</span>
<span class="sd">        - **label**: truth tensor with values -1 or 1. Must have the same size</span>
<span class="sd">          as pred.</span>
<span class="sd">        - **sample_weight**: element-wise weighting tensor. Must be broadcastable</span>
<span class="sd">          to the same shape as pred. For example, if pred has shape (64, 10)</span>
<span class="sd">          and you want to weigh each sample in the batch separately,</span>
<span class="sd">          sample_weight should have shape (64, 1).</span>

<span class="sd">    Outputs:</span>
<span class="sd">        - **loss**: loss tensor with shape (batch_size,). Dimenions other than</span>
<span class="sd">          batch_axis are averaged out.</span>
<span class="sd">    """</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">margin</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">batch_axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">HingeLoss</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="n">batch_axis</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_margin</span> <span class="o">=</span> <span class="n">margin</span>

    <span class="k">def</span> <span class="nf">hybrid_forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">pred</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">sample_weight</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">label</span> <span class="o">=</span> <span class="n">_reshape_like</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">pred</span><span class="p">)</span>
        <span class="n">loss</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">relu</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_margin</span> <span class="o">-</span> <span class="n">pred</span> <span class="o">*</span> <span class="n">label</span><span class="p">)</span>
        <span class="n">loss</span> <span class="o">=</span> <span class="n">_apply_weighting</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">loss</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_weight</span><span class="p">,</span> <span class="n">sample_weight</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">F</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">loss</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_batch_axis</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


<div class="viewcode-block" id="SquaredHingeLoss"><a class="viewcode-back" href="../../../api/python/gluon/loss.html#mxnet.gluon.loss.SquaredHingeLoss">[docs]</a><span class="k">class</span> <span class="nc">SquaredHingeLoss</span><span class="p">(</span><span class="n">Loss</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">"""Calculates the soft-margin loss function used in SVMs:</span>

<span class="sd">    .. math::</span>
<span class="sd">        L = \sum_i max(0, {margin} - {pred}_i \cdot {label}_i)^2</span>

<span class="sd">    where `pred` is the classifier prediction and `label` is the target tensor</span>
<span class="sd">    containing values -1 or 1. `pred` and `label` can have arbitrary shape as</span>
<span class="sd">    long as they have the same number of elements.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    margin : float</span>
<span class="sd">        The margin in hinge loss. Defaults to 1.0</span>
<span class="sd">    weight : float or None</span>
<span class="sd">        Global scalar weight for loss.</span>
<span class="sd">    batch_axis : int, default 0</span>
<span class="sd">        The axis that represents mini-batch.</span>


<span class="sd">    Inputs:</span>
<span class="sd">        - **pred**: prediction tensor with arbitrary shape</span>
<span class="sd">        - **label**: truth tensor with values -1 or 1. Must have the same size</span>
<span class="sd">          as pred.</span>
<span class="sd">        - **sample_weight**: element-wise weighting tensor. Must be broadcastable</span>
<span class="sd">          to the same shape as pred. For example, if pred has shape (64, 10)</span>
<span class="sd">          and you want to weigh each sample in the batch separately,</span>
<span class="sd">          sample_weight should have shape (64, 1).</span>

<span class="sd">    Outputs:</span>
<span class="sd">        - **loss**: loss tensor with shape (batch_size,). Dimenions other than</span>
<span class="sd">          batch_axis are averaged out.</span>
<span class="sd">    """</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">margin</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">batch_axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SquaredHingeLoss</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="n">batch_axis</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_margin</span> <span class="o">=</span> <span class="n">margin</span>

    <span class="k">def</span> <span class="nf">hybrid_forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">pred</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">sample_weight</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">label</span> <span class="o">=</span> <span class="n">_reshape_like</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">pred</span><span class="p">)</span>
        <span class="n">loss</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">relu</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_margin</span> <span class="o">-</span> <span class="n">pred</span> <span class="o">*</span> <span class="n">label</span><span class="p">))</span>
        <span class="n">loss</span> <span class="o">=</span> <span class="n">_apply_weighting</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">loss</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_weight</span><span class="p">,</span> <span class="n">sample_weight</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">F</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">loss</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_batch_axis</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


<div class="viewcode-block" id="LogisticLoss"><a class="viewcode-back" href="../../../api/python/gluon/loss.html#mxnet.gluon.loss.LogisticLoss">[docs]</a><span class="k">class</span> <span class="nc">LogisticLoss</span><span class="p">(</span><span class="n">Loss</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">"""Calculates the logistic loss (for binary losses only):</span>

<span class="sd">    .. math::</span>
<span class="sd">        L = \sum_i \log(1 + \exp(- {pred}_i \cdot {label}_i))</span>

<span class="sd">    where `pred` is the classifier prediction and `label` is the target tensor</span>
<span class="sd">    containing values -1 or 1 (0 or 1 if `label_format` is binary).</span>
<span class="sd">    `pred` and `label` can have arbitrary shape as long as they have the same number of elements.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    weight : float or None</span>
<span class="sd">        Global scalar weight for loss.</span>
<span class="sd">    batch_axis : int, default 0</span>
<span class="sd">        The axis that represents mini-batch.</span>
<span class="sd">    label_format : str, default 'signed'</span>
<span class="sd">        Can be either 'signed' or 'binary'. If the label_format is 'signed', all label values should</span>
<span class="sd">        be either -1 or 1. If the label_format is 'binary', all label values should be either</span>
<span class="sd">        0 or 1.</span>

<span class="sd">    Inputs:</span>
<span class="sd">        - **pred**: prediction tensor with arbitrary shape.</span>
<span class="sd">        - **label**: truth tensor with values -1/1 (label_format is 'signed')</span>
<span class="sd">          or 0/1 (label_format is 'binary'). Must have the same size as pred.</span>
<span class="sd">        - **sample_weight**: element-wise weighting tensor. Must be broadcastable</span>
<span class="sd">          to the same shape as pred. For example, if pred has shape (64, 10)</span>
<span class="sd">          and you want to weigh each sample in the batch separately,</span>
<span class="sd">          sample_weight should have shape (64, 1).</span>

<span class="sd">    Outputs:</span>
<span class="sd">        - **loss**: loss tensor with shape (batch_size,). Dimenions other than</span>
<span class="sd">          batch_axis are averaged out.</span>
<span class="sd">    """</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">batch_axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">label_format</span><span class="o">=</span><span class="s1">'signed'</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">LogisticLoss</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="n">batch_axis</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_label_format</span> <span class="o">=</span> <span class="n">label_format</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_label_format</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">"signed"</span><span class="p">,</span> <span class="s2">"binary"</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"label_format can only be signed or binary, recieved </span><span class="si">%s</span><span class="s2">."</span>
                             <span class="o">%</span> <span class="n">label_format</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">hybrid_forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">pred</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">sample_weight</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">label</span> <span class="o">=</span> <span class="n">_reshape_like</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">pred</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_label_format</span> <span class="o">==</span> <span class="s1">'signed'</span><span class="p">:</span>
            <span class="n">label</span> <span class="o">=</span> <span class="p">(</span><span class="n">label</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>  <span class="c1"># Transform label to be either 0 or 1</span>
        <span class="c1"># Use a stable formula in computation</span>
        <span class="n">loss</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">relu</span><span class="p">(</span><span class="n">pred</span><span class="p">)</span> <span class="o">-</span> <span class="n">pred</span> <span class="o">*</span> <span class="n">label</span> <span class="o">+</span> <span class="n">F</span><span class="o">.</span><span class="n">Activation</span><span class="p">(</span><span class="o">-</span><span class="n">F</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">pred</span><span class="p">),</span> <span class="n">act_type</span><span class="o">=</span><span class="s1">'softrelu'</span><span class="p">)</span>
        <span class="n">loss</span> <span class="o">=</span> <span class="n">_apply_weighting</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">loss</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_weight</span><span class="p">,</span> <span class="n">sample_weight</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">F</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">loss</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_batch_axis</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


<div class="viewcode-block" id="TripletLoss"><a class="viewcode-back" href="../../../api/python/gluon/loss.html#mxnet.gluon.loss.TripletLoss">[docs]</a><span class="k">class</span> <span class="nc">TripletLoss</span><span class="p">(</span><span class="n">Loss</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">"""Calculates triplet loss given three input tensors and a positive margin.</span>
<span class="sd">    Triplet loss measures the relative similarity between prediction, a positive</span>
<span class="sd">    example and a negative example:</span>

<span class="sd">    .. math::</span>
<span class="sd">        L = \sum_i \max(\Vert {pred}_i - {pos_i} \Vert_2^2 -</span>
<span class="sd">                        \Vert {pred}_i - {neg_i} \Vert_2^2 + {margin}, 0)</span>

<span class="sd">    `pred`, `positive` and `negative` can have arbitrary shape as long as they</span>
<span class="sd">    have the same number of elements.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    margin : float</span>
<span class="sd">        Margin of separation between correct and incorrect pair.</span>
<span class="sd">    weight : float or None</span>
<span class="sd">        Global scalar weight for loss.</span>
<span class="sd">    batch_axis : int, default 0</span>
<span class="sd">        The axis that represents mini-batch.</span>


<span class="sd">    Inputs:</span>
<span class="sd">        - **pred**: prediction tensor with arbitrary shape</span>
<span class="sd">        - **positive**: positive example tensor with arbitrary shape. Must have</span>
<span class="sd">          the same size as pred.</span>
<span class="sd">        - **negative**: negative example tensor with arbitrary shape Must have</span>
<span class="sd">          the same size as pred.</span>

<span class="sd">    Outputs:</span>
<span class="sd">        - **loss**: loss tensor with shape (batch_size,).</span>
<span class="sd">    """</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">margin</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">batch_axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">TripletLoss</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="n">batch_axis</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_margin</span> <span class="o">=</span> <span class="n">margin</span>

    <span class="k">def</span> <span class="nf">hybrid_forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">pred</span><span class="p">,</span> <span class="n">positive</span><span class="p">,</span> <span class="n">negative</span><span class="p">):</span>
        <span class="n">positive</span> <span class="o">=</span> <span class="n">_reshape_like</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">positive</span><span class="p">,</span> <span class="n">pred</span><span class="p">)</span>
        <span class="n">negative</span> <span class="o">=</span> <span class="n">_reshape_like</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">negative</span><span class="p">,</span> <span class="n">pred</span><span class="p">)</span>
        <span class="n">loss</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">pred</span><span class="o">-</span><span class="n">positive</span><span class="p">)</span> <span class="o">-</span> <span class="n">F</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">pred</span><span class="o">-</span><span class="n">negative</span><span class="p">),</span>
                     <span class="n">axis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_batch_axis</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">loss</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">relu</span><span class="p">(</span><span class="n">loss</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_margin</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_apply_weighting</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">loss</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_weight</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span></div>


<div class="viewcode-block" id="PoissonNLLLoss"><a class="viewcode-back" href="../../../api/python/gluon/loss.html#mxnet.gluon.loss.PoissonNLLLoss">[docs]</a><span class="k">class</span> <span class="nc">PoissonNLLLoss</span><span class="p">(</span><span class="n">Loss</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">"""For a target (Random Variable) in a Poisson distribution, the function calculates the Negative</span>
<span class="sd">    Log likelihood loss.</span>
<span class="sd">    PoissonNLLLoss measures the loss accrued from a poisson regression prediction made by the model.</span>

<span class="sd">    .. math::</span>
<span class="sd">        L = \text{pred} - \text{target} * \log(\text{pred}) +\log(\text{target!})</span>

<span class="sd">    `pred`, `target` can have arbitrary shape as long as they have the same number of elements.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    from_logits : boolean, default True</span>
<span class="sd">        indicating whether log(predicted) value has already been computed. If True, the loss is computed as</span>
<span class="sd">        :math:`\exp(\text{pred}) - \text{target} * \text{pred}`, and if False, then loss is computed as</span>
<span class="sd">        :math:`\text{pred} - \text{target} * \log(\text{pred}+\text{epsilon})`.The default value</span>
<span class="sd">    weight : float or None</span>
<span class="sd">        Global scalar weight for loss.</span>
<span class="sd">    batch_axis : int, default 0</span>
<span class="sd">        The axis that represents mini-batch.</span>
<span class="sd">    compute_full: boolean, default False</span>
<span class="sd">        Indicates whether to add an approximation(Stirling factor) for the Factorial term in the formula for the loss.</span>
<span class="sd">        The Stirling factor is:</span>
<span class="sd">        :math:`\text{target} * \log(\text{target}) - \text{target} + 0.5 * \log(2 * \pi * \text{target})`</span>
<span class="sd">    epsilon: float, default 1e-08</span>
<span class="sd">        This is to avoid calculating log(0) which is not defined.</span>


<span class="sd">    Inputs:</span>
<span class="sd">        - **pred**:   Predicted value</span>
<span class="sd">        - **target**: Random variable(count or number) which belongs to a Poisson distribution.</span>
<span class="sd">        - **sample_weight**: element-wise weighting tensor. Must be broadcastable</span>
<span class="sd">          to the same shape as pred. For example, if pred has shape (64, 10)</span>
<span class="sd">          and you want to weigh each sample in the batch separately,</span>
<span class="sd">          sample_weight should have shape (64, 1).</span>

<span class="sd">    Outputs:</span>
<span class="sd">        - **loss**: Average loss (shape=(1,1)) of the loss tensor with shape (batch_size,).</span>
<span class="sd">    """</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">from_logits</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">batch_axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">compute_full</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">PoissonNLLLoss</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="n">batch_axis</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_from_logits</span> <span class="o">=</span> <span class="n">from_logits</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_compute_full</span> <span class="o">=</span> <span class="n">compute_full</span>

    <span class="k">def</span> <span class="nf">hybrid_forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">pred</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">sample_weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="mf">1e-08</span><span class="p">):</span>
        <span class="n">target</span> <span class="o">=</span> <span class="n">_reshape_like</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">pred</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_from_logits</span><span class="p">:</span>
            <span class="n">loss</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">pred</span><span class="p">)</span> <span class="o">-</span> <span class="n">target</span> <span class="o">*</span> <span class="n">pred</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">loss</span> <span class="o">=</span> <span class="n">pred</span> <span class="o">-</span> <span class="n">target</span> <span class="o">*</span> <span class="n">F</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">pred</span> <span class="o">+</span> <span class="n">epsilon</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_full</span><span class="p">:</span>
            <span class="c1"># Using numpy's pi value</span>
            <span class="n">stirling_factor</span> <span class="o">=</span> <span class="n">target</span> <span class="o">*</span> <span class="n">F</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">target</span><span class="p">)</span><span class="o">-</span> <span class="n">target</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">F</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">target</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
            <span class="n">target_gt_1</span> <span class="o">=</span> <span class="n">target</span> <span class="o">></span> <span class="mi">1</span>
            <span class="n">stirling_factor</span> <span class="o">*=</span> <span class="n">target_gt_1</span>
            <span class="n">loss</span> <span class="o">+=</span> <span class="n">stirling_factor</span>
        <span class="n">loss</span> <span class="o">=</span> <span class="n">_apply_weighting</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">loss</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_weight</span><span class="p">,</span> <span class="n">sample_weight</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">F</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">loss</span><span class="p">)</span></div>


<div class="viewcode-block" id="CosineEmbeddingLoss"><a class="viewcode-back" href="../../../api/python/gluon/loss.html#mxnet.gluon.loss.CosineEmbeddingLoss">[docs]</a><span class="k">class</span> <span class="nc">CosineEmbeddingLoss</span><span class="p">(</span><span class="n">Loss</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">"""For a target label 1 or -1, vectors input1 and input2, the function computes the cosine distance</span>
<span class="sd">    between the vectors. This can be interpreted as how similar/dissimilar two input vectors are.</span>

<span class="sd">    .. math::</span>

<span class="sd">        L = \sum_i \begin{cases} 1 - {cos\_sim({input1}_i, {input2}_i)} &amp; \text{ if } {label}_i = 1\\</span>
<span class="sd">                         {cos\_sim({input1}_i, {input2}_i)} &amp; \text{ if } {label}_i = -1 \end{cases}\\</span>
<span class="sd">        cos\_sim(input1, input2) = \frac{{input1}_i.{input2}_i}{||{input1}_i||.||{input2}_i||}</span>

<span class="sd">    `input1`, `input2` can have arbitrary shape as long as they have the same number of elements.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    weight : float or None</span>
<span class="sd">        Global scalar weight for loss.</span>
<span class="sd">    batch_axis : int, default 0</span>
<span class="sd">        The axis that represents mini-batch.</span>
<span class="sd">    margin : float</span>
<span class="sd">        Margin of separation between correct and incorrect pair.</span>


<span class="sd">    Inputs:</span>
<span class="sd">        - **input1**: a tensor with arbitrary shape</span>
<span class="sd">        - **input2**: another tensor with same shape as pred to which input1 is</span>
<span class="sd">          compared for similarity and loss calculation</span>
<span class="sd">        - **label**: A 1-D tensor indicating for each pair input1 and input2, target label is 1 or -1</span>
<span class="sd">        - **sample_weight**: element-wise weighting tensor. Must be broadcastable</span>
<span class="sd">          to the same shape as input1. For example, if input1 has shape (64, 10)</span>
<span class="sd">          and you want to weigh each sample in the batch separately,</span>
<span class="sd">          sample_weight should have shape (64, 1).</span>

<span class="sd">    Outputs:</span>
<span class="sd">        - **loss**: The loss tensor with shape (batch_size,).</span>
<span class="sd">    """</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">batch_axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">margin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">CosineEmbeddingLoss</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="n">batch_axis</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_margin</span> <span class="o">=</span> <span class="n">margin</span>

    <span class="k">def</span> <span class="nf">hybrid_forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">input1</span><span class="p">,</span> <span class="n">input2</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">sample_weight</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">input1</span> <span class="o">=</span> <span class="n">_reshape_like</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">input1</span><span class="p">,</span> <span class="n">input2</span><span class="p">)</span>
        <span class="n">label</span> <span class="o">=</span> <span class="n">label</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">cos_sim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cosine_similarity</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">input1</span><span class="p">,</span> <span class="n">input2</span><span class="p">)</span>
        <span class="n">y_1</span> <span class="o">=</span> <span class="n">label</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="n">y_minus_1</span> <span class="o">=</span> <span class="n">label</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">cos_sim_a</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">cos_sim</span><span class="p">)</span> <span class="o">*</span> <span class="n">y_1</span>

        <span class="k">if</span> <span class="n">F</span> <span class="ow">is</span> <span class="n">ndarray</span><span class="p">:</span>
            <span class="n">z_array</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">z_array</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">cos_sim_b</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">broadcast_maximum</span><span class="p">(</span><span class="n">z_array</span><span class="p">,</span> <span class="n">y_minus_1</span> <span class="o">*</span> <span class="p">(</span><span class="n">cos_sim</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_margin</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">loss</span> <span class="o">=</span> <span class="n">cos_sim_a</span> <span class="o">+</span> <span class="n">cos_sim_b</span>
        <span class="n">loss</span> <span class="o">=</span> <span class="n">_apply_weighting</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">loss</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_weight</span><span class="p">,</span> <span class="n">sample_weight</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">loss</span>

    <span class="k">def</span> <span class="nf">_cosine_similarity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="c1"># Calculates the cosine similarity between 2 vectors</span>
        <span class="n">x_norm</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">y_norm</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">x_dot_y</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">F</span> <span class="ow">is</span> <span class="n">ndarray</span><span class="p">:</span>
            <span class="n">eps_arr</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1e-12</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">eps_arr</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="mf">1e-12</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">x_dot_y</span> <span class="o">/</span> <span class="n">F</span><span class="o">.</span><span class="n">broadcast_maximum</span><span class="p">(</span><span class="n">x_norm</span> <span class="o">*</span> <span class="n">y_norm</span><span class="p">,</span> <span class="n">eps_arr</span><span class="p">))</span></div>
</pre></div>
</div>
</div>
<div aria-label="main navigation" class="sphinxsidebar rightsidebar" role="navigation">
<div class="sphinxsidebarwrapper">
</div>
</div>
</div><div class="footer">
<div class="section-disclaimer">
<div class="container">
<div>
<img height="60" src="https://raw.githubusercontent.com/dmlc/web-data/master/mxnet/image/apache_incubator_logo.png"/>
<p>
            Apache MXNet is an effort undergoing incubation at The Apache Software Foundation (ASF), <strong>sponsored by the <i>Apache Incubator</i></strong>. Incubation is required of all newly accepted projects until a further review indicates that the infrastructure, communications, and decision making process have stabilized in a manner consistent with other successful ASF projects. While incubation status is not necessarily a reflection of the completeness or stability of the code, it does indicate that the project has yet to be fully endorsed by the ASF.
        </p>
<p>
            "Copyright © 2017-2018, The Apache Software Foundation
            Apache MXNet, MXNet, Apache, the Apache feather, and the Apache MXNet project logo are either registered trademarks or trademarks of the Apache Software Foundation."
        </p>
</div>
</div>
</div>
</div> <!-- pagename != index -->
</div>
<script crossorigin="anonymous" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>
<script src="../../../_static/js/sidebar.js" type="text/javascript"></script>
<script src="../../../_static/js/search.js" type="text/javascript"></script>
<script src="../../../_static/js/navbar.js" type="text/javascript"></script>
<script src="../../../_static/js/clipboard.min.js" type="text/javascript"></script>
<script src="../../../_static/js/copycode.js" type="text/javascript"></script>
<script src="../../../_static/js/page.js" type="text/javascript"></script>
<script src="../../../_static/js/docversion.js" type="text/javascript"></script>
<script type="text/javascript">
        $('body').ready(function () {
            $('body').css('visibility', 'visible');
        });
    </script>
</body>
</html>