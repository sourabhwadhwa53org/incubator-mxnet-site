<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="IE=edge" http-equiv="X-UA-Compatible"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<meta content="mxnet.ndarray.ndarray" property="og:title">
<meta content="https://raw.githubusercontent.com/dmlc/web-data/master/mxnet/image/og-logo.png" property="og:image">
<meta content="https://raw.githubusercontent.com/dmlc/web-data/master/mxnet/image/og-logo.png" property="og:image:secure_url">
<meta content="mxnet.ndarray.ndarray" property="og:description"/>
<title>mxnet.ndarray.ndarray — mxnet  documentation</title>
<link crossorigin="anonymous" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" rel="stylesheet"/>
<link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet"/>
<link href="../../../_static/basic.css" rel="stylesheet" type="text/css">
<link href="../../../_static/pygments.css" rel="stylesheet" type="text/css">
<link href="../../../_static/mxnet.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
<script src="https://code.jquery.com/jquery-1.11.1.min.js" type="text/javascript"></script>
<script src="../../../_static/underscore.js" type="text/javascript"></script>
<script src="../../../_static/searchtools_custom.js" type="text/javascript"></script>
<script src="../../../_static/doctools.js" type="text/javascript"></script>
<script src="../../../_static/selectlang.js" type="text/javascript"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
<script type="text/javascript"> jQuery(function() { Search.loadIndex("/versions/1.1.0/searchindex.js"); Search.init();}); </script>
<script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new
      Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-96378503-1', 'auto');
      ga('send', 'pageview');

    </script>
<!-- -->
<!-- <script type="text/javascript" src="../../../_static/jquery.js"></script> -->
<!-- -->
<!-- <script type="text/javascript" src="../../../_static/underscore.js"></script> -->
<!-- -->
<!-- <script type="text/javascript" src="../../../_static/doctools.js"></script> -->
<!-- -->
<!-- <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> -->
<!-- -->
<link href="../../../genindex.html" rel="index" title="Index">
<link href="../../../search.html" rel="search" title="Search"/>
<link href="../../index.html" rel="up" title="Module code"/>
<link href="https://raw.githubusercontent.com/dmlc/web-data/master/mxnet/image/mxnet-icon.png" rel="icon" type="image/png"/>
</link></link></link></meta></meta></meta></head>
<body background="https://raw.githubusercontent.com/dmlc/web-data/master/mxnet/image/mxnet-background-compressed.jpeg" role="document">
<div class="content-block"><div class="navbar navbar-fixed-top">
<div class="container" id="navContainer">
<div class="innder" id="header-inner">
<h1 id="logo-wrap">
<a href="../../../" id="logo"><img src="https://raw.githubusercontent.com/dmlc/web-data/master/mxnet/image/mxnet_logo.png"/></a>
</h1>
<nav class="nav-bar" id="main-nav">
<a class="main-nav-link" href="/versions/1.1.0/install/index.html">Install</a>
<span id="dropdown-menu-position-anchor">
<a aria-expanded="true" aria-haspopup="true" class="main-nav-link dropdown-toggle" data-toggle="dropdown" href="#" role="button">Gluon <span class="caret"></span></a>
<ul class="dropdown-menu navbar-menu" id="package-dropdown-menu">
<li><a class="main-nav-link" href="/versions/1.1.0/tutorials/gluon/gluon.html">About</a></li>
<li><a class="main-nav-link" href="https://www.d2l.ai/">Dive into Deep Learning</a></li>
<li><a class="main-nav-link" href="https://gluon-cv.mxnet.io">GluonCV Toolkit</a></li>
<li><a class="main-nav-link" href="https://gluon-nlp.mxnet.io/">GluonNLP Toolkit</a></li>
</ul>
</span>
<span id="dropdown-menu-position-anchor">
<a aria-expanded="true" aria-haspopup="true" class="main-nav-link dropdown-toggle" data-toggle="dropdown" href="#" role="button">API <span class="caret"></span></a>
<ul class="dropdown-menu navbar-menu" id="package-dropdown-menu">
<li><a class="main-nav-link" href="/versions/1.1.0/api/python/index.html">Python</a></li>
<li><a class="main-nav-link" href="/versions/1.1.0/api/c++/index.html">C++</a></li>
<li><a class="main-nav-link" href="/versions/1.1.0/api/julia/index.html">Julia</a></li>
<li><a class="main-nav-link" href="/versions/1.1.0/api/perl/index.html">Perl</a></li>
<li><a class="main-nav-link" href="/versions/1.1.0/api/r/index.html">R</a></li>
<li><a class="main-nav-link" href="/versions/1.1.0/api/scala/index.html">Scala</a></li>
</ul>
</span>
<span id="dropdown-menu-position-anchor-docs">
<a aria-expanded="true" aria-haspopup="true" class="main-nav-link dropdown-toggle" data-toggle="dropdown" href="#" role="button">Docs <span class="caret"></span></a>
<ul class="dropdown-menu navbar-menu" id="package-dropdown-menu-docs">
<li><a class="main-nav-link" href="/versions/1.1.0/faq/index.html">FAQ</a></li>
<li><a class="main-nav-link" href="/versions/1.1.0/tutorials/index.html">Tutorials</a>
<li><a class="main-nav-link" href="https://github.com/apache/incubator-mxnet/tree/v1.1.0/example">Examples</a></li>
<li><a class="main-nav-link" href="/versions/1.1.0/architecture/index.html">Architecture</a></li>
<li><a class="main-nav-link" href="https://cwiki.apache.org/confluence/display/MXNET/Apache+MXNet+Home">Developer Wiki</a></li>
<li><a class="main-nav-link" href="/versions/1.1.0/model_zoo/index.html">Model Zoo</a></li>
<li><a class="main-nav-link" href="https://github.com/onnx/onnx-mxnet">ONNX</a></li>
</li></ul>
</span>
<span id="dropdown-menu-position-anchor-community">
<a aria-expanded="true" aria-haspopup="true" class="main-nav-link dropdown-toggle" data-toggle="dropdown" href="#" role="button">Community <span class="caret"></span></a>
<ul class="dropdown-menu navbar-menu" id="package-dropdown-menu-community">
<li><a class="main-nav-link" href="http://discuss.mxnet.io">Forum</a></li>
<li><a class="main-nav-link" href="https://github.com/apache/incubator-mxnet/tree/v1.1.0">Github</a></li>
<li><a class="main-nav-link" href="/versions/1.1.0/community/contribute.html">Contribute</a></li>
<li><a class="main-nav-link" href="/versions/1.1.0/community/powered_by.html">Powered By</a></li>
</ul>
</span>
<span id="dropdown-menu-position-anchor-version" style="position: relative"><a href="#" class="main-nav-link dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="true">1.1.0<span class="caret"></span></a><ul id="package-dropdown-menu" class="dropdown-menu"><li><a href="/">master</a></li><li><a href=/versions/1.6/>1.6</a></li><li><a href=/versions/1.5.0/>1.5.0</a></li><li><a href=/versions/1.4.1/>1.4.1</a></li><li><a href=/versions/1.3.1/>1.3.1</a></li><li><a href=/versions/1.2.1/>1.2.1</a></li><li><a href=/versions/1.1.0/>1.1.0</a></li><li><a href=/versions/1.0.0/>1.0.0</a></li><li><a href=/versions/0.12.1/>0.12.1</a></li><li><a href=/versions/0.11.0/>0.11.0</a></li></ul></span></nav>
<script> function getRootPath(){ return "../../../" } </script>
<div class="burgerIcon dropdown">
<a class="dropdown-toggle" data-toggle="dropdown" href="#" role="button">☰</a>
<ul class="dropdown-menu" id="burgerMenu">
<li><a href="/versions/1.1.0/install/index.html">Install</a></li>
<li><a class="main-nav-link" href="/versions/1.1.0/tutorials/index.html">Tutorials</a></li>
<li class="dropdown-submenu dropdown">
<a aria-expanded="true" aria-haspopup="true" class="dropdown-toggle burger-link" data-toggle="dropdown" href="#" tabindex="-1">Gluon</a>
<ul class="dropdown-menu navbar-menu" id="package-dropdown-menu">
<li><a class="main-nav-link" href="/versions/1.1.0/tutorials/gluon/gluon.html">About</a></li>
<li><a class="main-nav-link" href="http://gluon.mxnet.io">The Straight Dope (Tutorials)</a></li>
<li><a class="main-nav-link" href="https://gluon-cv.mxnet.io">GluonCV Toolkit</a></li>
<li><a class="main-nav-link" href="https://gluon-nlp.mxnet.io/">GluonNLP Toolkit</a></li>
</ul>
</li>
<li class="dropdown-submenu">
<a aria-expanded="true" aria-haspopup="true" class="dropdown-toggle burger-link" data-toggle="dropdown" href="#" tabindex="-1">API</a>
<ul class="dropdown-menu">
<li><a class="main-nav-link" href="/versions/1.1.0/api/python/index.html">Python</a></li>
<li><a class="main-nav-link" href="/versions/1.1.0/api/c++/index.html">C++</a></li>
<li><a class="main-nav-link" href="/versions/1.1.0/api/julia/index.html">Julia</a></li>
<li><a class="main-nav-link" href="/versions/1.1.0/api/perl/index.html">Perl</a></li>
<li><a class="main-nav-link" href="/versions/1.1.0/api/r/index.html">R</a></li>
<li><a class="main-nav-link" href="/versions/1.1.0/api/scala/index.html">Scala</a></li>
</ul>
</li>
<li class="dropdown-submenu">
<a aria-expanded="true" aria-haspopup="true" class="dropdown-toggle burger-link" data-toggle="dropdown" href="#" tabindex="-1">Docs</a>
<ul class="dropdown-menu">
<li><a href="/versions/1.1.0/faq/index.html" tabindex="-1">FAQ</a></li>
<li><a href="/versions/1.1.0/tutorials/index.html" tabindex="-1">Tutorials</a></li>
<li><a href="https://github.com/apache/incubator-mxnet/tree/v1.1.0/example" tabindex="-1">Examples</a></li>
<li><a href="/versions/1.1.0/architecture/index.html" tabindex="-1">Architecture</a></li>
<li><a href="https://cwiki.apache.org/confluence/display/MXNET/Apache+MXNet+Home" tabindex="-1">Developer Wiki</a></li>
<li><a href="/versions/1.1.0/model_zoo/index.html" tabindex="-1">Gluon Model Zoo</a></li>
<li><a href="https://github.com/onnx/onnx-mxnet" tabindex="-1">ONNX</a></li>
</ul>
</li>
<li class="dropdown-submenu dropdown">
<a aria-haspopup="true" class="dropdown-toggle burger-link" data-toggle="dropdown" href="#" role="button" tabindex="-1">Community</a>
<ul class="dropdown-menu">
<li><a href="http://discuss.mxnet.io" tabindex="-1">Forum</a></li>
<li><a href="https://github.com/apache/incubator-mxnet/tree/v1.1.0" tabindex="-1">Github</a></li>
<li><a href="/versions/1.1.0/community/contribute.html" tabindex="-1">Contribute</a></li>
<li><a href="/versions/1.1.0/community/powered_by.html" tabindex="-1">Powered By</a></li>
</ul>
</li>
<li id="dropdown-menu-position-anchor-version-mobile" class="dropdown-submenu" style="position: relative"><a href="#" tabindex="-1">1.1.0</a><ul class="dropdown-menu"><li><a tabindex="-1" href=/>master</a></li><li><a tabindex="-1" href=/versions/1.6/>1.6</a></li><li><a tabindex="-1" href=/versions/1.5.0/>1.5.0</a></li><li><a tabindex="-1" href=/versions/1.4.1/>1.4.1</a></li><li><a tabindex="-1" href=/versions/1.3.1/>1.3.1</a></li><li><a tabindex="-1" href=/versions/1.2.1/>1.2.1</a></li><li><a tabindex="-1" href=/versions/1.1.0/>1.1.0</a></li><li><a tabindex="-1" href=/versions/1.0.0/>1.0.0</a></li><li><a tabindex="-1" href=/versions/0.12.1/>0.12.1</a></li><li><a tabindex="-1" href=/versions/0.11.0/>0.11.0</a></li></ul></li></ul>
</div>
<div class="plusIcon dropdown">
<a class="dropdown-toggle" data-toggle="dropdown" href="#" role="button"><span aria-hidden="true" class="glyphicon glyphicon-plus"></span></a>
<ul class="dropdown-menu dropdown-menu-right" id="plusMenu"></ul>
</div>
<div id="search-input-wrap">
<form action="../../../search.html" autocomplete="off" class="" method="get" role="search">
<div class="form-group inner-addon left-addon">
<i class="glyphicon glyphicon-search"></i>
<input class="form-control" name="q" placeholder="Search" type="text"/>
</div>
<input name="check_keywords" type="hidden" value="yes">
<input name="area" type="hidden" value="default"/>
</input></form>
<div id="search-preview"></div>
</div>
<div id="searchIcon">
<span aria-hidden="true" class="glyphicon glyphicon-search"></span>
</div>
<!-- <div id="lang-select-wrap"> -->
<!--   <label id="lang-select-label"> -->
<!--     <\!-- <i class="fa fa-globe"></i> -\-> -->
<!--     <span></span> -->
<!--   </label> -->
<!--   <select id="lang-select"> -->
<!--     <option value="en">Eng</option> -->
<!--     <option value="zh">中文</option> -->
<!--   </select> -->
<!-- </div> -->
<!--     <a id="mobile-nav-toggle">
        <span class="mobile-nav-toggle-bar"></span>
        <span class="mobile-nav-toggle-bar"></span>
        <span class="mobile-nav-toggle-bar"></span>
      </a> -->
</div>
</div>
</div>
<script type="text/javascript">
        $('body').css('background', 'white');
    </script>
<div class="container">
<div class="row">
<div aria-label="main navigation" class="sphinxsidebar leftsidebar" role="navigation">
<div class="sphinxsidebarwrapper">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api/python/index.html">Python Documents</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/r/index.html">R Documents</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/julia/index.html">Julia Documents</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/c++/index.html">C++ Documents</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/scala/index.html">Scala Documents</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/perl/index.html">Perl Documents</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../faq/index.html">HowTo Documents</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../architecture/index.html">System Documents</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/index.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../community/index.html">Community</a></li>
</ul>
</div>
</div>
<div class="content">
<div class="page-tracker"></div>
<h1>Source code for mxnet.ndarray.ndarray</h1><div class="highlight"><pre>
<span></span><span class="c1"># Licensed to the Apache Software Foundation (ASF) under one</span>
<span class="c1"># or more contributor license agreements.  See the NOTICE file</span>
<span class="c1"># distributed with this work for additional information</span>
<span class="c1"># regarding copyright ownership.  The ASF licenses this file</span>
<span class="c1"># to you under the Apache License, Version 2.0 (the</span>
<span class="c1"># "License"); you may not use this file except in compliance</span>
<span class="c1"># with the License.  You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1">#   http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing,</span>
<span class="c1"># software distributed under the License is distributed on an</span>
<span class="c1"># "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY</span>
<span class="c1"># KIND, either express or implied.  See the License for the</span>
<span class="c1"># specific language governing permissions and limitations</span>
<span class="c1"># under the License.</span>

<span class="c1"># coding: utf-8</span>
<span class="c1"># pylint: disable=too-many-lines, protected-access</span>
<span class="c1"># pylint: disable=import-error, no-name-in-module, undefined-variable</span>
<span class="sd">"""NDArray API of MXNet."""</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">absolute_import</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">__builtin__</span> <span class="k">import</span> <span class="nb">slice</span> <span class="k">as</span> <span class="n">py_slice</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">builtins</span> <span class="k">import</span> <span class="nb">slice</span> <span class="k">as</span> <span class="n">py_slice</span>

<span class="kn">from</span> <span class="nn">array</span> <span class="k">import</span> <span class="n">array</span> <span class="k">as</span> <span class="n">native_array</span>
<span class="kn">import</span> <span class="nn">ctypes</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="k">import</span> <span class="n">reduce</span> <span class="c1"># pylint: disable=redefined-builtin</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">..base</span> <span class="k">import</span> <span class="n">_LIB</span><span class="p">,</span> <span class="n">numeric_types</span><span class="p">,</span> <span class="n">integer_types</span>
<span class="kn">from</span> <span class="nn">..base</span> <span class="k">import</span> <span class="n">c_array</span><span class="p">,</span> <span class="n">c_array_buf</span><span class="p">,</span> <span class="n">c_handle_array</span><span class="p">,</span> <span class="n">mx_real_t</span>
<span class="kn">from</span> <span class="nn">..base</span> <span class="k">import</span> <span class="n">mx_uint</span><span class="p">,</span> <span class="n">NDArrayHandle</span><span class="p">,</span> <span class="n">check_call</span>
<span class="kn">from</span> <span class="nn">..base</span> <span class="k">import</span> <span class="n">ctypes2buffer</span>
<span class="kn">from</span> <span class="nn">..context</span> <span class="k">import</span> <span class="n">Context</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">_internal</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">op</span>
<span class="kn">from</span> <span class="nn">._internal</span> <span class="k">import</span> <span class="n">NDArrayBase</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">"NDArray"</span><span class="p">,</span> <span class="s2">"concatenate"</span><span class="p">,</span> <span class="s2">"_DTYPE_NP_TO_MX"</span><span class="p">,</span> <span class="s2">"_DTYPE_MX_TO_NP"</span><span class="p">,</span> <span class="s2">"_GRAD_REQ_MAP"</span><span class="p">,</span>
           <span class="s2">"ones"</span><span class="p">,</span> <span class="s2">"add"</span><span class="p">,</span> <span class="s2">"arange"</span><span class="p">,</span> <span class="s2">"divide"</span><span class="p">,</span> <span class="s2">"equal"</span><span class="p">,</span> <span class="s2">"full"</span><span class="p">,</span> <span class="s2">"greater"</span><span class="p">,</span> <span class="s2">"greater_equal"</span><span class="p">,</span>
           <span class="s2">"imdecode"</span><span class="p">,</span> <span class="s2">"lesser"</span><span class="p">,</span> <span class="s2">"lesser_equal"</span><span class="p">,</span> <span class="s2">"maximum"</span><span class="p">,</span> <span class="s2">"minimum"</span><span class="p">,</span> <span class="s2">"moveaxis"</span><span class="p">,</span> <span class="s2">"modulo"</span><span class="p">,</span>
           <span class="s2">"multiply"</span><span class="p">,</span> <span class="s2">"not_equal"</span><span class="p">,</span> <span class="s2">"onehot_encode"</span><span class="p">,</span> <span class="s2">"power"</span><span class="p">,</span> <span class="s2">"subtract"</span><span class="p">,</span> <span class="s2">"true_divide"</span><span class="p">,</span>
           <span class="s2">"waitall"</span><span class="p">,</span> <span class="s2">"_new_empty_handle"</span><span class="p">]</span>

<span class="n">_STORAGE_TYPE_UNDEFINED</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="n">_STORAGE_TYPE_DEFAULT</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">_STORAGE_TYPE_ROW_SPARSE</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">_STORAGE_TYPE_CSR</span> <span class="o">=</span> <span class="mi">2</span>

<span class="c1"># pylint: disable= no-member</span>
<span class="n">_DTYPE_NP_TO_MX</span> <span class="o">=</span> <span class="p">{</span>
    <span class="kc">None</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">np</span><span class="o">.</span><span class="n">float16</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
    <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span>
    <span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
    <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span>
<span class="p">}</span>

<span class="n">_DTYPE_MX_TO_NP</span> <span class="o">=</span> <span class="p">{</span>
    <span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="mi">0</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span>
    <span class="mi">1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
    <span class="mi">2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">float16</span><span class="p">,</span>
    <span class="mi">3</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">,</span>
    <span class="mi">4</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span>
    <span class="mi">5</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">,</span>
    <span class="mi">6</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span>
<span class="p">}</span>

<span class="n">_STORAGE_TYPE_STR_TO_ID</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">'undefined'</span><span class="p">:</span> <span class="n">_STORAGE_TYPE_UNDEFINED</span><span class="p">,</span>
    <span class="s1">'default'</span><span class="p">:</span> <span class="n">_STORAGE_TYPE_DEFAULT</span><span class="p">,</span>
    <span class="s1">'row_sparse'</span><span class="p">:</span> <span class="n">_STORAGE_TYPE_ROW_SPARSE</span><span class="p">,</span>
    <span class="s1">'csr'</span><span class="p">:</span> <span class="n">_STORAGE_TYPE_CSR</span><span class="p">,</span>
<span class="p">}</span>

<span class="n">_STORAGE_TYPE_ID_TO_STR</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">_STORAGE_TYPE_UNDEFINED</span><span class="p">:</span> <span class="s1">'undefined'</span><span class="p">,</span>
    <span class="n">_STORAGE_TYPE_DEFAULT</span><span class="p">:</span> <span class="s1">'default'</span><span class="p">,</span>
    <span class="n">_STORAGE_TYPE_ROW_SPARSE</span><span class="p">:</span> <span class="s1">'row_sparse'</span><span class="p">,</span>
    <span class="n">_STORAGE_TYPE_CSR</span><span class="p">:</span> <span class="s1">'csr'</span><span class="p">,</span>
<span class="p">}</span>

<span class="n">_GRAD_REQ_MAP</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">'null'</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
    <span class="s1">'write'</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
    <span class="s1">'add'</span><span class="p">:</span> <span class="mi">3</span>
<span class="p">}</span>
<span class="c1"># pylint: enable= no-member</span>

<span class="c1"># Return code for dispatching indexing function call</span>
<span class="n">_NDARRAY_UNSUPPORTED_INDEXING</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="n">_NDARRAY_BASIC_INDEXING</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">_NDARRAY_ADVANCED_INDEXING</span> <span class="o">=</span> <span class="mi">1</span>


<span class="k">def</span> <span class="nf">_new_empty_handle</span><span class="p">():</span>
    <span class="sd">"""Returns a new empty handle.</span>

<span class="sd">    Empty handle can be used to hold a result.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    handle</span>
<span class="sd">        A new empty `NDArray` handle.</span>
<span class="sd">    """</span>
    <span class="n">hdl</span> <span class="o">=</span> <span class="n">NDArrayHandle</span><span class="p">()</span>
    <span class="n">check_call</span><span class="p">(</span><span class="n">_LIB</span><span class="o">.</span><span class="n">MXNDArrayCreateNone</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">hdl</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">hdl</span>


<span class="k">def</span> <span class="nf">_new_alloc_handle</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">delay_alloc</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">mx_real_t</span><span class="p">):</span>
    <span class="sd">"""Return a new handle with specified shape and context.</span>

<span class="sd">    Empty handle is only used to hold results.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    handle</span>
<span class="sd">        A new empty `NDArray` handle.</span>
<span class="sd">    """</span>
    <span class="n">hdl</span> <span class="o">=</span> <span class="n">NDArrayHandle</span><span class="p">()</span>
    <span class="n">check_call</span><span class="p">(</span><span class="n">_LIB</span><span class="o">.</span><span class="n">MXNDArrayCreateEx</span><span class="p">(</span>
        <span class="n">c_array_buf</span><span class="p">(</span><span class="n">mx_uint</span><span class="p">,</span> <span class="n">native_array</span><span class="p">(</span><span class="s1">'I'</span><span class="p">,</span> <span class="n">shape</span><span class="p">)),</span>
        <span class="n">mx_uint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)),</span>
        <span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">device_typeid</span><span class="p">),</span>
        <span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">device_id</span><span class="p">),</span>
        <span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">delay_alloc</span><span class="p">)),</span>
        <span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">_DTYPE_NP_TO_MX</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">type</span><span class="p">])),</span>
        <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">hdl</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">hdl</span>


<span class="k">def</span> <span class="nf">_new_from_shared_mem</span><span class="p">(</span><span class="n">shared_pid</span><span class="p">,</span> <span class="n">shared_id</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
    <span class="n">hdl</span> <span class="o">=</span> <span class="n">NDArrayHandle</span><span class="p">()</span>
    <span class="n">check_call</span><span class="p">(</span><span class="n">_LIB</span><span class="o">.</span><span class="n">MXNDArrayCreateFromSharedMem</span><span class="p">(</span>
        <span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span><span class="p">(</span><span class="n">shared_pid</span><span class="p">),</span>
        <span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span><span class="p">(</span><span class="n">shared_id</span><span class="p">),</span>
        <span class="n">c_array</span><span class="p">(</span><span class="n">mx_uint</span><span class="p">,</span> <span class="n">shape</span><span class="p">),</span>
        <span class="n">mx_uint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)),</span>
        <span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">_DTYPE_NP_TO_MX</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">type</span><span class="p">])),</span>
        <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">hdl</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">hdl</span>


<div class="viewcode-block" id="waitall"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.waitall">[docs]</a><span class="k">def</span> <span class="nf">waitall</span><span class="p">():</span>
    <span class="sd">"""Wait for all async operations to finish in MXNet.</span>

<span class="sd">    This function is used for benchmarking only.</span>
<span class="sd">    """</span>
    <span class="n">check_call</span><span class="p">(</span><span class="n">_LIB</span><span class="o">.</span><span class="n">MXNDArrayWaitAll</span><span class="p">())</span></div>


<span class="k">def</span> <span class="nf">_storage_type</span><span class="p">(</span><span class="n">handle</span><span class="p">):</span>
    <span class="n">storage_type</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">check_call</span><span class="p">(</span><span class="n">_LIB</span><span class="o">.</span><span class="n">MXNDArrayGetStorageType</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">storage_type</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">storage_type</span><span class="o">.</span><span class="n">value</span>


<div class="viewcode-block" id="NDArray"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray">[docs]</a><span class="k">class</span> <span class="nc">NDArray</span><span class="p">(</span><span class="n">NDArrayBase</span><span class="p">):</span>
    <span class="sd">"""An array object representing a multidimensional, homogeneous array of</span>
<span class="sd">fixed-size items.</span>

<span class="sd">    """</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># make numpy functions return NDArray instead of numpy object array</span>
    <span class="n">__array_priority__</span> <span class="o">=</span> <span class="mf">1000.0</span>
    <span class="c1"># pylint: disable= no-member, undefined-variable</span>

<div class="viewcode-block" id="NDArray.__repr__"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.__repr__">[docs]</a>    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Returns a string representation of the array."""</span>
        <span class="n">shape_info</span> <span class="o">=</span> <span class="s1">'x'</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s1">'</span><span class="si">%d</span><span class="s1">'</span> <span class="o">%</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">])</span>
        <span class="k">return</span> <span class="s1">'</span><span class="se">\n</span><span class="si">%s</span><span class="se">\n</span><span class="s1"><</span><span class="si">%s</span><span class="s1"> </span><span class="si">%s</span><span class="s1"> @</span><span class="si">%s</span><span class="s1">>'</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()),</span>
                                      <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                                      <span class="n">shape_info</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">context</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">NDArray</span><span class="p">,</span> <span class="p">(</span><span class="kc">None</span><span class="p">,),</span> <span class="bp">self</span><span class="o">.</span><span class="n">__getstate__</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_to_shared_mem</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">shared_pid</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span><span class="p">()</span>
        <span class="n">shared_id</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span><span class="p">()</span>
        <span class="n">check_call</span><span class="p">(</span><span class="n">_LIB</span><span class="o">.</span><span class="n">MXNDArrayGetSharedMemHandle</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">handle</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">shared_pid</span><span class="p">),</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">shared_id</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">shared_pid</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">shared_id</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span>

<div class="viewcode-block" id="NDArray.__add__"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.__add__">[docs]</a>    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">"""x.__add__(y) <=> x+y <=> mx.nd.add(x, y) """</span>
        <span class="k">return</span> <span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.__iadd__"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.__iadd__">[docs]</a>    <span class="k">def</span> <span class="nf">__iadd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">"""x.__iadd__(y) <=> x+=y """</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">writable</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'trying to add to a readonly NDArray'</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">NDArray</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">broadcast_add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">numeric_types</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_internal</span><span class="o">.</span><span class="n">_plus_scalar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">other</span><span class="p">),</span> <span class="n">out</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">'type </span><span class="si">%s</span><span class="s1"> not supported'</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)))</span></div>

    <span class="k">def</span> <span class="nf">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__add__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

<div class="viewcode-block" id="NDArray.__sub__"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.__sub__">[docs]</a>    <span class="k">def</span> <span class="nf">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">"""x.__sub__(y) <=> x-y <=> mx.nd.subtract(x, y) """</span>
        <span class="k">return</span> <span class="n">subtract</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.__isub__"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.__isub__">[docs]</a>    <span class="k">def</span> <span class="nf">__isub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">"""x.__isub__(y) <=> x-=y """</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">writable</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'trying to subtract from a readonly NDArray'</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">NDArray</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">broadcast_sub</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">numeric_types</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_internal</span><span class="o">.</span><span class="n">_minus_scalar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">other</span><span class="p">),</span> <span class="n">out</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">'type </span><span class="si">%s</span><span class="s1"> not supported'</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)))</span></div>

<div class="viewcode-block" id="NDArray.__rsub__"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.__rsub__">[docs]</a>    <span class="k">def</span> <span class="nf">__rsub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">"""x.__rsub__(y) <=> y-x <=> mx.nd.subtract(y, x) """</span>
        <span class="k">return</span> <span class="n">subtract</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.__mul__"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.__mul__">[docs]</a>    <span class="k">def</span> <span class="nf">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">"""x.__mul__(y) <=> x*y <=> mx.nd.multiply(x, y) """</span>
        <span class="k">return</span> <span class="n">multiply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.__neg__"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.__neg__">[docs]</a>    <span class="k">def</span> <span class="nf">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""x.__neg__(y) <=> -x """</span>
        <span class="k">return</span> <span class="n">_internal</span><span class="o">.</span><span class="n">_mul_scalar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.__imul__"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.__imul__">[docs]</a>    <span class="k">def</span> <span class="nf">__imul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">"""x.__imul__(y) <=> x*=y """</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">writable</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'trying to multiply to a readonly NDArray'</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">NDArray</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">broadcast_mul</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">numeric_types</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_internal</span><span class="o">.</span><span class="n">_mul_scalar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">other</span><span class="p">),</span> <span class="n">out</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">'type </span><span class="si">%s</span><span class="s1"> not supported'</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)))</span></div>

    <span class="k">def</span> <span class="nf">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__mul__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

<div class="viewcode-block" id="NDArray.__div__"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.__div__">[docs]</a>    <span class="k">def</span> <span class="nf">__div__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">"""x.__div__(y) <=> x/y <=> mx.nd.divide(x, y) """</span>
        <span class="k">return</span> <span class="n">divide</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.__rdiv__"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.__rdiv__">[docs]</a>    <span class="k">def</span> <span class="nf">__rdiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">"""x.__rdiv__(y) <=> y/x <=> mx.nd.divide(y, x) """</span>
        <span class="k">return</span> <span class="n">divide</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.__idiv__"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.__idiv__">[docs]</a>    <span class="k">def</span> <span class="nf">__idiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">"""x.__rdiv__(y) <=> x/=y """</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">writable</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'trying to divide from a readonly NDArray'</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">NDArray</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">broadcast_div</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">numeric_types</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_internal</span><span class="o">.</span><span class="n">_div_scalar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">other</span><span class="p">),</span> <span class="n">out</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">'type </span><span class="si">%s</span><span class="s1"> not supported'</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)))</span></div>

    <span class="k">def</span> <span class="nf">__truediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">divide</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__rtruediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">divide</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__itruediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__idiv__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

<div class="viewcode-block" id="NDArray.__mod__"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.__mod__">[docs]</a>    <span class="k">def</span> <span class="nf">__mod__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">"""x.__mod__(y) <=> x%y <=> mx.nd.modulo(x, y) """</span>
        <span class="k">return</span> <span class="n">modulo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.__rmod__"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.__rmod__">[docs]</a>    <span class="k">def</span> <span class="nf">__rmod__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">"""x.__rmod__(y) <=> y%x <=> mx.nd.modulo(y, x) """</span>
        <span class="k">return</span> <span class="n">modulo</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.__imod__"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.__imod__">[docs]</a>    <span class="k">def</span> <span class="nf">__imod__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">"""x.__rmod__(y) <=> x%=y """</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">writable</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'trying to take modulo from a readonly NDArray'</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">NDArray</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">broadcast_mod</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">numeric_types</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_internal</span><span class="o">.</span><span class="n">_mod_scalar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">other</span><span class="p">),</span> <span class="n">out</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">'type </span><span class="si">%s</span><span class="s1"> not supported'</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)))</span></div>

<div class="viewcode-block" id="NDArray.__pow__"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.__pow__">[docs]</a>    <span class="k">def</span> <span class="nf">__pow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">"""x.__pow__(y) <=> x**y <=> mx.nd.power(x,y) """</span>
        <span class="k">return</span> <span class="n">power</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.__rpow__"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.__rpow__">[docs]</a>    <span class="k">def</span> <span class="nf">__rpow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">"""x.__pow__(y) <=> y**x <=> mx.nd.power(y,x) """</span>
        <span class="k">return</span> <span class="n">power</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.__eq__"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.__eq__">[docs]</a>    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">"""x.__eq__(y) <=> x==y <=> mx.nd.equal(x, y) """</span>
        <span class="k">return</span> <span class="n">equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.__hash__"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.__hash__">[docs]</a>    <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Default hash function."""</span>
        <span class="k">return</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">//</span><span class="mi">16</span></div>

<div class="viewcode-block" id="NDArray.__ne__"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.__ne__">[docs]</a>    <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">"""x.__ne__(y) <=> x!=y <=> mx.nd.not_equal(x, y) """</span>
        <span class="k">return</span> <span class="n">not_equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.__gt__"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.__gt__">[docs]</a>    <span class="k">def</span> <span class="nf">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">"""x.__gt__(y) <=> x>y <=> mx.nd.greater(x, y) """</span>
        <span class="k">return</span> <span class="n">greater</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.__ge__"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.__ge__">[docs]</a>    <span class="k">def</span> <span class="nf">__ge__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">"""x.__ge__(y) <=> x>=y <=> mx.nd.greater_equal(x, y) """</span>
        <span class="k">return</span> <span class="n">greater_equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.__lt__"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.__lt__">[docs]</a>    <span class="k">def</span> <span class="nf">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">"""x.__lt__(y) <=> x<y <=> mx.nd.lesser(x, y) """</span>
        <span class="k">return</span> <span class="n">lesser</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.__le__"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.__le__">[docs]</a>    <span class="k">def</span> <span class="nf">__le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">"""x.__le__(y) <=> x<=y <=> mx.nd.less_equal(x, y) """</span>
        <span class="k">return</span> <span class="n">lesser_equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__bool__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">num_elements</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">mul</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">num_elements</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="n">num_elements</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">asscalar</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"The truth value of an NDArray with multiple elements "</span> \
                             <span class="s2">"is ambiguous."</span><span class="p">)</span>

    <span class="n">__nonzero__</span> <span class="o">=</span> <span class="fm">__bool__</span>

<div class="viewcode-block" id="NDArray.__len__"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.__len__">[docs]</a>    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Number of element along the first axis."""</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">handle</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">handle</span>
        <span class="n">this</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'handle'</span> <span class="p">:</span> <span class="kc">None</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">handle</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">length</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_size_t</span><span class="p">()</span>
            <span class="n">cptr</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_char</span><span class="p">)()</span>
            <span class="n">check_call</span><span class="p">(</span><span class="n">_LIB</span><span class="o">.</span><span class="n">MXNDArraySaveRawBytes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">handle</span><span class="p">,</span>
                                                  <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">length</span><span class="p">),</span>
                                                  <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">cptr</span><span class="p">)))</span>
            <span class="n">this</span><span class="p">[</span><span class="s1">'handle'</span><span class="p">]</span> <span class="o">=</span> <span class="n">ctypes2buffer</span><span class="p">(</span><span class="n">cptr</span><span class="p">,</span> <span class="n">length</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">this</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="c1"># pylint: disable=assigning-non-slot</span>
        <span class="n">handle</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s1">'handle'</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">handle</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">handle</span>
            <span class="n">handle</span> <span class="o">=</span> <span class="n">NDArrayHandle</span><span class="p">()</span>
            <span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_char</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">buf</span><span class="p">))</span><span class="o">.</span><span class="n">from_buffer</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>
            <span class="n">length</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_size_t</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">buf</span><span class="p">))</span>
            <span class="n">check_call</span><span class="p">(</span><span class="n">_LIB</span><span class="o">.</span><span class="n">MXNDArrayLoadFromRawBytes</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">handle</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">handle</span> <span class="o">=</span> <span class="n">handle</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">handle</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># pylint: disable=line-too-long</span>
<div class="viewcode-block" id="NDArray.__setitem__"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.__setitem__">[docs]</a>    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">"""x.__setitem__(i, y) <=> x[i]=y</span>

<span class="sd">        Sets value to self[key]. This functions supports advanced indexing defined in the following reference with</span>
<span class="sd">        some restrictions.</span>

<span class="sd">        https://docs.scipy.org/doc/numpy-1.13.0/reference/arrays.indexing.html#combining-advanced-and-basic-indexing</span>

<span class="sd">        - If key is a list type, only a list of integers is supported, e.g. key=[1, 2] is supported,</span>
<span class="sd">          while not for key=[[1, 2]].</span>
<span class="sd">        - Ellipsis (...) and np.newaxis are not supported.</span>
<span class="sd">        - Boolean array indexing is not supported.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        key : int, slice, list, np.ndarray, NDArray, or tuple of all previous types</span>
<span class="sd">            The indexing key.</span>
<span class="sd">        value : scalar or array-like object that can be broadcast to the shape of self[key]</span>
<span class="sd">            The value to set.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        >>> x = mx.nd.zeros((2,3))</span>
<span class="sd">        >>> x[:] = 1</span>
<span class="sd">        >>> x.asnumpy()</span>
<span class="sd">        array([[ 1.,  1.,  1.],</span>
<span class="sd">               [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="sd">        >>> x.asnumpy()</span>
<span class="sd">        array([[ 1.,  1.,  1.],</span>
<span class="sd">               [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="sd">        >>> x[:,1:2] = 2</span>
<span class="sd">        >>> x.asnumpy()</span>
<span class="sd">        array([[ 1.,  2.,  1.],</span>
<span class="sd">               [ 1.,  2.,  1.]], dtype=float32)</span>
<span class="sd">        >>> x[1:2,1:] = 3</span>
<span class="sd">        >>> x.asnumpy()</span>
<span class="sd">        array([[ 1.,  2.,  1.],</span>
<span class="sd">               [ 1.,  3.,  3.]], dtype=float32)</span>
<span class="sd">        >>> x[1:,0:2] = mx.nd.zeros((1,2))</span>
<span class="sd">        >>> x.asnumpy()</span>
<span class="sd">        array([[ 1.,  2.,  1.],</span>
<span class="sd">               [ 0.,  0.,  3.]], dtype=float32)</span>
<span class="sd">        >>> x[1,2] = 4</span>
<span class="sd">        >>> x.asnumpy()</span>
<span class="sd">        array([[ 1.,  2.,  1.],</span>
<span class="sd">               [ 0.,  0.,  4.]], dtype=float32)</span>
<span class="sd">        >>> x[[0], [1, 2]] = 5</span>
<span class="sd">        >>> x.asnumpy()</span>
<span class="sd">        array([[ 1.,  5.,  5.],</span>
<span class="sd">               [ 0.,  0.,  4.]], dtype=float32)</span>
<span class="sd">        >>> x[::-1, 0:2:2] = [6]</span>
<span class="sd">        >>> x.asnumpy()</span>
<span class="sd">        array([[ 6.,  5.,  5.],</span>
<span class="sd">               [ 6.,  0.,  4.]], dtype=float32)</span>
<span class="sd">        """</span>
        <span class="n">indexing_dispatch_code</span> <span class="o">=</span> <span class="n">_get_indexing_dispatch_code</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">indexing_dispatch_code</span> <span class="o">==</span> <span class="n">_NDARRAY_BASIC_INDEXING</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_nd_basic_indexing</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">indexing_dispatch_code</span> <span class="o">==</span> <span class="n">_NDARRAY_ADVANCED_INDEXING</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_nd_advanced_indexing</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Indexing NDArray with index=</span><span class="si">%s</span><span class="s1"> and type=</span><span class="si">%s</span><span class="s1"> is not supported'</span>
                             <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">key</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">key</span><span class="p">))))</span></div>
    <span class="c1"># pylint: enable=line-too-long</span>

    <span class="c1"># pylint: disable=line-too-long</span>
<div class="viewcode-block" id="NDArray.__getitem__"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.__getitem__">[docs]</a>    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">"""x.__getitem__(i) <=> x[i]</span>

<span class="sd">        Returns a sliced view of this array if the elements fetched are contiguous in memory;</span>
<span class="sd">        otherwise, returns a newly created NDArray.</span>
<span class="sd">        This functions supports advanced indexing defined in the following reference with</span>
<span class="sd">        some restrictions.</span>

<span class="sd">        https://docs.scipy.org/doc/numpy-1.13.0/reference/arrays.indexing.html#combining-advanced-and-basic-indexing</span>

<span class="sd">        - If key is a list type, only a list of integers is supported, e.g. key=[1, 2] is supported,</span>
<span class="sd">          while not for key=[[1, 2]].</span>
<span class="sd">        - Ellipsis (...) and np.newaxis are not supported.</span>
<span class="sd">        - Boolean array indexing is not supported.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        key : int, slice, list, np.ndarray, NDArray, or tuple of all previous types</span>
<span class="sd">            Indexing key.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        >>> x = mx.nd.arange(0,6).reshape((2,3))</span>
<span class="sd">        >>> x.asnumpy()</span>
<span class="sd">        array([[ 0.,  1.,  2.],</span>
<span class="sd">               [ 3.,  4.,  5.]], dtype=float32)</span>
<span class="sd">        >>> x[1].asnumpy()</span>
<span class="sd">        array([ 3.,  4.,  5.], dtype=float32)</span>
<span class="sd">        >>> y = x[0:1]</span>
<span class="sd">        >>> y[:] = 2</span>
<span class="sd">        >>> x.asnumpy()</span>
<span class="sd">        array([[ 2.,  2.,  2.],</span>
<span class="sd">               [ 3.,  4.,  5.]], dtype=float32)</span>
<span class="sd">        >>> x = mx.nd.arange(0, 8, dtype='int32').reshape((2, 2, 2))</span>
<span class="sd">        >>> x[[0, 1]]</span>
<span class="sd">        [[[0 1]</span>
<span class="sd">          [2 3]]</span>
<span class="sd">         [[4 5]</span>
<span class="sd">          [6 7]]]</span>
<span class="sd">        >>> x[1:, [0, 1]]</span>
<span class="sd">        [[[4 5]</span>
<span class="sd">          [6 7]]]</span>
<span class="sd">        >>> y = np.array([0, 1], dtype='int32')</span>
<span class="sd">        >>> x[1:, y]</span>
<span class="sd">        [[[4 5]</span>
<span class="sd">          [6 7]]]</span>
<span class="sd">        >>> y = mx.nd.array([0, 1], dtype='int32')</span>
<span class="sd">        >>> x[1:, y]</span>
<span class="sd">        [[[4 5]</span>
<span class="sd">          [6 7]]]</span>
<span class="sd">        """</span>
        <span class="n">indexing_dispatch_code</span> <span class="o">=</span> <span class="n">_get_indexing_dispatch_code</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">indexing_dispatch_code</span> <span class="o">==</span> <span class="n">_NDARRAY_BASIC_INDEXING</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_nd_basic_indexing</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">indexing_dispatch_code</span> <span class="o">==</span> <span class="n">_NDARRAY_ADVANCED_INDEXING</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_nd_advanced_indexing</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Indexing NDArray with index=</span><span class="si">%s</span><span class="s1"> and type=</span><span class="si">%s</span><span class="s1"> is not supported'</span>
                             <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">key</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">key</span><span class="p">))))</span></div>
    <span class="c1"># pylint: enable=line-too-long</span>

    <span class="k">def</span> <span class="nf">_get_index_nd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">"""Returns an index array for use in scatter_nd and gather_nd."""</span>
        <span class="k">def</span> <span class="nf">_is_advanced_index</span><span class="p">(</span><span class="n">index</span><span class="p">):</span>
            <span class="sd">"""The definition of advanced index here includes integers as well, while</span>
<span class="sd">            integers are considered as basic index type when the key contains only</span>
<span class="sd">            slices and integers."""</span>
            <span class="k">return</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">py_slice</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">(</span><span class="n">NDArray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="n">integer_types</span><span class="p">,</span> <span class="n">py_slice</span><span class="p">)):</span>
            <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">key</span><span class="p">,)</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">),</span>\
            <span class="s1">'index=</span><span class="si">%s</span><span class="s1"> must be a NDArray, or np.ndarray, or list, or tuple '</span> \
            <span class="s1">' type to use advanced indexing, received type=</span><span class="si">%s</span><span class="s1">'</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">key</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">key</span><span class="p">)))</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">></span> <span class="mi">0</span><span class="p">,</span> <span class="s2">"Cannot slice with empty indices"</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">>=</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">),</span>\
            <span class="s2">"Slicing dimensions exceeds array dimensions, </span><span class="si">%d</span><span class="s2"> vs </span><span class="si">%d</span><span class="s2">"</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">))</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="s1">'int32'</span>  <span class="c1"># index data type passed to gather_nd op</span>
        <span class="n">need_broadcast</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">advanced_indices</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># include list, NDArray, np.ndarray, integer</span>
        <span class="n">basic_indices</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># include only slices</span>
        <span class="n">advanced_index_bshape</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># final advanced index shape</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">idx_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="n">is_advanced_index</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">idx_i</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
                <span class="n">idx_i</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">idx_i</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">context</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
                <span class="n">advanced_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">idx_i</span><span class="p">,</span> <span class="n">py_slice</span><span class="p">):</span>
                <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span> <span class="o">=</span> <span class="n">_get_index_range</span><span class="p">(</span><span class="n">idx_i</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">idx_i</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">idx_i</span><span class="o">.</span><span class="n">step</span><span class="p">)</span>
                <span class="n">idx_i</span> <span class="o">=</span> <span class="n">arange</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">context</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
                <span class="n">basic_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">is_advanced_index</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">idx_i</span><span class="p">,</span> <span class="n">integer_types</span><span class="p">):</span>
                <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span> <span class="o">=</span> <span class="n">_get_index_range</span><span class="p">(</span><span class="n">idx_i</span><span class="p">,</span> <span class="n">idx_i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">idx_i</span> <span class="o">=</span> <span class="n">arange</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">context</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
                <span class="n">advanced_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">idx_i</span><span class="p">,</span> <span class="n">NDArray</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">dtype</span> <span class="o">!=</span> <span class="n">idx_i</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
                    <span class="n">idx_i</span> <span class="o">=</span> <span class="n">idx_i</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
                <span class="n">advanced_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">'Indexing NDArray with index=</span><span class="si">%s</span><span class="s1"> of type=</span><span class="si">%s</span><span class="s1"> is not supported'</span>
                                 <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">key</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">key</span><span class="p">))))</span>
            <span class="k">if</span> <span class="n">is_advanced_index</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">advanced_index_bshape</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">advanced_index_bshape</span> <span class="o">=</span> <span class="n">idx_i</span><span class="o">.</span><span class="n">shape</span>
                <span class="k">elif</span> <span class="n">advanced_index_bshape</span> <span class="o">!=</span> <span class="n">idx_i</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                    <span class="n">need_broadcast</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">advanced_index_bshape</span> <span class="o">=</span> <span class="n">_get_broadcast_shape</span><span class="p">(</span><span class="n">advanced_index_bshape</span><span class="p">,</span> <span class="n">idx_i</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx_i</span><span class="p">)</span>

        <span class="c1"># Get final index shape for gather_nd. See the following reference</span>
        <span class="c1"># for determining the output array shape.</span>
        <span class="c1"># https://docs.scipy.org/doc/numpy-1.13.0/reference/arrays.indexing.html#combining-advanced-and-basic-indexing  # pylint: disable=line-too-long</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">advanced_indices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Advanced index tuple must contain at least one of the following types:'</span>
                             <span class="s1">' list, tuple, NDArray, np.ndarray, integer, received index=</span><span class="si">%s</span><span class="s1">'</span> <span class="o">%</span> <span class="n">key</span><span class="p">)</span>
        <span class="c1"># determine the output array's shape by checking whether advanced_indices are all adjacent</span>
        <span class="c1"># or separated by slices</span>
        <span class="n">advanced_indices_adjacent</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">advanced_indices</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">advanced_indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">!=</span> <span class="n">advanced_indices</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">advanced_indices_adjacent</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">break</span>

        <span class="n">index_bshape_list</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># index broadcasted shape</span>
        <span class="k">if</span> <span class="n">advanced_indices_adjacent</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">advanced_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">index_bshape_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">need_broadcast</span> <span class="ow">and</span> <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">advanced_index_bshape</span><span class="p">:</span>
                    <span class="n">need_broadcast</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">index_bshape_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">advanced_index_bshape</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">advanced_indices</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">need_broadcast</span> <span class="ow">and</span> <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">advanced_index_bshape</span><span class="p">:</span>
                    <span class="n">need_broadcast</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">index_bshape_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">index_bshape_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">advanced_index_bshape</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">basic_indices</span><span class="p">:</span>
                <span class="n">index_bshape_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">need_broadcast</span> <span class="ow">and</span> <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">advanced_index_bshape</span><span class="p">:</span>
                    <span class="n">need_broadcast</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">index_bshape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">index_bshape_list</span><span class="p">)</span>

        <span class="c1"># Need to broadcast all ndarrays in indices to the final shape.</span>
        <span class="c1"># For example, suppose an array has shape=(5, 6, 7, 8) and</span>
        <span class="c1"># key=(slice(1, 5), [[1, 2]], slice(2, 5), [1]).</span>
        <span class="c1"># Since key[1] and key[3] are two advanced indices here and they are</span>
        <span class="c1"># separated by basic indices key[0] and key[2], the output shape</span>
        <span class="c1"># is (1, 2, 4, 3), where the first two elements come from the shape</span>
        <span class="c1"># that key[1] and key[3] should broadcast to, which is (1, 2), and</span>
        <span class="c1"># the last two elements come from the shape of two basic indices.</span>
        <span class="c1"># In order to broadcast all basic and advanced indices to the output shape,</span>
        <span class="c1"># we need to reshape them based on their axis. For example, to broadcast key[0],</span>
        <span class="c1"># with shape=(4,), we first need to reshape it into (1, 1, 4, 1), and then</span>
        <span class="c1"># broadcast the reshaped array to (1, 2, 4, 3); to broadcast key[1], we first</span>
        <span class="c1"># reshape it into (1, 2, 1, 1), then broadcast the reshaped array to (1, 2, 4, 3).</span>
        <span class="k">if</span> <span class="n">need_broadcast</span><span class="p">:</span>
            <span class="n">broadcasted_indices</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">idx_rshape</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">index_bshape</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">advanced_indices_adjacent</span><span class="p">:</span>
                <span class="n">advanced_index_bshape_start</span> <span class="o">=</span> <span class="n">advanced_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># start index of advanced_index_bshape in index_shape</span>
                <span class="n">advanced_index_bshape_stop</span> <span class="o">=</span> <span class="n">advanced_index_bshape_start</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">advanced_index_bshape</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">_is_advanced_index</span><span class="p">(</span><span class="n">idx</span><span class="p">):</span>
                        <span class="n">k</span> <span class="o">=</span> <span class="n">advanced_index_bshape_stop</span>
                        <span class="c1"># find the reshaped shape for indices[i]</span>
                        <span class="k">for</span> <span class="n">dim_size</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                            <span class="n">k</span> <span class="o">-=</span> <span class="mi">1</span>
                            <span class="n">idx_rshape</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">dim_size</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">i</span> <span class="o"><</span> <span class="n">advanced_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>  <span class="c1"># slice is on the left side of advanced indices</span>
                            <span class="n">idx_rshape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="k">elif</span> <span class="n">i</span> <span class="o">></span> <span class="n">advanced_indices</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>  <span class="c1"># slice is on the right side of advanced indices</span>
                            <span class="n">idx_rshape</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)]</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'basic index i=</span><span class="si">%d</span><span class="s1"> cannot be between advanced index i=</span><span class="si">%d</span><span class="s1"> and i=</span><span class="si">%d</span><span class="s1">'</span>
                                             <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">advanced_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">advanced_indices</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
                    <span class="c1"># broadcast current index to the final shape</span>
                    <span class="n">broadcasted_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">idx_rshape</span><span class="p">))</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">index_bshape</span><span class="p">))</span>
                    <span class="c1"># reset idx_rshape to ones</span>
                    <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">idx_rshape</span><span class="p">):</span>
                        <span class="n">idx_rshape</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">basic_index_offset</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">advanced_index_bshape</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">_is_advanced_index</span><span class="p">(</span><span class="n">idx</span><span class="p">):</span>
                        <span class="n">k</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">advanced_index_bshape</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">dim_size</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                            <span class="n">k</span> <span class="o">-=</span> <span class="mi">1</span>
                            <span class="n">idx_rshape</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">dim_size</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">idx_rshape</span><span class="p">[</span><span class="n">basic_index_offset</span><span class="p">]</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">basic_index_offset</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="c1"># broadcast current index to the final shape</span>
                    <span class="n">broadcasted_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">idx_rshape</span><span class="p">))</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">index_bshape</span><span class="p">))</span>
                    <span class="c1"># reset idx_rshape to ones</span>
                    <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">idx_rshape</span><span class="p">):</span>
                        <span class="n">idx_rshape</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="n">indices</span> <span class="o">=</span> <span class="n">broadcasted_indices</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="o">*</span><span class="n">indices</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_prepare_value_nd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">vshape</span><span class="p">):</span>
        <span class="sd">"""Given value and vshape, create an `NDArray` from value with the same</span>
<span class="sd">        context and dtype as the current one and broadcast it to vshape."""</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">numeric_types</span><span class="p">):</span>
            <span class="n">value_nd</span> <span class="o">=</span> <span class="n">full</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">vshape</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="n">value</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">context</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">NDArray</span><span class="p">):</span>
            <span class="n">value_nd</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">as_in_context</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">context</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">value_nd</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
                <span class="n">value_nd</span> <span class="o">=</span> <span class="n">value_nd</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">value_nd</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">context</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">'NDArray does not support assignment with non-array-like'</span>
                                <span class="s1">' object </span><span class="si">%s</span><span class="s1"> of type </span><span class="si">%s</span><span class="s1">'</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">))))</span>
        <span class="k">if</span> <span class="n">value_nd</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">vshape</span><span class="p">:</span>
            <span class="n">value_nd</span> <span class="o">=</span> <span class="n">value_nd</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">vshape</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">value_nd</span>

    <span class="k">def</span> <span class="nf">_set_nd_basic_indexing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">"""This function is called by __setitem__ when key is a basic index, i.e.</span>
<span class="sd">        an integer, or a slice, or a tuple of integers and slices. No restrictions</span>
<span class="sd">        on the values of slices' steps."""</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">integer_types</span><span class="p">):</span>
            <span class="n">sliced_arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_at</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="n">sliced_arr</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">return</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">py_slice</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">step</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">key</span><span class="o">.</span><span class="n">step</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># trivial step</span>
                <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">key</span><span class="o">.</span><span class="n">stop</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">sliced_arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slice</span><span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">key</span><span class="o">.</span><span class="n">stop</span><span class="p">)</span>
                    <span class="n">sliced_arr</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">value</span>
                    <span class="k">return</span>
                <span class="c1"># assign value to the whole NDArray</span>
                <span class="c1"># may need to broadcast first</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">NDArray</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">value</span><span class="o">.</span><span class="n">handle</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">handle</span><span class="p">:</span>
                        <span class="n">value</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">numeric_types</span><span class="p">):</span>
                    <span class="n">_internal</span><span class="o">.</span><span class="n">_full</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">context</span><span class="p">,</span>
                                    <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">),</span> <span class="n">out</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">generic</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">generic</span><span class="p">)</span> <span class="ow">or</span> <span class="n">value</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">shape</span><span class="p">:</span>
                        <span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_sync_copyfrom</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># value might be a list or a tuple</span>
                    <span class="n">value_nd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prepare_value_nd</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span>
                    <span class="n">value_nd</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                <span class="k">return</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># non-trivial step, use _slice_assign or _slice_assign_scalar</span>
                <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">key</span><span class="p">,)</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">),</span> <span class="s2">"key=</span><span class="si">%s</span><span class="s2"> must be a tuple of slices and integers"</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o"><=</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">),</span> <span class="s2">"Indexing dimensions exceed array dimensions, </span><span class="si">%d</span><span class="s2"> vs </span><span class="si">%d</span><span class="s2">"</span>\
                                       <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">))</span>
        <span class="n">begin</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">end</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">steps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">oshape</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># output shape of slice using key</span>
        <span class="n">vshape</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># value shape of data[key]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">slice_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="n">dim_size</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">slice_i</span><span class="p">,</span> <span class="n">py_slice</span><span class="p">):</span>
                <span class="n">begin</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">slice_i</span><span class="o">.</span><span class="n">start</span><span class="p">)</span>
                <span class="n">end</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">slice_i</span><span class="o">.</span><span class="n">stop</span><span class="p">)</span>
                <span class="n">steps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">slice_i</span><span class="o">.</span><span class="n">step</span><span class="p">)</span>
                <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span> <span class="o">=</span> <span class="n">_get_index_range</span><span class="p">(</span><span class="n">slice_i</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">slice_i</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span>
                                                     <span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">slice_i</span><span class="o">.</span><span class="n">step</span><span class="p">)</span>
                <span class="n">dim_size</span> <span class="o">=</span> <span class="n">_get_dim_size</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>
                <span class="n">vshape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dim_size</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">slice_i</span><span class="p">,</span> <span class="n">integer_types</span><span class="p">):</span>
                <span class="n">begin</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">slice_i</span><span class="p">)</span>
                <span class="n">end</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">slice_i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">steps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"basic indexing does not support index=</span><span class="si">%s</span><span class="s2"> of type=</span><span class="si">%s</span><span class="s2">"</span>
                                 <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">slice_i</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">slice_i</span><span class="p">))))</span>
            <span class="n">oshape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dim_size</span><span class="p">)</span>

        <span class="n">oshape</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">):])</span>
        <span class="n">vshape</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">):])</span>
        <span class="c1"># if key contains all integers, vshape should be (1,)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">vshape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">vshape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">oshape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">oshape</span><span class="p">)</span>
        <span class="n">vshape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">vshape</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">numeric_types</span><span class="p">):</span>
            <span class="n">_internal</span><span class="o">.</span><span class="n">_slice_assign_scalar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">begin</span><span class="o">=</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">end</span><span class="p">,</span>
                                           <span class="n">step</span><span class="o">=</span><span class="n">steps</span><span class="p">,</span> <span class="n">scalar</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">value_nd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prepare_value_nd</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">vshape</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">vshape</span> <span class="o">!=</span> <span class="n">oshape</span><span class="p">:</span>
                <span class="n">value_nd</span> <span class="o">=</span> <span class="n">value_nd</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">oshape</span><span class="p">)</span>
            <span class="n">_internal</span><span class="o">.</span><span class="n">_slice_assign</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value_nd</span><span class="p">,</span> <span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">steps</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_nd_advanced_indexing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">"""This function is called by __setitem__ when key is an advanced index."""</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_index_nd</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="n">vshape</span> <span class="o">=</span> <span class="n">_get_oshape_of_gather_nd_op</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">indices</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">value_nd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prepare_value_nd</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">vshape</span><span class="p">)</span>
        <span class="n">_internal</span><span class="o">.</span><span class="n">_scatter_set_nd</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">value_nd</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="n">indices</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_nd_basic_indexing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">"""This function is called when key is a slice, or an integer,</span>
<span class="sd">        or a tuple of slices or integers"""</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">integer_types</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">></span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span>
                    <span class="s1">'index </span><span class="si">{}</span><span class="s1"> is out of bounds for axis 0 with size </span><span class="si">{}</span><span class="s1">'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">key</span><span class="p">,</span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_at</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">py_slice</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">step</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">key</span><span class="o">.</span><span class="n">step</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">step</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"slice step cannot be zero"</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">begin</span><span class="o">=</span><span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">start</span><span class="p">,),</span> <span class="n">end</span><span class="o">=</span><span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">stop</span><span class="p">,),</span> <span class="n">step</span><span class="o">=</span><span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">step</span><span class="p">,))</span>
            <span class="k">elif</span> <span class="n">key</span><span class="o">.</span><span class="n">start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">key</span><span class="o">.</span><span class="n">stop</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slice</span><span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">key</span><span class="o">.</span><span class="n">stop</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'index=</span><span class="si">%s</span><span class="s1"> must be a slice, or an ineger, or a tuple'</span>
                             <span class="s1">' of slices and integers to use basic indexing, received type=</span><span class="si">%s</span><span class="s1">'</span>
                             <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">key</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">key</span><span class="p">))))</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">'basic index cannot be an empty tuple'</span>
        <span class="n">begin</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">end</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">step</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">kept_axes</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># axes where slice_i is a slice</span>
        <span class="n">i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">slice_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">slice_i</span><span class="p">,</span> <span class="n">integer_types</span><span class="p">):</span>
                <span class="n">begin</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">slice_i</span><span class="p">)</span>
                <span class="n">end</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">slice_i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">step</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">slice_i</span><span class="p">,</span> <span class="n">py_slice</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">slice_i</span><span class="o">.</span><span class="n">step</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'basic index=</span><span class="si">%s</span><span class="s1"> cannot have slice=</span><span class="si">%s</span><span class="s1"> with step = 0'</span>
                                     <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">key</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">slice_i</span><span class="p">)))</span>
                <span class="n">begin</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">slice_i</span><span class="o">.</span><span class="n">start</span><span class="p">)</span>
                <span class="n">end</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">slice_i</span><span class="o">.</span><span class="n">stop</span><span class="p">)</span>
                <span class="n">step</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">slice_i</span><span class="o">.</span><span class="n">step</span><span class="p">)</span>
                <span class="n">kept_axes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'basic_indexing does not support slicing with '</span>
                                 <span class="s1">'index=</span><span class="si">%s</span><span class="s1"> of type=</span><span class="si">%s</span><span class="s1">.'</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">slice_i</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">slice_i</span><span class="p">))))</span>
        <span class="n">kept_axes</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)))</span>
        <span class="n">sliced_nd</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">kept_axes</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">sliced_nd</span>
        <span class="c1"># squeeze sliced_shape to remove the axes indexed by integers</span>
        <span class="n">oshape</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">sliced_shape</span> <span class="o">=</span> <span class="n">sliced_nd</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="n">kept_axes</span><span class="p">:</span>
            <span class="n">oshape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sliced_shape</span><span class="p">[</span><span class="n">axis</span><span class="p">])</span>
        <span class="c1"># if key is a tuple of integers, still need to keep 1 dim</span>
        <span class="c1"># while in Numpy, the output will become an value instead of an ndarray</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">oshape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">oshape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">oshape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">oshape</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">oshape</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">sliced_shape</span><span class="p">),</span> <span class="s1">'oshape=</span><span class="si">%s</span><span class="s1"> has different size'</span>\
                                                         <span class="s1">' than sliced_shape=</span><span class="si">%s</span><span class="s1">'</span>\
                                                         <span class="o">%</span> <span class="p">(</span><span class="n">oshape</span><span class="p">,</span> <span class="n">sliced_shape</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sliced_nd</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">oshape</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_nd_advanced_indexing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">"""Get item when key is a tuple of any objects of the following types:</span>
<span class="sd">        NDArray, np.ndarray, list, tuple, slice, and integer."""</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">gather_nd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_index_nd</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_sync_copyfrom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source_array</span><span class="p">):</span>
        <span class="sd">"""Performs a synchronized copy from the `source_array` to the current array.</span>
<span class="sd">        This is called through ``x[:] = source_array``, where the `source_array`</span>
<span class="sd">        is a `numpy.ndarray` or array-like object.</span>
<span class="sd">        This function blocks until all the pending read/write operations with respect</span>
<span class="sd">        to the current `NDArray` are finished and carry out the copy operation to the</span>
<span class="sd">        current NDArray.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        source_array : array_like</span>
<span class="sd">            The data source we would like to copy from.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        >>> a = mx.nd.array([1, 2])</span>
<span class="sd">        >>> a.asnumpy()</span>
<span class="sd">        array([ 1.,  2.], dtype=float32)</span>
<span class="sd">        >>> a[:] = np.array([3, 4])</span>
<span class="sd">        >> a.asnumpy()</span>
<span class="sd">        array([ 3.,  4.], dtype=float32)</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">source_array</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">source_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">source_array</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">'array must consist of array-like data,'</span> <span class="o">+</span>
                                <span class="s1">'type </span><span class="si">%s</span><span class="s1"> is not supported'</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">array</span><span class="p">)))</span>
        <span class="n">source_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">source_array</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">source_array</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Shape inconsistent: expected </span><span class="si">%s</span><span class="s1"> vs got </span><span class="si">%s</span><span class="s1">'</span><span class="o">%</span><span class="p">(</span>
                <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">source_array</span><span class="o">.</span><span class="n">shape</span><span class="p">)))</span>
        <span class="n">check_call</span><span class="p">(</span><span class="n">_LIB</span><span class="o">.</span><span class="n">MXNDArraySyncCopyFromCPU</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">handle</span><span class="p">,</span>
            <span class="n">source_array</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_void_p</span><span class="p">),</span>
            <span class="n">ctypes</span><span class="o">.</span><span class="n">c_size_t</span><span class="p">(</span><span class="n">source_array</span><span class="o">.</span><span class="n">size</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">):</span>
        <span class="sd">"""Returns a sliced NDArray that shares memory with the current one.</span>
<span class="sd">        This is called through ``x[start:stop]``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start : int</span>
<span class="sd">            Starting inclusive index of slice in the first dim.</span>
<span class="sd">        stop : int</span>
<span class="sd">            Finishing exclusive index of slice in the first dim.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            `NDArray` sharing the memory with the current one sliced from</span>
<span class="sd">            start to stop in the first dim.</span>

<span class="sd">        Examples:</span>
<span class="sd">        >>> a = mx.nd.array([[1,2], [3, 4], [5, 6], [7, 8]])</span>
<span class="sd">        >>> a[1:2].asnumpy()</span>
<span class="sd">        array([[ 3.,  4.]], dtype=float32)</span>
<span class="sd">        >>> a[1:1].asnumpy()</span>
<span class="sd">        array([], shape=(0, 2), dtype=float32)</span>
<span class="sd">        """</span>
        <span class="n">handle</span> <span class="o">=</span> <span class="n">NDArrayHandle</span><span class="p">()</span>
        <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_get_index_range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="n">check_call</span><span class="p">(</span><span class="n">_LIB</span><span class="o">.</span><span class="n">MXNDArraySlice</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">handle</span><span class="p">,</span> <span class="n">mx_uint</span><span class="p">(</span><span class="n">start</span><span class="p">),</span> <span class="n">mx_uint</span><span class="p">(</span><span class="n">stop</span><span class="p">),</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">handle</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">NDArray</span><span class="p">(</span><span class="n">handle</span><span class="o">=</span><span class="n">handle</span><span class="p">,</span> <span class="n">writable</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">writable</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_at</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
        <span class="sd">"""Returns a view of the array sliced at `idx` in the first dim.</span>
<span class="sd">        This is called through ``x[idx]``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        idx : int</span>
<span class="sd">            index for slicing the `NDArray` in the first dim.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        NDArray</span>
<span class="sd">            `NDArray` sharing the memory with the current one sliced at `idx` in the first dim.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        >>> a = mx.nd.array([[1,2], [3, 4]])</span>
<span class="sd">        >>> a[1].asnumpy()</span>
<span class="sd">        array([ 3.,  4.], dtype=float32)</span>
<span class="sd">        >>> b = mx.nd.array([1, 2, 3, 4])</span>
<span class="sd">        >>> b[0].asnumpy()</span>
<span class="sd">        array([ 1.], dtype=float32)</span>
<span class="sd">        """</span>
        <span class="n">handle</span> <span class="o">=</span> <span class="n">NDArrayHandle</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="o"><</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">idx</span> <span class="o">+=</span> <span class="n">length</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="o"><</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">'index </span><span class="si">%d</span><span class="s1"> is out of bounds for axis 0 with size </span><span class="si">%d</span><span class="s1">'</span>
                                 <span class="o">%</span> <span class="p">(</span><span class="n">idx</span><span class="o">-</span><span class="n">length</span><span class="p">,</span> <span class="n">length</span><span class="p">))</span>
        <span class="n">check_call</span><span class="p">(</span><span class="n">_LIB</span><span class="o">.</span><span class="n">MXNDArrayAt</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">handle</span><span class="p">,</span> <span class="n">mx_uint</span><span class="p">(</span><span class="n">idx</span><span class="p">),</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">handle</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">NDArray</span><span class="p">(</span><span class="n">handle</span><span class="o">=</span><span class="n">handle</span><span class="p">,</span> <span class="n">writable</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">writable</span><span class="p">)</span>

<div class="viewcode-block" id="NDArray.reshape"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.reshape">[docs]</a>    <span class="k">def</span> <span class="nf">reshape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">):</span>
        <span class="sd">"""Returns a **view** of this array with a new shape without altering any data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        shape : tuple of int</span>
<span class="sd">            The new shape should not change the array size, namely</span>
<span class="sd">            ``np.prod(new_shape)`` should be equal to ``np.prod(self.shape)``.</span>

<span class="sd">            One dimension can be -1. In this case, the value is inferred</span>
<span class="sd">            from the length of the array and remaining dimensions.</span>

<span class="sd">            0 Dimensions in shape will be copied from original shape, i.e.</span>
<span class="sd">            if x.shape == (3, 4, 5), x.reshape((0, 20)).shape will be (3, 20).</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        NDArray</span>
<span class="sd">            An array with desired shape that shares data with this array.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        >>> x = mx.nd.arange(0,6).reshape((2,3))</span>
<span class="sd">        >>> x.asnumpy()</span>
<span class="sd">        array([[ 0.,  1.,  2.],</span>
<span class="sd">               [ 3.,  4.,  5.]], dtype=float32)</span>
<span class="sd">        >>> y = x.reshape((3,2))</span>
<span class="sd">        >>> y.asnumpy()</span>
<span class="sd">        array([[ 0.,  1.],</span>
<span class="sd">               [ 2.,  3.],</span>
<span class="sd">               [ 4.,  5.]], dtype=float32)</span>
<span class="sd">        >>> y = x.reshape((3,-1))</span>
<span class="sd">        >>> y.asnumpy()</span>
<span class="sd">        array([[ 0.,  1.],</span>
<span class="sd">               [ 2.,  3.],</span>
<span class="sd">               [ 4.,  5.]], dtype=float32)</span>
<span class="sd">        >>> y[:] = -1</span>
<span class="sd">        >>> x.asnumpy()</span>
<span class="sd">        array([[-1., -1., -1.],</span>
<span class="sd">               [-1., -1., -1.]], dtype=float32)</span>
<span class="sd">        """</span>
        <span class="n">handle</span> <span class="o">=</span> <span class="n">NDArrayHandle</span><span class="p">()</span>

        <span class="c1"># Actual reshape</span>
        <span class="n">check_call</span><span class="p">(</span><span class="n">_LIB</span><span class="o">.</span><span class="n">MXNDArrayReshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">handle</span><span class="p">,</span>
                                         <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">),</span>
                                         <span class="n">c_array_buf</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span><span class="p">,</span> <span class="n">native_array</span><span class="p">(</span><span class="s1">'i'</span><span class="p">,</span> <span class="n">shape</span><span class="p">)),</span>
                                         <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">handle</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">NDArray</span><span class="p">(</span><span class="n">handle</span><span class="o">=</span><span class="n">handle</span><span class="p">,</span> <span class="n">writable</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">writable</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.reshape_like"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.reshape_like">[docs]</a>    <span class="k">def</span> <span class="nf">reshape_like</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""Convenience fluent method for :py:func:`reshape_like`.</span>

<span class="sd">        The arguments are the same as for :py:func:`reshape_like`, with</span>
<span class="sd">        this array as data.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">reshape_like</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.zeros_like"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.zeros_like">[docs]</a>    <span class="k">def</span> <span class="nf">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""Convenience fluent method for :py:func:`zeros_like`.</span>

<span class="sd">        The arguments are the same as for :py:func:`zeros_like`, with</span>
<span class="sd">        this array as data.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.ones_like"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.ones_like">[docs]</a>    <span class="k">def</span> <span class="nf">ones_like</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""Convenience fluent method for :py:func:`ones_like`.</span>

<span class="sd">        The arguments are the same as for :py:func:`ones_like`, with</span>
<span class="sd">        this array as data.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.broadcast_axes"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.broadcast_axes">[docs]</a>    <span class="k">def</span> <span class="nf">broadcast_axes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""Convenience fluent method for :py:func:`broadcast_axes`.</span>

<span class="sd">        The arguments are the same as for :py:func:`broadcast_axes`, with</span>
<span class="sd">        this array as data.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">broadcast_axes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.repeat"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.repeat">[docs]</a>    <span class="k">def</span> <span class="nf">repeat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""Convenience fluent method for :py:func:`repeat`.</span>

<span class="sd">        The arguments are the same as for :py:func:`repeat`, with</span>
<span class="sd">        this array as data.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.pad"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.pad">[docs]</a>    <span class="k">def</span> <span class="nf">pad</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""Convenience fluent method for :py:func:`pad`.</span>

<span class="sd">        The arguments are the same as for :py:func:`pad`, with</span>
<span class="sd">        this array as data.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.swapaxes"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.swapaxes">[docs]</a>    <span class="k">def</span> <span class="nf">swapaxes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""Convenience fluent method for :py:func:`swapaxes`.</span>

<span class="sd">        The arguments are the same as for :py:func:`swapaxes`, with</span>
<span class="sd">        this array as data.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.split"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.split">[docs]</a>    <span class="k">def</span> <span class="nf">split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""Convenience fluent method for :py:func:`split`.</span>

<span class="sd">        The arguments are the same as for :py:func:`split`, with</span>
<span class="sd">        this array as data.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.slice"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.slice">[docs]</a>    <span class="k">def</span> <span class="nf">slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""Convenience fluent method for :py:func:`slice`.</span>

<span class="sd">        The arguments are the same as for :py:func:`slice`, with</span>
<span class="sd">        this array as data.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.slice_axis"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.slice_axis">[docs]</a>    <span class="k">def</span> <span class="nf">slice_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""Convenience fluent method for :py:func:`slice_axis`.</span>

<span class="sd">        The arguments are the same as for :py:func:`slice_axis`, with</span>
<span class="sd">        this array as data.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">slice_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.take"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.take">[docs]</a>    <span class="k">def</span> <span class="nf">take</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""Convenience fluent method for :py:func:`take`.</span>

<span class="sd">        The arguments are the same as for :py:func:`take`, with</span>
<span class="sd">        this array as data.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.one_hot"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.one_hot">[docs]</a>    <span class="k">def</span> <span class="nf">one_hot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""Convenience fluent method for :py:func:`one_hot`.</span>

<span class="sd">        The arguments are the same as for :py:func:`one_hot`, with</span>
<span class="sd">        this array as data.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">one_hot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.pick"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.pick">[docs]</a>    <span class="k">def</span> <span class="nf">pick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""Convenience fluent method for :py:func:`pick`.</span>

<span class="sd">        The arguments are the same as for :py:func:`pick`, with</span>
<span class="sd">        this array as data.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">pick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.sort"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.sort">[docs]</a>    <span class="k">def</span> <span class="nf">sort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""Convenience fluent method for :py:func:`sort`.</span>

<span class="sd">        The arguments are the same as for :py:func:`sort`, with</span>
<span class="sd">        this array as data.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.topk"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.topk">[docs]</a>    <span class="k">def</span> <span class="nf">topk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""Convenience fluent method for :py:func:`topk`.</span>

<span class="sd">        The arguments are the same as for :py:func:`topk`, with</span>
<span class="sd">        this array as data.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">topk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.argsort"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.argsort">[docs]</a>    <span class="k">def</span> <span class="nf">argsort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""Convenience fluent method for :py:func:`argsort`.</span>

<span class="sd">        The arguments are the same as for :py:func:`argsort`, with</span>
<span class="sd">        this array as data.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.argmax"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.argmax">[docs]</a>    <span class="k">def</span> <span class="nf">argmax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""Convenience fluent method for :py:func:`argmax`.</span>

<span class="sd">        The arguments are the same as for :py:func:`argmax`, with</span>
<span class="sd">        this array as data.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.argmax_channel"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.argmax_channel">[docs]</a>    <span class="k">def</span> <span class="nf">argmax_channel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""Convenience fluent method for :py:func:`argmax_channel`.</span>

<span class="sd">        The arguments are the same as for :py:func:`argmax_channel`, with</span>
<span class="sd">        this array as data.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">argmax_channel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.argmin"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.argmin">[docs]</a>    <span class="k">def</span> <span class="nf">argmin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""Convenience fluent method for :py:func:`argmin`.</span>

<span class="sd">        The arguments are the same as for :py:func:`argmin`, with</span>
<span class="sd">        this array as data.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.clip"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.clip">[docs]</a>    <span class="k">def</span> <span class="nf">clip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""Convenience fluent method for :py:func:`clip`.</span>

<span class="sd">        The arguments are the same as for :py:func:`clip`, with</span>
<span class="sd">        this array as data.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.abs"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.abs">[docs]</a>    <span class="k">def</span> <span class="nf">abs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""Convenience fluent method for :py:func:`abs`.</span>

<span class="sd">        The arguments are the same as for :py:func:`abs`, with</span>
<span class="sd">        this array as data.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.sign"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.sign">[docs]</a>    <span class="k">def</span> <span class="nf">sign</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""Convenience fluent method for :py:func:`sign`.</span>

<span class="sd">        The arguments are the same as for :py:func:`sign`, with</span>
<span class="sd">        this array as data.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.flatten"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.flatten">[docs]</a>    <span class="k">def</span> <span class="nf">flatten</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""Convenience fluent method for :py:func:`flatten`.</span>

<span class="sd">        The arguments are the same as for :py:func:`flatten`, with</span>
<span class="sd">        this array as data.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.expand_dims"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.expand_dims">[docs]</a>    <span class="k">def</span> <span class="nf">expand_dims</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""Convenience fluent method for :py:func:`expand_dims`.</span>

<span class="sd">        The arguments are the same as for :py:func:`expand_dims`, with</span>
<span class="sd">        this array as data.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.tile"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.tile">[docs]</a>    <span class="k">def</span> <span class="nf">tile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""Convenience fluent method for :py:func:`tile`.</span>

<span class="sd">        The arguments are the same as for :py:func:`tile`, with</span>
<span class="sd">        this array as data.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.transpose"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.transpose">[docs]</a>    <span class="k">def</span> <span class="nf">transpose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""Convenience fluent method for :py:func:`transpose`.</span>

<span class="sd">        The arguments are the same as for :py:func:`transpose`, with</span>
<span class="sd">        this array as data.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.flip"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.flip">[docs]</a>    <span class="k">def</span> <span class="nf">flip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""Convenience fluent method for :py:func:`flip`.</span>

<span class="sd">        The arguments are the same as for :py:func:`flip`, with</span>
<span class="sd">        this array as data.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.sum"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.sum">[docs]</a>    <span class="k">def</span> <span class="nf">sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""Convenience fluent method for :py:func:`sum`.</span>

<span class="sd">        The arguments are the same as for :py:func:`sum`, with</span>
<span class="sd">        this array as data.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.nansum"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.nansum">[docs]</a>    <span class="k">def</span> <span class="nf">nansum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""Convenience fluent method for :py:func:`nansum`.</span>

<span class="sd">        The arguments are the same as for :py:func:`nansum`, with</span>
<span class="sd">        this array as data.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.prod"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.prod">[docs]</a>    <span class="k">def</span> <span class="nf">prod</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""Convenience fluent method for :py:func:`prod`.</span>

<span class="sd">        The arguments are the same as for :py:func:`prod`, with</span>
<span class="sd">        this array as data.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.nanprod"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.nanprod">[docs]</a>    <span class="k">def</span> <span class="nf">nanprod</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""Convenience fluent method for :py:func:`nanprod`.</span>

<span class="sd">        The arguments are the same as for :py:func:`nanprod`, with</span>
<span class="sd">        this array as data.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">nanprod</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.mean"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.mean">[docs]</a>    <span class="k">def</span> <span class="nf">mean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""Convenience fluent method for :py:func:`mean`.</span>

<span class="sd">        The arguments are the same as for :py:func:`mean`, with</span>
<span class="sd">        this array as data.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.max"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.max">[docs]</a>    <span class="k">def</span> <span class="nf">max</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""Convenience fluent method for :py:func:`max`.</span>

<span class="sd">        The arguments are the same as for :py:func:`max`, with</span>
<span class="sd">        this array as data.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.min"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.min">[docs]</a>    <span class="k">def</span> <span class="nf">min</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""Convenience fluent method for :py:func:`min`.</span>

<span class="sd">        The arguments are the same as for :py:func:`min`, with</span>
<span class="sd">        this array as data.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.norm"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.norm">[docs]</a>    <span class="k">def</span> <span class="nf">norm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""Convenience fluent method for :py:func:`norm`.</span>

<span class="sd">        The arguments are the same as for :py:func:`norm`, with</span>
<span class="sd">        this array as data.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.round"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.round">[docs]</a>    <span class="k">def</span> <span class="nf">round</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""Convenience fluent method for :py:func:`round`.</span>

<span class="sd">        The arguments are the same as for :py:func:`round`, with</span>
<span class="sd">        this array as data.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.rint"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.rint">[docs]</a>    <span class="k">def</span> <span class="nf">rint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""Convenience fluent method for :py:func:`rint`.</span>

<span class="sd">        The arguments are the same as for :py:func:`rint`, with</span>
<span class="sd">        this array as data.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.fix"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.fix">[docs]</a>    <span class="k">def</span> <span class="nf">fix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""Convenience fluent method for :py:func:`fix`.</span>

<span class="sd">        The arguments are the same as for :py:func:`fix`, with</span>
<span class="sd">        this array as data.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">fix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.floor"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.floor">[docs]</a>    <span class="k">def</span> <span class="nf">floor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""Convenience fluent method for :py:func:`floor`.</span>

<span class="sd">        The arguments are the same as for :py:func:`floor`, with</span>
<span class="sd">        this array as data.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.ceil"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.ceil">[docs]</a>    <span class="k">def</span> <span class="nf">ceil</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""Convenience fluent method for :py:func:`ceil`.</span>

<span class="sd">        The arguments are the same as for :py:func:`ceil`, with</span>
<span class="sd">        this array as data.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.trunc"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.trunc">[docs]</a>    <span class="k">def</span> <span class="nf">trunc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""Convenience fluent method for :py:func:`trunc`.</span>

<span class="sd">        The arguments are the same as for :py:func:`trunc`, with</span>
<span class="sd">        this array as data.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">trunc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.sin"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.sin">[docs]</a>    <span class="k">def</span> <span class="nf">sin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""Convenience fluent method for :py:func:`sin`.</span>

<span class="sd">        The arguments are the same as for :py:func:`sin`, with</span>
<span class="sd">        this array as data.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.cos"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.cos">[docs]</a>    <span class="k">def</span> <span class="nf">cos</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""Convenience fluent method for :py:func:`cos`.</span>

<span class="sd">        The arguments are the same as for :py:func:`cos`, with</span>
<span class="sd">        this array as data.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.tan"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.tan">[docs]</a>    <span class="k">def</span> <span class="nf">tan</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""Convenience fluent method for :py:func:`tan`.</span>

<span class="sd">        The arguments are the same as for :py:func:`tan`, with</span>
<span class="sd">        this array as data.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.arcsin"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.arcsin">[docs]</a>    <span class="k">def</span> <span class="nf">arcsin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""Convenience fluent method for :py:func:`arcsin`.</span>

<span class="sd">        The arguments are the same as for :py:func:`arcsin`, with</span>
<span class="sd">        this array as data.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.arccos"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.arccos">[docs]</a>    <span class="k">def</span> <span class="nf">arccos</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""Convenience fluent method for :py:func:`arccos`.</span>

<span class="sd">        The arguments are the same as for :py:func:`arccos`, with</span>
<span class="sd">        this array as data.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.arctan"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.arctan">[docs]</a>    <span class="k">def</span> <span class="nf">arctan</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""Convenience fluent method for :py:func:`arctan`.</span>

<span class="sd">        The arguments are the same as for :py:func:`arctan`, with</span>
<span class="sd">        this array as data.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.degrees"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.degrees">[docs]</a>    <span class="k">def</span> <span class="nf">degrees</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""Convenience fluent method for :py:func:`degrees`.</span>

<span class="sd">        The arguments are the same as for :py:func:`degrees`, with</span>
<span class="sd">        this array as data.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.radians"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.radians">[docs]</a>    <span class="k">def</span> <span class="nf">radians</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""Convenience fluent method for :py:func:`radians`.</span>

<span class="sd">        The arguments are the same as for :py:func:`radians`, with</span>
<span class="sd">        this array as data.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.sinh"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.sinh">[docs]</a>    <span class="k">def</span> <span class="nf">sinh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""Convenience fluent method for :py:func:`sinh`.</span>

<span class="sd">        The arguments are the same as for :py:func:`sinh`, with</span>
<span class="sd">        this array as data.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">sinh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.cosh"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.cosh">[docs]</a>    <span class="k">def</span> <span class="nf">cosh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""Convenience fluent method for :py:func:`cosh`.</span>

<span class="sd">        The arguments are the same as for :py:func:`cosh`, with</span>
<span class="sd">        this array as data.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">cosh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.tanh"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.tanh">[docs]</a>    <span class="k">def</span> <span class="nf">tanh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""Convenience fluent method for :py:func:`tanh`.</span>

<span class="sd">        The arguments are the same as for :py:func:`tanh`, with</span>
<span class="sd">        this array as data.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">tanh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.arcsinh"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.arcsinh">[docs]</a>    <span class="k">def</span> <span class="nf">arcsinh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""Convenience fluent method for :py:func:`arcsinh`.</span>

<span class="sd">        The arguments are the same as for :py:func:`arcsinh`, with</span>
<span class="sd">        this array as data.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">arcsinh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.arccosh"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.arccosh">[docs]</a>    <span class="k">def</span> <span class="nf">arccosh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""Convenience fluent method for :py:func:`arccosh`.</span>

<span class="sd">        The arguments are the same as for :py:func:`arccosh`, with</span>
<span class="sd">        this array as data.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">arccosh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.arctanh"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.arctanh">[docs]</a>    <span class="k">def</span> <span class="nf">arctanh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""Convenience fluent method for :py:func:`arctanh`.</span>

<span class="sd">        The arguments are the same as for :py:func:`arctanh`, with</span>
<span class="sd">        this array as data.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">arctanh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.exp"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.exp">[docs]</a>    <span class="k">def</span> <span class="nf">exp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""Convenience fluent method for :py:func:`exp`.</span>

<span class="sd">        The arguments are the same as for :py:func:`exp`, with</span>
<span class="sd">        this array as data.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.expm1"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.expm1">[docs]</a>    <span class="k">def</span> <span class="nf">expm1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""Convenience fluent method for :py:func:`expm1`.</span>

<span class="sd">        The arguments are the same as for :py:func:`expm1`, with</span>
<span class="sd">        this array as data.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">expm1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.log"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.log">[docs]</a>    <span class="k">def</span> <span class="nf">log</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""Convenience fluent method for :py:func:`log`.</span>

<span class="sd">        The arguments are the same as for :py:func:`log`, with</span>
<span class="sd">        this array as data.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.log10"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.log10">[docs]</a>    <span class="k">def</span> <span class="nf">log10</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""Convenience fluent method for :py:func:`log10`.</span>

<span class="sd">        The arguments are the same as for :py:func:`log10`, with</span>
<span class="sd">        this array as data.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.log2"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.log2">[docs]</a>    <span class="k">def</span> <span class="nf">log2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""Convenience fluent method for :py:func:`log2`.</span>

<span class="sd">        The arguments are the same as for :py:func:`log2`, with</span>
<span class="sd">        this array as data.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.log1p"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.log1p">[docs]</a>    <span class="k">def</span> <span class="nf">log1p</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""Convenience fluent method for :py:func:`log1p`.</span>

<span class="sd">        The arguments are the same as for :py:func:`log1p`, with</span>
<span class="sd">        this array as data.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">log1p</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.sqrt"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.sqrt">[docs]</a>    <span class="k">def</span> <span class="nf">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""Convenience fluent method for :py:func:`sqrt`.</span>

<span class="sd">        The arguments are the same as for :py:func:`sqrt`, with</span>
<span class="sd">        this array as data.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.rsqrt"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.rsqrt">[docs]</a>    <span class="k">def</span> <span class="nf">rsqrt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""Convenience fluent method for :py:func:`rsqrt`.</span>

<span class="sd">        The arguments are the same as for :py:func:`rsqrt`, with</span>
<span class="sd">        this array as data.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">rsqrt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.cbrt"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.cbrt">[docs]</a>    <span class="k">def</span> <span class="nf">cbrt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""Convenience fluent method for :py:func:`cbrt`.</span>

<span class="sd">        The arguments are the same as for :py:func:`cbrt`, with</span>
<span class="sd">        this array as data.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">cbrt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.rcbrt"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.rcbrt">[docs]</a>    <span class="k">def</span> <span class="nf">rcbrt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""Convenience fluent method for :py:func:`rcbrt`.</span>

<span class="sd">        The arguments are the same as for :py:func:`rcbrt`, with</span>
<span class="sd">        this array as data.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">rcbrt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.square"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.square">[docs]</a>    <span class="k">def</span> <span class="nf">square</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""Convenience fluent method for :py:func:`square`.</span>

<span class="sd">        The arguments are the same as for :py:func:`square`, with</span>
<span class="sd">        this array as data.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.reciprocal"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.reciprocal">[docs]</a>    <span class="k">def</span> <span class="nf">reciprocal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""Convenience fluent method for :py:func:`reciprocal`.</span>

<span class="sd">        The arguments are the same as for :py:func:`reciprocal`, with</span>
<span class="sd">        this array as data.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">reciprocal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.relu"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.relu">[docs]</a>    <span class="k">def</span> <span class="nf">relu</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""Convenience fluent method for :py:func:`relu`.</span>

<span class="sd">        The arguments are the same as for :py:func:`relu`, with</span>
<span class="sd">        this array as data.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">relu</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.sigmoid"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.sigmoid">[docs]</a>    <span class="k">def</span> <span class="nf">sigmoid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""Convenience fluent method for :py:func:`sigmoid`.</span>

<span class="sd">        The arguments are the same as for :py:func:`sigmoid`, with</span>
<span class="sd">        this array as data.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">sigmoid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.softmax"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.softmax">[docs]</a>    <span class="k">def</span> <span class="nf">softmax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""Convenience fluent method for :py:func:`softmax`.</span>

<span class="sd">        The arguments are the same as for :py:func:`softmax`, with</span>
<span class="sd">        this array as data.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">softmax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.log_softmax"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.log_softmax">[docs]</a>    <span class="k">def</span> <span class="nf">log_softmax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""Convenience fluent method for :py:func:`log_softmax`.</span>

<span class="sd">        The arguments are the same as for :py:func:`log_softmax`, with</span>
<span class="sd">        this array as data.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">log_softmax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    <span class="c1"># pylint: disable= undefined-variable</span>
<div class="viewcode-block" id="NDArray.broadcast_to"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.broadcast_to">[docs]</a>    <span class="k">def</span> <span class="nf">broadcast_to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">):</span>
        <span class="sd">"""Broadcasts the input array to a new shape.</span>

<span class="sd">        Broadcasting is only allowed on axes with size 1. The new shape cannot change</span>
<span class="sd">        the number of dimensions.</span>
<span class="sd">        For example, you could broadcast from shape (2, 1) to (2, 3), but not from</span>
<span class="sd">        shape (2, 3) to (2, 3, 3).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        shape : tuple of int</span>
<span class="sd">            The shape of the desired array.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        NDArray</span>
<span class="sd">            A NDArray with the desired shape that is not sharing data with this</span>
<span class="sd">            array, even if the new shape is the same as ``self.shape``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        >>> x = mx.nd.arange(0,3).reshape((1,3,1))</span>
<span class="sd">        >>> x.asnumpy()</span>
<span class="sd">        array([[[ 0.],</span>
<span class="sd">                [ 1.],</span>
<span class="sd">                [ 2.]]], dtype=float32)</span>
<span class="sd">        >>> y = x.broadcast_to((2,3,3))</span>
<span class="sd">        >>> y.asnumpy()</span>
<span class="sd">        array([[[ 0.,  0.,  0.],</span>
<span class="sd">                [ 1.,  1.,  1.],</span>
<span class="sd">                [ 2.,  2.,  2.]],</span>
<span class="sd">        <BLANKLINE></span>
<span class="sd">               [[ 0.,  0.,  0.],</span>
<span class="sd">                [ 1.,  1.,  1.],</span>
<span class="sd">                [ 2.,  2.,  2.]]], dtype=float32)</span>
<span class="sd">        """</span>
        <span class="n">cur_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">err_str</span> <span class="o">=</span> <span class="s1">'operands could not be broadcast together with remapped shapes'</span> \
                  <span class="s1">'[original->remapped]: </span><span class="si">{}</span><span class="s1"> and requested shape </span><span class="si">{}</span><span class="s1">'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cur_shape</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o"><</span> <span class="nb">len</span><span class="p">(</span><span class="n">cur_shape</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">err_str</span><span class="p">)</span>
        <span class="n">cur_shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">cur_shape</span><span class="p">))</span> <span class="o">+</span> <span class="n">cur_shape</span>
        <span class="n">cur_shape_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cur_shape</span><span class="p">)</span>
        <span class="n">broadcasting_axes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">cur_shape_arr</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">shape</span><span class="p">))</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">cur_shape_arr</span><span class="p">[</span><span class="n">broadcasting_axes</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">err_str</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cur_shape</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">cur_shape</span><span class="p">),</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">shape</span><span class="p">))</span></div>
    <span class="c1"># pylint: enable= undefined-variable</span>

<div class="viewcode-block" id="NDArray.wait_to_read"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.wait_to_read">[docs]</a>    <span class="k">def</span> <span class="nf">wait_to_read</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Waits until all previous write operations on the current array are finished.</span>

<span class="sd">        This method guarantees that all previous write operations that pushed</span>
<span class="sd">        into the backend engine for execution are actually finished.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        >>> import time</span>
<span class="sd">        >>> tic = time.time()</span>
<span class="sd">        >>> a = mx.nd.ones((1000,1000))</span>
<span class="sd">        >>> b = mx.nd.dot(a, a)</span>
<span class="sd">        >>> print(time.time() - tic) # doctest: +SKIP</span>
<span class="sd">        0.003854036331176758</span>
<span class="sd">        >>> b.wait_to_read()</span>
<span class="sd">        >>> print(time.time() - tic) # doctest: +SKIP</span>
<span class="sd">        0.0893700122833252</span>
<span class="sd">        """</span>
        <span class="n">check_call</span><span class="p">(</span><span class="n">_LIB</span><span class="o">.</span><span class="n">MXNDArrayWaitToRead</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">handle</span><span class="p">))</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ndim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Returns the number of dimensions of this array</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        >>> x = mx.nd.array([1, 2, 3, 4])</span>
<span class="sd">        >>> x.ndim</span>
<span class="sd">        1</span>
<span class="sd">        >>> x = mx.nd.array([[1, 2], [3, 4]])</span>
<span class="sd">        >>> x.ndim</span>
<span class="sd">        2</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Tuple of array dimensions.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        >>> x = mx.nd.array([1, 2, 3, 4])</span>
<span class="sd">        >>> x.shape</span>
<span class="sd">        (4L,)</span>
<span class="sd">        >>> y = mx.nd.zeros((2, 3, 4))</span>
<span class="sd">        >>> y.shape</span>
<span class="sd">        (2L, 3L, 4L)</span>
<span class="sd">        """</span>
        <span class="n">ndim</span> <span class="o">=</span> <span class="n">mx_uint</span><span class="p">()</span>
        <span class="n">pdata</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">mx_uint</span><span class="p">)()</span>
        <span class="n">check_call</span><span class="p">(</span><span class="n">_LIB</span><span class="o">.</span><span class="n">MXNDArrayGetShape</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">handle</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">ndim</span><span class="p">),</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">pdata</span><span class="p">)))</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">pdata</span><span class="p">[:</span><span class="n">ndim</span><span class="o">.</span><span class="n">value</span><span class="p">])</span>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Number of elements in the array.</span>

<span class="sd">        Equivalent to the product of the array's dimensions.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        >>> import numpy as np</span>
<span class="sd">        >>> x = mx.nd.zeros((3, 5, 2))</span>
<span class="sd">        >>> x.size</span>
<span class="sd">        30</span>
<span class="sd">        >>> np.prod(x.shape)</span>
<span class="sd">        30</span>
<span class="sd">        """</span>
        <span class="n">size</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">*=</span> <span class="n">i</span>
        <span class="k">return</span> <span class="n">size</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">context</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Device context of the array.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        >>> x = mx.nd.array([1, 2, 3, 4])</span>
<span class="sd">        >>> x.context</span>
<span class="sd">        cpu(0)</span>
<span class="sd">        >>> type(x.context)</span>
<span class="sd">        <class 'mxnet.context.Context'></span>
<span class="sd">        >>> y = mx.nd.zeros((2,3), mx.gpu(0))</span>
<span class="sd">        >>> y.context</span>
<span class="sd">        gpu(0)</span>
<span class="sd">        """</span>
        <span class="n">dev_typeid</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span><span class="p">()</span>
        <span class="n">dev_id</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span><span class="p">()</span>
        <span class="n">check_call</span><span class="p">(</span><span class="n">_LIB</span><span class="o">.</span><span class="n">MXNDArrayGetContext</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">handle</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">dev_typeid</span><span class="p">),</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">dev_id</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">Context</span><span class="p">(</span><span class="n">Context</span><span class="o">.</span><span class="n">devtype2str</span><span class="p">[</span><span class="n">dev_typeid</span><span class="o">.</span><span class="n">value</span><span class="p">],</span> <span class="n">dev_id</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Data-type of the array's elements.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.dtype</span>
<span class="sd">            This NDArray's data type.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        >>> x = mx.nd.zeros((2,3))</span>
<span class="sd">        >>> x.dtype</span>
<span class="sd">        <type 'numpy.float32'></span>
<span class="sd">        >>> y = mx.nd.zeros((2,3), dtype='int32')</span>
<span class="sd">        >>> y.dtype</span>
<span class="sd">        <type 'numpy.int32'></span>
<span class="sd">        """</span>
        <span class="n">mx_dtype</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span><span class="p">()</span>
        <span class="n">check_call</span><span class="p">(</span><span class="n">_LIB</span><span class="o">.</span><span class="n">MXNDArrayGetDType</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">handle</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">mx_dtype</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">_DTYPE_MX_TO_NP</span><span class="p">[</span><span class="n">mx_dtype</span><span class="o">.</span><span class="n">value</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">stype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Storage-type of the array.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">_STORAGE_TYPE_ID_TO_STR</span><span class="p">[</span><span class="n">_storage_type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">handle</span><span class="p">)]</span>

    <span class="nd">@property</span>
    <span class="c1"># pylint: disable= invalid-name, undefined-variable</span>
    <span class="k">def</span> <span class="nf">T</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Returns a copy of the array with axes transposed.</span>

<span class="sd">        Equivalent to ``mx.nd.transpose(self)`` except that</span>
<span class="sd">        self is returned if ``self.ndim < 2``.</span>

<span class="sd">        Unlike ``numpy.ndarray.T``, this function returns a copy</span>
<span class="sd">        rather than a view of the array unless ``self.ndim < 2``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        >>> x = mx.nd.arange(0,6).reshape((2,3))</span>
<span class="sd">        >>> x.asnumpy()</span>
<span class="sd">        array([[ 0.,  1.,  2.],</span>
<span class="sd">               [ 3.,  4.,  5.]], dtype=float32)</span>
<span class="sd">        >>> x.T.asnumpy()</span>
<span class="sd">        array([[ 0.,  3.],</span>
<span class="sd">               [ 1.,  4.],</span>
<span class="sd">               [ 2.,  5.]], dtype=float32)</span>

<span class="sd">        """</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o"><</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="c1"># pylint: enable= invalid-name, undefined-variable</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_fresh_grad</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Whether this array's corresponding gradient array</span>
<span class="sd">        (registered via `autograd.mark_variables`) has been</span>
<span class="sd">        updated by `autograd.backward` since last reset.</span>

<span class="sd">        `_fresh_grad` need to be manually set to False</span>
<span class="sd">        after consuming gradient (usually after updating this</span>
<span class="sd">        array).</span>
<span class="sd">        """</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span><span class="p">()</span>
        <span class="n">check_call</span><span class="p">(</span><span class="n">_LIB</span><span class="o">.</span><span class="n">MXNDArrayGetGradState</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">handle</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">out</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">out</span><span class="o">.</span><span class="n">value</span>

    <span class="nd">@_fresh_grad</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">_fresh_grad</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="n">check_call</span><span class="p">(</span><span class="n">_LIB</span><span class="o">.</span><span class="n">MXNDArraySetGradState</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">handle</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span><span class="p">(</span><span class="n">state</span><span class="p">)))</span>

<div class="viewcode-block" id="NDArray.asnumpy"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.asnumpy">[docs]</a>    <span class="k">def</span> <span class="nf">asnumpy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Returns a ``numpy.ndarray`` object with value copied from this array.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        >>> x = mx.nd.ones((2,3))</span>
<span class="sd">        >>> y = x.asnumpy()</span>
<span class="sd">        >>> type(y)</span>
<span class="sd">        <type 'numpy.ndarray'></span>
<span class="sd">        >>> y</span>
<span class="sd">        array([[ 1.,  1.,  1.],</span>
<span class="sd">               [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="sd">        >>> z = mx.nd.ones((2,3), dtype='int32')</span>
<span class="sd">        >>> z.asnumpy()</span>
<span class="sd">        array([[1, 1, 1],</span>
<span class="sd">               [1, 1, 1]], dtype=int32)</span>
<span class="sd">        """</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">check_call</span><span class="p">(</span><span class="n">_LIB</span><span class="o">.</span><span class="n">MXNDArraySyncCopyToCPU</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">handle</span><span class="p">,</span>
            <span class="n">data</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_void_p</span><span class="p">),</span>
            <span class="n">ctypes</span><span class="o">.</span><span class="n">c_size_t</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">size</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">data</span></div>

<div class="viewcode-block" id="NDArray.asscalar"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.asscalar">[docs]</a>    <span class="k">def</span> <span class="nf">asscalar</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Returns a scalar whose value is copied from this array.</span>

<span class="sd">        This function is equivalent to ``self.asnumpy()[0]``. This NDArray must have shape (1,).</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        >>> x = mx.nd.ones((1,), dtype='int32')</span>
<span class="sd">        >>> x.asscalar()</span>
<span class="sd">        1</span>
<span class="sd">        >>> type(x.asscalar())</span>
<span class="sd">        <type 'numpy.int32'></span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"The current array is not a scalar"</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="NDArray.astype"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.astype">[docs]</a>    <span class="k">def</span> <span class="nf">astype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
        <span class="sd">"""Returns a copy of the array after casting to a specified type.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dtype : numpy.dtype or str</span>
<span class="sd">            The type of the returned array.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        NDArray, CSRNDArray or RowSparseNDArray</span>
<span class="sd">            The copied array after casting to the specified type.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        >>> x = mx.nd.zeros((2,3), dtype='float32')</span>
<span class="sd">        >>> y = x.astype('int32')</span>
<span class="sd">        >>> y.dtype</span>
<span class="sd">        <type 'numpy.int32'></span>
<span class="sd">        """</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">context</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span></div>

<div class="viewcode-block" id="NDArray.copyto"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.copyto">[docs]</a>    <span class="k">def</span> <span class="nf">copyto</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">"""Copies the value of this array to another array.</span>

<span class="sd">        If ``other`` is a ``NDArray`` object, then ``other.shape`` and</span>
<span class="sd">        ``self.shape`` should be the same. This function copies the value from</span>
<span class="sd">        ``self`` to ``other``.</span>

<span class="sd">        If ``other`` is a context, a new ``NDArray`` will be first created on</span>
<span class="sd">        the target context, and the value of ``self`` is copied.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : NDArray or Context</span>
<span class="sd">            The destination array or context.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        NDArray, CSRNDArray or RowSparseNDArray</span>
<span class="sd">            The copied array. If ``other`` is an ``NDArray``, then the return value</span>
<span class="sd">            and ``other`` will point to the same ``NDArray``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        >>> x = mx.nd.ones((2,3))</span>
<span class="sd">        >>> y = mx.nd.zeros((2,3), mx.gpu(0))</span>
<span class="sd">        >>> z = x.copyto(y)</span>
<span class="sd">        >>> z is y</span>
<span class="sd">        True</span>
<span class="sd">        >>> y.asnumpy()</span>
<span class="sd">        array([[ 1.,  1.,  1.],</span>
<span class="sd">               [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="sd">        >>> y.copyto(mx.gpu(0))</span>
<span class="sd">        <NDArray 2x3 @gpu(0)></span>

<span class="sd">        """</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">NDArray</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">handle</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">handle</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">'You are attempting to copy an array to itself'</span><span class="p">,</span> <span class="ne">RuntimeWarning</span><span class="p">)</span>
                <span class="k">return</span>
            <span class="k">return</span> <span class="n">_internal</span><span class="o">.</span><span class="n">_copyto</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">other</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Context</span><span class="p">):</span>
            <span class="n">hret</span> <span class="o">=</span> <span class="n">NDArray</span><span class="p">(</span><span class="n">_new_alloc_handle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">_internal</span><span class="o">.</span><span class="n">_copyto</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">hret</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">'copyto does not support type '</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)))</span></div>

<div class="viewcode-block" id="NDArray.copy"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Makes a copy of this ``NDArray``, keeping the same context.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        NDArray, CSRNDArray or RowSparseNDArray</span>
<span class="sd">            The copied array</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        >>> x = mx.nd.ones((2,3))</span>
<span class="sd">        >>> y = x.copy()</span>
<span class="sd">        >>> y.asnumpy()</span>
<span class="sd">        array([[ 1.,  1.,  1.],</span>
<span class="sd">               [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">context</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.as_in_context"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.as_in_context">[docs]</a>    <span class="k">def</span> <span class="nf">as_in_context</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
        <span class="sd">"""Returns an array on the target device with the same value as this array.</span>

<span class="sd">        If the target context is the same as ``self.context``, then ``self`` is</span>
<span class="sd">        returned.  Otherwise, a copy is made.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        context : Context</span>
<span class="sd">            The target context.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        NDArray, CSRNDArray or RowSparseNDArray</span>
<span class="sd">            The target array.</span>


<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        >>> x = mx.nd.ones((2,3))</span>
<span class="sd">        >>> y = x.as_in_context(mx.cpu())</span>
<span class="sd">        >>> y is x</span>
<span class="sd">        True</span>
<span class="sd">        >>> z = x.as_in_context(mx.gpu(0))</span>
<span class="sd">        >>> z is x</span>
<span class="sd">        False</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">context</span> <span class="o">==</span> <span class="n">context</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">context</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.attach_grad"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.attach_grad">[docs]</a>    <span class="k">def</span> <span class="nf">attach_grad</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grad_req</span><span class="o">=</span><span class="s1">'write'</span><span class="p">,</span> <span class="n">stype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">"""Attach a gradient buffer to this NDArray, so that `backward`</span>
<span class="sd">        can compute gradient with respect to it.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        grad_req : {'write', 'add', 'null'}</span>
<span class="sd">            How gradient will be accumulated.</span>
<span class="sd">            - 'write': gradient will be overwritten on every backward.</span>
<span class="sd">            - 'add': gradient will be added to existing value on every backward.</span>
<span class="sd">            - 'null': do not compute gradient for this NDArray.</span>
<span class="sd">        stype : str, optional</span>
<span class="sd">            The storage type of the gradient array. Defaults to the same stype of this NDArray.</span>
<span class="sd">        """</span>
        <span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">zeros</span> <span class="k">as</span> <span class="n">_zeros</span>
        <span class="k">if</span> <span class="n">stype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">grad</span> <span class="o">=</span> <span class="n">_zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">stype</span><span class="o">=</span><span class="n">stype</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">grad</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>  <span class="c1"># pylint: disable=undefined-variable</span>
        <span class="n">grad_req</span> <span class="o">=</span> <span class="n">_GRAD_REQ_MAP</span><span class="p">[</span><span class="n">grad_req</span><span class="p">]</span>
        <span class="n">check_call</span><span class="p">(</span><span class="n">_LIB</span><span class="o">.</span><span class="n">MXAutogradMarkVariables</span><span class="p">(</span>
            <span class="mi">1</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">pointer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">handle</span><span class="p">),</span>
            <span class="n">ctypes</span><span class="o">.</span><span class="n">pointer</span><span class="p">(</span><span class="n">mx_uint</span><span class="p">(</span><span class="n">grad_req</span><span class="p">)),</span>
            <span class="n">ctypes</span><span class="o">.</span><span class="n">pointer</span><span class="p">(</span><span class="n">grad</span><span class="o">.</span><span class="n">handle</span><span class="p">)))</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">grad</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Returns gradient buffer attached to this NDArray."""</span>
        <span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">_ndarray_cls</span>
        <span class="n">hdl</span> <span class="o">=</span> <span class="n">NDArrayHandle</span><span class="p">()</span>
        <span class="n">check_call</span><span class="p">(</span><span class="n">_LIB</span><span class="o">.</span><span class="n">MXNDArrayGetGrad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">handle</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">hdl</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">hdl</span><span class="o">.</span><span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">_ndarray_cls</span><span class="p">(</span><span class="n">hdl</span><span class="p">)</span>

<div class="viewcode-block" id="NDArray.detach"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.detach">[docs]</a>    <span class="k">def</span> <span class="nf">detach</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Returns a new NDArray, detached from the current graph."""</span>
        <span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">_ndarray_cls</span>
        <span class="n">hdl</span> <span class="o">=</span> <span class="n">NDArrayHandle</span><span class="p">()</span>
        <span class="n">check_call</span><span class="p">(</span><span class="n">_LIB</span><span class="o">.</span><span class="n">MXNDArrayDetach</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">handle</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">hdl</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">_ndarray_cls</span><span class="p">(</span><span class="n">hdl</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.backward"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.backward">[docs]</a>    <span class="k">def</span> <span class="nf">backward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out_grad</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">retain_graph</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">train_mode</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">"""Compute the gradients of this NDArray w.r.t variables.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        out_grad : NDArray, optional</span>
<span class="sd">            Gradient with respect to head.</span>
<span class="sd">        retain_graph : bool, optional</span>
<span class="sd">            Whether to retain the computaion graph for another backward</span>
<span class="sd">            pass on the same graph. By default the computaion history</span>
<span class="sd">            is cleared.</span>
<span class="sd">        train_mode : bool, optional</span>
<span class="sd">            Whether to compute gradient for training or inference.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">out_grad</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ograd_handles</span> <span class="o">=</span> <span class="p">[</span><span class="n">NDArrayHandle</span><span class="p">(</span><span class="mi">0</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ograd_handles</span> <span class="o">=</span> <span class="p">[</span><span class="n">out_grad</span><span class="o">.</span><span class="n">handle</span><span class="p">]</span>

        <span class="n">check_call</span><span class="p">(</span><span class="n">_LIB</span><span class="o">.</span><span class="n">MXAutogradBackwardEx</span><span class="p">(</span>
            <span class="mi">1</span><span class="p">,</span> <span class="n">c_handle_array</span><span class="p">([</span><span class="bp">self</span><span class="p">]),</span>
            <span class="n">c_array</span><span class="p">(</span><span class="n">NDArrayHandle</span><span class="p">,</span> <span class="n">ograd_handles</span><span class="p">),</span>
            <span class="mi">0</span><span class="p">,</span>
            <span class="n">ctypes</span><span class="o">.</span><span class="n">c_void_p</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
            <span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span><span class="p">(</span><span class="n">retain_graph</span><span class="p">),</span>
            <span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
            <span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span><span class="p">(</span><span class="n">train_mode</span><span class="p">),</span>
            <span class="n">ctypes</span><span class="o">.</span><span class="n">c_void_p</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
            <span class="n">ctypes</span><span class="o">.</span><span class="n">c_void_p</span><span class="p">(</span><span class="mi">0</span><span class="p">)))</span></div>

<div class="viewcode-block" id="NDArray.tostype"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.NDArray.tostype">[docs]</a>    <span class="k">def</span> <span class="nf">tostype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stype</span><span class="p">):</span>
        <span class="sd">"""Return a copy of the array with chosen storage type.</span>

<span class="sd">        See Also</span>
<span class="sd">        ----------</span>
<span class="sd">        :meth:`mxnet.ndarray.cast_storage`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        NDArray, CSRNDArray or RowSparseNDArray</span>
<span class="sd">            A copy of the array with the chosen storage stype</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">cast_storage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stype</span><span class="o">=</span><span class="n">stype</span><span class="p">)</span></div></div>


<span class="k">def</span> <span class="nf">_get_indexing_dispatch_code</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
    <span class="sd">"""Returns a dispatch code for calling basic or advanced indexing functions."""</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">(</span><span class="n">NDArray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
        <span class="k">return</span> <span class="n">_NDARRAY_ADVANCED_INDEXING</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="c1"># TODO(junwu): Add support for nested lists besides integer list</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">key</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">integer_types</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">'Indexing NDArray only supports a list of integers as index'</span>
                                <span class="s1">' when key is of list type, received element=</span><span class="si">%s</span><span class="s1"> of type=</span><span class="si">%s</span><span class="s1">'</span>
                                <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">i</span><span class="p">))))</span>
        <span class="k">return</span> <span class="n">_NDARRAY_ADVANCED_INDEXING</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">(</span><span class="n">integer_types</span><span class="p">,</span> <span class="n">py_slice</span><span class="p">)):</span>
        <span class="k">return</span> <span class="n">_NDARRAY_BASIC_INDEXING</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">key</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="p">(</span><span class="n">NDArray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
                <span class="k">return</span> <span class="n">_NDARRAY_ADVANCED_INDEXING</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="p">(</span><span class="n">py_slice</span><span class="p">,</span> <span class="n">integer_types</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"NDArray does not support slicing with key </span><span class="si">%s</span><span class="s2"> of type </span><span class="si">%s</span><span class="s2">."</span>
                                 <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">idx</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">idx</span><span class="p">))))</span>
        <span class="k">return</span> <span class="n">_NDARRAY_BASIC_INDEXING</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_NDARRAY_UNSUPPORTED_INDEXING</span>


<span class="k">def</span> <span class="nf">_get_index_range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">"""Given start, stop, step and array length, return</span>
<span class="sd">    absolute values of start, stop, and step for generating index range.</span>
<span class="sd">    The returned values have been compensated by adding length if they</span>
<span class="sd">    are less than zero for all the cases but slice(None, None, -1).</span>
<span class="sd">    Note that the returned value of stop is not necessarily >= 0, since</span>
<span class="sd">    absolute stop is -1 in the case of slice(None, None, -1)."""</span>
    <span class="k">if</span> <span class="n">step</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'step size cannot be zero'</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">length</span> <span class="o"><</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'array length cannot be less than zero'</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">step</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">step</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">step</span> <span class="o">></span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">length</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">elif</span> <span class="n">start</span> <span class="o"><</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">start</span> <span class="o">+=</span> <span class="n">length</span>
        <span class="k">if</span> <span class="n">start</span> <span class="o"><</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">'Slicing start </span><span class="si">%d</span><span class="s1"> exceeds limit of </span><span class="si">%d</span><span class="s1">'</span> <span class="o">%</span> <span class="p">(</span><span class="n">start</span><span class="o">-</span><span class="n">length</span><span class="p">,</span> <span class="n">length</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">start</span> <span class="o">>=</span> <span class="n">length</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">'Slicing start </span><span class="si">%d</span><span class="s1"> exceeds limit of </span><span class="si">%d</span><span class="s1">'</span> <span class="o">%</span> <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">length</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">stop</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">step</span> <span class="o">></span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="n">length</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># this supports case such as ::-1</span>
            <span class="c1"># stop = -1 here refers to the element before index 0,</span>
            <span class="c1"># instead of the last element in the array</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">elif</span> <span class="n">stop</span> <span class="o"><</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">stop</span> <span class="o">+=</span> <span class="n">length</span>
        <span class="k">if</span> <span class="n">stop</span> <span class="o"><</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">'Slicing stop </span><span class="si">%d</span><span class="s1"> exceeds limit of </span><span class="si">%d</span><span class="s1">'</span> <span class="o">%</span> <span class="p">(</span><span class="n">stop</span><span class="o">-</span><span class="n">length</span><span class="p">,</span> <span class="n">length</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">stop</span> <span class="o">></span> <span class="n">length</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">'Slicing stop </span><span class="si">%d</span><span class="s1"> exceeds limit of </span><span class="si">%d</span><span class="s1">'</span> <span class="o">%</span> <span class="p">(</span><span class="n">stop</span><span class="p">,</span> <span class="n">length</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span>


<span class="k">def</span> <span class="nf">_get_oshape_of_gather_nd_op</span><span class="p">(</span><span class="n">dshape</span><span class="p">,</span> <span class="n">ishape</span><span class="p">):</span>
    <span class="sd">"""Given data and index shapes, get the output `NDArray` shape.</span>
<span class="sd">    This basically implements the infer shape logic of op gather_nd."""</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">dshape</span><span class="p">)</span> <span class="o">></span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">ishape</span><span class="p">)</span> <span class="o">></span> <span class="mi">0</span>
    <span class="n">oshape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ishape</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
    <span class="k">if</span> <span class="n">ishape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o"><</span> <span class="nb">len</span><span class="p">(</span><span class="n">dshape</span><span class="p">):</span>
        <span class="n">oshape</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">dshape</span><span class="p">[</span><span class="n">ishape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:])</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">oshape</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_get_dim_size</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">):</span>
    <span class="sd">"""Given start, stop, and stop, calculate the number of elements</span>
<span class="sd">    of this slice."""</span>
    <span class="k">assert</span> <span class="n">step</span> <span class="o">!=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">step</span> <span class="o">></span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">start</span> <span class="o"><</span> <span class="n">stop</span>
        <span class="n">dim_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">stop</span> <span class="o">-</span> <span class="n">start</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="n">step</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">stop</span> <span class="o"><</span> <span class="n">start</span>
        <span class="n">dim_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">start</span> <span class="o">-</span> <span class="n">stop</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="p">(</span><span class="o">-</span><span class="n">step</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">dim_size</span>


<span class="k">def</span> <span class="nf">_get_broadcast_shape</span><span class="p">(</span><span class="n">shape1</span><span class="p">,</span> <span class="n">shape2</span><span class="p">):</span>
    <span class="sd">"""Given two shapes that are not identical, find the shape</span>
<span class="sd">    that both input shapes can broadcast to."""</span>
    <span class="k">if</span> <span class="n">shape1</span> <span class="o">==</span> <span class="n">shape2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">shape1</span>

    <span class="n">length1</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape1</span><span class="p">)</span>
    <span class="n">length2</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape2</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">length1</span> <span class="o">></span> <span class="n">length2</span><span class="p">:</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">shape1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">shape2</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">length1</span><span class="p">,</span> <span class="n">length2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">shape1</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">shape2</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
        <span class="k">if</span> <span class="n">a</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">b</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">a</span> <span class="o">!=</span> <span class="n">b</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'shape1=</span><span class="si">%s</span><span class="s1"> is not broadcastable to shape2=</span><span class="si">%s</span><span class="s1">'</span> <span class="o">%</span> <span class="p">(</span><span class="n">shape1</span><span class="p">,</span> <span class="n">shape2</span><span class="p">))</span>
        <span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>


<div class="viewcode-block" id="onehot_encode"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.onehot_encode">[docs]</a><span class="k">def</span> <span class="nf">onehot_encode</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">out</span><span class="p">):</span>
    <span class="sd">"""One-hot encoding indices into matrix out.</span>

<span class="sd">    .. note:: `onehot_encode` is deprecated. Use `one_hot` instead.</span>

<span class="sd">    """</span>
    <span class="c1"># pylint: disable= no-member, protected-access</span>
    <span class="k">return</span> <span class="n">_internal</span><span class="o">.</span><span class="n">_onehot_encode</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>
    <span class="c1"># pylint: enable= no-member, protected-access</span>


<div class="viewcode-block" id="ones"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.ones">[docs]</a><span class="k">def</span> <span class="nf">ones</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">"""Returns a new array filled with all ones, with the given shape and type.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    shape : int or tuple of int or list of int</span>
<span class="sd">        The shape of the empty array.</span>
<span class="sd">    ctx : Context, optional</span>
<span class="sd">        An optional device context.</span>
<span class="sd">        Defaults to the current default context (``mxnet.Context.default_ctx``).</span>
<span class="sd">    dtype : str or numpy.dtype, optional</span>
<span class="sd">        An optional value type (default is `float32`).</span>
<span class="sd">    out : NDArray, optional</span>
<span class="sd">        The output NDArray (default is `None`).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    NDArray</span>
<span class="sd">        A new array of the specified shape filled with all ones.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    >>> mx.nd.ones(1).asnumpy()</span>
<span class="sd">    array([ 1.], dtype=float32)</span>
<span class="sd">    >>> mx.nd.ones((1,2), mx.gpu(0))</span>
<span class="sd">    <NDArray 1x2 @gpu(0)></span>
<span class="sd">    >>> mx.nd.ones((1,2), dtype='float16').asnumpy()</span>
<span class="sd">    array([[ 1.,  1.]], dtype=float16)</span>
<span class="sd">    """</span>
    <span class="c1"># pylint: disable= unused-argument</span>
    <span class="k">if</span> <span class="n">ctx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ctx</span> <span class="o">=</span> <span class="n">Context</span><span class="o">.</span><span class="n">default_ctx</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">mx_real_t</span> <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">dtype</span>
    <span class="c1"># pylint: disable= no-member, protected-access</span>
    <span class="k">return</span> <span class="n">_internal</span><span class="o">.</span><span class="n">_ones</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="n">ctx</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
    <span class="c1"># pylint: enable= no-member, protected-access</span>


<div class="viewcode-block" id="full"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.full">[docs]</a><span class="k">def</span> <span class="nf">full</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">mx_real_t</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">"""Returns a new array of given shape and type, filled with the given value `val`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    --------</span>
<span class="sd">    shape : int or tuple of int</span>
<span class="sd">        The shape of the new array.</span>
<span class="sd">    val : scalar</span>
<span class="sd">        Fill value.</span>
<span class="sd">    ctx : Context, optional</span>
<span class="sd">        Device context (default is the current default context).</span>
<span class="sd">    dtype : `str` or `numpy.dtype`, optional</span>
<span class="sd">        The data type of the returned `NDArray`. The default datatype is `float32`.</span>
<span class="sd">    out : NDArray, optional</span>
<span class="sd">        The output NDArray (default is `None`).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    NDArray</span>
<span class="sd">        `NDArray` filled with `val`, with the given shape, ctx, and dtype.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    >>> mx.nd.full(1, 2.0).asnumpy()</span>
<span class="sd">    array([ 2.], dtype=float32)</span>
<span class="sd">    >>> mx.nd.full((1, 2), 2.0, mx.gpu(0))</span>
<span class="sd">    <NDArray 1x2 @gpu(0)></span>
<span class="sd">    >>> mx.nd.full((1, 2), 2.0, dtype='float16').asnumpy()</span>
<span class="sd">    array([[ 2.,  2.]], dtype=float16)</span>
<span class="sd">    """</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span> <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">out</span>
    <span class="n">out</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">val</span>
    <span class="k">return</span> <span class="n">out</span></div>


<span class="k">def</span> <span class="nf">array</span><span class="p">(</span><span class="n">source_array</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">"""Creates an array from any object exposing the array interface.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    source_array : array_like</span>
<span class="sd">        An object exposing the array interface, an object whose `__array__`</span>
<span class="sd">        method returns an array, or any (nested) sequence.</span>
<span class="sd">    ctx : Context, optional</span>
<span class="sd">        Device context (default is the current default context).</span>
<span class="sd">    dtype : str or numpy.dtype, optional</span>
<span class="sd">        The data type of the output array. The default dtype is ``source_array.dtype``</span>
<span class="sd">        if `source_array` is an `NDArray`, `float32` otherwise.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    NDArray</span>
<span class="sd">        An `NDArray` with the same contents as the `source_array`.</span>
<span class="sd">    """</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">source_array</span><span class="p">,</span> <span class="n">NDArray</span><span class="p">):</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">source_array</span><span class="o">.</span><span class="n">dtype</span> <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">dtype</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">mx_real_t</span> <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">dtype</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">source_array</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">source_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">source_array</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">'source_array must be array like object'</span><span class="p">)</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="n">empty</span><span class="p">(</span><span class="n">source_array</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
    <span class="n">arr</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">source_array</span>
    <span class="k">return</span> <span class="n">arr</span>


<div class="viewcode-block" id="moveaxis"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.moveaxis">[docs]</a><span class="k">def</span> <span class="nf">moveaxis</span><span class="p">(</span><span class="n">tensor</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">):</span>
    <span class="sd">"""Moves the `source` axis into the `destination` position</span>
<span class="sd">    while leaving the other axes in their original order</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    tensor : mx.nd.array</span>
<span class="sd">        The array which axes should be reordered</span>
<span class="sd">    source : int</span>
<span class="sd">        Original position of the axes to move.</span>
<span class="sd">    destination : int</span>
<span class="sd">        Destination position for each of the original axes.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    result : mx.nd.array</span>
<span class="sd">        Array with moved axes.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    >>> X = mx.nd.array([[1, 2, 3], [4, 5, 6]])</span>
<span class="sd">    >>> mx.nd.moveaxis(X, 0, 1).shape</span>
<span class="sd">    (3L, 2L)</span>
<span class="sd">    """</span>
    <span class="n">axes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">tensor</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">axes</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Source should verify 0 <= source < tensor.ndim'</span>
                         <span class="s1">'Got </span><span class="si">%d</span><span class="s1">'</span> <span class="o">%</span> <span class="n">source</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">axes</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">destination</span><span class="p">,</span> <span class="n">source</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Destination should verify 0 <= destination < tensor.ndim'</span>
                         <span class="s1">'Got </span><span class="si">%d</span><span class="s1">'</span> <span class="o">%</span> <span class="n">destination</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">tensor</span><span class="p">,</span> <span class="n">axes</span><span class="p">)</span></div>


<span class="c1"># pylint: disable= no-member, protected-access, too-many-arguments, redefined-outer-name</span>
<div class="viewcode-block" id="arange"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.arange">[docs]</a><span class="k">def</span> <span class="nf">arange</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">repeat</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">mx_real_t</span><span class="p">):</span>
    <span class="sd">"""Returns evenly spaced values within a given interval.</span>

<span class="sd">    Values are generated within the half-open interval [`start`, `stop`). In other</span>
<span class="sd">    words, the interval includes `start` but excludes `stop`. The function is</span>
<span class="sd">    similar to the built-in Python function `range` and to `numpy.arange`,</span>
<span class="sd">    but returns an `NDArray`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    start : number, optional</span>
<span class="sd">        Start of interval. The default start value is 0.</span>
<span class="sd">    stop : number</span>
<span class="sd">        End of interval.</span>
<span class="sd">    step : number, optional</span>
<span class="sd">        Spacing between values. The default step size is 1.</span>
<span class="sd">    repeat : int, optional</span>
<span class="sd">        Number of times to repeat each element. The default repeat count is 1.</span>
<span class="sd">    ctx : Context, optional</span>
<span class="sd">        Device context. Default context is the current default context.</span>
<span class="sd">    dtype : str or numpy.dtype, optional</span>
<span class="sd">        The data type of the `NDArray`. The default datatype is `np.float32`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    NDArray</span>
<span class="sd">        `NDArray` of evenly spaced values in the specified range.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    >>> mx.nd.arange(3).asnumpy()</span>
<span class="sd">    array([ 0.,  1.,  2.], dtype=float32)</span>
<span class="sd">    >>> mx.nd.arange(2, 6).asnumpy()</span>
<span class="sd">    array([ 2.,  3.,  4.,  5.], dtype=float32)</span>
<span class="sd">    >>> mx.nd.arange(2, 6, step=2).asnumpy()</span>
<span class="sd">    array([ 2.,  4.], dtype=float32)</span>
<span class="sd">    >>> mx.nd.arange(2, 6, step=1.5, repeat=2).asnumpy()</span>
<span class="sd">    array([ 2. ,  2. ,  3.5,  3.5,  5. ,  5. ], dtype=float32)</span>
<span class="sd">    >>> mx.nd.arange(2, 6, step=2, repeat=3, dtype='int32').asnumpy()</span>
<span class="sd">    array([2, 2, 2, 4, 4, 4], dtype=int32)</span>
<span class="sd">    """</span>
    <span class="k">if</span> <span class="n">ctx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ctx</span> <span class="o">=</span> <span class="n">Context</span><span class="o">.</span><span class="n">default_ctx</span>
    <span class="k">return</span> <span class="n">_internal</span><span class="o">.</span><span class="n">_arange</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="n">step</span><span class="p">,</span> <span class="n">repeat</span><span class="o">=</span><span class="n">repeat</span><span class="p">,</span>
                             <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">ctx</span><span class="p">))</span></div>
<span class="c1"># pylint: enable= no-member, protected-access, too-many-arguments</span>


<span class="c1">#pylint: disable= too-many-arguments, no-member, protected-access</span>
<span class="k">def</span> <span class="nf">_ufunc_helper</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">fn_array</span><span class="p">,</span> <span class="n">fn_scalar</span><span class="p">,</span> <span class="n">lfn_scalar</span><span class="p">,</span> <span class="n">rfn_scalar</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">""" Helper function for element-wise operation.</span>
<span class="sd">    The function will perform numpy-like broadcasting if needed and call different functions.</span>

<span class="sd">    Parameters</span>
<span class="sd">    --------</span>
<span class="sd">    lhs : NDArray or numeric value</span>
<span class="sd">        Left-hand side operand.</span>

<span class="sd">    rhs : NDArray or numeric value</span>
<span class="sd">        Right-hand operand,</span>

<span class="sd">    fn_array : function</span>
<span class="sd">        Function to be called if both lhs and rhs are of ``NDArray`` type.</span>

<span class="sd">    fn_scalar : function</span>
<span class="sd">        Function to be called if both lhs and rhs are numeric values.</span>

<span class="sd">    lfn_scalar : function</span>
<span class="sd">        Function to be called if lhs is ``NDArray`` while rhs is numeric value</span>

<span class="sd">    rfn_scalar : function</span>
<span class="sd">        Function to be called if lhs is numeric value while rhs is ``NDArray``;</span>
<span class="sd">        if none is provided, then the function is commutative, so rfn_scalar is equal to lfn_scalar</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    NDArray</span>
<span class="sd">        result array</span>
<span class="sd">    """</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">numeric_types</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rhs</span><span class="p">,</span> <span class="n">numeric_types</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">fn_scalar</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">rfn_scalar</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># commutative function</span>
                <span class="k">return</span> <span class="n">lfn_scalar</span><span class="p">(</span><span class="n">rhs</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">lhs</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">rfn_scalar</span><span class="p">(</span><span class="n">rhs</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">lhs</span><span class="p">))</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rhs</span><span class="p">,</span> <span class="n">numeric_types</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">lfn_scalar</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">rhs</span><span class="p">))</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rhs</span><span class="p">,</span> <span class="n">NDArray</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">fn_array</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">'type </span><span class="si">%s</span><span class="s1"> not supported'</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">rhs</span><span class="p">)))</span>
<span class="c1">#pylint: enable= too-many-arguments, no-member, protected-access</span>


<div class="viewcode-block" id="add"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.add">[docs]</a><span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">):</span>
    <span class="sd">"""Returns element-wise sum of the input arrays with broadcasting.</span>

<span class="sd">    Equivalent to ``lhs + rhs``, ``mx.nd.broadcast_add(lhs, rhs)`` and</span>
<span class="sd">    ``mx.nd.broadcast_plus(lhs, rhs)``.</span>

<span class="sd">    .. note::</span>

<span class="sd">       If the corresponding dimensions of two arrays have the same size or one of them has size 1,</span>
<span class="sd">       then the arrays are broadcastable to a common shape.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lhs : scalar or array</span>
<span class="sd">        First array to be added.</span>
<span class="sd">    rhs : scalar or array</span>
<span class="sd">         Second array to be added.</span>
<span class="sd">        If ``lhs.shape != rhs.shape``, they must be</span>
<span class="sd">        broadcastable to a common shape.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    NDArray</span>
<span class="sd">        The element-wise sum of the input arrays.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    >>> x = mx.nd.ones((2,3))</span>
<span class="sd">    >>> y = mx.nd.arange(2).reshape((2,1))</span>
<span class="sd">    >>> z = mx.nd.arange(2).reshape((1,2))</span>
<span class="sd">    >>> x.asnumpy()</span>
<span class="sd">    array([[ 1.,  1.,  1.],</span>
<span class="sd">           [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="sd">    >>> y.asnumpy()</span>
<span class="sd">    array([[ 0.],</span>
<span class="sd">           [ 1.]], dtype=float32)</span>
<span class="sd">    >>> z.asnumpy()</span>
<span class="sd">    array([[ 0.,  1.]], dtype=float32)</span>
<span class="sd">    >>> (x+2).asnumpy()</span>
<span class="sd">    array([[ 3.,  3.,  3.],</span>
<span class="sd">           [ 3.,  3.,  3.]], dtype=float32)</span>
<span class="sd">    >>> (x+y).asnumpy()</span>
<span class="sd">    array([[ 1.,  1.,  1.],</span>
<span class="sd">           [ 2.,  2.,  2.]], dtype=float32)</span>
<span class="sd">    >>> mx.nd.add(x,y).asnumpy()</span>
<span class="sd">    array([[ 1.,  1.,  1.],</span>
<span class="sd">           [ 2.,  2.,  2.]], dtype=float32)</span>
<span class="sd">    >>> (z + y).asnumpy()</span>
<span class="sd">    array([[ 0.,  1.],</span>
<span class="sd">           [ 1.,  2.]], dtype=float32)</span>
<span class="sd">    """</span>
    <span class="c1"># pylint: disable= no-member, protected-access</span>
    <span class="k">return</span> <span class="n">_ufunc_helper</span><span class="p">(</span>
        <span class="n">lhs</span><span class="p">,</span>
        <span class="n">rhs</span><span class="p">,</span>
        <span class="n">op</span><span class="o">.</span><span class="n">broadcast_add</span><span class="p">,</span>
        <span class="n">operator</span><span class="o">.</span><span class="n">add</span><span class="p">,</span>
        <span class="n">_internal</span><span class="o">.</span><span class="n">_plus_scalar</span><span class="p">,</span>
        <span class="kc">None</span><span class="p">)</span></div>
    <span class="c1"># pylint: enable= no-member, protected-access</span>


<div class="viewcode-block" id="subtract"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.subtract">[docs]</a><span class="k">def</span> <span class="nf">subtract</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">):</span>
    <span class="sd">"""Returns element-wise difference of the input arrays with broadcasting.</span>

<span class="sd">    Equivalent to ``lhs - rhs``, ``mx.nd.broadcast_sub(lhs, rhs)`` and</span>
<span class="sd">    ``mx.nd.broadcast_minus(lhs, rhs)``.</span>

<span class="sd">    .. note::</span>

<span class="sd">       If the corresponding dimensions of two arrays have the same size or one of them has size 1,</span>
<span class="sd">       then the arrays are broadcastable to a common shape.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lhs : scalar or array</span>
<span class="sd">        First array to be subtracted.</span>
<span class="sd">    rhs : scalar or array</span>
<span class="sd">         Second array to be subtracted.</span>
<span class="sd">        If ``lhs.shape != rhs.shape``, they must be</span>
<span class="sd">        broadcastable to a common shape.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    NDArray</span>
<span class="sd">        The element-wise difference of the input arrays.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    >>> x = mx.nd.ones((2,3))</span>
<span class="sd">    >>> y = mx.nd.arange(2).reshape((2,1))</span>
<span class="sd">    >>> z = mx.nd.arange(2).reshape((1,2))</span>
<span class="sd">    >>> x.asnumpy()</span>
<span class="sd">    array([[ 1.,  1.,  1.],</span>
<span class="sd">           [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="sd">    >>> y.asnumpy()</span>
<span class="sd">    array([[ 0.],</span>
<span class="sd">           [ 1.]], dtype=float32)</span>
<span class="sd">    >>> z.asnumpy()</span>
<span class="sd">    array([[ 0.,  1.]], dtype=float32)</span>
<span class="sd">    >>> (x-2).asnumpy()</span>
<span class="sd">    array([[-1., -1., -1.],</span>
<span class="sd">           [-1., -1., -1.]], dtype=float32)</span>
<span class="sd">    >>> (x-y).asnumpy()</span>
<span class="sd">    array([[ 1.,  1.,  1.],</span>
<span class="sd">           [ 0.,  0.,  0.]], dtype=float32)</span>
<span class="sd">    >>> mx.nd.subtract(x,y).asnumpy()</span>
<span class="sd">    array([[ 1.,  1.,  1.],</span>
<span class="sd">           [ 0.,  0.,  0.]], dtype=float32)</span>
<span class="sd">    >>> (z-y).asnumpy()</span>
<span class="sd">    array([[ 0.,  1.],</span>
<span class="sd">           [-1.,  0.]], dtype=float32)</span>
<span class="sd">    """</span>
    <span class="c1"># pylint: disable= no-member, protected-access</span>
    <span class="k">return</span> <span class="n">_ufunc_helper</span><span class="p">(</span>
        <span class="n">lhs</span><span class="p">,</span>
        <span class="n">rhs</span><span class="p">,</span>
        <span class="n">op</span><span class="o">.</span><span class="n">broadcast_sub</span><span class="p">,</span>
        <span class="n">operator</span><span class="o">.</span><span class="n">sub</span><span class="p">,</span>
        <span class="n">_internal</span><span class="o">.</span><span class="n">_minus_scalar</span><span class="p">,</span>
        <span class="n">_internal</span><span class="o">.</span><span class="n">_rminus_scalar</span><span class="p">)</span></div>
    <span class="c1"># pylint: enable= no-member, protected-access</span>


<div class="viewcode-block" id="multiply"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.multiply">[docs]</a><span class="k">def</span> <span class="nf">multiply</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">):</span>
    <span class="sd">"""Returns element-wise product of the input arrays with broadcasting.</span>

<span class="sd">    Equivalent to ``lhs * rhs`` and ``mx.nd.broadcast_mul(lhs, rhs)``.</span>

<span class="sd">    .. note::</span>

<span class="sd">       If the corresponding dimensions of two arrays have the same size or one of them has size 1,</span>
<span class="sd">       then the arrays are broadcastable to a common shape.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lhs : scalar or array</span>
<span class="sd">        First array to be multiplied.</span>
<span class="sd">    rhs : scalar or array</span>
<span class="sd">         Second array to be multiplied.</span>
<span class="sd">        If ``lhs.shape != rhs.shape``, they must be</span>
<span class="sd">        broadcastable to a common shape.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    NDArray</span>
<span class="sd">        The element-wise multiplication of the input arrays.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    >>> x = mx.nd.ones((2,3))</span>
<span class="sd">    >>> y = mx.nd.arange(2).reshape((2,1))</span>
<span class="sd">    >>> z = mx.nd.arange(2).reshape((1,2))</span>
<span class="sd">    >>> x.asnumpy()</span>
<span class="sd">    array([[ 1.,  1.,  1.],</span>
<span class="sd">           [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="sd">    >>> y.asnumpy()</span>
<span class="sd">    array([[ 0.],</span>
<span class="sd">           [ 1.]], dtype=float32)</span>
<span class="sd">    >>> z.asnumpy()</span>
<span class="sd">    array([[ 0.,  1.]], dtype=float32)</span>
<span class="sd">    >>> (x*2).asnumpy()</span>
<span class="sd">    array([[ 2.,  2.,  2.],</span>
<span class="sd">           [ 2.,  2.,  2.]], dtype=float32)</span>
<span class="sd">    >>> (x*y).asnumpy()</span>
<span class="sd">    array([[ 0.,  0.,  0.],</span>
<span class="sd">           [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="sd">    >>> mx.nd.multiply(x, y).asnumpy()</span>
<span class="sd">    array([[ 0.,  0.,  0.],</span>
<span class="sd">           [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="sd">    >>> (z*y).asnumpy()</span>
<span class="sd">    array([[ 0.,  0.],</span>
<span class="sd">           [ 0.,  1.]], dtype=float32)</span>
<span class="sd">    """</span>
    <span class="c1"># pylint: disable= no-member, protected-access</span>
    <span class="k">return</span> <span class="n">_ufunc_helper</span><span class="p">(</span>
        <span class="n">lhs</span><span class="p">,</span>
        <span class="n">rhs</span><span class="p">,</span>
        <span class="n">op</span><span class="o">.</span><span class="n">broadcast_mul</span><span class="p">,</span>
        <span class="n">operator</span><span class="o">.</span><span class="n">mul</span><span class="p">,</span>
        <span class="n">_internal</span><span class="o">.</span><span class="n">_mul_scalar</span><span class="p">,</span>
        <span class="kc">None</span><span class="p">)</span></div>
    <span class="c1"># pylint: enable= no-member, protected-access</span>


<div class="viewcode-block" id="divide"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.divide">[docs]</a><span class="k">def</span> <span class="nf">divide</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">):</span>
    <span class="sd">"""Returns element-wise division of the input arrays with broadcasting.</span>

<span class="sd">    Equivalent to ``lhs / rhs`` and ``mx.nd.broadcast_div(lhs, rhs)``.</span>

<span class="sd">    .. note::</span>

<span class="sd">       If the corresponding dimensions of two arrays have the same size or one of them has size 1,</span>
<span class="sd">       then the arrays are broadcastable to a common shape.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lhs : scalar or array</span>
<span class="sd">        First array in division.</span>
<span class="sd">    rhs : scalar or array</span>
<span class="sd">         Second array in division.</span>
<span class="sd">        The arrays to be divided. If ``lhs.shape != rhs.shape``, they must be</span>
<span class="sd">        broadcastable to a common shape.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    NDArray</span>
<span class="sd">        The element-wise division of the input arrays.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    >>> x = mx.nd.ones((2,3))*6</span>
<span class="sd">    >>> y = mx.nd.ones((2,1))*2</span>
<span class="sd">    >>> x.asnumpy()</span>
<span class="sd">    array([[ 6.,  6.,  6.],</span>
<span class="sd">           [ 6.,  6.,  6.]], dtype=float32)</span>
<span class="sd">    >>> y.asnumpy()</span>
<span class="sd">    array([[ 2.],</span>
<span class="sd">           [ 2.]], dtype=float32)</span>
<span class="sd">    >>> x/2</span>
<span class="sd">    <NDArray 2x3 @cpu(0)></span>
<span class="sd">    >>> (x/3).asnumpy()</span>
<span class="sd">    array([[ 2.,  2.,  2.],</span>
<span class="sd">           [ 2.,  2.,  2.]], dtype=float32)</span>
<span class="sd">    >>> (x/y).asnumpy()</span>
<span class="sd">    array([[ 3.,  3.,  3.],</span>
<span class="sd">           [ 3.,  3.,  3.]], dtype=float32)</span>
<span class="sd">    >>> mx.nd.divide(x,y).asnumpy()</span>
<span class="sd">    array([[ 3.,  3.,  3.],</span>
<span class="sd">           [ 3.,  3.,  3.]], dtype=float32)</span>
<span class="sd">    """</span>
    <span class="c1"># pylint: disable= no-member, protected-access</span>
    <span class="k">return</span> <span class="n">_ufunc_helper</span><span class="p">(</span>
        <span class="n">lhs</span><span class="p">,</span>
        <span class="n">rhs</span><span class="p">,</span>
        <span class="n">op</span><span class="o">.</span><span class="n">broadcast_div</span><span class="p">,</span>
        <span class="n">operator</span><span class="o">.</span><span class="n">truediv</span><span class="p">,</span>
        <span class="n">_internal</span><span class="o">.</span><span class="n">_div_scalar</span><span class="p">,</span>
        <span class="n">_internal</span><span class="o">.</span><span class="n">_rdiv_scalar</span><span class="p">)</span></div>
    <span class="c1"># pylint: enable= no-member, protected-access</span>


<div class="viewcode-block" id="modulo"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.modulo">[docs]</a><span class="k">def</span> <span class="nf">modulo</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">):</span>
    <span class="sd">"""Returns element-wise modulo of the input arrays with broadcasting.</span>

<span class="sd">    Equivalent to ``lhs % rhs`` and ``mx.nd.broadcast_mod(lhs, rhs)``.</span>

<span class="sd">    .. note::</span>

<span class="sd">       If the corresponding dimensions of two arrays have the same size or one of them has size 1,</span>
<span class="sd">       then the arrays are broadcastable to a common shape.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lhs : scalar or array</span>
<span class="sd">        First array in modulo.</span>
<span class="sd">    rhs : scalar or array</span>
<span class="sd">         Second array in modulo.</span>
<span class="sd">        The arrays to be taken modulo. If ``lhs.shape != rhs.shape``, they must be</span>
<span class="sd">        broadcastable to a common shape.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    NDArray</span>
<span class="sd">        The element-wise modulo of the input arrays.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    >>> x = mx.nd.ones((2,3))*6</span>
<span class="sd">    >>> y = mx.nd.ones((2,1))*4</span>
<span class="sd">    >>> x.asnumpy()</span>
<span class="sd">    array([[ 6.,  6.,  6.],</span>
<span class="sd">           [ 6.,  6.,  6.]], dtype=float32)</span>
<span class="sd">    >>> y.asnumpy()</span>
<span class="sd">    array([[ 4.],</span>
<span class="sd">           [ 4.]], dtype=float32)</span>
<span class="sd">    >>> x%5</span>
<span class="sd">    <NDArray 2x3 @cpu(0)></span>
<span class="sd">    >>> (x%5).asnumpy()</span>
<span class="sd">    array([[ 1.,  1.,  1.],</span>
<span class="sd">           [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="sd">    >>> (x%y).asnumpy()</span>
<span class="sd">    array([[ 2.,  2.,  2.],</span>
<span class="sd">           [ 2.,  2.,  2.]], dtype=float32)</span>
<span class="sd">    >>> mx.nd.modulo(x,y).asnumpy()</span>
<span class="sd">    array([[ 2.,  2.,  2.],</span>
<span class="sd">           [ 2.,  2.,  2.]], dtype=float32)</span>
<span class="sd">    """</span>
    <span class="c1"># pylint: disable= no-member, protected-access</span>
    <span class="k">return</span> <span class="n">_ufunc_helper</span><span class="p">(</span>
        <span class="n">lhs</span><span class="p">,</span>
        <span class="n">rhs</span><span class="p">,</span>
        <span class="n">op</span><span class="o">.</span><span class="n">broadcast_mod</span><span class="p">,</span>
        <span class="n">operator</span><span class="o">.</span><span class="n">mod</span><span class="p">,</span>
        <span class="n">_internal</span><span class="o">.</span><span class="n">_mod_scalar</span><span class="p">,</span>
        <span class="n">_internal</span><span class="o">.</span><span class="n">_rmod_scalar</span><span class="p">)</span></div>
    <span class="c1"># pylint: enable= no-member, protected-access</span>


<div class="viewcode-block" id="power"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.power">[docs]</a><span class="k">def</span> <span class="nf">power</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">exp</span><span class="p">):</span>
    <span class="sd">"""Returns result of first array elements raised to powers from second array, element-wise</span>
<span class="sd">    with broadcasting.</span>

<span class="sd">    Equivalent to ``base ** exp`` and ``mx.nd.broadcast_power(lhs, rhs)``.</span>

<span class="sd">    .. note::</span>

<span class="sd">       If the corresponding dimensions of two arrays have the same size or one of them has size 1,</span>
<span class="sd">       then the arrays are broadcastable to a common shape.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    base : scalar or NDArray</span>
<span class="sd">         The base array</span>
<span class="sd">    exp : scalar or NDArray</span>
<span class="sd">         The exponent array. If ``base.shape != exp.shape``, they must be</span>
<span class="sd">        broadcastable to a common shape.</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    NDArray</span>
<span class="sd">        The bases in x raised to the exponents in y.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    >>> x = mx.nd.ones((2,3))*2</span>
<span class="sd">    >>> y = mx.nd.arange(1,3).reshape((2,1))</span>
<span class="sd">    >>> z = mx.nd.arange(1,3).reshape((2,1))</span>
<span class="sd">    >>> x.asnumpy()</span>
<span class="sd">    array([[ 2.,  2.,  2.],</span>
<span class="sd">           [ 2.,  2.,  2.]], dtype=float32)</span>
<span class="sd">    >>> y.asnumpy()</span>
<span class="sd">    array([[ 1.],</span>
<span class="sd">           [ 2.]], dtype=float32)</span>
<span class="sd">    >>> z.asnumpy()</span>
<span class="sd">    array([[ 1.],</span>
<span class="sd">           [ 2.]], dtype=float32)</span>
<span class="sd">    >>> (x**2).asnumpy()</span>
<span class="sd">    array([[ 4.,  4.,  4.],</span>
<span class="sd">           [ 4.,  4.,  4.]], dtype=float32)</span>
<span class="sd">    >>> (x**y).asnumpy()</span>
<span class="sd">    array([[ 2.,  2.,  2.],</span>
<span class="sd">           [ 4.,  4.,  4.]], dtype=float32)</span>
<span class="sd">    >>> mx.nd.power(x,y).asnumpy()</span>
<span class="sd">    array([[ 2.,  2.,  2.],</span>
<span class="sd">           [ 4.,  4.,  4.]], dtype=float32)</span>
<span class="sd">    >>> (z**y).asnumpy()</span>
<span class="sd">    array([[ 1.],</span>
<span class="sd">           [ 4.]], dtype=float32)</span>
<span class="sd">    """</span>
    <span class="c1"># pylint: disable= no-member, protected-access</span>
    <span class="k">return</span> <span class="n">_ufunc_helper</span><span class="p">(</span>
        <span class="n">base</span><span class="p">,</span>
        <span class="n">exp</span><span class="p">,</span>
        <span class="n">op</span><span class="o">.</span><span class="n">broadcast_power</span><span class="p">,</span>
        <span class="n">operator</span><span class="o">.</span><span class="n">pow</span><span class="p">,</span>
        <span class="n">_internal</span><span class="o">.</span><span class="n">_power_scalar</span><span class="p">,</span>
        <span class="n">_internal</span><span class="o">.</span><span class="n">_rpower_scalar</span><span class="p">)</span></div>
    <span class="c1"># pylint: enable= no-member, protected-access</span>


<div class="viewcode-block" id="maximum"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.maximum">[docs]</a><span class="k">def</span> <span class="nf">maximum</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">):</span>
    <span class="sd">"""Returns element-wise maximum of the input arrays with broadcasting.</span>

<span class="sd">    Equivalent to ``mx.nd.broadcast_maximum(lhs, rhs)``.</span>

<span class="sd">    .. note::</span>

<span class="sd">       If the corresponding dimensions of two arrays have the same size or one of them has size 1,</span>
<span class="sd">       then the arrays are broadcastable to a common shape.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lhs : scalar or array</span>
<span class="sd">        First array to be compared.</span>
<span class="sd">    rhs : scalar or array</span>
<span class="sd">         Second array to be compared. If ``lhs.shape != rhs.shape``, they must be</span>
<span class="sd">        broadcastable to a common shape.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    NDArray</span>
<span class="sd">        The element-wise maximum of the input arrays.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    >>> x = mx.nd.ones((2,3))</span>
<span class="sd">    >>> y = mx.nd.arange(2).reshape((2,1))</span>
<span class="sd">    >>> z = mx.nd.arange(2).reshape((1,2))</span>
<span class="sd">    >>> x.asnumpy()</span>
<span class="sd">    array([[ 1.,  1.,  1.],</span>
<span class="sd">           [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="sd">    >>> y.asnumpy()</span>
<span class="sd">    array([[ 0.],</span>
<span class="sd">           [ 1.]], dtype=float32)</span>
<span class="sd">    >>> z.asnumpy()</span>
<span class="sd">    array([[ 0.,  1.]], dtype=float32)</span>
<span class="sd">    >>> mx.nd.maximum(x, 2).asnumpy()</span>
<span class="sd">    array([[ 2.,  2.,  2.],</span>
<span class="sd">           [ 2.,  2.,  2.]], dtype=float32)</span>
<span class="sd">    >>> mx.nd.maximum(x, y).asnumpy()</span>
<span class="sd">    array([[ 1.,  1.,  1.],</span>
<span class="sd">           [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="sd">    >>> mx.nd.maximum(y, z).asnumpy()</span>
<span class="sd">    array([[ 0.,  1.],</span>
<span class="sd">           [ 1.,  1.]], dtype=float32)</span>
<span class="sd">    """</span>
    <span class="c1"># pylint: disable= no-member, protected-access</span>
    <span class="k">return</span> <span class="n">_ufunc_helper</span><span class="p">(</span>
        <span class="n">lhs</span><span class="p">,</span>
        <span class="n">rhs</span><span class="p">,</span>
        <span class="n">op</span><span class="o">.</span><span class="n">broadcast_maximum</span><span class="p">,</span>
        <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="k">if</span> <span class="n">x</span> <span class="o">></span> <span class="n">y</span> <span class="k">else</span> <span class="n">y</span><span class="p">,</span>
        <span class="n">_internal</span><span class="o">.</span><span class="n">_maximum_scalar</span><span class="p">,</span>
        <span class="kc">None</span><span class="p">)</span></div>
    <span class="c1"># pylint: enable= no-member, protected-access</span>


<div class="viewcode-block" id="minimum"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.minimum">[docs]</a><span class="k">def</span> <span class="nf">minimum</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">):</span>
    <span class="sd">"""Returns element-wise minimum of the input arrays with broadcasting.</span>

<span class="sd">    Equivalent to ``mx.nd.broadcast_minimum(lhs, rhs)``.</span>

<span class="sd">    .. note::</span>

<span class="sd">       If the corresponding dimensions of two arrays have the same size or one of them has size 1,</span>
<span class="sd">       then the arrays are broadcastable to a common shape.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lhs : scalar or array</span>
<span class="sd">        First array to be compared.</span>
<span class="sd">    rhs : scalar or array</span>
<span class="sd">         Second array to be compared. If ``lhs.shape != rhs.shape``, they must be</span>
<span class="sd">        broadcastable to a common shape.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    NDArray</span>
<span class="sd">        The element-wise minimum of the input arrays.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    >>> x = mx.nd.ones((2,3))</span>
<span class="sd">    >>> y = mx.nd.arange(2).reshape((2,1))</span>
<span class="sd">    >>> z = mx.nd.arange(2).reshape((1,2))</span>
<span class="sd">    >>> x.asnumpy()</span>
<span class="sd">    array([[ 1.,  1.,  1.],</span>
<span class="sd">           [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="sd">    >>> y.asnumpy()</span>
<span class="sd">    array([[ 0.],</span>
<span class="sd">           [ 1.]], dtype=float32)</span>
<span class="sd">    >>> z.asnumpy()</span>
<span class="sd">    array([[ 0.,  1.]], dtype=float32)</span>
<span class="sd">    >>> mx.nd.minimum(x, 2).asnumpy()</span>
<span class="sd">    array([[ 1.,  1.,  1.],</span>
<span class="sd">           [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="sd">    >>> mx.nd.minimum(x, y).asnumpy()</span>
<span class="sd">    array([[ 0.,  0.,  0.],</span>
<span class="sd">           [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="sd">    >>> mx.nd.minimum(z, y).asnumpy()</span>
<span class="sd">    array([[ 0.,  0.],</span>
<span class="sd">           [ 0.,  1.]], dtype=float32)</span>
<span class="sd">    """</span>
    <span class="c1"># pylint: disable= no-member, protected-access</span>
    <span class="k">return</span> <span class="n">_ufunc_helper</span><span class="p">(</span>
        <span class="n">lhs</span><span class="p">,</span>
        <span class="n">rhs</span><span class="p">,</span>
        <span class="n">op</span><span class="o">.</span><span class="n">broadcast_minimum</span><span class="p">,</span>
        <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="k">if</span> <span class="n">x</span> <span class="o"><</span> <span class="n">y</span> <span class="k">else</span> <span class="n">y</span><span class="p">,</span>
        <span class="n">_internal</span><span class="o">.</span><span class="n">_minimum_scalar</span><span class="p">,</span>
        <span class="kc">None</span><span class="p">)</span></div>
    <span class="c1"># pylint: enable= no-member, protected-access</span>


<div class="viewcode-block" id="equal"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.equal">[docs]</a><span class="k">def</span> <span class="nf">equal</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">):</span>
    <span class="sd">"""Returns the result of element-wise **equal to** (==) comparison operation with</span>
<span class="sd">    broadcasting.</span>

<span class="sd">    For each element in input arrays, return 1(true) if corresponding elements are same,</span>
<span class="sd">    otherwise return 0(false).</span>

<span class="sd">    Equivalent to ``lhs == rhs`` and ``mx.nd.broadcast_equal(lhs, rhs)``.</span>

<span class="sd">    .. note::</span>

<span class="sd">       If the corresponding dimensions of two arrays have the same size or one of them has size 1,</span>
<span class="sd">       then the arrays are broadcastable to a common shape.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lhs : scalar or array</span>
<span class="sd">        First array to be compared.</span>
<span class="sd">    rhs : scalar or array</span>
<span class="sd">         Second array to be compared. If ``lhs.shape != rhs.shape``, they must be</span>
<span class="sd">        broadcastable to a common shape.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    NDArray</span>
<span class="sd">        Output array of boolean values.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    >>> x = mx.nd.ones((2,3))</span>
<span class="sd">    >>> y = mx.nd.arange(2).reshape((2,1))</span>
<span class="sd">    >>> z = mx.nd.arange(2).reshape((1,2))</span>
<span class="sd">    >>> x.asnumpy()</span>
<span class="sd">    array([[ 1.,  1.,  1.],</span>
<span class="sd">           [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="sd">    >>> y.asnumpy()</span>
<span class="sd">    array([[ 0.],</span>
<span class="sd">           [ 1.]], dtype=float32)</span>
<span class="sd">    >>> z.asnumpy()</span>
<span class="sd">    array([[ 0.,  1.]], dtype=float32)</span>
<span class="sd">    >>> (x == 1).asnumpy()</span>
<span class="sd">    array([[ 1.,  1.,  1.],</span>
<span class="sd">           [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="sd">    >>> (x == y).asnumpy()</span>
<span class="sd">    array([[ 0.,  0.,  0.],</span>
<span class="sd">           [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="sd">    >>> mx.nd.equal(x,y).asnumpy()</span>
<span class="sd">    array([[ 0.,  0.,  0.],</span>
<span class="sd">           [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="sd">    >>> (z == y).asnumpy()</span>
<span class="sd">    array([[ 1.,  0.],</span>
<span class="sd">           [ 0.,  1.]], dtype=float32)</span>
<span class="sd">    """</span>
    <span class="c1"># pylint: disable= no-member, protected-access</span>
    <span class="k">return</span> <span class="n">_ufunc_helper</span><span class="p">(</span>
        <span class="n">lhs</span><span class="p">,</span>
        <span class="n">rhs</span><span class="p">,</span>
        <span class="n">op</span><span class="o">.</span><span class="n">broadcast_equal</span><span class="p">,</span>
        <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span> <span class="k">else</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">_internal</span><span class="o">.</span><span class="n">_equal_scalar</span><span class="p">,</span>
        <span class="kc">None</span><span class="p">)</span></div>
    <span class="c1"># pylint: enable= no-member, protected-access</span>


<div class="viewcode-block" id="not_equal"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.not_equal">[docs]</a><span class="k">def</span> <span class="nf">not_equal</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">):</span>
    <span class="sd">"""Returns the result of element-wise **not equal to** (!=) comparison operation</span>
<span class="sd">    with broadcasting.</span>

<span class="sd">    For each element in input arrays, return 1(true) if corresponding elements are different,</span>
<span class="sd">    otherwise return 0(false).</span>

<span class="sd">    Equivalent to ``lhs != rhs`` and ``mx.nd.broadcast_not_equal(lhs, rhs)``.</span>

<span class="sd">    .. note::</span>

<span class="sd">       If the corresponding dimensions of two arrays have the same size or one of them has size 1,</span>
<span class="sd">       then the arrays are broadcastable to a common shape.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lhs : scalar or array</span>
<span class="sd">        First array to be compared.</span>
<span class="sd">    rhs : scalar or array</span>
<span class="sd">         Second array to be compared. If ``lhs.shape != rhs.shape``, they must be</span>
<span class="sd">        broadcastable to a common shape.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    NDArray</span>
<span class="sd">        Output array of boolean values.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    >>> x = mx.nd.ones((2,3))</span>
<span class="sd">    >>> y = mx.nd.arange(2).reshape((2,1))</span>
<span class="sd">    >>> z = mx.nd.arange(2).reshape((1,2))</span>
<span class="sd">    >>> x.asnumpy()</span>
<span class="sd">    array([[ 1.,  1.,  1.],</span>
<span class="sd">           [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="sd">    >>> y.asnumpy()</span>
<span class="sd">    array([[ 0.],</span>
<span class="sd">           [ 1.]], dtype=float32)</span>
<span class="sd">    >>> z.asnumpy()</span>
<span class="sd">    array([[ 0.,  1.]], dtype=float32)</span>
<span class="sd">    >>> (z == y).asnumpy()</span>
<span class="sd">    array([[ 1.,  0.],</span>
<span class="sd">           [ 0.,  1.]], dtype=float32)</span>
<span class="sd">    >>> (x != 1).asnumpy()</span>
<span class="sd">    array([[ 0.,  0.,  0.],</span>
<span class="sd">           [ 0.,  0.,  0.]], dtype=float32)</span>
<span class="sd">    >>> (x != y).asnumpy()</span>
<span class="sd">    array([[ 1.,  1.,  1.],</span>
<span class="sd">           [ 0.,  0.,  0.]], dtype=float32)</span>
<span class="sd">    >>> mx.nd.not_equal(x, y).asnumpy()</span>
<span class="sd">    array([[ 1.,  1.,  1.],</span>
<span class="sd">           [ 0.,  0.,  0.]], dtype=float32)</span>
<span class="sd">    >>> (z != y).asnumpy()</span>
<span class="sd">    array([[ 0.,  1.],</span>
<span class="sd">           [ 1.,  0.]], dtype=float32)</span>
<span class="sd">    """</span>
    <span class="c1"># pylint: disable= no-member, protected-access</span>
    <span class="k">return</span> <span class="n">_ufunc_helper</span><span class="p">(</span>
        <span class="n">lhs</span><span class="p">,</span>
        <span class="n">rhs</span><span class="p">,</span>
        <span class="n">op</span><span class="o">.</span><span class="n">broadcast_not_equal</span><span class="p">,</span>
        <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">y</span> <span class="k">else</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">_internal</span><span class="o">.</span><span class="n">_not_equal_scalar</span><span class="p">,</span>
        <span class="kc">None</span><span class="p">)</span></div>
    <span class="c1"># pylint: enable= no-member, protected-access</span>


<div class="viewcode-block" id="greater"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.greater">[docs]</a><span class="k">def</span> <span class="nf">greater</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">):</span>
    <span class="sd">"""Returns the result of element-wise **greater than** (>) comparison operation</span>
<span class="sd">    with broadcasting.</span>

<span class="sd">    For each element in input arrays, return 1(true) if lhs elements are greater than rhs,</span>
<span class="sd">    otherwise return 0(false).</span>

<span class="sd">    Equivalent to ``lhs > rhs`` and ``mx.nd.broadcast_greater(lhs, rhs)``.</span>

<span class="sd">    .. note::</span>

<span class="sd">       If the corresponding dimensions of two arrays have the same size or one of them has size 1,</span>
<span class="sd">       then the arrays are broadcastable to a common shape.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lhs : scalar or array</span>
<span class="sd">        First array to be compared.</span>
<span class="sd">    rhs : scalar or array</span>
<span class="sd">         Second array to be compared. If ``lhs.shape != rhs.shape``, they must be</span>
<span class="sd">        broadcastable to a common shape.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    NDArray</span>
<span class="sd">        Output array of boolean values.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    >>> x = mx.nd.ones((2,3))</span>
<span class="sd">    >>> y = mx.nd.arange(2).reshape((2,1))</span>
<span class="sd">    >>> z = mx.nd.arange(2).reshape((1,2))</span>
<span class="sd">    >>> x.asnumpy()</span>
<span class="sd">    array([[ 1.,  1.,  1.],</span>
<span class="sd">           [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="sd">    >>> y.asnumpy()</span>
<span class="sd">    array([[ 0.],</span>
<span class="sd">           [ 1.]], dtype=float32)</span>
<span class="sd">    >>> z.asnumpy()</span>
<span class="sd">    array([[ 0.,  1.]], dtype=float32)</span>
<span class="sd">    >>> (x > 1).asnumpy()</span>
<span class="sd">    array([[ 0.,  0.,  0.],</span>
<span class="sd">           [ 0.,  0.,  0.]], dtype=float32)</span>
<span class="sd">    >>> (x > y).asnumpy()</span>
<span class="sd">    array([[ 1.,  1.,  1.],</span>
<span class="sd">           [ 0.,  0.,  0.]], dtype=float32)</span>
<span class="sd">    >>> mx.nd.greater(x, y).asnumpy()</span>
<span class="sd">    array([[ 1.,  1.,  1.],</span>
<span class="sd">           [ 0.,  0.,  0.]], dtype=float32)</span>
<span class="sd">    >>> (z > y).asnumpy()</span>
<span class="sd">    array([[ 0.,  1.],</span>
<span class="sd">           [ 0.,  0.]], dtype=float32)</span>
<span class="sd">    """</span>
    <span class="c1"># pylint: disable= no-member, protected-access</span>
    <span class="k">return</span> <span class="n">_ufunc_helper</span><span class="p">(</span>
        <span class="n">lhs</span><span class="p">,</span>
        <span class="n">rhs</span><span class="p">,</span>
        <span class="n">op</span><span class="o">.</span><span class="n">broadcast_greater</span><span class="p">,</span>
        <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">x</span> <span class="o">></span> <span class="n">y</span> <span class="k">else</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">_internal</span><span class="o">.</span><span class="n">_greater_scalar</span><span class="p">,</span>
        <span class="n">_internal</span><span class="o">.</span><span class="n">_lesser_scalar</span><span class="p">)</span></div>
    <span class="c1"># pylint: enable= no-member, protected-access</span>


<div class="viewcode-block" id="greater_equal"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.greater_equal">[docs]</a><span class="k">def</span> <span class="nf">greater_equal</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">):</span>
    <span class="sd">"""Returns the result of element-wise **greater than or equal to** (>=) comparison</span>
<span class="sd">    operation with broadcasting.</span>

<span class="sd">    For each element in input arrays, return 1(true) if lhs elements are greater than equal to rhs,</span>
<span class="sd">    otherwise return 0(false).</span>

<span class="sd">    Equivalent to ``lhs >= rhs`` and ``mx.nd.broadcast_greater_equal(lhs, rhs)``.</span>

<span class="sd">    .. note::</span>

<span class="sd">       If the corresponding dimensions of two arrays have the same size or one of them has size 1,</span>
<span class="sd">       then the arrays are broadcastable to a common shape.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lhs : scalar or array</span>
<span class="sd">        First array to be compared.</span>
<span class="sd">    rhs : scalar or array</span>
<span class="sd">         Second array to be compared. If ``lhs.shape != rhs.shape``, they must be</span>
<span class="sd">        broadcastable to a common shape.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    NDArray</span>
<span class="sd">        Output array of boolean values.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    >>> x = mx.nd.ones((2,3))</span>
<span class="sd">    >>> y = mx.nd.arange(2).reshape((2,1))</span>
<span class="sd">    >>> z = mx.nd.arange(2).reshape((1,2))</span>
<span class="sd">    >>> x.asnumpy()</span>
<span class="sd">    array([[ 1.,  1.,  1.],</span>
<span class="sd">           [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="sd">    >>> y.asnumpy()</span>
<span class="sd">    array([[ 0.],</span>
<span class="sd">           [ 1.]], dtype=float32)</span>
<span class="sd">    >>> z.asnumpy()</span>
<span class="sd">    array([[ 0.,  1.]], dtype=float32)</span>
<span class="sd">    >>> (x >= 1).asnumpy()</span>
<span class="sd">    array([[ 1.,  1.,  1.],</span>
<span class="sd">           [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="sd">    >>> (x >= y).asnumpy()</span>
<span class="sd">    array([[ 1.,  1.,  1.],</span>
<span class="sd">           [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="sd">    >>> mx.nd.greater_equal(x, y).asnumpy()</span>
<span class="sd">    array([[ 1.,  1.,  1.],</span>
<span class="sd">           [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="sd">    >>> (z >= y).asnumpy()</span>
<span class="sd">    array([[ 1.,  1.],</span>
<span class="sd">           [ 0.,  1.]], dtype=float32)</span>
<span class="sd">    """</span>
    <span class="c1"># pylint: disable= no-member, protected-access</span>
    <span class="k">return</span> <span class="n">_ufunc_helper</span><span class="p">(</span>
        <span class="n">lhs</span><span class="p">,</span>
        <span class="n">rhs</span><span class="p">,</span>
        <span class="n">op</span><span class="o">.</span><span class="n">broadcast_greater_equal</span><span class="p">,</span>
        <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">x</span> <span class="o">>=</span> <span class="n">y</span> <span class="k">else</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">_internal</span><span class="o">.</span><span class="n">_greater_equal_scalar</span><span class="p">,</span>
        <span class="n">_internal</span><span class="o">.</span><span class="n">_lesser_equal_scalar</span><span class="p">)</span></div>
    <span class="c1"># pylint: enable= no-member, protected-access</span>


<div class="viewcode-block" id="lesser"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.lesser">[docs]</a><span class="k">def</span> <span class="nf">lesser</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">):</span>
    <span class="sd">"""Returns the result of element-wise **lesser than** (<) comparison operation</span>
<span class="sd">    with broadcasting.</span>

<span class="sd">    For each element in input arrays, return 1(true) if lhs elements are less than rhs,</span>
<span class="sd">    otherwise return 0(false).</span>

<span class="sd">    Equivalent to ``lhs < rhs`` and ``mx.nd.broadcast_lesser(lhs, rhs)``.</span>

<span class="sd">    .. note::</span>

<span class="sd">       If the corresponding dimensions of two arrays have the same size or one of them has size 1,</span>
<span class="sd">       then the arrays are broadcastable to a common shape.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lhs : scalar or array</span>
<span class="sd">        First array to be compared.</span>
<span class="sd">    rhs : scalar or array</span>
<span class="sd">         Second array to be compared. If ``lhs.shape != rhs.shape``, they must be</span>
<span class="sd">        broadcastable to a common shape.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    NDArray</span>
<span class="sd">        Output array of boolean values.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    >>> x = mx.nd.ones((2,3))</span>
<span class="sd">    >>> y = mx.nd.arange(2).reshape((2,1))</span>
<span class="sd">    >>> z = mx.nd.arange(2).reshape((1,2))</span>
<span class="sd">    >>> x.asnumpy()</span>
<span class="sd">    array([[ 1.,  1.,  1.],</span>
<span class="sd">           [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="sd">    >>> y.asnumpy()</span>
<span class="sd">    array([[ 0.],</span>
<span class="sd">           [ 1.]], dtype=float32)</span>
<span class="sd">    >>> z.asnumpy()</span>
<span class="sd">    array([[ 0.,  1.]], dtype=float32)</span>
<span class="sd">    >>> (x < 1).asnumpy()</span>
<span class="sd">    array([[ 0.,  0.,  0.],</span>
<span class="sd">           [ 0.,  0.,  0.]], dtype=float32)</span>
<span class="sd">    >>> (x < y).asnumpy()</span>
<span class="sd">    array([[ 0.,  0.,  0.],</span>
<span class="sd">           [ 0.,  0.,  0.]], dtype=float32)</span>
<span class="sd">    >>> mx.nd.lesser(x, y).asnumpy()</span>
<span class="sd">    array([[ 0.,  0.,  0.],</span>
<span class="sd">           [ 0.,  0.,  0.]], dtype=float32)</span>
<span class="sd">    >>> (z < y).asnumpy()</span>
<span class="sd">    array([[ 0.,  0.],</span>
<span class="sd">           [ 1.,  0.]], dtype=float32)</span>
<span class="sd">    """</span>
    <span class="c1"># pylint: disable= no-member, protected-access</span>
    <span class="k">return</span> <span class="n">_ufunc_helper</span><span class="p">(</span>
        <span class="n">lhs</span><span class="p">,</span>
        <span class="n">rhs</span><span class="p">,</span>
        <span class="n">op</span><span class="o">.</span><span class="n">broadcast_lesser</span><span class="p">,</span>
        <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">x</span> <span class="o"><</span> <span class="n">y</span> <span class="k">else</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">_internal</span><span class="o">.</span><span class="n">_lesser_scalar</span><span class="p">,</span>
        <span class="n">_internal</span><span class="o">.</span><span class="n">_greater_scalar</span><span class="p">)</span></div>
    <span class="c1"># pylint: enable= no-member, protected-access</span>


<div class="viewcode-block" id="lesser_equal"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.lesser_equal">[docs]</a><span class="k">def</span> <span class="nf">lesser_equal</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">):</span>
    <span class="sd">"""Returns the result of element-wise **lesser than or equal to** (<=) comparison</span>
<span class="sd">    operation with broadcasting.</span>

<span class="sd">    For each element in input arrays, return 1(true) if lhs elements are</span>
<span class="sd">    lesser than equal to rhs, otherwise return 0(false).</span>

<span class="sd">    Equivalent to ``lhs <= rhs`` and ``mx.nd.broadcast_lesser_equal(lhs, rhs)``.</span>

<span class="sd">    .. note::</span>

<span class="sd">       If the corresponding dimensions of two arrays have the same size or one of them has size 1,</span>
<span class="sd">       then the arrays are broadcastable to a common shape.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lhs : scalar or array</span>
<span class="sd">        First array to be compared.</span>
<span class="sd">    rhs : scalar or array</span>
<span class="sd">         Second array to be compared. If ``lhs.shape != rhs.shape``, they must be</span>
<span class="sd">        broadcastable to a common shape.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    NDArray</span>
<span class="sd">        Output array of boolean values.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    >>> x = mx.nd.ones((2,3))</span>
<span class="sd">    >>> y = mx.nd.arange(2).reshape((2,1))</span>
<span class="sd">    >>> z = mx.nd.arange(2).reshape((1,2))</span>
<span class="sd">    >>> x.asnumpy()</span>
<span class="sd">    array([[ 1.,  1.,  1.],</span>
<span class="sd">           [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="sd">    >>> y.asnumpy()</span>
<span class="sd">    array([[ 0.],</span>
<span class="sd">           [ 1.]], dtype=float32)</span>
<span class="sd">    >>> z.asnumpy()</span>
<span class="sd">    array([[ 0.,  1.]], dtype=float32)</span>
<span class="sd">    >>> (x <= 1).asnumpy()</span>
<span class="sd">    array([[ 1.,  1.,  1.],</span>
<span class="sd">           [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="sd">    >>> (x <= y).asnumpy()</span>
<span class="sd">    array([[ 0.,  0.,  0.],</span>
<span class="sd">           [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="sd">    >>> mx.nd.lesser_equal(x, y).asnumpy()</span>
<span class="sd">    array([[ 0.,  0.,  0.],</span>
<span class="sd">           [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="sd">    >>> (z <= y).asnumpy()</span>
<span class="sd">    array([[ 1.,  0.],</span>
<span class="sd">           [ 1.,  1.]], dtype=float32)</span>
<span class="sd">    """</span>
    <span class="c1"># pylint: disable= no-member, protected-access</span>
    <span class="k">return</span> <span class="n">_ufunc_helper</span><span class="p">(</span>
        <span class="n">lhs</span><span class="p">,</span>
        <span class="n">rhs</span><span class="p">,</span>
        <span class="n">op</span><span class="o">.</span><span class="n">broadcast_lesser_equal</span><span class="p">,</span>
        <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">x</span> <span class="o"><=</span> <span class="n">y</span> <span class="k">else</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">_internal</span><span class="o">.</span><span class="n">_lesser_equal_scalar</span><span class="p">,</span>
        <span class="n">_internal</span><span class="o">.</span><span class="n">_greater_equal_scalar</span><span class="p">)</span></div>
    <span class="c1"># pylint: enable= no-member, protected-access</span>


<div class="viewcode-block" id="true_divide"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.true_divide">[docs]</a><span class="k">def</span> <span class="nf">true_divide</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">):</span>

    <span class="sd">"""This function is similar to :meth:`divide`.</span>
<span class="sd">    """</span>
    <span class="k">return</span> <span class="n">divide</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span></div>


<div class="viewcode-block" id="concatenate"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.concatenate">[docs]</a><span class="k">def</span> <span class="nf">concatenate</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">always_copy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">"""DEPRECATED, use ``concat`` instead</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arrays : list of `NDArray`</span>
<span class="sd">        Arrays to be concatenate. They must have identical shape except</span>
<span class="sd">        the first dimension. They also must have the same data type.</span>
<span class="sd">    axis : int</span>
<span class="sd">        The axis along which to concatenate.</span>
<span class="sd">    always_copy : bool</span>
<span class="sd">        Default `True`. When not `True`, if the arrays only contain one</span>
<span class="sd">        `NDArray`, that element will be returned directly, avoid copying.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    NDArray</span>
<span class="sd">        An `NDArray` that lives on the same context as `arrays[0].context`.</span>
<span class="sd">    """</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">arrays</span><span class="p">)</span> <span class="o">></span> <span class="mi">0</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">NDArray</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">always_copy</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">arrays</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">shape_axis</span> <span class="o">=</span> <span class="n">arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
    <span class="n">shape_rest1</span> <span class="o">=</span> <span class="n">arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">axis</span><span class="p">]</span>
    <span class="n">shape_rest2</span> <span class="o">=</span> <span class="n">arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span>
    <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="n">shape_axis</span> <span class="o">+=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
        <span class="k">assert</span> <span class="n">shape_rest1</span> <span class="o">==</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">axis</span><span class="p">]</span>
        <span class="k">assert</span> <span class="n">shape_rest2</span> <span class="o">==</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">assert</span> <span class="n">dtype</span> <span class="o">==</span> <span class="n">arr</span><span class="o">.</span><span class="n">dtype</span>
    <span class="n">ret_shape</span> <span class="o">=</span> <span class="n">shape_rest1</span> <span class="o">+</span> <span class="p">(</span><span class="n">shape_axis</span><span class="p">,)</span> <span class="o">+</span> <span class="n">shape_rest2</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">empty</span><span class="p">(</span><span class="n">ret_shape</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="n">arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">context</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

    <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">begin</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">ret_shape</span><span class="p">]</span>
    <span class="n">end</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ret_shape</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">ret</span><span class="p">[</span><span class="n">idx</span><span class="p">:</span><span class="n">idx</span><span class="o">+</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">arr</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">begin</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span>
            <span class="n">end</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span><span class="o">+</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
            <span class="c1"># pylint: disable=no-member,protected-access</span>
            <span class="n">_internal</span><span class="o">.</span><span class="n">_crop_assign</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">arr</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">ret</span><span class="p">,</span>
                                   <span class="n">begin</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">begin</span><span class="p">),</span>
                                   <span class="n">end</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">end</span><span class="p">))</span>
            <span class="c1"># pylint: enable=no-member,protected-access</span>
        <span class="n">idx</span> <span class="o">+=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">ret</span></div>


<span class="c1"># pylint: disable=redefined-outer-name</span>
<div class="viewcode-block" id="imdecode"><a class="viewcode-back" href="../../../api/python/ndarray/ndarray.html#mxnet.ndarray.imdecode">[docs]</a><span class="k">def</span> <span class="nf">imdecode</span><span class="p">(</span><span class="n">str_img</span><span class="p">,</span> <span class="n">clip_rect</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">channels</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">mean</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">"""DEPRECATED, use mx.img instead</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    str_img : str</span>
<span class="sd">        Binary image data</span>
<span class="sd">    clip_rect : iterable of 4 int</span>
<span class="sd">        Clip decoded image to rectangle (x0, y0, x1, y1).</span>
<span class="sd">    out : NDArray</span>
<span class="sd">        Output buffer. Can be 3 dimensional (c, h, w) or 4 dimensional (n, c, h, w).</span>
<span class="sd">    index : int</span>
<span class="sd">        Output decoded image to i-th slice of 4 dimensional buffer.</span>
<span class="sd">    channels : int</span>
<span class="sd">        Number of channels to output. Decode to grey scale when channels = 1.</span>
<span class="sd">    mean : NDArray</span>
<span class="sd">        Subtract mean from decode image before outputing.</span>
<span class="sd">    """</span>
    <span class="c1"># pylint: disable= no-member, protected-access, too-many-arguments</span>
    <span class="k">if</span> <span class="n">mean</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mean</span> <span class="o">=</span> <span class="n">NDArray</span><span class="p">(</span><span class="n">_new_empty_handle</span><span class="p">())</span>
    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_internal</span><span class="o">.</span><span class="n">_imdecode</span><span class="p">(</span><span class="n">mean</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span>
                                   <span class="n">clip_rect</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                   <span class="n">clip_rect</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                   <span class="n">clip_rect</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                                   <span class="n">clip_rect</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
                                   <span class="n">channels</span><span class="p">,</span>
                                   <span class="nb">len</span><span class="p">(</span><span class="n">str_img</span><span class="p">),</span>
                                   <span class="n">str_img</span><span class="o">=</span><span class="n">str_img</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_internal</span><span class="o">.</span><span class="n">_imdecode</span><span class="p">(</span><span class="n">mean</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span>
                                   <span class="n">clip_rect</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                   <span class="n">clip_rect</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                   <span class="n">clip_rect</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                                   <span class="n">clip_rect</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
                                   <span class="n">channels</span><span class="p">,</span>
                                   <span class="nb">len</span><span class="p">(</span><span class="n">str_img</span><span class="p">),</span>
                                   <span class="n">str_img</span><span class="o">=</span><span class="n">str_img</span><span class="p">,</span>
                                   <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">"""Returns a new array filled with all zeros, with the given shape and type.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    shape : int or tuple of int</span>
<span class="sd">        The shape of the empty array.</span>
<span class="sd">    ctx : Context, optional</span>
<span class="sd">        An optional device context (default is the current default context).</span>
<span class="sd">    dtype : str or numpy.dtype, optional</span>
<span class="sd">        An optional value type (default is `float32`).</span>
<span class="sd">    out : NDArray, optional</span>
<span class="sd">        The output NDArray (default is `None`).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    NDArray</span>
<span class="sd">        A created array</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    >>> mx.nd.zeros(1).asnumpy()</span>
<span class="sd">    array([ 0.], dtype=float32)</span>
<span class="sd">    >>> mx.nd.zeros((1,2), mx.gpu(0))</span>
<span class="sd">    <NDArray 1x2 @gpu(0)></span>
<span class="sd">    >>> mx.nd.zeros((1,2), mx.gpu(0), 'float16').asnumpy()</span>
<span class="sd">    array([[ 0.,  0.]], dtype=float16)</span>
<span class="sd">    """</span>
    <span class="c1"># pylint: disable= unused-argument</span>
    <span class="k">if</span> <span class="n">ctx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ctx</span> <span class="o">=</span> <span class="n">Context</span><span class="o">.</span><span class="n">default_ctx</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">mx_real_t</span> <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">dtype</span>
    <span class="c1"># pylint: disable= no-member, protected-access</span>
    <span class="k">return</span> <span class="n">_internal</span><span class="o">.</span><span class="n">_zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="n">ctx</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="c1"># pylint: enable= no-member, protected-access</span>


<span class="k">def</span> <span class="nf">empty</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">"""Returns a new array of given shape and type, without initializing entries.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    shape : int or tuple of int</span>
<span class="sd">        The shape of the empty array.</span>
<span class="sd">    ctx : Context, optional</span>
<span class="sd">        An optional device context (default is the current default context).</span>
<span class="sd">    dtype : str or numpy.dtype, optional</span>
<span class="sd">        An optional value type (default is `float32`).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    NDArray</span>
<span class="sd">        A created array.</span>

<span class="sd">    """</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="p">)</span>
    <span class="k">if</span> <span class="n">ctx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ctx</span> <span class="o">=</span> <span class="n">Context</span><span class="o">.</span><span class="n">default_ctx</span>
    <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">mx_real_t</span>
    <span class="k">return</span> <span class="n">NDArray</span><span class="p">(</span><span class="n">handle</span><span class="o">=</span><span class="n">_new_alloc_handle</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">dtype</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div aria-label="main navigation" class="sphinxsidebar rightsidebar" role="navigation">
<div class="sphinxsidebarwrapper">
</div>
</div>
</div><div class="footer">
<div class="section-disclaimer">
<div class="container">
<div>
<img height="60" src="https://raw.githubusercontent.com/dmlc/web-data/master/mxnet/image/apache_incubator_logo.png"/>
<p>
            Apache MXNet is an effort undergoing incubation at The Apache Software Foundation (ASF), <strong>sponsored by the <i>Apache Incubator</i></strong>. Incubation is required of all newly accepted projects until a further review indicates that the infrastructure, communications, and decision making process have stabilized in a manner consistent with other successful ASF projects. While incubation status is not necessarily a reflection of the completeness or stability of the code, it does indicate that the project has yet to be fully endorsed by the ASF.
        </p>
<p>
            "Copyright © 2017-2018, The Apache Software Foundation
            Apache MXNet, MXNet, Apache, the Apache feather, and the Apache MXNet project logo are either registered trademarks or trademarks of the Apache Software Foundation."
        </p>
</div>
</div>
</div>
</div> <!-- pagename != index -->
</div>
<script crossorigin="anonymous" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>
<script src="../../../_static/js/sidebar.js" type="text/javascript"></script>
<script src="../../../_static/js/search.js" type="text/javascript"></script>
<script src="../../../_static/js/navbar.js" type="text/javascript"></script>
<script src="../../../_static/js/clipboard.min.js" type="text/javascript"></script>
<script src="../../../_static/js/copycode.js" type="text/javascript"></script>
<script src="../../../_static/js/page.js" type="text/javascript"></script>
<script src="../../../_static/js/docversion.js" type="text/javascript"></script>
<script type="text/javascript">
        $('body').ready(function () {
            $('body').css('visibility', 'visible');
        });
    </script>
</body>
</html>