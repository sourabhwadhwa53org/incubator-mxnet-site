<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>mxnet: mxnet::NDArray Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">mxnet
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemxnet.html">mxnet</a></li><li class="navelem"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classmxnet_1_1NDArray-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mxnet::NDArray Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>ndarray interface  
 <a href="classmxnet_1_1NDArray.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="include_2mxnet_2ndarray_8h_source.html">ndarray.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for mxnet::NDArray:</div>
<div class="dyncontent">
<div class="center"><img src="classmxnet_1_1NDArray__coll__graph.png" border="0" usemap="#mxnet_1_1NDArray_coll__map" alt="Collaboration graph"/></div>
<map name="mxnet_1_1NDArray_coll__map" id="mxnet_1_1NDArray_coll__map">
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a12ec978e5dbe9092d21721a657c39756"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a12ec978e5dbe9092d21721a657c39756">NDArray</a> ()</td></tr>
<tr class="memdesc:a12ec978e5dbe9092d21721a657c39756"><td class="mdescLeft">&#160;</td><td class="mdescRight">default constructor  <a href="#a12ec978e5dbe9092d21721a657c39756">More...</a><br /></td></tr>
<tr class="separator:a12ec978e5dbe9092d21721a657c39756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58d6f716d7eebf822c75e841342d9feb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a58d6f716d7eebf822c75e841342d9feb">NDArray</a> (const <a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a> &amp;<a class="el" href="classmxnet_1_1NDArray.html#aa0ff3466e6ff09f8fe0a8019b53d5d42">shape</a>, <a class="el" href="structmxnet_1_1Context.html">Context</a> <a class="el" href="classmxnet_1_1NDArray.html#a26d1ddb2bb0ed1e671ce7606498b942d">ctx</a>, bool delay_alloc=false, int <a class="el" href="classmxnet_1_1NDArray.html#a67b0f8eb36568b4c9fbd3da2a1c4b0a3">dtype</a>=<a class="el" href="namespacemshadow.html#a143ad1a73ba518ef0aad29d36f2569ee">mshadow::default_type_flag</a>)</td></tr>
<tr class="memdesc:a58d6f716d7eebf822c75e841342d9feb"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructs a new dynamic <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>  <a href="#a58d6f716d7eebf822c75e841342d9feb">More...</a><br /></td></tr>
<tr class="separator:a58d6f716d7eebf822c75e841342d9feb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad45e6e6669cdde0232d05f1e549ec607"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#ad45e6e6669cdde0232d05f1e549ec607">NDArray</a> (const <a class="el" href="namespacemxnet.html#a536b732faa980e1de446c552460ff76a">NDArrayStorageType</a> stype, const <a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a> &amp;<a class="el" href="classmxnet_1_1NDArray.html#aa0ff3466e6ff09f8fe0a8019b53d5d42">shape</a>, <a class="el" href="structmxnet_1_1Context.html">Context</a> <a class="el" href="classmxnet_1_1NDArray.html#a26d1ddb2bb0ed1e671ce7606498b942d">ctx</a>, bool delay_alloc=true, int <a class="el" href="classmxnet_1_1NDArray.html#a67b0f8eb36568b4c9fbd3da2a1c4b0a3">dtype</a>=<a class="el" href="namespacemshadow.html#a143ad1a73ba518ef0aad29d36f2569ee">mshadow::default_type_flag</a>, std::vector&lt; int &gt; <a class="el" href="classmxnet_1_1NDArray.html#aa475e532890ae08c2a63ea2707a5053b">aux_types</a>={}, <a class="el" href="namespacemxnet.html#a87e1c30aafac389774c6f4d905c0e5ea">mxnet::ShapeVector</a> <a class="el" href="classmxnet_1_1NDArray.html#aa18b9a6db4601e6b96bbe0560abeac98">aux_shapes</a>={}, <a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a> <a class="el" href="classmxnet_1_1NDArray.html#aa30cf4bfe565044616228286b8334931">storage_shape</a>=<a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a>(<a class="el" href="namespacemshadow.html#a05e468ef4d8882fccce53ae951b7bdbd">mshadow::Shape1</a>(0)))</td></tr>
<tr class="memdesc:ad45e6e6669cdde0232d05f1e549ec607"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor for <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> with storage type  <a href="#ad45e6e6669cdde0232d05f1e549ec607">More...</a><br /></td></tr>
<tr class="separator:ad45e6e6669cdde0232d05f1e549ec607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbfcf25b4e005007c40300c711c34f69"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#afbfcf25b4e005007c40300c711c34f69">NDArray</a> (<a class="el" href="structmxnet_1_1Context.html">Context</a> <a class="el" href="classmxnet_1_1NDArray.html#a26d1ddb2bb0ed1e671ce7606498b942d">ctx</a>, int <a class="el" href="classmxnet_1_1NDArray.html#a67b0f8eb36568b4c9fbd3da2a1c4b0a3">dtype</a>=<a class="el" href="namespacemshadow.html#a143ad1a73ba518ef0aad29d36f2569ee">mshadow::default_type_flag</a>)</td></tr>
<tr class="memdesc:afbfcf25b4e005007c40300c711c34f69"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructs a new dynamic <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> whose shape is unknown, hence the <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> is inherently lazily created  <a href="#afbfcf25b4e005007c40300c711c34f69">More...</a><br /></td></tr>
<tr class="separator:afbfcf25b4e005007c40300c711c34f69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a7288505ac9bbb19830161f7e5c1a6f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a1a7288505ac9bbb19830161f7e5c1a6f">NDArray</a> (const <a class="el" href="classmxnet_1_1TBlob.html">TBlob</a> &amp;<a class="el" href="classmxnet_1_1NDArray.html#ade5c291caf0e240892b1bffaf7e5c8b5">data</a>, int dev_id)</td></tr>
<tr class="memdesc:a1a7288505ac9bbb19830161f7e5c1a6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructing a static <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> that shares data with <a class="el" href="classmxnet_1_1TBlob.html" title="tensor blob class that can be used to hold tensor of any dimension, any device and any data type...">TBlob</a> Use with caution: allocate ONLY ONE <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> for each <a class="el" href="classmxnet_1_1TBlob.html" title="tensor blob class that can be used to hold tensor of any dimension, any device and any data type...">TBlob</a>, make sure the memory region is available through out the life of <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>  <a href="#a1a7288505ac9bbb19830161f7e5c1a6f">More...</a><br /></td></tr>
<tr class="separator:a1a7288505ac9bbb19830161f7e5c1a6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2e26d3d53e546a8b5f458c0cc204387"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#aa2e26d3d53e546a8b5f458c0cc204387">NDArray</a> (const <a class="el" href="classmxnet_1_1TBlob.html">TBlob</a> &amp;<a class="el" href="classmxnet_1_1NDArray.html#ade5c291caf0e240892b1bffaf7e5c8b5">data</a>, int dev_id, const std::function&lt; void()&gt; &amp;deleter)</td></tr>
<tr class="memdesc:aa2e26d3d53e546a8b5f458c0cc204387"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructing a static <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> that shares data with <a class="el" href="classmxnet_1_1TBlob.html" title="tensor blob class that can be used to hold tensor of any dimension, any device and any data type...">TBlob</a> which is with deleter Use with caution: allocate ONLY ONE <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> for each <a class="el" href="classmxnet_1_1TBlob.html" title="tensor blob class that can be used to hold tensor of any dimension, any device and any data type...">TBlob</a>, make sure the memory region is available through out the life of <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>  <a href="#aa2e26d3d53e546a8b5f458c0cc204387">More...</a><br /></td></tr>
<tr class="separator:aa2e26d3d53e546a8b5f458c0cc204387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5858cd154fbf68f832c2717f4f925e8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#ac5858cd154fbf68f832c2717f4f925e8">NDArray</a> (int shared_pid, int shared_id, const <a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a> &amp;<a class="el" href="classmxnet_1_1NDArray.html#aa0ff3466e6ff09f8fe0a8019b53d5d42">shape</a>, int <a class="el" href="classmxnet_1_1NDArray.html#a67b0f8eb36568b4c9fbd3da2a1c4b0a3">dtype</a>)</td></tr>
<tr class="memdesc:ac5858cd154fbf68f832c2717f4f925e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">create ndarray from shared memory  <a href="#ac5858cd154fbf68f832c2717f4f925e8">More...</a><br /></td></tr>
<tr class="separator:ac5858cd154fbf68f832c2717f4f925e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ab28f889680e6aad1b981b378f206d9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a3ab28f889680e6aad1b981b378f206d9">NDArray</a> (const <a class="el" href="namespacemxnet.html#a536b732faa980e1de446c552460ff76a">NDArrayStorageType</a> stype, const <a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a> &amp;<a class="el" href="classmxnet_1_1NDArray.html#aa0ff3466e6ff09f8fe0a8019b53d5d42">shape</a>, const <a class="el" href="classmxnet_1_1TBlob.html">TBlob</a> &amp;<a class="el" href="classmxnet_1_1NDArray.html#ade5c291caf0e240892b1bffaf7e5c8b5">data</a>, const std::vector&lt; <a class="el" href="classmxnet_1_1TBlob.html">TBlob</a> &gt; &amp;<a class="el" href="classmxnet_1_1NDArray.html#a0bb9681f2b23318ff38566ed71af26a9">aux_data</a>, int dev_id)</td></tr>
<tr class="memdesc:a3ab28f889680e6aad1b981b378f206d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructing a static <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> of non-default storage that shares data with <a class="el" href="classmxnet_1_1TBlob.html" title="tensor blob class that can be used to hold tensor of any dimension, any device and any data type...">TBlob</a> Use with caution: allocate ONLY ONE <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> for each <a class="el" href="classmxnet_1_1TBlob.html" title="tensor blob class that can be used to hold tensor of any dimension, any device and any data type...">TBlob</a>, make sure the memory region is available through out the life of <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>  <a href="#a3ab28f889680e6aad1b981b378f206d9">More...</a><br /></td></tr>
<tr class="separator:a3ab28f889680e6aad1b981b378f206d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e789a9d17c0b15749d247122e9b207a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a1e789a9d17c0b15749d247122e9b207a">Init</a> (const <a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a> &amp;<a class="el" href="classmxnet_1_1NDArray.html#aa0ff3466e6ff09f8fe0a8019b53d5d42">shape</a>)</td></tr>
<tr class="memdesc:a1e789a9d17c0b15749d247122e9b207a"><td class="mdescLeft">&#160;</td><td class="mdescRight">initialize the <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>, assuming it is not assigned a meaningful shape before  <a href="#a1e789a9d17c0b15749d247122e9b207a">More...</a><br /></td></tr>
<tr class="separator:a1e789a9d17c0b15749d247122e9b207a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24287317390bd1a58d7f93772a64c2cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a24287317390bd1a58d7f93772a64c2cb">SetShapeFromChunk</a> ()</td></tr>
<tr class="memdesc:a24287317390bd1a58d7f93772a64c2cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the correct shape of <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> directly from the storage_shape of its own chunk.  <a href="#a24287317390bd1a58d7f93772a64c2cb">More...</a><br /></td></tr>
<tr class="separator:a24287317390bd1a58d7f93772a64c2cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe1e6281a1bc6d0a0f2377d8870fb8f5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#afe1e6281a1bc6d0a0f2377d8870fb8f5">IsView</a> () const</td></tr>
<tr class="separator:afe1e6281a1bc6d0a0f2377d8870fb8f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5c172c0f1d77d212790583ba11a3cd2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#ab5c172c0f1d77d212790583ba11a3cd2">IsSame</a> (const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;other) const</td></tr>
<tr class="separator:ab5c172c0f1d77d212790583ba11a3cd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0ff3466e6ff09f8fe0a8019b53d5d42"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#aa0ff3466e6ff09f8fe0a8019b53d5d42">shape</a> () const</td></tr>
<tr class="separator:aa0ff3466e6ff09f8fe0a8019b53d5d42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa30cf4bfe565044616228286b8334931"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#aa30cf4bfe565044616228286b8334931">storage_shape</a> () const</td></tr>
<tr class="separator:aa30cf4bfe565044616228286b8334931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f1d95c104a092be10a22a546e74f836"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a7f1d95c104a092be10a22a546e74f836">aux_shape</a> (size_t index) const</td></tr>
<tr class="memdesc:a7f1d95c104a092be10a22a546e74f836"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the shape of aux_data(index)  <a href="#a7f1d95c104a092be10a22a546e74f836">More...</a><br /></td></tr>
<tr class="separator:a7f1d95c104a092be10a22a546e74f836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa18b9a6db4601e6b96bbe0560abeac98"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacemxnet.html#a87e1c30aafac389774c6f4d905c0e5ea">mxnet::ShapeVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#aa18b9a6db4601e6b96bbe0560abeac98">aux_shapes</a> () const</td></tr>
<tr class="separator:aa18b9a6db4601e6b96bbe0560abeac98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa475e532890ae08c2a63ea2707a5053b"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#aa475e532890ae08c2a63ea2707a5053b">aux_types</a> () const</td></tr>
<tr class="separator:aa475e532890ae08c2a63ea2707a5053b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a245bf6c0b4dd454fa5d5bfb255005221"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a245bf6c0b4dd454fa5d5bfb255005221">set_aux_shape</a> (size_t index, const <a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a> &amp;<a class="el" href="classmxnet_1_1NDArray.html#aa0ff3466e6ff09f8fe0a8019b53d5d42">shape</a>) const</td></tr>
<tr class="memdesc:a245bf6c0b4dd454fa5d5bfb255005221"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a sparse operation on a csr matrix for example, the size of the column index array is an estimated value in the beginning for allocating enough capacity for the final result. After the operation is done, the exact size of the shape is known and need to be reset using this function.  <a href="#a245bf6c0b4dd454fa5d5bfb255005221">More...</a><br /></td></tr>
<tr class="separator:a245bf6c0b4dd454fa5d5bfb255005221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade5c291caf0e240892b1bffaf7e5c8b5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmxnet_1_1TBlob.html">TBlob</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#ade5c291caf0e240892b1bffaf7e5c8b5">data</a> () const</td></tr>
<tr class="separator:ade5c291caf0e240892b1bffaf7e5c8b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c038544414ed2b992f9393a14eff6cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a9c038544414ed2b992f9393a14eff6cd">grad</a> () const</td></tr>
<tr class="separator:a9c038544414ed2b992f9393a14eff6cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bb9681f2b23318ff38566ed71af26a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmxnet_1_1TBlob.html">TBlob</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a0bb9681f2b23318ff38566ed71af26a9">aux_data</a> (size_t i) const</td></tr>
<tr class="separator:a0bb9681f2b23318ff38566ed71af26a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26d1ddb2bb0ed1e671ce7606498b942d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmxnet_1_1Context.html">Context</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a26d1ddb2bb0ed1e671ce7606498b942d">ctx</a> () const</td></tr>
<tr class="separator:a26d1ddb2bb0ed1e671ce7606498b942d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67b0f8eb36568b4c9fbd3da2a1c4b0a3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a67b0f8eb36568b4c9fbd3da2a1c4b0a3">dtype</a> () const</td></tr>
<tr class="separator:a67b0f8eb36568b4c9fbd3da2a1c4b0a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1f24bbdb0013050415ef0542d8273f1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#ac1f24bbdb0013050415ef0542d8273f1">aux_type</a> (size_t i) const</td></tr>
<tr class="separator:ac1f24bbdb0013050415ef0542d8273f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67cb416db42a52288bb0a693026a8b97"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemxnet.html#a536b732faa980e1de446c552460ff76a">NDArrayStorageType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a67cb416db42a52288bb0a693026a8b97">storage_type</a> () const</td></tr>
<tr class="separator:a67cb416db42a52288bb0a693026a8b97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29673998ea5bec1cab7337595d907c67"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a29673998ea5bec1cab7337595d907c67">is_none</a> () const</td></tr>
<tr class="separator:a29673998ea5bec1cab7337595d907c67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9d2fa3ffbe963fb5960375da1b557a2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#ad9d2fa3ffbe963fb5960375da1b557a2">fresh_out_grad</a> () const</td></tr>
<tr class="separator:ad9d2fa3ffbe963fb5960375da1b557a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec1b90af51327c2956adf182c201de03"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#aec1b90af51327c2956adf182c201de03">set_fresh_out_grad</a> (bool state) const</td></tr>
<tr class="separator:aec1b90af51327c2956adf182c201de03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4ccbd0815226566d65d53229f719222"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#ac4ccbd0815226566d65d53229f719222">storage_initialized</a> () const</td></tr>
<tr class="memdesc:ac4ccbd0815226566d65d53229f719222"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if a sparse ndarray's aux_data and storage are initialized Throws an exception if the indices array shape is inconsistent Returns false if the indices array is empty(nnz = 0) for csr/row_sparse.  <a href="#ac4ccbd0815226566d65d53229f719222">More...</a><br /></td></tr>
<tr class="separator:ac4ccbd0815226566d65d53229f719222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbafb6c0712694be87ab034a2eb1639c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmxnet_1_1Storage_1_1Handle.html">Storage::Handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#afbafb6c0712694be87ab034a2eb1639c">storage_handle</a> () const</td></tr>
<tr class="memdesc:afbafb6c0712694be87ab034a2eb1639c"><td class="mdescLeft">&#160;</td><td class="mdescRight">get storage handle  <a href="#afbafb6c0712694be87ab034a2eb1639c">More...</a><br /></td></tr>
<tr class="separator:afbafb6c0712694be87ab034a2eb1639c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cf4c49e6925d35586f75a1c9bdb51e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a1cf4c49e6925d35586f75a1c9bdb51e4">WaitToRead</a> () const</td></tr>
<tr class="memdesc:a1cf4c49e6925d35586f75a1c9bdb51e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block until all the pending write operations with respect to current <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> are finished, and read can be performed.  <a href="#a1cf4c49e6925d35586f75a1c9bdb51e4">More...</a><br /></td></tr>
<tr class="separator:a1cf4c49e6925d35586f75a1c9bdb51e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8599450a4ba06b5890c5d06bd024d8e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#ad8599450a4ba06b5890c5d06bd024d8e">WaitToWrite</a> () const</td></tr>
<tr class="memdesc:ad8599450a4ba06b5890c5d06bd024d8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block until all the pending read/write operations with respect to current <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> are finished, and write can be performed.  <a href="#ad8599450a4ba06b5890c5d06bd024d8e">More...</a><br /></td></tr>
<tr class="separator:ad8599450a4ba06b5890c5d06bd024d8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a168da55c01cc5c7a218d975af6b5b1f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmxnet_1_1Engine.html#aac31510c793a12944c33f9cac6150491">Engine::VarHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a168da55c01cc5c7a218d975af6b5b1f9">var</a> () const</td></tr>
<tr class="separator:a168da55c01cc5c7a218d975af6b5b1f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7574bc7633ff7f796bf8a1f2e6e2a392"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a7574bc7633ff7f796bf8a1f2e6e2a392">byte_offset</a> () const</td></tr>
<tr class="separator:a7574bc7633ff7f796bf8a1f2e6e2a392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0cd632ca10d91e65734cd8ce558cb08"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#ab0cd632ca10d91e65734cd8ce558cb08">version</a> () const</td></tr>
<tr class="memdesc:ab0cd632ca10d91e65734cd8ce558cb08"><td class="mdescLeft">&#160;</td><td class="mdescRight">return var version of the <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>  <a href="#ab0cd632ca10d91e65734cd8ce558cb08">More...</a><br /></td></tr>
<tr class="separator:ab0cd632ca10d91e65734cd8ce558cb08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dd1143eeb4fbe15cebe85f28142551f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a7dd1143eeb4fbe15cebe85f28142551f">Save</a> (<a class="el" href="classdmlc_1_1Stream.html">dmlc::Stream</a> *strm) const</td></tr>
<tr class="memdesc:a7dd1143eeb4fbe15cebe85f28142551f"><td class="mdescLeft">&#160;</td><td class="mdescRight">save the content into binary stream  <a href="#a7dd1143eeb4fbe15cebe85f28142551f">More...</a><br /></td></tr>
<tr class="separator:a7dd1143eeb4fbe15cebe85f28142551f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b212c0a0c4c83c64a6bf6d0c430602b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a0b212c0a0c4c83c64a6bf6d0c430602b">LegacyLoad</a> (<a class="el" href="classdmlc_1_1Stream.html">dmlc::Stream</a> *strm, const uint32_t magic)</td></tr>
<tr class="memdesc:a0b212c0a0c4c83c64a6bf6d0c430602b"><td class="mdescLeft">&#160;</td><td class="mdescRight">load ndarrays before supporting sparse ndarrays  <a href="#a0b212c0a0c4c83c64a6bf6d0c430602b">More...</a><br /></td></tr>
<tr class="separator:a0b212c0a0c4c83c64a6bf6d0c430602b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5203aa033a53942deaecb7bb3bf46480"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a5203aa033a53942deaecb7bb3bf46480">Load</a> (<a class="el" href="classdmlc_1_1Stream.html">dmlc::Stream</a> *strm)</td></tr>
<tr class="memdesc:a5203aa033a53942deaecb7bb3bf46480"><td class="mdescLeft">&#160;</td><td class="mdescRight">load the content from binary stream  <a href="#a5203aa033a53942deaecb7bb3bf46480">More...</a><br /></td></tr>
<tr class="separator:a5203aa033a53942deaecb7bb3bf46480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7a198e3e4c80a48cf92a913009aab8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#aa7a198e3e4c80a48cf92a913009aab8f">operator=</a> (<a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a> scalar)</td></tr>
<tr class="memdesc:aa7a198e3e4c80a48cf92a913009aab8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">set all the elements in ndarray to be scalar  <a href="#aa7a198e3e4c80a48cf92a913009aab8f">More...</a><br /></td></tr>
<tr class="separator:aa7a198e3e4c80a48cf92a913009aab8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7df5a5d9956a481635fc43ca4d9a196c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a7df5a5d9956a481635fc43ca4d9a196c">operator+=</a> (const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;src)</td></tr>
<tr class="memdesc:a7df5a5d9956a481635fc43ca4d9a196c"><td class="mdescLeft">&#160;</td><td class="mdescRight">elementwise add to current space this mutate the current <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>  <a href="#a7df5a5d9956a481635fc43ca4d9a196c">More...</a><br /></td></tr>
<tr class="separator:a7df5a5d9956a481635fc43ca4d9a196c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1068954b69113429bab7b369300fdbe0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a1068954b69113429bab7b369300fdbe0">operator+=</a> (const <a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a> &amp;src)</td></tr>
<tr class="memdesc:a1068954b69113429bab7b369300fdbe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">elementwise add to current space this mutate the current <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>  <a href="#a1068954b69113429bab7b369300fdbe0">More...</a><br /></td></tr>
<tr class="separator:a1068954b69113429bab7b369300fdbe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad35ba01da6949494afe895b7429e4fc3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#ad35ba01da6949494afe895b7429e4fc3">operator-=</a> (const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;src)</td></tr>
<tr class="memdesc:ad35ba01da6949494afe895b7429e4fc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">elementwise subtract from current ndarray this mutate the current <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>  <a href="#ad35ba01da6949494afe895b7429e4fc3">More...</a><br /></td></tr>
<tr class="separator:ad35ba01da6949494afe895b7429e4fc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81a7b37678af0f23edc2beec6daca3ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a81a7b37678af0f23edc2beec6daca3ab">operator-=</a> (const <a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a> &amp;src)</td></tr>
<tr class="memdesc:a81a7b37678af0f23edc2beec6daca3ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">elementwise subtract from current ndarray this mutate the current <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>  <a href="#a81a7b37678af0f23edc2beec6daca3ab">More...</a><br /></td></tr>
<tr class="separator:a81a7b37678af0f23edc2beec6daca3ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b47078a60bf0369ff0a7df893caf65b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a1b47078a60bf0369ff0a7df893caf65b">operator*=</a> (const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;src)</td></tr>
<tr class="memdesc:a1b47078a60bf0369ff0a7df893caf65b"><td class="mdescLeft">&#160;</td><td class="mdescRight">elementwise multiplication to current ndarray this mutate the current <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>  <a href="#a1b47078a60bf0369ff0a7df893caf65b">More...</a><br /></td></tr>
<tr class="separator:a1b47078a60bf0369ff0a7df893caf65b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b4b2ac8b0c154ae8c53ebfd2d1d3fcf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a7b4b2ac8b0c154ae8c53ebfd2d1d3fcf">operator*=</a> (const <a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a> &amp;src)</td></tr>
<tr class="memdesc:a7b4b2ac8b0c154ae8c53ebfd2d1d3fcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">elementwise multiplication to current ndarray this mutate the current <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>  <a href="#a7b4b2ac8b0c154ae8c53ebfd2d1d3fcf">More...</a><br /></td></tr>
<tr class="separator:a7b4b2ac8b0c154ae8c53ebfd2d1d3fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebc61006705874666423c45f161df546"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#aebc61006705874666423c45f161df546">operator/=</a> (const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;src)</td></tr>
<tr class="memdesc:aebc61006705874666423c45f161df546"><td class="mdescLeft">&#160;</td><td class="mdescRight">elementwise division from current ndarray this mutate the current <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>  <a href="#aebc61006705874666423c45f161df546">More...</a><br /></td></tr>
<tr class="separator:aebc61006705874666423c45f161df546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab88b476b2092b30c7d456d99df9f36e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#ab88b476b2092b30c7d456d99df9f36e3">operator/=</a> (const <a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a> &amp;src)</td></tr>
<tr class="memdesc:ab88b476b2092b30c7d456d99df9f36e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">elementwise division from current ndarray this mutate the current <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>  <a href="#ab88b476b2092b30c7d456d99df9f36e3">More...</a><br /></td></tr>
<tr class="separator:ab88b476b2092b30c7d456d99df9f36e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6617e1bf4242314f7ee6b6e3a66ce493"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a6617e1bf4242314f7ee6b6e3a66ce493">Copy</a> (<a class="el" href="structmxnet_1_1Context.html">Context</a> <a class="el" href="classmxnet_1_1NDArray.html#a26d1ddb2bb0ed1e671ce7606498b942d">ctx</a>) const</td></tr>
<tr class="memdesc:a6617e1bf4242314f7ee6b6e3a66ce493"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a new copy this <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>  <a href="#a6617e1bf4242314f7ee6b6e3a66ce493">More...</a><br /></td></tr>
<tr class="separator:a6617e1bf4242314f7ee6b6e3a66ce493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac390edfdd8a7dd99f69ea373f4d18e1a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#ac390edfdd8a7dd99f69ea373f4d18e1a">SyncCopyFromCPU</a> (const void *<a class="el" href="classmxnet_1_1NDArray.html#ade5c291caf0e240892b1bffaf7e5c8b5">data</a>, size_t size) const</td></tr>
<tr class="memdesc:ac390edfdd8a7dd99f69ea373f4d18e1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do a synchronize copy from a contiguous CPU memory region.  <a href="#ac390edfdd8a7dd99f69ea373f4d18e1a">More...</a><br /></td></tr>
<tr class="separator:ac390edfdd8a7dd99f69ea373f4d18e1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3943fcf632304f6ab165b8628710609"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#aa3943fcf632304f6ab165b8628710609">SyncCopyFromNDArray</a> (const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;src, int i=-1, int j=-1)</td></tr>
<tr class="memdesc:aa3943fcf632304f6ab165b8628710609"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy from src.data()/aux_data(i) to this-&gt;<a class="el" href="classmxnet_1_1NDArray.html#ade5c291caf0e240892b1bffaf7e5c8b5">data()</a>/aux_data(j)  <a href="#aa3943fcf632304f6ab165b8628710609">More...</a><br /></td></tr>
<tr class="separator:aa3943fcf632304f6ab165b8628710609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb3dbc357c53e1e0b980257f6c5e2cac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#afb3dbc357c53e1e0b980257f6c5e2cac">SyncCopyToCPU</a> (void *<a class="el" href="classmxnet_1_1NDArray.html#ade5c291caf0e240892b1bffaf7e5c8b5">data</a>, size_t size) const</td></tr>
<tr class="memdesc:afb3dbc357c53e1e0b980257f6c5e2cac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do a synchronize copy to a contiguous CPU memory region.  <a href="#afb3dbc357c53e1e0b980257f6c5e2cac">More...</a><br /></td></tr>
<tr class="separator:afb3dbc357c53e1e0b980257f6c5e2cac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8b6b078a376806d8a72ea14befe02c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#ab8b6b078a376806d8a72ea14befe02c9">SyncCheckFormat</a> (const bool full_check) const</td></tr>
<tr class="memdesc:ab8b6b078a376806d8a72ea14befe02c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">check whether the <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> format is valid  <a href="#ab8b6b078a376806d8a72ea14befe02c9">More...</a><br /></td></tr>
<tr class="separator:ab8b6b078a376806d8a72ea14befe02c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cfa7466a652feb2258bb990453a0a7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a0cfa7466a652feb2258bb990453a0a7d">Slice</a> (<a class="el" href="namespacemxnet.html#abadedc1b42ee3e5b8852e63783b982ef">index_t</a> begin, <a class="el" href="namespacemxnet.html#abadedc1b42ee3e5b8852e63783b982ef">index_t</a> end) const</td></tr>
<tr class="memdesc:a0cfa7466a652feb2258bb990453a0a7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slice a <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>.  <a href="#a0cfa7466a652feb2258bb990453a0a7d">More...</a><br /></td></tr>
<tr class="separator:a0cfa7466a652feb2258bb990453a0a7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d868e5303669d6ce8a5ada1c34940ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a0d868e5303669d6ce8a5ada1c34940ac">SliceWithRecord</a> (<a class="el" href="namespacemxnet.html#abadedc1b42ee3e5b8852e63783b982ef">index_t</a> begin, <a class="el" href="namespacemxnet.html#abadedc1b42ee3e5b8852e63783b982ef">index_t</a> end)</td></tr>
<tr class="memdesc:a0d868e5303669d6ce8a5ada1c34940ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slice a <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>. Supports recording with autograd.  <a href="#a0d868e5303669d6ce8a5ada1c34940ac">More...</a><br /></td></tr>
<tr class="separator:a0d868e5303669d6ce8a5ada1c34940ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addb42a7353a4c07b2d1bae0afa8ef48e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#addb42a7353a4c07b2d1bae0afa8ef48e">At</a> (<a class="el" href="namespacemxnet.html#abadedc1b42ee3e5b8852e63783b982ef">index_t</a> idx) const</td></tr>
<tr class="memdesc:addb42a7353a4c07b2d1bae0afa8ef48e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index a <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>.  <a href="#addb42a7353a4c07b2d1bae0afa8ef48e">More...</a><br /></td></tr>
<tr class="separator:addb42a7353a4c07b2d1bae0afa8ef48e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2a801dd5c47b5bdd01a385d2c4327b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#aa2a801dd5c47b5bdd01a385d2c4327b8">AtWithRecord</a> (<a class="el" href="namespacemxnet.html#abadedc1b42ee3e5b8852e63783b982ef">index_t</a> idx)</td></tr>
<tr class="memdesc:aa2a801dd5c47b5bdd01a385d2c4327b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index a <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>.  <a href="#aa2a801dd5c47b5bdd01a385d2c4327b8">More...</a><br /></td></tr>
<tr class="separator:aa2a801dd5c47b5bdd01a385d2c4327b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3279047ec28e02b794e7662ec68384a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#ac3279047ec28e02b794e7662ec68384a">aux_ndarray</a> (size_t i) const</td></tr>
<tr class="memdesc:ac3279047ec28e02b794e7662ec68384a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a deep copy of aux_data(i) returned as a default storage type <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>.  <a href="#ac3279047ec28e02b794e7662ec68384a">More...</a><br /></td></tr>
<tr class="separator:ac3279047ec28e02b794e7662ec68384a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae14d45e2bae697565a0723f4963db7e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#ae14d45e2bae697565a0723f4963db7e4">data_ndarray</a> () const</td></tr>
<tr class="memdesc:ae14d45e2bae697565a0723f4963db7e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a deep copy of <a class="el" href="classmxnet_1_1NDArray.html#ade5c291caf0e240892b1bffaf7e5c8b5">data()</a> returned as a default storage type <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>.  <a href="#ae14d45e2bae697565a0723f4963db7e4">More...</a><br /></td></tr>
<tr class="separator:ae14d45e2bae697565a0723f4963db7e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65b47e2d501a8e623ea70c0ae88b789e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a65b47e2d501a8e623ea70c0ae88b789e">AsArray</a> (const <a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a> &amp;<a class="el" href="classmxnet_1_1NDArray.html#aa0ff3466e6ff09f8fe0a8019b53d5d42">shape</a>, int <a class="el" href="classmxnet_1_1NDArray.html#a67b0f8eb36568b4c9fbd3da2a1c4b0a3">dtype</a>) const</td></tr>
<tr class="memdesc:a65b47e2d501a8e623ea70c0ae88b789e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> that shares memory with current one The new array must have smaller memory size than the current array.  <a href="#a65b47e2d501a8e623ea70c0ae88b789e">More...</a><br /></td></tr>
<tr class="separator:a65b47e2d501a8e623ea70c0ae88b789e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf96f31bf9cb46c4bf1a425e82e26f33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDLManagedTensor.html">DLManagedTensor</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#aaf96f31bf9cb46c4bf1a425e82e26f33">ToDLPack</a> () const</td></tr>
<tr class="memdesc:aaf96f31bf9cb46c4bf1a425e82e26f33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a reference view of <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> that represents as <a class="el" href="structDLManagedTensor.html" title="C Tensor object, manage memory of DLTensor. This data structure is intended to facilitate the borrowi...">DLManagedTensor</a>.  <a href="#aaf96f31bf9cb46c4bf1a425e82e26f33">More...</a><br /></td></tr>
<tr class="separator:aaf96f31bf9cb46c4bf1a425e82e26f33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b390d8776568e2ffc8c2ed227e12f96"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a8b390d8776568e2ffc8c2ed227e12f96">SparseUpdateChunk</a> (const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;arr) const</td></tr>
<tr class="memdesc:a8b390d8776568e2ffc8c2ed227e12f96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update ndarray chunk storage handles using existing ndarray storage handles Also update the aux_handle, aux_shapes and aux_types. This is specifically used for custom op to update the inputs and outputs from the temporary ndarray which stores intermediate custom op results. Should be used with caution elsewhere. Supports only CSR and RSP formats.  <a href="#a8b390d8776568e2ffc8c2ed227e12f96">More...</a><br /></td></tr>
<tr class="separator:a8b390d8776568e2ffc8c2ed227e12f96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6011ffa88e84bdcdc9bfa5d3365647d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a6011ffa88e84bdcdc9bfa5d3365647d9">Reshape</a> (const <a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a> &amp;<a class="el" href="classmxnet_1_1NDArray.html#aa0ff3466e6ff09f8fe0a8019b53d5d42">shape</a>) const</td></tr>
<tr class="memdesc:a6011ffa88e84bdcdc9bfa5d3365647d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an reshaped <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>.  <a href="#a6011ffa88e84bdcdc9bfa5d3365647d9">More...</a><br /></td></tr>
<tr class="separator:a6011ffa88e84bdcdc9bfa5d3365647d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a318e6f3ae6f94026dec90aa98a7e3f10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a318e6f3ae6f94026dec90aa98a7e3f10">ReshapeWithRecord</a> (const <a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a> &amp;<a class="el" href="classmxnet_1_1NDArray.html#aa0ff3466e6ff09f8fe0a8019b53d5d42">shape</a>)</td></tr>
<tr class="memdesc:a318e6f3ae6f94026dec90aa98a7e3f10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an reshaped <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>. Supports autograd recording.  <a href="#a318e6f3ae6f94026dec90aa98a7e3f10">More...</a><br /></td></tr>
<tr class="separator:a318e6f3ae6f94026dec90aa98a7e3f10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76646c5c7e164bd7c81854521d3bee52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a76646c5c7e164bd7c81854521d3bee52">Detach</a> () const</td></tr>
<tr class="memdesc:a76646c5c7e164bd7c81854521d3bee52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a copy of this <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> without autograd history.  <a href="#a76646c5c7e164bd7c81854521d3bee52">More...</a><br /></td></tr>
<tr class="separator:a76646c5c7e164bd7c81854521d3bee52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9b6fd0a27d13af7b2494be903f501ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnnvm_1_1Symbol.html">nnvm::Symbol</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#ab9b6fd0a27d13af7b2494be903f501ec">get_autograd_symbol</a> () const</td></tr>
<tr class="separator:ab9b6fd0a27d13af7b2494be903f501ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a531a3437dde0dfc9b0c40a32450f4c7a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a531a3437dde0dfc9b0c40a32450f4c7a">CheckAndAlloc</a> () const</td></tr>
<tr class="memdesc:a531a3437dde0dfc9b0c40a32450f4c7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate the space if it is delayed allocated. This is an internal function used by system that normal user should not use.  <a href="#a531a3437dde0dfc9b0c40a32450f4c7a">More...</a><br /></td></tr>
<tr class="separator:a531a3437dde0dfc9b0c40a32450f4c7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa99f425040db90b52f945007a2f11b73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#aa99f425040db90b52f945007a2f11b73">ReshapeAndAlloc</a> (const <a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a> &amp;<a class="el" href="classmxnet_1_1NDArray.html#aa0ff3466e6ff09f8fe0a8019b53d5d42">shape</a>)</td></tr>
<tr class="memdesc:aa99f425040db90b52f945007a2f11b73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate the space if the allocation has been delayed or the requested size is bigger than the available one. This function can only be called by ndarray of default storage type and effectively changes the ndarray's shape_. Note: This function is named as this to avoid overload conflict with CheckAndAlloc(const mxnet::ShapeVector &amp;aux_shapes), since <a class="el" href="classmxnet_1_1TShape.html" title="A Shape class that is used to represent shape of each tensor. ">mxnet::TShape</a> tmp = some_shape is equivalent to <a class="el" href="classmxnet_1_1TShape.html" title="A Shape class that is used to represent shape of each tensor. ">mxnet::TShape</a> tmp = {some_shape}.  <a href="#aa99f425040db90b52f945007a2f11b73">More...</a><br /></td></tr>
<tr class="separator:aa99f425040db90b52f945007a2f11b73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fbabba18b71e4ad61fee8da1a05a275"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a5fbabba18b71e4ad61fee8da1a05a275">CheckAndAlloc</a> (const <a class="el" href="namespacemxnet.html#a87e1c30aafac389774c6f4d905c0e5ea">mxnet::ShapeVector</a> &amp;<a class="el" href="classmxnet_1_1NDArray.html#aa18b9a6db4601e6b96bbe0560abeac98">aux_shapes</a>) const</td></tr>
<tr class="separator:a5fbabba18b71e4ad61fee8da1a05a275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba6fd4c790a1857c080321572b61546c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#aba6fd4c790a1857c080321572b61546c">CheckAndAllocData</a> (const <a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a> &amp;<a class="el" href="classmxnet_1_1NDArray.html#aa30cf4bfe565044616228286b8334931">storage_shape</a>) const</td></tr>
<tr class="separator:aba6fd4c790a1857c080321572b61546c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa49fb5edddbf0d9ca38e8c2130e3ca88"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#aa49fb5edddbf0d9ca38e8c2130e3ca88">CheckAndAllocAuxData</a> (size_t i, const <a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a> &amp;<a class="el" href="classmxnet_1_1NDArray.html#a7f1d95c104a092be10a22a546e74f836">aux_shape</a>) const</td></tr>
<tr class="separator:aa49fb5edddbf0d9ca38e8c2130e3ca88"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a0d7a0ccf8e8a76e8be1c5817f4754236"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a0d7a0ccf8e8a76e8be1c5817f4754236">FromDLPack</a> (const <a class="el" href="structDLManagedTensor.html">DLManagedTensor</a> *tensor, bool transient_handle)</td></tr>
<tr class="memdesc:a0d7a0ccf8e8a76e8be1c5817f4754236"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> backed by a dlpack tensor.  <a href="#a0d7a0ccf8e8a76e8be1c5817f4754236">More...</a><br /></td></tr>
<tr class="separator:a0d7a0ccf8e8a76e8be1c5817f4754236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af215b7a886e717b4bb3c911fe3c1a032"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#af215b7a886e717b4bb3c911fe3c1a032">Save</a> (<a class="el" href="classdmlc_1_1Stream.html">dmlc::Stream</a> *fo, const std::vector&lt; <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &gt; &amp;<a class="el" href="classmxnet_1_1NDArray.html#ade5c291caf0e240892b1bffaf7e5c8b5">data</a>, const std::vector&lt; std::string &gt; &amp;names)</td></tr>
<tr class="memdesc:af215b7a886e717b4bb3c911fe3c1a032"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save list of ndarray into the Stream.x.  <a href="#af215b7a886e717b4bb3c911fe3c1a032">More...</a><br /></td></tr>
<tr class="separator:af215b7a886e717b4bb3c911fe3c1a032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae45c38de80d6d4dc79ad3d24baa9e981"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#ae45c38de80d6d4dc79ad3d24baa9e981">Load</a> (<a class="el" href="classdmlc_1_1Stream.html">dmlc::Stream</a> *fi, std::vector&lt; <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &gt; *<a class="el" href="classmxnet_1_1NDArray.html#ade5c291caf0e240892b1bffaf7e5c8b5">data</a>, std::vector&lt; std::string &gt; *keys)</td></tr>
<tr class="memdesc:ae45c38de80d6d4dc79ad3d24baa9e981"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load list of ndarray into from the stream.  <a href="#ae45c38de80d6d4dc79ad3d24baa9e981">More...</a><br /></td></tr>
<tr class="separator:ae45c38de80d6d4dc79ad3d24baa9e981"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:add286ab9a359eb017008c9a3ff53701f"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#add286ab9a359eb017008c9a3ff53701f">Imperative</a></td></tr>
<tr class="separator:add286ab9a359eb017008c9a3ff53701f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>ndarray interface </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a12ec978e5dbe9092d21721a657c39756"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12ec978e5dbe9092d21721a657c39756">&#9670;&nbsp;</a></span>NDArray() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mxnet::NDArray::NDArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>default constructor </p>

</div>
</div>
<a id="a58d6f716d7eebf822c75e841342d9feb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58d6f716d7eebf822c75e841342d9feb">&#9670;&nbsp;</a></span>NDArray() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mxnet::NDArray::NDArray </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a> &amp;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmxnet_1_1Context.html">Context</a>&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>delay_alloc</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dtype</em> = <code><a class="el" href="namespacemshadow.html#a143ad1a73ba518ef0aad29d36f2569ee">mshadow::default_type_flag</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructs a new dynamic <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shape</td><td>the shape of array </td></tr>
    <tr><td class="paramname">ctx</td><td>context of <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> </td></tr>
    <tr><td class="paramname">delay_alloc</td><td>whether delay the allocation </td></tr>
    <tr><td class="paramname">dtype</td><td>data type of this ndarray </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad45e6e6669cdde0232d05f1e549ec607"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad45e6e6669cdde0232d05f1e549ec607">&#9670;&nbsp;</a></span>NDArray() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mxnet::NDArray::NDArray </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacemxnet.html#a536b732faa980e1de446c552460ff76a">NDArrayStorageType</a>&#160;</td>
          <td class="paramname"><em>stype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a> &amp;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmxnet_1_1Context.html">Context</a>&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>delay_alloc</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dtype</em> = <code><a class="el" href="namespacemshadow.html#a143ad1a73ba518ef0aad29d36f2569ee">mshadow::default_type_flag</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>aux_types</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemxnet.html#a87e1c30aafac389774c6f4d905c0e5ea">mxnet::ShapeVector</a>&#160;</td>
          <td class="paramname"><em>aux_shapes</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a>&#160;</td>
          <td class="paramname"><em>storage_shape</em> = <code><a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a>(<a class="el" href="namespacemshadow.html#a05e468ef4d8882fccce53ae951b7bdbd">mshadow::Shape1</a>(0))</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructor for <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> with storage type </p>

</div>
</div>
<a id="afbfcf25b4e005007c40300c711c34f69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbfcf25b4e005007c40300c711c34f69">&#9670;&nbsp;</a></span>NDArray() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mxnet::NDArray::NDArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmxnet_1_1Context.html">Context</a>&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dtype</em> = <code><a class="el" href="namespacemshadow.html#a143ad1a73ba518ef0aad29d36f2569ee">mshadow::default_type_flag</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructs a new dynamic <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> whose shape is unknown, hence the <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> is inherently lazily created </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>context of <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> </td></tr>
    <tr><td class="paramname">dtype</td><td>data type of this ndarray </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1a7288505ac9bbb19830161f7e5c1a6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a7288505ac9bbb19830161f7e5c1a6f">&#9670;&nbsp;</a></span>NDArray() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mxnet::NDArray::NDArray </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmxnet_1_1TBlob.html">TBlob</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dev_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructing a static <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> that shares data with <a class="el" href="classmxnet_1_1TBlob.html" title="tensor blob class that can be used to hold tensor of any dimension, any device and any data type...">TBlob</a> Use with caution: allocate ONLY ONE <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> for each <a class="el" href="classmxnet_1_1TBlob.html" title="tensor blob class that can be used to hold tensor of any dimension, any device and any data type...">TBlob</a>, make sure the memory region is available through out the life of <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>the memory content of static data </td></tr>
    <tr><td class="paramname">dev_id</td><td>the device id this tensor sits at </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa2e26d3d53e546a8b5f458c0cc204387"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2e26d3d53e546a8b5f458c0cc204387">&#9670;&nbsp;</a></span>NDArray() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mxnet::NDArray::NDArray </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmxnet_1_1TBlob.html">TBlob</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void()&gt; &amp;&#160;</td>
          <td class="paramname"><em>deleter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructing a static <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> that shares data with <a class="el" href="classmxnet_1_1TBlob.html" title="tensor blob class that can be used to hold tensor of any dimension, any device and any data type...">TBlob</a> which is with deleter Use with caution: allocate ONLY ONE <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> for each <a class="el" href="classmxnet_1_1TBlob.html" title="tensor blob class that can be used to hold tensor of any dimension, any device and any data type...">TBlob</a>, make sure the memory region is available through out the life of <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>the memory content of static data </td></tr>
    <tr><td class="paramname">dev_id</td><td>the device id this tensor sits at </td></tr>
    <tr><td class="paramname">deleter</td><td>the function pointer of custom deleter </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac5858cd154fbf68f832c2717f4f925e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5858cd154fbf68f832c2717f4f925e8">&#9670;&nbsp;</a></span>NDArray() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mxnet::NDArray::NDArray </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>shared_pid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>shared_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a> &amp;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create ndarray from shared memory </p>

</div>
</div>
<a id="a3ab28f889680e6aad1b981b378f206d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ab28f889680e6aad1b981b378f206d9">&#9670;&nbsp;</a></span>NDArray() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mxnet::NDArray::NDArray </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacemxnet.html#a536b732faa980e1de446c552460ff76a">NDArrayStorageType</a>&#160;</td>
          <td class="paramname"><em>stype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a> &amp;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmxnet_1_1TBlob.html">TBlob</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classmxnet_1_1TBlob.html">TBlob</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>aux_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dev_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructing a static <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> of non-default storage that shares data with <a class="el" href="classmxnet_1_1TBlob.html" title="tensor blob class that can be used to hold tensor of any dimension, any device and any data type...">TBlob</a> Use with caution: allocate ONLY ONE <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> for each <a class="el" href="classmxnet_1_1TBlob.html" title="tensor blob class that can be used to hold tensor of any dimension, any device and any data type...">TBlob</a>, make sure the memory region is available through out the life of <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stype</td><td>the storage type of <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> </td></tr>
    <tr><td class="paramname">shape</td><td>the shape of <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> </td></tr>
    <tr><td class="paramname">data</td><td>the memory content of static data </td></tr>
    <tr><td class="paramname">aux_data</td><td>the memory content of static aux data </td></tr>
    <tr><td class="paramname">dev_id</td><td>the device id this tensor sits at </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a65b47e2d501a8e623ea70c0ae88b789e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65b47e2d501a8e623ea70c0ae88b789e">&#9670;&nbsp;</a></span>AsArray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> mxnet::NDArray::AsArray </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a> &amp;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> that shares memory with current one The new array must have smaller memory size than the current array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shape</td><td>new shape </td></tr>
    <tr><td class="paramname">dtype</td><td>The data type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> in new shape and type. </dd></dl>

</div>
</div>
<a id="addb42a7353a4c07b2d1bae0afa8ef48e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addb42a7353a4c07b2d1bae0afa8ef48e">&#9670;&nbsp;</a></span>At()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> mxnet::NDArray::At </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemxnet.html#abadedc1b42ee3e5b8852e63783b982ef">index_t</a>&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Index a <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>idx-th sub array <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> </dd></dl>

</div>
</div>
<a id="aa2a801dd5c47b5bdd01a385d2c4327b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2a801dd5c47b5bdd01a385d2c4327b8">&#9670;&nbsp;</a></span>AtWithRecord()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> mxnet::NDArray::AtWithRecord </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemxnet.html#abadedc1b42ee3e5b8852e63783b982ef">index_t</a>&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Index a <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>idx-th sub array <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> </dd></dl>

</div>
</div>
<a id="a0bb9681f2b23318ff38566ed71af26a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bb9681f2b23318ff38566ed71af26a9">&#9670;&nbsp;</a></span>aux_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmxnet_1_1TBlob.html">TBlob</a> mxnet::NDArray::aux_data </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the aux <a class="el" href="classmxnet_1_1TBlob.html" title="tensor blob class that can be used to hold tensor of any dimension, any device and any data type...">TBlob</a> </dd></dl>

</div>
</div>
<a id="ac3279047ec28e02b794e7662ec68384a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3279047ec28e02b794e7662ec68384a">&#9670;&nbsp;</a></span>aux_ndarray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> mxnet::NDArray::aux_ndarray </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a deep copy of aux_data(i) returned as a default storage type <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>. </p>

</div>
</div>
<a id="a7f1d95c104a092be10a22a546e74f836"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f1d95c104a092be10a22a546e74f836">&#9670;&nbsp;</a></span>aux_shape()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a>&amp; mxnet::NDArray::aux_shape </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get the shape of aux_data(index) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the aux data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the shape of aux data at given index </dd></dl>

</div>
</div>
<a id="aa18b9a6db4601e6b96bbe0560abeac98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa18b9a6db4601e6b96bbe0560abeac98">&#9670;&nbsp;</a></span>aux_shapes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacemxnet.html#a87e1c30aafac389774c6f4d905c0e5ea">mxnet::ShapeVector</a>&amp; mxnet::NDArray::aux_shapes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac1f24bbdb0013050415ef0542d8273f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1f24bbdb0013050415ef0542d8273f1">&#9670;&nbsp;</a></span>aux_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int mxnet::NDArray::aux_type </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa475e532890ae08c2a63ea2707a5053b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa475e532890ae08c2a63ea2707a5053b">&#9670;&nbsp;</a></span>aux_types()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;int&gt;&amp; mxnet::NDArray::aux_types </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>returns the dtypes of all aux data </p>

</div>
</div>
<a id="a7574bc7633ff7f796bf8a1f2e6e2a392"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7574bc7633ff7f796bf8a1f2e6e2a392">&#9670;&nbsp;</a></span>byte_offset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t mxnet::NDArray::byte_offset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>byte offset in chunk of the ndarray </dd></dl>

</div>
</div>
<a id="a531a3437dde0dfc9b0c40a32450f4c7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a531a3437dde0dfc9b0c40a32450f4c7a">&#9670;&nbsp;</a></span>CheckAndAlloc() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mxnet::NDArray::CheckAndAlloc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate the space if it is delayed allocated. This is an internal function used by system that normal user should not use. </p>

</div>
</div>
<a id="a5fbabba18b71e4ad61fee8da1a05a275"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fbabba18b71e4ad61fee8da1a05a275">&#9670;&nbsp;</a></span>CheckAndAlloc() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mxnet::NDArray::CheckAndAlloc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacemxnet.html#a87e1c30aafac389774c6f4d905c0e5ea">mxnet::ShapeVector</a> &amp;&#160;</td>
          <td class="paramname"><em>aux_shapes</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa49fb5edddbf0d9ca38e8c2130e3ca88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa49fb5edddbf0d9ca38e8c2130e3ca88">&#9670;&nbsp;</a></span>CheckAndAllocAuxData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mxnet::NDArray::CheckAndAllocAuxData </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a> &amp;&#160;</td>
          <td class="paramname"><em>aux_shape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aba6fd4c790a1857c080321572b61546c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba6fd4c790a1857c080321572b61546c">&#9670;&nbsp;</a></span>CheckAndAllocData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mxnet::NDArray::CheckAndAllocData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a> &amp;&#160;</td>
          <td class="paramname"><em>storage_shape</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6617e1bf4242314f7ee6b6e3a66ce493"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6617e1bf4242314f7ee6b6e3a66ce493">&#9670;&nbsp;</a></span>Copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> mxnet::NDArray::Copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmxnet_1_1Context.html">Context</a>&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return a new copy this <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the new context of this <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new copy </dd></dl>

</div>
</div>
<a id="a26d1ddb2bb0ed1e671ce7606498b942d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26d1ddb2bb0ed1e671ce7606498b942d">&#9670;&nbsp;</a></span>ctx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmxnet_1_1Context.html">Context</a> mxnet::NDArray::ctx </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the context of <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>, this function is only valid when the <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> is not empty </dd></dl>

</div>
</div>
<a id="ade5c291caf0e240892b1bffaf7e5c8b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade5c291caf0e240892b1bffaf7e5c8b5">&#9670;&nbsp;</a></span>data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmxnet_1_1TBlob.html">TBlob</a>&amp; mxnet::NDArray::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the data <a class="el" href="classmxnet_1_1TBlob.html" title="tensor blob class that can be used to hold tensor of any dimension, any device and any data type...">TBlob</a> </dd></dl>

</div>
</div>
<a id="ae14d45e2bae697565a0723f4963db7e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae14d45e2bae697565a0723f4963db7e4">&#9670;&nbsp;</a></span>data_ndarray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> mxnet::NDArray::data_ndarray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a deep copy of <a class="el" href="classmxnet_1_1NDArray.html#ade5c291caf0e240892b1bffaf7e5c8b5">data()</a> returned as a default storage type <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>. </p>

</div>
</div>
<a id="a76646c5c7e164bd7c81854521d3bee52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76646c5c7e164bd7c81854521d3bee52">&#9670;&nbsp;</a></span>Detach()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> mxnet::NDArray::Detach </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a copy of this <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> without autograd history. </p>

</div>
</div>
<a id="a67b0f8eb36568b4c9fbd3da2a1c4b0a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67b0f8eb36568b4c9fbd3da2a1c4b0a3">&#9670;&nbsp;</a></span>dtype()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int mxnet::NDArray::dtype </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the data type of <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>, this function is only valid when the <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> is not empty </dd></dl>

</div>
</div>
<a id="ad9d2fa3ffbe963fb5960375da1b557a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9d2fa3ffbe963fb5960375da1b557a2">&#9670;&nbsp;</a></span>fresh_out_grad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mxnet::NDArray::fresh_out_grad </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>updated grad state in entry_ </dd></dl>

</div>
</div>
<a id="a0d7a0ccf8e8a76e8be1c5817f4754236"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d7a0ccf8e8a76e8be1c5817f4754236">&#9670;&nbsp;</a></span>FromDLPack()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> mxnet::NDArray::FromDLPack </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structDLManagedTensor.html">DLManagedTensor</a> *&#160;</td>
          <td class="paramname"><em>tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transient_handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> backed by a dlpack tensor. </p>
<p>This allows us to create a <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> using the memory allocated by an external deep learning framework that is DLPack compatible.</p>
<p>The memory is retained until the <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> went out of scope.</p>
<dl class="section return"><dt>Returns</dt><dd>The created <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> view. </dd></dl>

</div>
</div>
<a id="ab9b6fd0a27d13af7b2494be903f501ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9b6fd0a27d13af7b2494be903f501ec">&#9670;&nbsp;</a></span>get_autograd_symbol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnnvm_1_1Symbol.html">nnvm::Symbol</a> mxnet::NDArray::get_autograd_symbol </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9c038544414ed2b992f9393a14eff6cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c038544414ed2b992f9393a14eff6cd">&#9670;&nbsp;</a></span>grad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> mxnet::NDArray::grad </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the gradient ndarray. </dd></dl>

</div>
</div>
<a id="a1e789a9d17c0b15749d247122e9b207a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e789a9d17c0b15749d247122e9b207a">&#9670;&nbsp;</a></span>Init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mxnet::NDArray::Init </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a> &amp;&#160;</td>
          <td class="paramname"><em>shape</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>initialize the <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>, assuming it is not assigned a meaningful shape before </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shape</td><td>the shape of the <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a29673998ea5bec1cab7337595d907c67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29673998ea5bec1cab7337595d907c67">&#9670;&nbsp;</a></span>is_none()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mxnet::NDArray::is_none </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>whether this ndarray is not initialized </dd></dl>

</div>
</div>
<a id="ab5c172c0f1d77d212790583ba11a3cd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5c172c0f1d77d212790583ba11a3cd2">&#9670;&nbsp;</a></span>IsSame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mxnet::NDArray::IsSame </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afe1e6281a1bc6d0a0f2377d8870fb8f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe1e6281a1bc6d0a0f2377d8870fb8f5">&#9670;&nbsp;</a></span>IsView()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mxnet::NDArray::IsView </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0b212c0a0c4c83c64a6bf6d0c430602b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b212c0a0c4c83c64a6bf6d0c430602b">&#9670;&nbsp;</a></span>LegacyLoad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mxnet::NDArray::LegacyLoad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdmlc_1_1Stream.html">dmlc::Stream</a> *&#160;</td>
          <td class="paramname"><em>strm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>magic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>load ndarrays before supporting sparse ndarrays </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strm</td><td>the output stream </td></tr>
    <tr><td class="paramname">magic</td><td>the magic number used for version control </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5203aa033a53942deaecb7bb3bf46480"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5203aa033a53942deaecb7bb3bf46480">&#9670;&nbsp;</a></span>Load() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mxnet::NDArray::Load </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdmlc_1_1Stream.html">dmlc::Stream</a> *&#160;</td>
          <td class="paramname"><em>strm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>load the content from binary stream </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strm</td><td>the output stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the load is successful </dd></dl>

</div>
</div>
<a id="ae45c38de80d6d4dc79ad3d24baa9e981"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae45c38de80d6d4dc79ad3d24baa9e981">&#9670;&nbsp;</a></span>Load() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void mxnet::NDArray::Load </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdmlc_1_1Stream.html">dmlc::Stream</a> *&#160;</td>
          <td class="paramname"><em>fi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &gt; *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; *&#160;</td>
          <td class="paramname"><em>keys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load list of ndarray into from the stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fi</td><td>The stream of the input file. </td></tr>
    <tr><td class="paramname">data</td><td>the NDArrays to be loaded </td></tr>
    <tr><td class="paramname">keys</td><td>the name of the <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>, if saved in the file. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1b47078a60bf0369ff0a7df893caf65b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b47078a60bf0369ff0a7df893caf65b">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a>&amp; mxnet::NDArray::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>elementwise multiplication to current ndarray this mutate the current <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the data to subtract </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference of self </dd></dl>

</div>
</div>
<a id="a7b4b2ac8b0c154ae8c53ebfd2d1d3fcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b4b2ac8b0c154ae8c53ebfd2d1d3fcf">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a>&amp; mxnet::NDArray::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>elementwise multiplication to current ndarray this mutate the current <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the data to subtract </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference of self </dd></dl>

</div>
</div>
<a id="a7df5a5d9956a481635fc43ca4d9a196c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7df5a5d9956a481635fc43ca4d9a196c">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a>&amp; mxnet::NDArray::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>elementwise add to current space this mutate the current <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the data to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference of self </dd></dl>

</div>
</div>
<a id="a1068954b69113429bab7b369300fdbe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1068954b69113429bab7b369300fdbe0">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a>&amp; mxnet::NDArray::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>elementwise add to current space this mutate the current <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the data to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference of self </dd></dl>

</div>
</div>
<a id="ad35ba01da6949494afe895b7429e4fc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad35ba01da6949494afe895b7429e4fc3">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a>&amp; mxnet::NDArray::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>elementwise subtract from current ndarray this mutate the current <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the data to subtract </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference of self </dd></dl>

</div>
</div>
<a id="a81a7b37678af0f23edc2beec6daca3ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81a7b37678af0f23edc2beec6daca3ab">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a>&amp; mxnet::NDArray::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>elementwise subtract from current ndarray this mutate the current <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the data to subtract </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference of self </dd></dl>

</div>
</div>
<a id="aebc61006705874666423c45f161df546"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebc61006705874666423c45f161df546">&#9670;&nbsp;</a></span>operator/=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a>&amp; mxnet::NDArray::operator/= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>elementwise division from current ndarray this mutate the current <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the data to subtract </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference of self </dd></dl>

</div>
</div>
<a id="ab88b476b2092b30c7d456d99df9f36e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab88b476b2092b30c7d456d99df9f36e3">&#9670;&nbsp;</a></span>operator/=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a>&amp; mxnet::NDArray::operator/= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>elementwise division from current ndarray this mutate the current <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the data to subtract </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference of self </dd></dl>

</div>
</div>
<a id="aa7a198e3e4c80a48cf92a913009aab8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7a198e3e4c80a48cf92a913009aab8f">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a>&amp; mxnet::NDArray::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a>&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set all the elements in ndarray to be scalar </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>the scalar to set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference of self </dd></dl>

</div>
</div>
<a id="a6011ffa88e84bdcdc9bfa5d3365647d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6011ffa88e84bdcdc9bfa5d3365647d9">&#9670;&nbsp;</a></span>Reshape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> mxnet::NDArray::Reshape </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a> &amp;&#160;</td>
          <td class="paramname"><em>shape</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an reshaped <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shape</td><td>new shape </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> in new shape </dd></dl>

</div>
</div>
<a id="aa99f425040db90b52f945007a2f11b73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa99f425040db90b52f945007a2f11b73">&#9670;&nbsp;</a></span>ReshapeAndAlloc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mxnet::NDArray::ReshapeAndAlloc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a> &amp;&#160;</td>
          <td class="paramname"><em>shape</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate the space if the allocation has been delayed or the requested size is bigger than the available one. This function can only be called by ndarray of default storage type and effectively changes the ndarray's shape_. Note: This function is named as this to avoid overload conflict with CheckAndAlloc(const mxnet::ShapeVector &amp;aux_shapes), since <a class="el" href="classmxnet_1_1TShape.html" title="A Shape class that is used to represent shape of each tensor. ">mxnet::TShape</a> tmp = some_shape is equivalent to <a class="el" href="classmxnet_1_1TShape.html" title="A Shape class that is used to represent shape of each tensor. ">mxnet::TShape</a> tmp = {some_shape}. </p>

</div>
</div>
<a id="a318e6f3ae6f94026dec90aa98a7e3f10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a318e6f3ae6f94026dec90aa98a7e3f10">&#9670;&nbsp;</a></span>ReshapeWithRecord()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> mxnet::NDArray::ReshapeWithRecord </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a> &amp;&#160;</td>
          <td class="paramname"><em>shape</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an reshaped <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>. Supports autograd recording. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shape</td><td>new shape </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> in new shape </dd></dl>

</div>
</div>
<a id="a7dd1143eeb4fbe15cebe85f28142551f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dd1143eeb4fbe15cebe85f28142551f">&#9670;&nbsp;</a></span>Save() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mxnet::NDArray::Save </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdmlc_1_1Stream.html">dmlc::Stream</a> *&#160;</td>
          <td class="paramname"><em>strm</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>save the content into binary stream </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strm</td><td>the output stream </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af215b7a886e717b4bb3c911fe3c1a032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af215b7a886e717b4bb3c911fe3c1a032">&#9670;&nbsp;</a></span>Save() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void mxnet::NDArray::Save </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdmlc_1_1Stream.html">dmlc::Stream</a> *&#160;</td>
          <td class="paramname"><em>fo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Save list of ndarray into the Stream.x. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fo</td><td>The stream of output. </td></tr>
    <tr><td class="paramname">data</td><td>the NDArrays to be saved. </td></tr>
    <tr><td class="paramname">names</td><td>the name of the <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>, optional, can be zero length. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a245bf6c0b4dd454fa5d5bfb255005221"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a245bf6c0b4dd454fa5d5bfb255005221">&#9670;&nbsp;</a></span>set_aux_shape()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mxnet::NDArray::set_aux_shape </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a> &amp;&#160;</td>
          <td class="paramname"><em>shape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For a sparse operation on a csr matrix for example, the size of the column index array is an estimated value in the beginning for allocating enough capacity for the final result. After the operation is done, the exact size of the shape is known and need to be reset using this function. </p>

</div>
</div>
<a id="aec1b90af51327c2956adf182c201de03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec1b90af51327c2956adf182c201de03">&#9670;&nbsp;</a></span>set_fresh_out_grad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mxnet::NDArray::set_fresh_out_grad </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>updated grad state in entry_ </dd></dl>

</div>
</div>
<a id="a24287317390bd1a58d7f93772a64c2cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24287317390bd1a58d7f93772a64c2cb">&#9670;&nbsp;</a></span>SetShapeFromChunk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mxnet::NDArray::SetShapeFromChunk </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set the correct shape of <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> directly from the storage_shape of its own chunk. </p>

</div>
</div>
<a id="aa0ff3466e6ff09f8fe0a8019b53d5d42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0ff3466e6ff09f8fe0a8019b53d5d42">&#9670;&nbsp;</a></span>shape()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a>&amp; mxnet::NDArray::shape </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the shape of current <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>. </dd></dl>

</div>
</div>
<a id="a0cfa7466a652feb2258bb990453a0a7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cfa7466a652feb2258bb990453a0a7d">&#9670;&nbsp;</a></span>Slice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> mxnet::NDArray::Slice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemxnet.html#abadedc1b42ee3e5b8852e63783b982ef">index_t</a>&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemxnet.html#abadedc1b42ee3e5b8852e63783b982ef">index_t</a>&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Slice a <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>begin index in first dim (inclusive) </td></tr>
    <tr><td class="paramname">end</td><td>end index in first dim (exclusive) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sliced <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> </dd></dl>

</div>
</div>
<a id="a0d868e5303669d6ce8a5ada1c34940ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d868e5303669d6ce8a5ada1c34940ac">&#9670;&nbsp;</a></span>SliceWithRecord()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> mxnet::NDArray::SliceWithRecord </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemxnet.html#abadedc1b42ee3e5b8852e63783b982ef">index_t</a>&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemxnet.html#abadedc1b42ee3e5b8852e63783b982ef">index_t</a>&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Slice a <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>. Supports recording with autograd. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>begin index in first dim (inclusive) </td></tr>
    <tr><td class="paramname">end</td><td>end index in first dim (exclusive) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sliced <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> </dd></dl>

</div>
</div>
<a id="a8b390d8776568e2ffc8c2ed227e12f96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b390d8776568e2ffc8c2ed227e12f96">&#9670;&nbsp;</a></span>SparseUpdateChunk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mxnet::NDArray::SparseUpdateChunk </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;&#160;</td>
          <td class="paramname"><em>arr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update ndarray chunk storage handles using existing ndarray storage handles Also update the aux_handle, aux_shapes and aux_types. This is specifically used for custom op to update the inputs and outputs from the temporary ndarray which stores intermediate custom op results. Should be used with caution elsewhere. Supports only CSR and RSP formats. </p>

</div>
</div>
<a id="afbafb6c0712694be87ab034a2eb1639c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbafb6c0712694be87ab034a2eb1639c">&#9670;&nbsp;</a></span>storage_handle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmxnet_1_1Storage_1_1Handle.html">Storage::Handle</a> mxnet::NDArray::storage_handle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get storage handle </p>

</div>
</div>
<a id="ac4ccbd0815226566d65d53229f719222"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4ccbd0815226566d65d53229f719222">&#9670;&nbsp;</a></span>storage_initialized()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mxnet::NDArray::storage_initialized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if a sparse ndarray's aux_data and storage are initialized Throws an exception if the indices array shape is inconsistent Returns false if the indices array is empty(nnz = 0) for csr/row_sparse. </p>

</div>
</div>
<a id="aa30cf4bfe565044616228286b8334931"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa30cf4bfe565044616228286b8334931">&#9670;&nbsp;</a></span>storage_shape()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a>&amp; mxnet::NDArray::storage_shape </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the shape of underlying chunk which stores the <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> data/value. It is only intended for non-default storage. For row-sparse storage, it is the shape of the tensor which stores the non-zero values. </dd></dl>

</div>
</div>
<a id="a67cb416db42a52288bb0a693026a8b97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67cb416db42a52288bb0a693026a8b97">&#9670;&nbsp;</a></span>storage_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemxnet.html#a536b732faa980e1de446c552460ff76a">NDArrayStorageType</a> mxnet::NDArray::storage_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab8b6b078a376806d8a72ea14befe02c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8b6b078a376806d8a72ea14befe02c9">&#9670;&nbsp;</a></span>SyncCheckFormat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mxnet::NDArray::SyncCheckFormat </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>full_check</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>check whether the <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> format is valid </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">full_check</td><td>if <code>True</code>, rigorous check, O(N) operations Otherwise basic check, O(1) operations </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac390edfdd8a7dd99f69ea373f4d18e1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac390edfdd8a7dd99f69ea373f4d18e1a">&#9670;&nbsp;</a></span>SyncCopyFromCPU()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mxnet::NDArray::SyncCopyFromCPU </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do a synchronize copy from a contiguous CPU memory region. </p>
<p>This function will call WaitToWrite before the copy is performed. This is useful to copy data from existing memory region that are not wrapped by NDArray(thus dependency not being tracked).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>the data source to copy from. </td></tr>
    <tr><td class="paramname">size</td><td>the size of the source array, in sizeof(DType) not raw btyes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa3943fcf632304f6ab165b8628710609"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3943fcf632304f6ab165b8628710609">&#9670;&nbsp;</a></span>SyncCopyFromNDArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mxnet::NDArray::SyncCopyFromNDArray </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy from src.data()/aux_data(i) to this-&gt;<a class="el" href="classmxnet_1_1NDArray.html#ade5c291caf0e240892b1bffaf7e5c8b5">data()</a>/aux_data(j) </p>

</div>
</div>
<a id="afb3dbc357c53e1e0b980257f6c5e2cac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb3dbc357c53e1e0b980257f6c5e2cac">&#9670;&nbsp;</a></span>SyncCopyToCPU()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mxnet::NDArray::SyncCopyToCPU </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do a synchronize copy to a contiguous CPU memory region. </p>
<p>This function will call WaitToRead before the copy is performed. This is useful to copy data from existing memory region that are not wrapped by NDArray(thus dependency not being tracked).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>the data source to copyinto. </td></tr>
    <tr><td class="paramname">size</td><td>the memory size we want to copy into, in sizeof(DType) not raw btyes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaf96f31bf9cb46c4bf1a425e82e26f33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf96f31bf9cb46c4bf1a425e82e26f33">&#9670;&nbsp;</a></span>ToDLPack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDLManagedTensor.html">DLManagedTensor</a>* mxnet::NDArray::ToDLPack </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a reference view of <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> that represents as <a class="el" href="structDLManagedTensor.html" title="C Tensor object, manage memory of DLTensor. This data structure is intended to facilitate the borrowi...">DLManagedTensor</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="structDLManagedTensor.html" title="C Tensor object, manage memory of DLTensor. This data structure is intended to facilitate the borrowi...">DLManagedTensor</a> </dd></dl>

</div>
</div>
<a id="a168da55c01cc5c7a218d975af6b5b1f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a168da55c01cc5c7a218d975af6b5b1f9">&#9670;&nbsp;</a></span>var()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmxnet_1_1Engine.html#aac31510c793a12944c33f9cac6150491">Engine::VarHandle</a> mxnet::NDArray::var </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the associated variable of the ndarray. </dd></dl>

</div>
</div>
<a id="ab0cd632ca10d91e65734cd8ce558cb08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0cd632ca10d91e65734cd8ce558cb08">&#9670;&nbsp;</a></span>version()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t mxnet::NDArray::version </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return var version of the <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> </p>

</div>
</div>
<a id="a1cf4c49e6925d35586f75a1c9bdb51e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cf4c49e6925d35586f75a1c9bdb51e4">&#9670;&nbsp;</a></span>WaitToRead()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mxnet::NDArray::WaitToRead </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Block until all the pending write operations with respect to current <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> are finished, and read can be performed. </p>

</div>
</div>
<a id="ad8599450a4ba06b5890c5d06bd024d8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8599450a4ba06b5890c5d06bd024d8e">&#9670;&nbsp;</a></span>WaitToWrite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mxnet::NDArray::WaitToWrite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Block until all the pending read/write operations with respect to current <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> are finished, and write can be performed. </p>
<p>Push an empty mutable function to flush all preceding reads to the variable.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="add286ab9a359eb017008c9a3ff53701f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add286ab9a359eb017008c9a3ff53701f">&#9670;&nbsp;</a></span>Imperative</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classmxnet_1_1Imperative.html">Imperative</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/work/mxnet/include/mxnet/<a class="el" href="include_2mxnet_2ndarray_8h_source.html">ndarray.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Apr 19 2021 18:14:36 for mxnet by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
